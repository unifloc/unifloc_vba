''=======================================================================================
''Unifloc 7.38 aspo                                    khabibullinra@gmail.com
''Petroleum engineering calculations modules (macroses)
''2000 - 2022
''
''=======================================================================================
'' класс для расчета свойств скважины c УЭЦН - распределение давления и температуры в скважине
'
'Option Explicit
'Option Base 0
'
'
''обработчкик событий. на перспективну для использования в сложных программах. Пока не задействован (7.25 от 05.2020)
'Public Event ReportProgress(msg As String)
'
'' ============= ключевые дочерние объекты обеспечивающие работу скважины ================
''основная система ЭЦН встроенная в скважину
'Private ESP_ As CESPsystem
'
'' штуцер установленный на поверхности
'' choke always exist in well (but can have diam = 0 which means - no influence on flow)
'Public choke As New Cchoke
'
'Private fluid_ As CPVT                       ' флюид из пласта. setter устанавливает для дочерних объектов поэтому Private
'
'' ambient formation object needed for full temperature calculation
'' must be accessed through property - in order to pass it to pipes properly
'Private ambient_formation_ As CAmbientFormation
'
'' коллекция кривых с результатами расчетов
'Public trajectory_tub As CPipeTrajectory     ' полная траектория скважины с инклинометрии (основной способ задания скважины)
'Public trajectory_cas As CPipeTrajectory     ' полная траектория скважины с инклинометрии (основной способ задания скважины)
'
'' ключевые элементы конструкции
'Private pipe_cas_below_pump_ As New CPipe           ' от приема насоса до забоя (перфорации)      ' pipe segment from bottom to tubing setting depth
'Private pipe_tub_above_pump_ As New CPipe  ' от приема насоса по устья скважины до нкт
'Private pipe_ann_above_pump_ As New CPipe  ' от приема насоса до устья
'Private pipe_ann_gas_above_pump_ As New CPipe  ' от приема насоса до устья газовая шапка в затрубе с учетом плотности газа
'Private pipe_ann_pump_intake_discharge_ As CPipe ' участок для учета затруба вдоль насоса
'Private pipe_ann_pump_intake_motor_ As CPipe     ' участок для учета затруба ниже приема насоса
'
'Public h_perf_m As Double
'Public h_tub_m As Double
'
'' кривые для хранения параметров и результатов
'Public curve As New CCurves
'
'Public isCalcCasing As Boolean
'Public isCalcESPtemp As Boolean
'
'Private hcor_ As H_CORRELATION
'Private temp_method_ As TEMP_CALC_METHOD
'Private calc_along_flow_ As Boolean
'Private calc_along_coord_ As Boolean
'
'' calculated parameters for well'данные расчета
'Private PT_buf_ As PTtype
'Private PT_lin_ As PTtype
'Private PT_cas_ As PTtype
'Private PT_wf_ As PTtype
'Private PT_int_ As PTtype
'Private PT_pump_bottom_ As PTtype
'Private PT_pump_ann_top_ As PTtype
'Private PT_dis_ As PTtype
'' temperature params
'' температура задается отдельно, поэтому для удобства прямые параметры для работы с температурной моделью скважины заданы
'Private t_wh_C_ As Double
'Private t_surf_C_ As Double
'Private t_bh_C_ As Double
'Private t_int_C_ As Double
''Private t_res_C_ As Double
''Private param_ As PARAMCALC                 ' параметры расчета по трубе
'' поправочные коэффициенты для расчета распределения давления
'Private calibr_grav_ As Double
'Private calibr_fric_ As Double
'
'Private Hdyn_Pcas_ As PCAS_HDYN_type        ' динамический уровень
'Private h_sp_m_ As Double                   ' tubing depth
'Private d_cas_pump_mm_ As Double              ' casing diam at pump install depth
'
'Private gas_frac_intake_before_separ_d As Double ' intake gas fraction before separation
'Private gas_frac_intake_after_separ_d As Double     ' intake gas fraction after separation
'Private qgas_cas_sm3day As Double
'Private qgas_tub_sm3day As Double
'
'
'
'
'' =============================================================================
'' ============ constructor ====================================================
'Private Sub Class_Initialize()
'    hcor_ = BeggsBrill
'    calc_along_flow_ = False
'    calc_along_coord_ = False
'    temp_method_ = StartEndTemp
'
'   ' param = param_                         ' здесь распространим все настройки на трубы
'    Set ESP_ = Nothing                     ' по умолчанию УЭЦН отключен
''    Set fluid_ = New CPVT
''    Set ambient_formation_ = New CAmbientFormation
''    Set ambient_formation = ambient_formation_
'
'    calibr_grav_ = 1
'    calibr_fric_ = 1
'    isCalcCasing = True
'    isCalcESPtemp = False
'End Sub
'
'Public Property Get isCalcESP() As Boolean
'    Dim is_esp As Boolean
'    Dim is_cas_ok As Boolean
'    is_cas_ok = False
'    is_esp = Not ESP_ Is Nothing
'    If is_esp Then
'        is_cas_ok = d_cas_pump_mm_ > ESP_.ESP_pump.db.d_motor_od_m * 1000
'    End If
'    isCalcESP = is_cas_ok And is_esp
'End Property
'
'Public Property Get d_cas_pump_mm() As Double
'    d_cas_pump_mm = d_cas_pump_mm_
'End Property
'
''------------------------------------------------------------
'' fluid general properties
''------------------------------------------------------------
'Public Property Get fluid() As CPVT
'   Set fluid = fluid_
'End Property
'
'Public Property Get fluid_tub() As CPVT
'   If Not ESP_ Is Nothing Then Set fluid_tub = esp.fluid_tub
'End Property
'
'Public Property Get fluid_cas() As CPVT
'   If Not ESP_ Is Nothing Then Set fluid_cas = esp.fluid_cas
'End Property
'
'Public Property Set fluid(val As CPVT)
'' Установка PVT свойств для скважины
'' Для разных сегментов скважины задается один и тот же флюид. После расчета скважины некоторые флюиды могут модифицироваться
'  Set fluid_ = val
'  Set pipe_cas_below_pump_.fluid = fluid
'  Set pipe_tub_above_pump_.fluid = fluid
'
'  If Not pipe_ann_above_pump_ Is Nothing Then Set pipe_ann_above_pump_.fluid = fluid
'  If Not pipe_ann_gas_above_pump_ Is Nothing Then Set pipe_ann_gas_above_pump_.fluid = fluid
'  If Not pipe_ann_pump_intake_discharge_ Is Nothing Then Set pipe_ann_pump_intake_discharge_.fluid = fluid
'  If Not pipe_ann_pump_intake_motor_ Is Nothing Then Set pipe_ann_pump_intake_motor_.fluid = fluid
'
'  Set choke.fluid = fluid
'  If Not ESP_ Is Nothing Then
'      Set esp.fluid = fluid
'  End If
'End Property
'
'' ---------------------------------------------------------------
'' flow correlations tuning
'' калибровки действуют только поток ниже насоса и в НКТ
'' на поток в затрубе не действуют todo возможно надо добавить дополнительные варианты калиброки для затруба
'' ---------------------------------------------------------------
'Public Property Get calibr_grav() As Double
'   calibr_grav = calibr_grav_
'End Property
'
'Public Property Get calibr_fric() As Double
'   calibr_fric = calibr_fric_
'End Property
'
'Public Property Let calibr_grav(val As Double)
'   If val > 0 And val < 2 Then ' не стоит подстрочный коэффициент менять слишком сильно - если что тут можно поправить
'       pipe_cas_below_pump_.calibr_grav = val
'       pipe_tub_above_pump_.calibr_grav = val
'       calibr_grav_ = val
'   Else
'       add_log_msg "CWellESP.calibr_grav: value " & str(val) & " not set. Out of range"
'   End If
'End Property
'
'Public Property Let calibr_fric(val As Double)
'   If val > 0 And val < 2 Then
'   ' не стоит подстрочный коэффициент менять слишком сильно - если что тут можно поправить
'       pipe_cas_below_pump_.calibr_fric = val
'       pipe_tub_above_pump_.calibr_fric = val
'       calibr_fric_ = val
'   Else
'       add_log_msg "CWellESP.calibr_fric: value " & str(val) & " not set. Out of range"
'   End If
'End Property
'
'
''------------------------------------------------------------
'' temperature general properties
''------------------------------------------------------------
'Public Property Get t_line_C() As Double
'    t_line_C = PT_lin_.t_C
'End Property
'
'Public Property Get t_buf_C() As Double
'    t_buf_C = PT_buf_.t_C
'End Property
'
'Public Property Get t_bh_C() As Double
'    t_bh_C = PT_wf_.t_C
'End Property
'
'Public Property Get t_wh_C() As Double
'    t_wh_C = PT_buf_.t_C
'End Property
'
'Public Property Get t_surf_C() As Double
'    On Error Resume Next
'    t_surf_C = PT_buf_.t_C
'    t_surf_C = ambient_formation.amb_temp_C(0)
'End Property
'
'Public Property Get ambient_formation() As CAmbientFormation
'    Set ambient_formation = ambient_formation_
'End Property
'
'Public Property Set ambient_formation(ByVal vNewValue As CAmbientFormation)
'    Set ambient_formation_ = vNewValue
'    Set pipe_cas_below_pump_.ambient_formation = ambient_formation_
'    Set pipe_ann_above_pump_.ambient_formation = ambient_formation_
'    Set pipe_ann_gas_above_pump_.ambient_formation = ambient_formation_
'    Set pipe_tub_above_pump_.ambient_formation = ambient_formation_
'    If Not pipe_ann_pump_intake_discharge_ Is Nothing Then
'        Set pipe_ann_pump_intake_discharge_.ambient_formation = ambient_formation_
'    End If
'    If Not pipe_ann_pump_intake_motor_ Is Nothing Then
'        Set pipe_ann_pump_intake_motor_.ambient_formation = ambient_formation_
'    End If
'    ' после ручного задания объекта - периинициализируем параметры температурного расчета
'    Call fill_temperature_from_amb
'End Property
'
''------------------------------------------------------------
'' pressure general properties
''------------------------------------------------------------
'Public Property Get p_line_atma() As Double
'   p_line_atma = PT_lin_.p_atma
'End Property
'
'Public Property Get pbuf_atma() As Double
'' buffer pressure
'   pbuf_atma = PT_buf_.p_atma
'End Property
'
'Public Property Get p_wf_atma() As Double
'' давление на забое
'   p_wf_atma = PT_wf_.p_atma
'End Property
'
'Public Property Get p_an_atma() As Double
'' annulus presure
'   p_an_atma = PT_cas_.p_atma
'End Property
'
'Public Property Get p_cas_atma() As Double
'    p_cas_atma = PT_cas_.p_atma
'End Property
'
'Public Property Let p_cas_atma(ByVal p_cas_atma As Double)
'    PT_cas_.p_atma = p_cas_atma
'End Property
'
''------------------------------------------------------------
'' well rates general properties
''------------------------------------------------------------
'Property Let q_liq_sm3day(Qval_scm3day As Double)
'   fluid.q_liq_sm3day = Qval_scm3day
'   ' далее надо сбросить все флюиды которые были в системе на единый, что возможно потребует пересчета
'   Set fluid = fluid
'End Property
'
''' дебит жидкости из скважины в поверхностных условиях
'Public Property Get q_liq_sm3day() As Double
'   q_liq_sm3day = fluid_.q_liq_sm3day
'End Property
'
'Public Property Get w_kgsec() As Double
''    массовый расход продукции рассчитаем
'   w_kgsec = fluid_.wm_kgsec
'End Property
'
'Public Property Get q_oil_sm3day() As Double
'   q_oil_sm3day = fluid_.q_oil_sm3day
'End Property
'
'Public Property Get q_oil_sctday() As Double
'   q_oil_sctday = fluid_.q_liq_sm3day * (1 - fluid_.fw_fr) * fluid_.gamma_o
'End Property
'
'Public Property Get q_wat_sm3day() As Double
'   q_wat_sm3day = fluid_.q_liq_sm3day * fluid_.fw_fr
'End Property
'
'Public Property Get q_gas_scm3day() As Double
'   q_gas_scm3day = fluid_.q_gas_sm3day
'End Property
'
'Property Get fw_perc() As Double
'    fw_perc = fluid_.fw_perc
'End Property
'
'Property Let fw_perc(wcval As Double)
'   Dim Wc As Double
'   Wc = wcval / 100
'   fluid_.fw_fr = Wc
'   ' далее надо сбросить все флюиды которые были в системе на единый, что возможно потребует пересчета
'   Set fluid = fluid_
'End Property
'
'Property Get rp_m3m3() As Double
'    rp_m3m3 = fluid_.rp_full_m3m3
'End Property
'
'Property Let rp_m3m3(Rpval As Double)
'   fluid_.rp_m3m3 = Rpval
'   ' далее надо сбросить все флюиды которые были в системе на единый, что возможно потребует пересчета
'   Set fluid = fluid_
'End Property
'
'' ---------------------------------------------------------------
'' service function
'' ---------------------------------------------------------------
'Public Function clone() As CWellESP
'   Dim WL As New CWellESP
'   Dim i As Integer
'
'   Set WL.trajectory_tub = trajectory_tub
'   Set WL.trajectory_cas = trajectory_cas
'   Set WL.ambient_formation = ambient_formation
'   Call WL.choke.Copy(choke)
'
'   Dim ESP_1 As New CESPpump
'   Call ESP_1.Copy(esp)
'   Set WL.esp = ESP_1
'   Set WL.fluid = fluid.clone
'   Set clone = WL
'End Function
'
'Private Sub fill_temperature_from_amb()
'    ' here we must have ambient_formation_ ready for initialisation
'On Error GoTo err1:
'
'    t_bh_C_ = ambient_formation_.amb_temp_C(trajectory_cas.h_abs_hmes_m(h_perf_m))
'    t_wh_C_ = ambient_formation_.amb_temp_C(0)
'    t_surf_C_ = t_wh_C_
' '   t_res_C_ = fluid.t_res_C
'
'    ' инициализируем все элементы скважины для расчета по линейной зависимости от измеренной глубине
'    ' это метод расчета по умолчанию
'    ' все другие режимы расчета используют объект ambient_formation_ и не зависят от этой инициализации
'    Dim TempGrad As Double
'    Dim t_int_C As Double
'    TempGrad = (t_bh_C_ - t_wh_C_) / h_perf_m
'    t_int_C_ = t_bh_C_ - TempGrad * pipe_cas_below_pump_.length_mes_m
'
''    Call pipe_cas_below_pump_.init_t_model(amb0:=ambient_formation_)  '  InitTlinear t_int_C_, t_bh_C_
''
''    pipe_cas_below_pump_.InitTlinear t_int_C_, t_bh_C_
''    pipe_tub_above_pump_.InitTlinear t_wh_C_, t_int_C_
''    pipe_ann_above_pump_.InitTlinear t_wh_C_, t_int_C_
''    pipe_ann_gas_above_pump_.InitTlinear t_wh_C_, t_int_C_
''
''    If Not pipe_ann_pump_intake_discharge_ Is Nothing Then pipe_ann_pump_intake_discharge_.InitTlinear t_int_C_, t_int_C_
''    If Not pipe_ann_pump_intake_motor_ Is Nothing Then pipe_ann_pump_intake_motor_.InitTlinear t_int_C_, t_int_C_
'
'    ' зададим значения всех температур в ключевых точках в соответствии с исходными параметрами
'    ' некоторые из этих параметров потом могут быть перевычисленны
'    PT_buf_.t_C = t_wh_C_
'    PT_lin_.t_C = t_wh_C_
'    PT_cas_.t_C = t_wh_C_
'    PT_wf_.t_C = t_bh_C_
'    PT_dis_.t_C = t_int_C_
'    PT_int_.t_C = t_int_C_
'
'    Exit Sub
'err1:
'    Dim errmsg As String
'    errmsg = "CWellESP.init_well_temperature: error in temperature init " & sDELIM & Err.Description
'    add_log_msg errmsg
'    RaiseEvent ReportProgress(errmsg)
'    Err.Raise kErrInitCalc, Err.source, errmsg
'End Sub
'
'' ============================================================
'' основные расчетные функции
'' ============================================================
''Public Function calc_pintake_p_wf_atma( _
''                             ByVal p_wf_atma As Double) As Double
''' @brief расчет давления на приеме через забойное давление (снизу -> вверх)
''' @param p_wf_atma - исходное забойное давление
''
''On Error GoTo err1:
''
''    ' 1. Начало расчета. Заданы забойное давление p_wf, температура на забое скважины Tbh
''    PT_wf_.p_atma = p_wf_atma
''    PT_wf_.t_C = t_bh_C
''    ' 2. Рассчитывается давление на приеме насоса PIn и температура в потоке перед насосом TbIт
''    '    pipe_cas_below_pump_ - труба от забоя до приема, задаем расчет параметров снизу-вверх
''    pipe_cas_below_pump_.param = set_calc_flow_param(True, False, hcor_, temp_method_)
''    ' Расчитываем давление на приеме (p_wf - забойное давление на работающей скважине, Pws - забойное давление на неработающей скважине,)
''    pipe_cas_below_pump_.t_calc_C = t_bh_C
''    PT_int_ = pipe_cas_below_pump_.calc_dPipe(p_wf_atma)
''    calc_pintake_p_wf_atma = PT_int_.p_atma
''
''    Exit Function
''err1:
''    Dim errmsg As String
''    errmsg = "CWellESP.calc_Pintake_p_wf_atma: ошибка" & sDELIM & Err.Description
''    add_log_msg errmsg
''    RaiseEvent ReportProgress(errmsg)
''    Err.Raise kErrInitCalc, Err.source, errmsg
''
''End Function
''
''Public Function calc_pwf_pint_atma( _
''                             ByVal pintake_atma As Double) As Double
''' @brief расчет забойного давления через давление на приеме   (сверху -> вниз)
''' @param p_wf_atma - исходное забойное давление
''
''On Error GoTo err1:
''    ' 1. Начало расчета. Задано давление на приеме Pintake_atma
''    '    температуру на приеме явно задавать не надо - она определится из температурной модели
''    '                                           сработают только простые температурные модели
''    PT_int_.p_atma = pintake_atma
''    Dim t_int_C As Double
''    t_int_C = PT_int_.t_C
''    pipe_cas_below_pump_.param = set_calc_flow_param(True, False, hcor_, temp_method_)
''    ' Расчитываем давление на приеме (p_wf - забойное давление на работающей скважине, Pws - забойное давление на неработающей скважине,)
''    ' todo 30/07/2019 надо тут разобраться с температурой
''    PT_wf_ = pipe_cas_below_pump_.calc_dPipe(pintake_atma)
''    calc_pwf_pint_atma = PT_wf_.p_atma
''
''    Exit Function
''err1:
''    Dim errmsg As String
''    errmsg = "CWellESP.calc_pwf_pint_atma: ошибка" & sDELIM & Err.Description
''    add_log_msg errmsg
''    RaiseEvent ReportProgress(errmsg)
''    Err.Raise kErrInitCalc, Err.source, errmsg
''
''End Function
'
'Public Function calc_plin_p_wf_atma( _
'                             ByVal p_wf_atma As Double, _
'                             ByVal twf_C As Double, _
'                             ByVal q_liq_sm3day As Double, _
'                    Optional ByVal fw_perc As Double, _
'                    Optional ByVal q_gas_sm3day As Double = 0, _
'                    Optional ByVal p_cas_atma As Double, _
'                    Optional ByVal saveCurve As CALC_RESULTS = nocurves _
'                                  ) As Double
'' wellhead pressure calculation through bottom hole pressure (bottom -> top)
'' key params must be given explicitly
'' p_wf_atma - initial face pressure
'' saveCurve - shows how much detail the results of the calculation should be saved.
'
'Dim Tintake_esp_C As Double
'Dim PT_cas__temp As PTtype
'Dim p_PTintgas_temp As PTtype
'Dim Tan_C As Double
'Dim pcur As CInterpolation
'
'  If q_liq_sm3day > 0 Then fluid.q_liq_sm3day = q_liq_sm3day
'    fluid.fw_perc = fw_perc
'    fluid.q_gas_free_sm3day = q_gas_sm3day
'
'On Error GoTo err1:
'    ' 1. Start the calculation. set bottomhole pressure p_wf, bottomhole temperature Tbh
'    PT_wf_.p_atma = p_wf_atma
'    t_bh_C_ = twf_C
'    PT_wf_.t_C = t_bh_C_
'
'    ' 2. Pintake pressure and flow temperature in front of pump are calculated.
'    With pipe_cas_below_pump_
'        .param = set_calc_flow_param(False, False, hcor_, temp_method_)
'        PT_int_ = .calc_dPipe(PT_wf_.p_atma, t_bh_C_, saveCurve:=saveCurve)
'
'        ' если давление на приеме меньше 1 значит поток не доходит до насоса, значит надо поправить расчеты
'        If PT_int_.p_atma < 1 Then
'            calc_plin_p_wf_atma = 0
'            GoTo save_cont:
'            Exit Function
'        End If
'
'        ' save intake conditions for output
'        Call .fluid.calc_PVT_PT(PT_int_)
'        gas_frac_intake_before_separ_d = .fluid.gas_fraction_d
'        gas_frac_intake_after_separ_d = gas_frac_intake_before_separ_d
'
'    End With
'    ' 3. Расчет изменения температуры в насосе Если есть насос
'    If isCalcESP Then
'        '3.1  сначала пытаемся оценить перепад давления вдоль двигателя и давление на приемной сетке насоса
'        If Not (pipe_ann_pump_intake_motor_ Is Nothing) Then
'            With pipe_ann_pump_intake_motor_
'                ' рассчитываем перепад давления в зазоре между ПЭД ЭЦН и э/к
'                ' для расчета используем простую корреляцию ББ - так как другие при расчете в узких зазорах могут давать странные результаты
'                .param = set_calc_flow_param(False, False, BeggsBrill, temp_method_)
'                PT_pump_bottom_ = PT_int_
'                PT_int_ = .calc_dPipe(PT_pump_bottom_.p_atma, PT_pump_bottom_.t_C, saveCurve:=saveCurve)
'                ' если давление на приеме меньше 1 значит поток не доходит до насоса, значит надо поправить расчеты
'                If PT_int_.p_atma < 1 Then
'                    calc_plin_p_wf_atma = 0
'                    GoTo save_cont:
'                    Exit Function
'                End If
'            End With
'        End If
'
'        ' 3.2 потом считаем сепарацию и модификацию флюидов
'       ' Call esp.separ.calc_separation(PT_int_.p_atma, PT_int_.t_C)
'        esp.t_int_C = PT_int_.t_C
'
'        ' save intake conditions for output
'        Call esp.ESP_pump.fluid.calc_PVT_PT(PT_int_)
'        gas_frac_intake_after_separ_d = esp.ESP_pump.fluid.gas_fraction_d
'        qgas_cas_sm3day = esp.fluid_cas.q_gas_free_sm3day
'        qgas_tub_sm3day = esp.fluid_tub.q_gas_sm3day
'
'        ' 3.3 считаем перепад давления насоса
'        Call esp.calc_ESPsys(PT_int_.p_atma, PT_int_.t_C, PT_int_.t_C, calc_temperature:=isCalcESPtemp)
'        PT_dis_ = set_PT(esp.ESP_pump.p_dis_atma, esp.ESP_pump.t_dis_C)
'        Set pipe_tub_above_pump_.fluid = esp.fluid_tub       ' учитываем что выше насоса пойдет модифицированный флюид
'        Set pipe_ann_above_pump_.fluid = esp.fluid_cas
'        Set pipe_ann_gas_above_pump_.fluid = esp.fluid_cas
'    Else                                                            ' Если насоса нет, то совпадают
'        PT_dis_ = PT_int_
'    End If
'
'    ' 4. Рассчитываем затруб и динамический уровень  calc casing (dynamic level) if data given
'    If isCalcCasing And isCalcESP Then
'        Call calc_casing(p_cas_atma)
'    End If
'
'    ' 5. Расчет распределения давления в НКТ и расчет буферного давления c учетом движения в НКТ нефти после сепарации PVTtub
'    With pipe_tub_above_pump_
'        .param = set_calc_flow_param(False, False, hcor_, temp_method_)
'        .t_calc_C = PT_dis_.t_C
'        PT_buf_ = .calc_dPipe(PT_dis_.p_atma, PT_dis_.t_C, saveCurve)
'    End With
'
'    ' 8. Расчет линейного давления по штуцеру
'    On Error GoTo err_choke:
'        If choke.d_choke_m > 0 Then       ' пока отключено
'            PT_lin_ = choke.calc_choke_p_lin(PT_buf_)
'            If PT_lin_.p_atma <= 0 Then
'                PT_lin_.p_atma = 0
'            End If
'        Else
'            PT_lin_ = PT_buf_
'        End If
'resume_after_choke:
'    On Error GoTo err1:
'    ' Если при заданном затрубном давлении Pan существует отличный от нуля динамический уровень Hdyn
'    ' то в качестве результатов расчетов сохраняются эти значения
'    ' уже подсчитано
'    calc_plin_p_wf_atma = PT_lin_.p_atma
'
'save_cont:
'    Call save_curves(saveCurve)
'
'    Exit Function
'err_choke:
'    add_log_msg "CWellESP.calc_plin_p_wf_atma: error in choke calculation. p_buf = ", S(PT_buf_.p_atma)
'    Resume resume_after_choke:
'
'    Exit Function
'err1:
'    Dim errmsg As String
'    errmsg = "CWellESP.calc_plin_p_wf_atma: error in well pressure calculation -> " & sDELIM & Err.Description
'    'add_log_msg errmsg
'    RaiseEvent ReportProgress(errmsg)
'    Err.Raise kErrInitCalc, Err.source, errmsg
'
'End Function
'
''Public Function calc_pwf_plin_atma(ByVal plin_atma As Double, _
''                                   ByVal t_bh_C As Double, _
''                                   Optional fast As Boolean = True, _
''                                   Optional saveCurve As CALC_RESULTS = nocurves)
''' функция расчета сверху вниз
''' тут смотрим можно ли провести расчет быстро
''' или надо вызывать медленный метод (итерациями снизу вверх)
''   ' надо сделать приближение по расчету давления - чтобы сработала сепарация
''   If p_int_atma = 0 Then PT_int_ = set_PT(50, t_bh_C)
''   If fast And temp_method_ <> AmbientTemp Then
''      calc_pwf_plin_atma = fast_pwf_plin_atma(plin_atma, t_bh_C, saveCurve)
''   Else
''      calc_pwf_plin_atma = slow_pwf_plin_atma(plin_atma, t_bh_C, saveCurve)
''   End If
''
''End Function
''
''Public Function calc_well(ByVal plin_atma As Double, _
''                          ByVal pbuf_atma As Double, _
''                          ByVal p_wf_atma As Double, _
''                          ByVal p_cas_atma As Double) As Boolean
'''функция анализа работы скважины и определения ключевых параметров по скважине
'''надо еще сюда добавить расчет забойного давления по динамическому уровню или давлению на приеме и получится замкнутый анализ скважины
'''надо еще сюда добавить построение всех графиков по скважине
''' после выполнения этой функции можно сказать что расчет по скважине проведен в полном объеме
''   Dim i As Integer
''   Dim p_linTemp_atma As Double
''   Dim PbufTemp_atma As Double
''   Dim ESPdegrDir As Double
''   Dim p_linOld1 As Double, p_linOld2 As Double
''   Dim foundDegr As Boolean
''On Error GoTo err1:
''   calc_well = True    ' по умолчанию ждем что все будет хорошо
''   esp.calibr_head = 0   ' деградация УЭЦН = 0
''   ' расчет параетров калибровки штуцера
''   '     - проводится если только данные для штуцера коррекно заданы
''   '     - если линейное давление и оно меньше буферного
''   If plin_atma > 0 And pbuf_atma > plin_atma And choke.d_choke_m > 0 Then
''       '  ищем распределение давления в скважине соответствующее текущим условиям
''       Call choke.calc_choke_calibration(pbuf_atma, plin_atma, t_wh_C)
''       ' определили поправочный коэффициент для штуцера
''   End If
''   isCalcCasing = False
''   p_linTemp_atma = calc_plin_p_wf_atma(p_wf_atma)
''   ' получаем на выходе коэффициент сепарации и параметры флюида на участке выше насоса
''   If isEqual(PT_dis_.p_atma, PT_int_.p_atma) Then ' значит насос не развивает перепад давления и подобрать коэффициент деградации не удасться
''       calc_well = False     ' расчет провести не удалось
''       esp.calibr_head = 0   ' возвращаем насос в исходное состояние
''       Exit Function
''   End If
''   esp.calibr_head = FindDegradation(plin_atma, p_wf_atma)
''   ' перерасчитываем распределения давления в скважине с учетом деградации
''   isCalcCasing = True
''   p_linTemp_atma = calc_plin_p_wf_atma(p_wf_atma)
''   ' после этого расчета определили все параметры по скважине которые нас могут интересовать
''   Exit Function
''err1:
''    If Err.Number = kErrDegradationNotFound Then
''        calc_well = False     ' расчет провести не удалось
''        esp.calibr_head = 0   ' возвращаем насос в исходное состояние
''        Exit Function
''    Else
''        Dim errmsg As String
''        errmsg = "CWellESP.calc_well: ошибка" & sDELIM & Err.Description
''        add_log_msg errmsg
''        RaiseEvent ReportProgress(errmsg)
''        Err.Raise kErrInitCalc, Err.source, errmsg
''    End If
''
''End Function
'
'Public Sub set_flow_param( _
'                Optional ByVal calc_along_coord As Boolean = False, _
'                Optional ByVal flow_along_coord As Boolean = False, _
'                Optional ByVal hcor As H_CORRELATION = Ansari, _
'                Optional ByVal temp_method As TEMP_CALC_METHOD = StartEndTemp, _
'                Optional ByVal length_gas_m As Double = 0)
'' calc_along_coord - calculation direction flag
'' flow_along_coord - flow direction relative to coordinate
'' hcor             - hydraulic correlation selector
'' temp_method      - temperature method selector
'' length_gas_m     - boundary of gas correlation application in flow
'
'    Dim prm As PARAMCALC
'    prm.calc_along_coord = calc_along_coord
'    prm.flow_along_coord = flow_along_coord
'    prm.correlation = hcor
'    prm.temp_method = temp_method
'    prm.length_gas_m = length_gas_m
'
'    hcor_ = hcor
'    temp_method_ = temp_method
'
'    pipe_tub_above_pump_.param = prm
'    pipe_cas_below_pump_.param = prm
'
'End Sub
'
'Public Sub set_annulus_param( _
'                Optional ByVal calc_along_coord As Boolean = False, _
'                Optional ByVal flow_along_coord As Boolean = False, _
'                Optional ByVal hcor As H_CORRELATION = Ansari, _
'                Optional ByVal temp_method As TEMP_CALC_METHOD = StartEndTemp, _
'                Optional ByVal length_gas_m As Double = 0)
'' calc_along_coord - calculation direction flag
'' flow_along_coord - flow direction relative to coordinate
'' hcor             - hydraulic correlation selector
'' temp_method      - temperature method selector
'' length_gas_m     - boundary of gas correlation application in flow
'
'    Dim prm As PARAMCALC
'    prm.calc_along_coord = calc_along_coord
'    prm.flow_along_coord = flow_along_coord
'    prm.correlation = hcor
'    prm.temp_method = temp_method
'    prm.length_gas_m = length_gas_m
'
'    hcor_ = hcor
'    temp_method_ = temp_method
'
'    pipe_ann_above_pump_.param = prm
'    pipe_ann_gas_above_pump_.param = prm
'
'End Sub
'
'Public Sub set_flow_at_pump_param( _
'                Optional ByVal calc_along_coord As Boolean = False, _
'                Optional ByVal flow_along_coord As Boolean = False, _
'                Optional ByVal hcor As H_CORRELATION = Ansari, _
'                Optional ByVal temp_method As TEMP_CALC_METHOD = StartEndTemp, _
'                Optional ByVal length_gas_m As Double = 0)
'' calc_along_coord - calculation direction flag
'' flow_along_coord - flow direction relative to coordinate
'' hcor             - hydraulic correlation selector
'' temp_method      - temperature method selector
'' length_gas_m     - boundary of gas correlation application in flow
'
'    Dim prm As PARAMCALC
'    prm.calc_along_coord = calc_along_coord
'    prm.flow_along_coord = flow_along_coord
'    prm.correlation = hcor
'    prm.temp_method = temp_method
'    prm.length_gas_m = length_gas_m
'
'    hcor_ = hcor
'    temp_method_ = temp_method
'
'    pipe_ann_pump_intake_discharge_.param = prm
'    pipe_ann_pump_intake_motor_.param = prm
'
'End Sub
'
''------------------------------------------------------------
'' ESP  properties
''------------------------------------------------------------
'Public Property Get esp() As CESPsystem
'    Set esp = ESP_
'End Property
'
'Public Property Set esp(val As CESPsystem)
'    Set ESP_ = val
'    If Not val Is Nothing Then
'        Set ESP_.fluid = fluid
'    End If
'End Property
'
''------------------------------------------------------------
'' ESP well specific properties
''------------------------------------------------------------
'Public Property Get p_int_atma() As Double
'' давление на приеме
'   p_int_atma = PT_int_.p_atma
'End Property
'
'Public Property Get p_dis_atma() As Double
' ' давление на приеме
'   p_dis_atma = PT_dis_.p_atma
'End Property
'
'Public Property Get t_int_C() As Double
'   t_int_C = PT_int_.t_C
'End Property
'
'Public Property Get t_dis_C() As Double
'   t_dis_C = PT_dis_.t_C
'End Property
'
'Public Property Get h_dyn_m() As String
'    If Hdyn_Pcas_.correct Then
'        h_dyn_m = CStr(Hdyn_Pcas_.hdyn_m)
'    ElseIf Hdyn_Pcas_.pump_off_condition Then
'        h_dyn_m = CStr(Hdyn_Pcas_.hdyn_m) + "+pump_off"
'    ElseIf Hdyn_Pcas_.self_flow_condition Then
'        h_dyn_m = CStr(Hdyn_Pcas_.hdyn_m) + "+self_flow"
'    Else
'        h_dyn_m = "no"
'    End If
'End Property
'
''Public Sub init_well_simple_numbers( _
''                          ByVal h_perf_m As Double, _
''                          ByVal h_tub_m As Double, _
''                          ByVal udl_m As Double, _
''                          ByVal d_cas_mm As Variant, _
''                          ByVal d_tub_mm As Variant)
''
''    Dim habs_curve_m As New CInterpolation
''    Dim dcas_curve_mm As New CInterpolation
''    Dim dtub_curve_mm As New CInterpolation
''    Dim errmsg As String
''
''On Error GoTo err1:
''
''    habs_curve_m.AddPoint 0, 0
''    habs_curve_m.AddPoint h_perf_m, h_perf_m - udl_m
''
''    dcas_curve_mm.AddPoint 0, d_cas_mm
''    dcas_curve_mm.AddPoint h_perf_m, d_cas_mm
''
''    dtub_curve_mm.AddPoint 0, d_tub_mm
''    dtub_curve_mm.AddPoint h_tub_m, d_tub_mm
''
''    Call trajectory_tub.init_from_curves(habs_curve_m, dtub_curve_mm)
''    Call trajectory_cas.init_from_curves(habs_curve_m, dcas_curve_mm)
''
''    Me.h_perf_m = h_perf_m
''    Me.h_tub_m = trajectory_tub.bottom_m  ' tubing must be cut already at this point here
''
''    Call FillWellConstructionTr
''
''    Exit Sub
''err1:
''   errmsg = "init_well_simple_numbers: Ошибка простой инициализации скважины " & sDELIM & Err.Description
''   Err.Raise kErrInitCalc, Err.source, errmsg
''
''End Sub
'
''Public Sub init_well_extended( _
''                          ByVal h_perf_m As Double, _
''                          ByVal incl_h_mes_m As Variant, _
''                 Optional ByVal incl_h_vert_m As Variant, _
''                 Optional ByVal dcas_arr_hmes_m As Variant, _
''                 Optional ByVal dcas_arr_mm As Variant, _
''                 Optional ByVal dtub_arr_hmes_m As Variant, _
''                 Optional ByVal dtub_arr_mm As Variant)
''
''    Dim habs_curve_m As New CInterpolation
''    Dim dcas_curve_mm As New CInterpolation
''    Dim dtub_curve_mm As New CInterpolation
''    Dim errmsg As String
''
''On Error GoTo err1:
''        ' проверим сначала конструкцию и инклинометрию скважины
''        ' не делаем лишних проверок - ожидаем что прочитать получится
''        If Not IsMissing(incl_h_mes_m) And IsMissing(incl_h_vert_m) Then
''            Call habs_curve_m.loadFromVertRange(incl_h_mes_m) ' читаем инклинометрию из одной таблицы
''        ElseIf Not IsMissing(incl_h_mes_m) And Not IsMissing(incl_h_vert_m) Then
''            Call habs_curve_m.loadFromVertRange(incl_h_mes_m, incl_h_vert_m) ' читаем инклинометрию из двух столбцов
''
''        End If
''
''
''        ' проверим диаметры эксплуатационной колонны
''        If Not IsMissing(dcas_arr_mm) And IsMissing(dcas_arr_hmes_m) Then
''            Call dcas_curve_mm.loadFromVertRange(dcas_arr_mm) ' читаем инклинометрию из одной таблицы
''        ElseIf Not IsMissing(dcas_arr_mm) And Not IsMissing(dcas_arr_hmes_m) Then
''            Call dcas_curve_mm.loadFromVertRange(dcas_arr_hmes_m, dcas_arr_mm) ' читаем инклинометрию из двух столбцов
''        End If
''
''        ' проверим диаметры НКТ
''        If Not IsMissing(dtub_arr_mm) And IsMissing(dtub_arr_hmes_m) Then
''            Call dtub_curve_mm.loadFromVertRange(dtub_arr_mm) ' читаем инклинометрию из одной таблицы
''        ElseIf Not IsMissing(dtub_arr_mm) And Not IsMissing(dtub_arr_hmes_m) Then
''            Call dtub_curve_mm.loadFromVertRange(dtub_arr_hmes_m, dtub_arr_mm) ' читаем инклинометрию из двух столбцов
''        End If
''        Call trajectory_tub.init_from_curves(habs_curve_m, dtub_curve_mm)
''        Call trajectory_cas.init_from_curves(habs_curve_m, dcas_curve_mm)
''
''        Me.h_perf_m = h_perf_m
''        Me.h_tub_m = trajectory_tub.bottom_m  ' tubing must be cut already at this point here
''
''        Call FillWellConstructionTr
''
''    Exit Sub
''err1:
''   errmsg = "init_well_extended: Ошибка расширенной инициализации скважины " & sDELIM & Err.Description
''   Err.Raise kErrInitCalc, Err.source, errmsg
''
''End Sub
'
'Private Sub set_well_trajectory( _
'                          ByVal h_perf_m As Double, _
'                 Optional ByVal tr_cas As CPipeTrajectory, _
'                 Optional ByVal tr_tub As CPipeTrajectory)
'
'On Error GoTo err1:
'
'    Set trajectory_tub = tr_tub
'    Set trajectory_cas = tr_cas
'
'    Me.h_perf_m = h_perf_m
'    Me.h_tub_m = trajectory_tub.bottom_m  ' tubing must be cut already at this point here
'
'    Call FillWellConstructionTr
'
'    Exit Sub
'err1:
'   Dim errmsg As String
'   errmsg = "set_well_trajectory: Ошибка простой инициализации скважины " & sDELIM & Err.Description
'   Err.Raise kErrInitCalc, Err.source, errmsg
'
'End Sub
'
'
'' полная инициализация скважины по данным с листа Excel
'Public Sub init_well_full( _
'    Optional ByVal str_PVT As String = PVT_DEFAULT, _
'    Optional ByVal str_construct As String = WELL_DEFAULT, _
'    Optional ByVal str_ESP As String = "", _
'    Optional ByVal str_gassep As String = "", _
'    Optional ByVal str_motor As String = "", _
'    Optional ByVal str_cable As String = "", _
'    Optional ByVal str_amb As String = "", _
'    Optional ByVal ksep_tot As Double, _
'    Optional ByVal hydr_corr As H_CORRELATION = 0, _
'    Optional ByVal temp_method As TEMP_CALC_METHOD = StartEndTemp, _
'    Optional ByVal calibr = 1)
'
'
'    Dim tr_cas As CPipeTrajectory
'    Dim tr_tub As CPipeTrajectory
'    Dim amb As CAmbientFormation
'    Dim temp_crv As CInterpolation
'    Dim calibr_grav As Double
'    Dim calibr_fric As Double
'    Dim calibr_choke As Double
'
'    Dim dict_constr As Dictionary
'    Dim h_list_m As Collection
'    Dim d_cas_list_mm As Collection
'    Dim d_tub_list_mm As Collection
'    Dim t_val_C As Collection
'    Dim h_tub_m As Double
'    Dim d_choke_mm As Double
'    Dim roughness_m As Double
'
'    Dim tvl
'On Error GoTo err1:
'
'    ' ====== ESP ===============
'    If Len(str_ESP) < 3 Then
'        Set ESP_ = Nothing
'    Else
'        Set ESP_ = New CESPsystem
'        Call ESP_.init_json(str_ESP, str_motor, str_cable, str_gassep)
'
'        isCalcESPtemp = True
'        isCalcCasing = True
'        ' set separation coefficient if given
''        If esp.separ.ksep_total_manual_fr >= 0 And esp.separ.ksep_total_manual_fr <= 1 Then
''            Call esp.separ.set_ksep_total(valueManual, esp.separ.ksep_total_manual_fr, 0)
''        Else
''            'Call esp.set_ksep_total(byCorrealation, esp.ksep_manual_fr, esp.ksep_gassep_fr)
''        End If
'    End If
'
'    ' ====== well construction ===============
'    Set dict_constr = ParseJson(str_construct)
'    With dict_constr
'        h_perf_m = .Item("h_perf_m")
'        h_tub_m = .Item("h_tub_m")
'        roughness_m = .Item("rough_m")
'        d_choke_mm = .Item("d_choke_mm")
'
'        ' дальше читаем сложные парамметры - получим на выходе коллекции
'        Set t_val_C = .Item("t_val_C")
'        Set h_list_m = .Item("h_list_m")
'        Set d_cas_list_mm = .Item("d_cas_list_mm")
'        Set d_tub_list_mm = .Item("d_tub_list_mm")
'    End With
'
'    Set tr_cas = New CPipeTrajectory
'    Call tr_cas.init_from_vert_range(h_list_m, d_cas_list_mm)
'    tr_cas.roughness_m = roughness_m
'
'    Set tr_tub = New CPipeTrajectory
'    Call tr_tub.init_from_vert_range(h_list_m, d_tub_list_mm, h_tub_m)
'    tr_tub.roughness_m = roughness_m
'
'    Call set_well_trajectory(h_perf_m, tr_cas:=tr_cas, tr_tub:=tr_tub)
'    ' ====== ambient formation ===============
'    tvl = array_num_from_range(t_val_C, True)
'
'    Set amb = New CAmbientFormation
'    Call amb.set_props_json(str_amb)
'    If UBound(tvl, 1) = 1 Or UBound(tvl, 2) = 1 Then
'        Call amb.init_amb_temp_points(0, tvl(1, 1), h_perf_m, tvl(1, 1))
'    Else
'        Call amb.init_amb_temp_arr(t_val_C)
'    End If
'    Set ambient_formation = amb
'
'    ' ====== pvt ===============
'
'    Call fluid.init_feed(str_PVT)
'
'    choke.d_choke_m = d_choke_mm / 1000
'
'    ' запомним настройки корреляция для дальнейшего применения
'    hcor_ = hydr_corr
'    temp_method_ = temp_method
'
'    Call read_calibr(calibr, calibr_grav_, calibr_fric_, choke.calibr_fr)
'
''   Me.p_cas_atma = p_cas_atma
'
'    Exit Sub
'
'err1:
'    Dim errmsg As String
'    errmsg = "CWellESP.init_well_full: error   -> " & sDELIM & Err.Description
'    'add_log_msg errmsg
'    Err.Raise kErrWellConstruction, , errmsg
'End Sub
'
'
'Private Sub FillWellConstructionTr()
'    Dim ESPintake_m As Double
'    Dim ESPbottom_m As Double
'    Dim NN As Integer
'    Dim tr_tub_new As CPipeTrajectory
'    Dim crv_habs_m As CInterpolation
'    Dim crv_diam_mm As CInterpolation
'
'    ' инициализация скважины по данным траектории скважин
'    Call pipe_tub_above_pump_.init_pipe_constr_by_trajectory(trajectory_tub, 0, h_tub_m)
'    h_sp_m_ = h_tub_m ' определим глубину спуска установки
'
'
'    If Not ESP_ Is Nothing Then
'        ' оценим диаметр э/к в месте установки насоса
'        esp.d_cas_mm = trajectory_cas.diam_hmes_m(h_sp_m_) * 1000
'        ESP_.angle_deg = trajectory_cas.ang_hmes_deg(h_sp_m_)
'        d_cas_pump_mm_ = esp.d_cas_mm
'    End If
'
'    If isCalcESP Then
'        esp.h_mes_top_m = h_sp_m_  ' установим глубину спуска оборудования
'        ESPbottom_m = esp.h_mes_bottom_m
'        ESPintake_m = esp.h_mes_intake_m
'
'        ' установим доп параметры для сепарации, после того, как они определены
'        Call esp.separ.set_gassep_param(OD_mm:=esp.d_intake_mm, _
'                                    h_mes_top_m:=esp.h_mes_intake_m, _
'                                    d_cas_mm:=esp.d_cas_mm, _
'                                    angle_deg:=esp.angle_deg)
'
'        ' добавим диаметры насоса и двигателя
'        Set crv_habs_m = trajectory_tub.get_habs_curve_m
'        Set crv_diam_mm = trajectory_tub.get_diam_curve_mm
'        Call crv_diam_mm.AddPoint(h_sp_m_, esp.ESP_pump.db.d_od_m * 1000, True)
'        Call crv_diam_mm.AddPoint(ESPintake_m, esp.ESP_pump.db.d_motor_od_m * 1000, True)
'
'        Set tr_tub_new = New CPipeTrajectory
'        Call tr_tub_new.init_from_curves(crv_habs_m, crv_diam_mm)
'
'        Set pipe_ann_pump_intake_discharge_ = New CPipe
'        With pipe_ann_pump_intake_discharge_
'           Call .init_pipe_constr_by_trajectory(tr_tub_new, h_sp_m_, ESPintake_m, trajectory_cas)
'            Set .fluid = pipe_cas_below_pump_.fluid
'            Set .ambient_formation = ambient_formation_
'        End With
'
'        Set pipe_ann_pump_intake_motor_ = New CPipe
'        With pipe_ann_pump_intake_motor_
'           Call .init_pipe_constr_by_trajectory(tr_tub_new, ESPintake_m, ESPbottom_m, trajectory_cas)
'            Set .fluid = pipe_ann_above_pump_.fluid
'            Set .ambient_formation = ambient_formation_
'        End With
'
'    Else
'        ESPintake_m = h_sp_m_
'        ESPbottom_m = h_sp_m_
'    End If
'
'        ' оценим диаметр э/к в месте установки насоса для справки и вывода
'    d_cas_pump_mm_ = MinReal(trajectory_cas.diam_hmes_m(h_sp_m_), trajectory_cas.diam_hmes_m(ESPbottom_m)) * 1000
'
'    ' созданим трубу для затруба с учетом длины насоса (участок от приема до выкида насоса учитывается в затрубе)
'    Call pipe_ann_above_pump_.init_pipe_constr_by_trajectory(trajectory_tub, 0, h_sp_m_, trajectory_cas)
'    Call pipe_ann_gas_above_pump_.init_pipe_constr_by_trajectory(trajectory_tub, 0, h_sp_m_, trajectory_cas)
'    Call pipe_cas_below_pump_.init_pipe_constr_by_trajectory(trajectory_cas, ESPbottom_m, h_perf_m)
'
'    choke.d_up_m = 0.06
'    choke.d_down_m = 0.06
'
'    Set pipe_tub_above_pump_.ambient_formation = ambient_formation_
'    Set pipe_cas_below_pump_.ambient_formation = ambient_formation_
'    Set pipe_ann_above_pump_.ambient_formation = ambient_formation_
'    Set pipe_ann_gas_above_pump_.ambient_formation = ambient_formation_
'
'    ' repopulate calibration values to new pipes
'    calibr_fric = calibr_fric
'    calibr_grav = calibr_grav
'End Sub
'
''Private Function FindDegradation(ByVal plin_targ As Double, _
''                                 ByVal p_wf_atma As Double)
''' функция для поиска значения деградации УЭЦН
''' plin_targ  - целевое значение линейного давления
''' p_wf_atma   - забойное давление
'''
''' kESP = 1 - degr  поправочный коэффициент на насос
''   Dim kESP1 As Double ', degr2 As Double
''   Dim p_lin1 As Double ', p_lin2 As Double
''   Dim kESP_Up As Double   ' верхняя граница значения деградации
''   Dim kESP_Down As Double ' нижняя граница значения деградации
''   Dim plin_Up As Double
''   Dim plin_Down As Double
''   Dim found_solution As Double
''   Dim i As Integer
''    Dim errmsg As String
''
''On Error GoTo err1:
''   i = 0
''   ' first guess of cf cf=0
''   curve(str_Pdisc_calibr_head_curve).ClearPoints
''   isCalcCasing = False
''
''   kESP1 = 1
''   ' max cf
''   kESP_Up = 10
''   esp.calibr_head = 1 - kESP_Up
''   p_lin1 = calc_plin_p_wf_atma(p_wf_atma)
''   curve(str_Pdisc_calibr_head_curve).AddPoint p_lin1, 1 - kESP_Up
''   ' check if high limit is ok
''   If p_lin1 > plin_targ Then
''       plin_Up = p_lin1
''   Else
''        errmsg = " CWellESP.FindDegradation: cf must be too high (more that 10 times) " & sDELIM & Err.Description
''        GoTo err2:
''        Exit Function
''   End If
''
''   kESP_Down = -10
''
''   esp.calibr_head = 1 - kESP_Down
''   p_lin1 = calc_plin_p_wf_atma(p_wf_atma)
''   curve(str_Pdisc_calibr_head_curve).AddPoint p_lin1, 1 - kESP_Up
''   ' check if low limit is ok
''   If p_lin1 < plin_targ Then
''       plin_Down = p_lin1
''   Else
''       errmsg = " CWellESP.FindDegradation: can't find correction. flow without pump" & sDELIM & Err.Description
''       GoTo err2:
''       Exit Function
''   End If
''
''   Do
''       esp.calibr_head = 1 - kESP1
''       p_lin1 = calc_plin_p_wf_atma(p_wf_atma)
''       curve(str_Pdisc_calibr_head_curve).AddPoint p_lin1, 1 - kESP1
''       ' посмотрим если вдруг нашли решение то запомним его и завершим расчет
''       If (Abs(p_lin1 - plin_targ) < const_well_P_tolerance) Then
''            found_solution = True
''            FindDegradation = esp.calibr_head
''            Exit Function
''       End If
''       If Not found_solution Then
''          If p_lin1 > plin_targ Then
''               ' если новое лин давление больше целевого - значит нашли нижнюю границу деградации - искомое значение должно быть больше
''              kESP_Up = kESP1
''              plin_Up = p_lin1
''              If (plin_Down >= 0) And (plin_Down < plin_targ) Then
''                  kESP1 = (kESP_Up + kESP_Down) / 2 'kESP1 + (kESP_Up - kESP_Down) * (plin_targ - plin_Down) / (plin_Up - plin_Down) '
''              Else
''                  kESP1 = kESP1 - 1
''              End If
''          Else
''              kESP_Down = kESP1
''              plin_Down = p_lin1
''              If (plin_Up > 0) And (plin_Up > plin_targ) Then
''                  kESP1 = (kESP_Up + kESP_Down) / 2 'kESP1 + (kESP_Up - kESP_Down) * (plin_targ - plin_Down) / (plin_Up - plin_Down) '
''              Else
''                  kESP1 = kESP1 + 1
''              End If
''          End If
''        End If
''       i = i + 1
''   Loop While Not found_solution And i < 20
''
''   Exit Function
''err1:
''    errmsg = " CWellESP.FindDegradation: ошибка" & sDELIM & Err.Description
''    add_log_msg errmsg
''    RaiseEvent ReportProgress(errmsg)
''    Err.Raise kErrDegradationError, Err.source, errmsg
''   Exit Function
''err2:
''    On Error GoTo 0
''    add_log_msg errmsg
''    RaiseEvent ReportProgress(errmsg)
''    Err.Raise kErrDegradationNotFound, Err.source, errmsg
''
''End Function
'
'Private Sub calc_casing(pcas As Double)
''  расчет параметров затрубного простраства скважины
''  должно быть задано давление на приеме - от которого проводится расчет снизу вверх
''                     и затрубное давление - от которого проводится расчет сверзу вниз
''  результат расчет - распределение давление и значение динамического уровня
'
'    Dim PT_cas__temp As PTtype
'    Dim p_PTintgas_temp As PTtype
'    Dim p_PTcasgas_temp As PTtype
'    Dim cas_crv As CInterpolation
'    Dim num_Hd As Integer
'    Dim H_dyn_m_ As Double
'
'On Error GoTo err_casing:
'        ' 1. Оценим перепад давления в пространств между приемом насоса выкидом насоса для затруба, если это можно сделать
'        Dim PTcas_dis As PTtype
'        If Not pipe_ann_pump_intake_discharge_ Is Nothing Then
'            With pipe_ann_pump_intake_discharge_
'                .param = set_calc_flow_param(False, False, hcor_, temp_method_)
'                .set_ZNLF
'                PTcas_dis = .calc_dPipe(PT_int_.p_atma, PT_int_.t_C, allCurves)
'            End With
'        Else
'            PTcas_dis = PT_int_
'        End If
'
'        ' 2. Расчет расхода свободного газа двигающегося через затрубное пространство после сепарации
'        ' для затруба считаем снизу вверх
'        With pipe_ann_above_pump_
'            .param = set_calc_flow_param(False, False, hcor_, temp_method_)
'            .set_ZNLF
'            PT_cas__temp = .calc_dPipe(PTcas_dis.p_atma, PTcas_dis.t_C, allCurves)
'        End With
'
'        ' 3. для затруба считаем распределение давления в газовом столбе сверху вниз
'        PT_cas_.p_atma = pcas
'        With pipe_ann_gas_above_pump_
'            .param = set_calc_flow_param(True, True, gas, temp_method_)
'            p_PTintgas_temp = .calc_dPipe(PT_cas_.p_atma, PT_cas_.t_C, allCurves)
'        End With
'
'        ' 4. найдем пересечение  распределений газа и жидкости в затрубе по давлению
'        Set cas_crv = pipe_ann_above_pump_.p_curve.SubtractCurve(pipe_ann_gas_above_pump_.p_curve)
'        num_Hd = cas_crv.FindSolutions(0, TS_NO_EXTRPOLATION)  ' ищем количество пересечений
'
'        ' 5. если пересечение одно, то все в порядке - это Ндин если значение хорошее
'        If num_Hd = 1 Then
'            H_dyn_m_ = cas_crv.SolutionPointX(1)
'            Hdyn_Pcas_.correct = True
'            Hdyn_Pcas_.pump_off_condition = False
'            Hdyn_Pcas_.self_flow_condition = False
'            ' проверяем, чтобы значение динамического уровня было разумным, иначе фиксируем крайние значения
'            If H_dyn_m_ < 0 Then
'                H_dyn_m_ = 0
'                Hdyn_Pcas_.self_flow_condition = True
'            ElseIf H_dyn_m_ >= h_sp_m_ Then
'                H_dyn_m_ = h_sp_m_
'                Hdyn_Pcas_.pump_off_condition = True
'            End If
'            ' готовим кривую распределения давления в затрубе из двух - для жидкости и для газа
'            Set curve("Pcas_Hd") = pipe_ann_above_pump_.p_curve.CutByCurve(pipe_ann_gas_above_pump_.p_curve)
'            Dim crv_gas_hl As CInterpolation
'            Dim crv_liq_hl As CInterpolation
'            Set crv_liq_hl = pipe_ann_above_pump_.curve("c_Hl")
'            Set crv_gas_hl = pipe_ann_gas_above_pump_.curve("c_Hl")
'            Call curve("Pcas_Hl").FillByTemplate(crv_liq_hl, crv_gas_hl, curve("Pcas_Hd"), pipe_ann_above_pump_.p_curve, pipe_ann_gas_above_pump_.p_curve)
'            Hdyn_Pcas_.hdyn_m = H_dyn_m_
'            Hdyn_Pcas_.p_cas_atma = PT_cas_.p_atma
'        ElseIf num_Hd = 0 Then
'        ' 6. если пересечение найти не удалось - то фиксируем крайние значения
'
'            Hdyn_Pcas_.correct = False
'            Hdyn_Pcas_.pump_off_condition = False
'            Hdyn_Pcas_.self_flow_condition = False
'
'            pipe_ann_gas_above_pump_.param = set_calc_flow_param(False, False, gas, temp_method_)
'            p_PTcasgas_temp = pipe_ann_gas_above_pump_.calc_dPipe(PT_int_.p_atma, PT_int_.t_C, allCurves)
'
'            If PT_cas_.p_atma >= p_PTcasgas_temp.p_atma Then
'                H_dyn_m_ = h_sp_m_
'                ' готовим кривую распределения давления в затрубе из двух - для жидкости и для газа
'                Set curve("Pcas_Hd") = pipe_ann_gas_above_pump_.p_curve
'                Set curve("Pcas_Hl") = pipe_ann_gas_above_pump_.curve("c_Hl")
'                Hdyn_Pcas_.p_cas_atma = p_PTcasgas_temp.p_atma
'                Hdyn_Pcas_.pump_off_condition = True
'            Else
'                H_dyn_m_ = 0
'                ' готовим кривую распределения давления в затрубе из двух - для жидкости и для газа
'                Set curve("Pcas_Hd") = pipe_ann_above_pump_.p_curve
'                Set curve("Pcas_Hl") = pipe_ann_above_pump_.curve("c_Hl")
'                Hdyn_Pcas_.p_cas_atma = PT_cas_.p_atma
'                Hdyn_Pcas_.self_flow_condition = True
'            End If
'
'            Hdyn_Pcas_.hdyn_m = H_dyn_m_
'        Else
'        '7. если пересечений не одно, то пытаемся применить устаревший алгоритм без учета плотности газа
'            add_log_msg "CWellESP.calc_plin_p_wf_atma: abnormal casing behavior. Num of intersections =", num_Hd
'            ' Если заданному затрубному давлению Pan соответствует отрицательный динамический уровень Hdyn,
'            ' тогда ищется затрубное давление P(Hdyn=0)an соответствующее Hdyn=0 и данные значения сохраняются как результат
'            Hdyn_Pcas_.correct = False
'            Hdyn_Pcas_.pump_off_condition = False
'            Hdyn_Pcas_.self_flow_condition = False
'
'            If (PT_cas_.p_atma = 0 Or PT_cas_.p_atma >= PT_int_.p_atma) Then
'                'p_p_an_atma = pipe_ann_above_pump_.p_curve.getPoint(0)
'                H_dyn_m_ = h_sp_m_
'                'PT_cas_.p_atma = PT_int_.p_atma
'                Hdyn_Pcas_.p_cas_atma = PT_int_.p_atma
'                Hdyn_Pcas_.pump_off_condition = True
'            Else
'                With pipe_ann_above_pump_.p_curve
'                    H_dyn_m_ = .FindMinOneSolution(PT_cas_.p_atma)
'                    Hdyn_Pcas_.p_cas_atma = PT_cas_.p_atma
'                End With
'            End If
'
'            If (H_dyn_m_ < 0) Then
'                H_dyn_m_ = 0
'                Hdyn_Pcas_.p_cas_atma = pipe_ann_above_pump_.p_curve.getPoint(0)
'                Hdyn_Pcas_.pump_off_condition = True
'            End If
'
'            ' Если заданному затрубному давлению Pan соответствует динамический уровень Hdyn больше глубины спуска насоса Hpump, _
'            ' тогда ищется затрубное давление P(Hdyn=Hpump)an соответствующее Hdyn=Hpump и данные значения сохраняются как результат
'            If is_Hdyn_Larger_Hsp Then
'                H_dyn_m_ = h_sp_m_
'                PT_cas_.p_atma = pipe_ann_above_pump_.p_curve.getPoint(h_sp_m_)
'            End If
'            Set curve("Pcas_Hd") = pipe_ann_above_pump_.p_curve.CutByValue(H_dyn_m_)
'            Hdyn_Pcas_.hdyn_m = H_dyn_m_
'        End If
'        '7. сохраним параметры для расчета распределения давления
'        ambient_formation_.h_dyn_m = H_dyn_m_
'        ambient_formation_.h_pump_m = h_sp_m_
'        Call pipe_tub_above_pump_.add_h_mes_save_m(H_dyn_m_)
'    Exit Sub
'
'err_casing:
'    ' стандартная схема обработки ошибок
'    Dim err_str As String
'    err_str = "CWellESP.calc_casing: error in casing calculation. Pcas = " & S(PT_cas_.p_atma) & " -> " & sDELIM & Err.Description
'    'add_log_msg err_str
'    RaiseEvent ReportProgress(err_str)
'    Err.Raise Err.Number, Err.source, err_str
'
' End Sub
'
'Private Sub add_crv(crv_name As String, _
'                    crv_pipe_name As String, _
'                    tub As Boolean, _
'                    cas As Boolean, _
'                    xnam As String, _
'                    ynam As String, _
'                    Optional crv_name2 As String)
'    If crv_name2 = "" Then
'        If tub And cas Then
'            ' сохраняем кривую вдоль течения флюида
'            Call curve(crv_name).AddPointsCurve(pipe_tub_above_pump_.curve(crv_pipe_name), _
'                                                pipe_cas_below_pump_.curve(crv_pipe_name))
'            If Not pipe_ann_pump_intake_motor_ Is Nothing Then
'                Call curve(crv_name).AddPointsCurve(pipe_ann_pump_intake_motor_.curve(crv_pipe_name))
'            End If
'        ElseIf cas Then
'            ' для затруба выводим затруб между НКТ и э/к, и между насосом и э/к
'            Call curve(crv_name).AddPointsCurve(pipe_ann_above_pump_.curve(crv_pipe_name))
'            If Not pipe_ann_pump_intake_discharge_ Is Nothing Then
'                Call curve(crv_name).AddPointsCurve(pipe_ann_pump_intake_discharge_.curve(crv_pipe_name))
'            End If
'        ElseIf tub Then
'            ' только НКТ до выкида
'            Call curve(crv_name).AddPointsCurve(pipe_tub_above_pump_.curve(crv_pipe_name))
'        Else
'            Call curve(crv_name).AddPointsCurve(pipe_cas_below_pump_.curve(crv_pipe_name))
'            If Not pipe_ann_pump_intake_motor_ Is Nothing Then
'                Call curve(crv_name).AddPointsCurve(pipe_ann_pump_intake_motor_.curve(crv_pipe_name))
'            End If
'
'        End If
'    Else
'        Call curve(crv_name).AddPointsCurve(pipe_ann_above_pump_.curve(crv_name2))
'        If Not pipe_ann_pump_intake_motor_ Is Nothing Then
'            Call curve(crv_name).AddPointsCurve(pipe_ann_pump_intake_discharge_.curve(crv_pipe_name))
'        End If
'    End If
'    curve(crv_name).xName = xnam
'    curve(crv_name).yName = ynam
'
'End Sub
'
' Private Sub save_curves(saveCurve As CALC_RESULTS)
' On Error GoTo err1:
'
'    If saveCurve > 0 Then
'        add_crv "c_udl_m", "c_udl_m", tub:=True, cas:=True, xnam:="hmes_m", ynam:="udl_m"
'
'        add_crv "P_curve", "c_P", tub:=True, cas:=True, xnam:="hmes_m", ynam:="p_tub_atma"
'        add_crv "PtubHmes_curve", "c_P", tub:=True, cas:=False, xnam:="hmes_m", ynam:="p_tub_atma"
'        add_crv "PcasHmes_curve", "c_P", tub:=False, cas:=True, xnam:="hmes_m", ynam:="p_cas_atma"
'        add_crv "PcasDownHmes_curve", "c_P", tub:=False, cas:=False, xnam:="hmes_m", ynam:="p_cas_atma"
'
'        add_crv "T_curve", "c_T", tub:=True, cas:=True, xnam:="hmes_m", ynam:="t_tub_C"
'        add_crv "TtubHmes_curve", "c_T", tub:=True, cas:=False, xnam:="hmes_m", ynam:="t_tub_C"
'        add_crv "TcasHmes_curve", "c_T", tub:=True, cas:=False, xnam:="hmes_m", ynam:="t_cas_C"
'        add_crv "TcasDownHmes_curve", "c_T", tub:=False, cas:=False, xnam:="hmes_m", ynam:="t_cas_C"
'        add_crv "TambHmes_curve", "c_Tamb", tub:=True, cas:=True, xnam:="hmes_m", ynam:="t_amb_C"
'
'        add_crv "Pcas_Hd", "c_P", tub:=False, cas:=True, xnam:="hmes_m", ynam:="p_cas_atma", crv_name2:="Pcas_Hd"
'
'        add_crv "c_Diam", "c_Diam", tub:=True, cas:=False, xnam:="hmes_m", ynam:="c_Diam"
'        add_crv "c_Roughness", "c_Roughness", tub:=False, cas:=True, xnam:="hmes_m", ynam:="c_Roughness"
'        add_crv "c_Theta", "c_Theta", tub:=False, cas:=True, xnam:="hmes_m", ynam:="c_Theta"
'
'        If saveCurve > 1 Then
'            add_crv str_HlHmes_curve, "c_Hl", tub:=True, cas:=True, xnam:="hmes_m", ynam:="Hl_tub"
'            add_crv str_HLcasHmes_curve, "c_Hl", tub:=False, cas:=True, xnam:="hmes_m", ynam:="Hl_cas"
'
'            add_crv "c_fpat", "c_fpat", tub:=True, cas:=True, xnam:="hmes_m", ynam:="c_fpat"
'            add_crv "c_Rs", "c_Rs", tub:=True, cas:=True, xnam:="hmes_m", ynam:="c_Rs"
'            add_crv "c_gasfrac", "c_gasfrac", tub:=True, cas:=True, xnam:="hmes_m", ynam:="c_gasfrac"
'
'            add_crv "c_dpdl_g", "c_dpdl_g", tub:=True, cas:=True, xnam:="hmes_m", ynam:="c_dpdl_g"
'            add_crv "c_dpdl_f", "c_dpdl_f", tub:=True, cas:=True, xnam:="hmes_m", ynam:="c_dpdl_f"
'            add_crv "c_dpdl_a", "c_dpdl_a", tub:=True, cas:=True, xnam:="hmes_m", ynam:="c_dpdl_a"
'            add_crv "c_vsl", "c_vsl", tub:=True, cas:=True, xnam:="hmes_m", ynam:="c_vsl"
'            add_crv "c_vsg", "c_vsg", tub:=True, cas:=True, xnam:="hmes_m", ynam:="c_vsg"
'            add_crv "c_muo", "c_muo", tub:=True, cas:=True, xnam:="hmes_m", ynam:="c_muo"
'            add_crv "c_muw", "c_muw", tub:=True, cas:=True, xnam:="hmes_m", ynam:="c_muw"
'            add_crv "c_mug", "c_mug", tub:=True, cas:=True, xnam:="hmes_m", ynam:="c_mug"
'            add_crv "c_mumix", "c_mumix", tub:=True, cas:=True, xnam:="hmes_m", ynam:="c_mumix"
'
'        End If
'
'    End If
'
'     Exit Sub
'err1:
'    Dim errmsg As String
'    errmsg = "CWellESP.save_curves: ошибка" & sDELIM & Err.Description
'    add_log_msg errmsg
'    RaiseEvent ReportProgress(errmsg)
'    Err.Raise kErrInitCalc, Err.source, errmsg
'
' End Sub
'
'
'' Private Function fast_pwf_plin_atma( _
''                         plin_atma As Double, _
''                         ByVal t_bh_C As Double, _
''                Optional saveCurve As CALC_RESULTS = nocurves _
''                                    )
'''@brief  быстрый метод расчета забойного давления через линейное (без итераций - прямой счет)
'''         считает за один проход, за счет дополнительных упрощений и предположений
'''@param plin_atma  линейное давление
'''@param t_bh_C      температура на забое
'''@param saveCurve  флаг показывает - что сохранять в качестве результатов
'''       для уточнения оценки сепарации флюида желательно задать
'''       оценочные значения давления и температуры на приеме УЭЦН p_int_atma t_int_C для объекта расчета
''
'''       расчет температуры по заданной извне температурной корреляции, которая должны быть простой
''On Error GoTo err1:
''    If temp_method_ = AmbientTemp Then
''        temp_method_ = GeoGradTemp
''    End If
''
''    ' 1. если есть ЭЦН пытаемся оценить сепарацию и модификацию флюида на основе предполагаемого давления на приеме насоса
''    If Not ESP_ Is Nothing Then
''        Call esp.calc_separation(p_int_atma, t_int_C)
''        Set pipe_tub_above_pump_.fluid = esp.fluid_tub
''        If choke.d_choke_m > 0 Then Set choke.fluid = esp.fluid_tub
''    End If
''
''    ' 2. фиксируем заданные линейные давления
''    PT_lin_.p_atma = plin_atma
''    PT_lin_.t_C = t_wh_C
''
''    ' 3. Расчет буферного давления по штуцеру
''    If choke.d_choke_m > 0 Then
''        PT_buf_ = choke.calc_choke_p_buf(PT_lin_)
''        If PT_buf_.p_atma < 0 Then PT_buf_.p_atma = 1
''    Else
''        PT_buf_ = PT_lin_
''    End If
''
''    ' 4. Расчет давления на выкиде по буферному
''    pipe_tub_above_pump_.param = set_calc_flow_param(calc_along_coord:=True, _
''                                                      flow_along_coord:=False, _
''                                                      hcor:=hcor_, _
''                                                      temp_method:=temp_method_)
''    PT_dis_ = pipe_tub_above_pump_.calc_dPipe(PT_buf_.p_atma, PT_buf_.t_C, saveCurve)
''
''    ' 5. если есть ЭЦН то считаем давление на приеме по давлению на выкиде сверху вниз
''    If Not ESP_ Is Nothing Then                                                 ' Если есть насос
''        ' расчитываются параметры насоса включая сепарацию и модификацию флюидов
''        'Call esp.calc_ESPsys(PT_dis_.p_atma, calc_along_flow:=False)
''        PT_int_ = set_PT(esp.ESP_pump.p_int_atma, esp.ESP_pump.t_int_C)
''    Else                                                            ' Если насоса нет, то совпадают
''        PT_int_ = PT_dis_
''    End If
''    ' 6. По давлению на приеме считаем забойное давление
''    pipe_cas_below_pump_.param = set_calc_flow_param(calc_along_coord:=True, _
''                                             flow_along_coord:=False, _
''                                             hcor:=hcor_, _
''                                             temp_method:=temp_method_)
''    PT_wf_ = pipe_cas_below_pump_.calc_dPipe(PT_int_.p_atma, PT_int_.t_C, saveCurve)
''    fast_pwf_plin_atma = PT_wf_.p_atma
''    ' 7. если надо считаем затруб
''    Dim PT_cas__temp As PTtype
''    If isCalcCasing And p_cas_atma >= 1 Then
''        Call calc_casing
''    End If
''
''    Call save_curves(saveCurve)
''
''    Exit Function
''err1:
''    Dim errmsg As String
''    errmsg = "CWellESP.fast_pwf_plin_atma: ошибка" & sDELIM & Err.Description
''    add_log_msg errmsg
''    RaiseEvent ReportProgress(errmsg)
''    Err.Raise kErrInitCalc, Err.source, errmsg
''End Function
''
''Private Function slow_pwf_plin_atma(ByVal plin_atma As Double, _
''                                        ByVal t_bh_C As Double, _
''                                        Optional saveCurve As CALC_RESULTS = nocurves)
''' @brief calc_pwf_plin_atma расчет забойного давления по известному давлению в линии и конструкции скважины дихотомией
''' @param plin_atma - давление в линии
''' @param Hd - динамический уровень
''' @param t_bh_C - температура на забое скважины
''' @return Подсчитанное для заданного линейного давление
''On Error GoTo err1:
''    Dim p_wf1 As Double      ' первое приближение
''    Dim p_wfUp As Double, p_wfDown As Double
''    Dim p_linUp As Double, p_linDown As Double
''    Dim p_lin0 As Double, p_lin1 As Double
''    Dim found_solution As Boolean
''    Dim i As Integer
''    found_solution = False
''    i = 0
''    p_wf1 = 60
''    p_wfUp = -1
''    p_wfDown = -1
''    Do
''        ' ищем  приближения
''        p_lin1 = calc_plin_p_wf_atma(p_wf1, t_bh_C, saveCurve:=nocurves)
''        If (Abs(p_lin1 - plin_atma) < const_well_P_tolerance) Then
''             found_solution = True
''             PT_wf_.p_atma = p_wf1
''             PT_wf_.t_C = t_bh_C
''        End If
''        If Not found_solution Then
''          If p_lin1 > plin_atma Then
''              p_wfUp = p_wf1
''              p_linUp = p_lin1
''              If p_wfDown < 0 Then
''                  p_wf1 = p_wfUp / 2
''              Else
''                  p_wf1 = p_wfDown + (p_wfUp - p_wfDown) * (plin_atma - p_linDown) / (p_linUp - p_linDown)
''              End If
''          Else
''              p_wfDown = p_wf1
''              p_linDown = p_lin1
''              If p_wfUp < 0 Then
''                  p_wf1 = p_wf1 * 2
''              Else
''                  p_wf1 = (p_wfUp + p_wfDown) / 2
''                '  p_wf1 = p_wfDown + (p_wfUp - p_wfDown) * (plin_atma - p_linDown) / (p_linUp - p_linDown)
''              End If
''          End If
''        End If
''        i = i + 1
''    Loop While Not found_solution And i < 20
''    ' calc more one time to restore all what needed
''    PT_lin_.p_atma = calc_plin_p_wf_atma(PT_wf_.p_atma, t_bh_C, saveCurve:=saveCurve)
''    If Abs(Me.p_line_atma - plin_atma) > const_well_P_tolerance Then
''       add_log_msg "calc_pwf_plin_atma: ошибка расчета забойного давления больше " & const_well_P_tolerance & ". Равна = " & Abs(Me.p_line_atma - plin_atma)
''    End If
''    slow_pwf_plin_atma = PT_wf_.p_atma
''
''    Exit Function
''err1:
''    Dim errmsg As String
''    errmsg = "CWellESP.slow_pwf_plin_atma: ошибка" & sDELIM & Err.Description
''    add_log_msg errmsg
''    RaiseEvent ReportProgress(errmsg)
''    Err.Raise kErrInitCalc, Err.source, errmsg
'' End Function
''
''Public Function calc_pwf_pcas_hdyn_atma(ByVal p_an_atma As Double, ByVal Hd_m As Double, ByVal t_bh_C As Double) As PTtype
''' @brief calc_pwf_pcas_hdyn_atma - расчет забойного давления через динамический уровень
''' @param Pan - затрубное давление
''' @param Hd - динамический уровень
''' @param t_bh_C - температура на забое скважины
''' @return Подсчитанное для заданного динамического уровня давление
''On Error GoTo err1:
''
''    Set curve(str_Hd_Depend_p_wf) = Build_Hdp_wfcurve(p_an_atma, t_bh_C)
''    ' 3. По построенной кривой находим значение забойного давления соответствующее заданному динамическому уровню
''    PT_wf_.p_atma = curve(str_Hd_Depend_p_wf).FindMinOneSolution(Hd_m)
''    ' 4. Для обеспечение целостности данных по скважине проводим расчет распределения давления по скважине для найденного забойного давления
''    ' расчет давления на устье через забойное давление
''    Call calc_plin_p_wf_atma(PT_wf_.p_atma)
''    PT_cas_.p_atma = p_an_atma
''   ' Me.h_dyn_m = Hd_m
''    calc_pwf_pcas_hdyn_atma = PT_wf_
''    Exit Function
''err1:
''    Dim errmsg As String
''    errmsg = "CWellESP.slow_pwf_plin_atma: ошибка" & sDELIM & Err.Description
''    add_log_msg errmsg
''    RaiseEvent ReportProgress(errmsg)
''    Err.Raise kErrInitCalc, Err.source, errmsg
''
''End Function
'
'Private Function is_Hdyn_Larger_Hsp() As Boolean
'' Динамический уровень Hdyn больше глубины спуска насоса Hpump,
'    is_Hdyn_Larger_Hsp = Not ESP_ Is Nothing And Hdyn_Pcas_.hdyn_m > h_sp_m_
'End Function
'
''Public Function Build_Pwhp_wfcurve( _
''                Optional ByVal p_linMax As Double = -1, _
''                Optional ByVal p_wf1_atma As Double = -1, _
''                Optional ByVal Pstep As Integer = DEFAULT_PAN_STEP, _
''                Optional ByVal calcFast As Boolean = False _
''                                 ) As CInterpolation
''' @brief Build_Pwhp_wfcurve построение кривой зависимости буферного и линейного давлений на скважине от забойного давления
'''               на кривой есть две особые точки, на которых теряется гладкость
'''                   1 - там где буферное давление становится больше нуля (граница работы скважины по забойному)
'''                   2 - там где линейное давление становится больше нуля
'''               эти точки ищутся более точным алгоритмом для правильной отрисовки графика
''' @param p_linMax - ограничение величины линейного давления определяющее границы построения кривой
''' @param p_wf1_atma - значение забойного давления, которое останется после проведения расчета
''' @param Pstep  - шаг поиска значений
''' @param calcFast - флаг показывающий насколько точно надо строить кривую (влияет на поиск пересечений с нулем)
''
''    Dim pwf_temp As Double
''    Dim P_step As Double
''    Dim processing As Boolean
''    Dim pwf_temp1 As Double ' забойное давление минимальное с которого надо начинать поиск
''    Dim pwf_temp_old As Double
''    Dim pwf_temp_new As Double
''
''    Dim iter  As Integer
''
''    Dim p_wfmin_atma As Double   ' временная переменная для хранения минимального забойного давления с которого надо начинать поиск зайбоного давления
''On Error GoTo err1:
''    p_wfmin_atma = 1
''
''    If (p_linMax < 0) And (p_line_atma > 0) Then
''        p_linMax = p_line_atma
''    End If
''
''    If p_wf1_atma < 0 Then
''        p_wf1_atma = p_wf_atma
''    End If
''
''    ' 1. Начало расчета. Заданы линейное давление p_line,
''    '    Температура на забое скважины Tbh определяется температурной моделью
''    P_step = Pstep
''    ' 2. Строим графическую зависимость линейного давления от забойного давления для заданных параметров скважины
''    curve(str_plin_Depend_p_wf).ClearPoints
''    curve(str_pbuf_pwf_curve).ClearPoints
''    processing = True
''    isCalcCasing = False
''    pwf_temp = p_wfmin_atma     ' здесь надо получше выбирать начальное приближения для расчета для ускорения
''    Do
''        pwf_temp = pwf_temp + P_step
''        PT_lin_.p_atma = calc_plin_p_wf_atma(pwf_temp)
''        If (pbuf_atma > const_minPpipe_atma) Then    ' вышли в область больших буферных давлений
''            If curve(str_pbuf_pwf_curve).num_points = 0 Then  ' первый раз тут - ищем поточнее начало
''                curve(str_pbuf_pwf_curve).AddPoint pwf_temp, pbuf_atma
''                pwf_temp_old = pwf_temp - P_step
''                pwf_temp_new = pwf_temp
''                iter = 1
''                ' надо точнее искать точку если нет противопоказаний
''                While (pbuf_atma > const_minPpipe_atma * 1.1) And processing And Not calcFast
''                    pwf_temp = (pwf_temp_old + pwf_temp_new) / 2
''                    PT_lin_.p_atma = calc_plin_p_wf_atma(pwf_temp)
''                    If pbuf_atma > const_minPpipe_atma Then
''                        pwf_temp_new = pwf_temp
''                    Else
''                        pwf_temp_old = pwf_temp
''                    End If
''                    iter = iter + 1
''                    If iter > 10 Then processing = False
''                Wend
''                If processing = False Then
''                     PT_lin_.p_atma = 0
''                     ' здесь нет  ошибки - определена достаточно корректна стартовая точка кривой тут
''                     add_log_msg "Build_Pwhp_wfcurve: Предупреждение: не сошлась итерация по поиску начала графика зависимости ,буферного давления от забойного. p_wf = " _
''                                                    & pwf_temp & " итераций = " & iter & " дебит = " & q_liq_sm3day & " Рбуф = " & pbuf_atma
''                End If
''                curve(str_pbuf_pwf_curve).AddPoint pwf_temp, pbuf_atma
''                curve(str_plin_Depend_p_wf).AddPoint pwf_temp, p_line_atma
''            End If
''            Pstep = DEFAULT_PAN_STEP / 3
''        Else
''            p_wfmin_atma = pwf_temp
''        End If
''
''        If (p_line_atma > -1) And (Not isEqual(p_line_atma, pbuf_atma)) Then      ' вышли в область больших линейных давлений
''            If curve(str_plin_Depend_p_wf).num_points = 0 Then   ' первый раз тут - ищем поточнее начало
''                pwf_temp_old = pwf_temp - P_step
''                pwf_temp_new = pwf_temp
''                iter = 1
''                While (p_line_atma <> 0) And processing And Not calcFast  ' Then   ' надо точнее искать точку
''                    pwf_temp = (pwf_temp_old + pwf_temp_new) / 2
''                    isCalcCasing = False
''                    PT_lin_.p_atma = calc_plin_p_wf_atma(pwf_temp)
''                    If p_line_atma > 0 Then
''                        pwf_temp_new = pwf_temp
''                    Else
''                        pwf_temp_old = pwf_temp
''                    End If
''                    iter = iter + 1
''                    If iter > 20 Then processing = False
''                    If (p_line_atma >= 0) Then                          ' если ставить точки слишком часто - тогда проявляются неустойчивости - может надо будет сделать прореживание
''                        curve(str_plin_Depend_p_wf).AddPoint pwf_temp, p_line_atma
''                        curve(str_pbuf_pwf_curve).AddPoint pwf_temp, pbuf_atma
''                    End If
''                Wend
''                If p_line_atma <> 0 Then
''                     PT_lin_.p_atma = 0
''                     ' здесь нет  ошибки - определена достаточно корректна стартовая точка кривой тут
''                     add_log_msg "Build_Pwhp_wfcurve: Предупреждение: не сошлась итерация по поиску начала графика зависимости линейного давления от забойного. p_wf = " _
''                                                    & pwf_temp & " итераций = " & iter & " дебит = " & q_liq_sm3day & " Рбуф = " & pbuf_atma
''                End If
''                curve(str_plin_Depend_p_wf).AddPoint pwf_temp, p_line_atma
''                curve(str_pbuf_pwf_curve).AddPoint pwf_temp, pbuf_atma
''            End If
''        Else
''            If isEqual(p_line_atma, pbuf_atma) And (p_line_atma > 1) Then
''                curve(str_plin_Depend_p_wf).AddPoint pwf_temp, p_line_atma
''                curve(str_pbuf_pwf_curve).AddPoint pwf_temp, pbuf_atma
''            End If
''        End If
''        If p_line_atma > 1 Then
''           curve(str_plin_Depend_p_wf).AddPoint pwf_temp, p_line_atma
''           curve(str_pbuf_pwf_curve).AddPoint pwf_temp, pbuf_atma
''        End If
''        ' ждем пока кривая перечеркнет уровень целевого линейного давления
''    Loop While (p_line_atma < p_linMax + 10) Or (curve(str_plin_Depend_p_wf).num_points < MinCountPoints_calc_pwf_pcas_hdyn_atma)
''    isCalcCasing = True
''    PT_lin_.p_atma = calc_plin_p_wf_atma(p_wf1_atma)
''    Set Build_Pwhp_wfcurve = curve(str_plin_Depend_p_wf)
''
''    Exit Function
''err1:
''    Dim errmsg As String
''    errmsg = "CWellESP.Build_Pwhp_wfcurve: ошибка" & sDELIM & Err.Description
''    add_log_msg errmsg
''    RaiseEvent ReportProgress(errmsg)
''    Err.Raise kErrInitCalc, Err.source, errmsg
''
''End Function
''
''Public Function Build_Hdp_wfcurve(p_an_atma As Double, t_bh_C As Double, Optional p_wf1_atma As Double = -1) As CInterpolation
''' расчет зависимости динамического уровня от забойного давления для заданных условий
''' @brief Build_Hdp_wfcurve - расчет забойного давления через динамический уровень
''' @param Pan - затрубное давление
''' @param t_bh_C - температура на забое скважины
''' @return Подсчитанное для заданного динамического уровня давление
''
''  On Error GoTo er1:
''
''    Dim pwf_temp As Double
''    Dim plin_temp As Double
''    Dim P_step As Double
''    Dim processing As Boolean
''    Dim HdAtIntake As Boolean, Panold As Double
''    Dim p_wfold As Double, p_wfold1 As Double
''    Dim Hdold As Double
''    Dim itr As Integer, itr2 As Integer, itr3 As Integer
''    Dim Hdpump As Double
''
''    If p_an_atma <= 0 Then
''        add_log_msg "CWellESP.Build_Hdp_wfcurve: попытка построить график динамического уровня от забойного давления при затрубном давлении =" & p_an_atma
''        Exit Function
''    End If
''
''    ' 1. Начало расчета. Заданы затрубное давление Pan, динамический уровень Hdyn, температура на забое скважины Tbh
''  '  p_an_atma = p_an_atma
''  '  t_bh_C_ = t_bh_C
''    P_step = DEFAULT_PAN_STEP '/ 3
''    ' 2. Строим графическую зависимость динамического уровня от забойного давления для заданных параметров скважины
''    curve(str_Hd_Depend_p_wf).ClearPoints
''    processing = True
''
''    If p_wf1_atma < 0 Then
''        p_wf1_atma = p_wf_atma
''    End If
''
''    HdAtIntake = False
''    itr3 = 0
''    Do
''       pwf_temp = p_an_atma
''       itr2 = 0
''       Do
''            PT_cas_.p_atma = p_an_atma
''            isCalcCasing = True
''            plin_temp = calc_plin_p_wf_atma(pwf_temp)
''
''            If Me.p_an_atma < p_an_atma Then
''            ' уровень на приеме - надо найти точно точку начала слома
''                HdAtIntake = True
''                Panold = Me.p_an_atma
''                p_wfold = pwf_temp
''                Hdold = Hdyn_Pcas_.hdyn_m
''                Hdpump = Hdyn_Pcas_.hdyn_m
''            Else
''            ' вышли в зону где уровень выше приема насоса
''                If HdAtIntake And Abs(Hdold - Hdyn_Pcas_.hdyn_m) > 10 Then
''                    ' погрешность около точки слома по дин уровню больше 10 метров - надо уточнить лучше
''                    p_wfold1 = pwf_temp
''                    itr = 0
''                    Do
''                        itr = itr + 1
''                        pwf_temp = (p_wfold1 + p_wfold) / 2
''                        PT_cas_.p_atma = p_an_atma
''                        isCalcCasing = True
''                        plin_temp = calc_plin_p_wf_atma(pwf_temp)
''                        If Hdyn_Pcas_.hdyn_m = Hdpump Then
''                            HdAtIntake = True
''                            Panold = Me.p_an_atma
''                            p_wfold = pwf_temp
''                            Hdold = Hdyn_Pcas_.hdyn_m
''                        Else
''                            p_wfold1 = pwf_temp
''                        End If
''                    Loop While ((Abs(Hdpump - Hdyn_Pcas_.hdyn_m) > 10) Or Abs(p_an_atma - Me.p_an_atma) > 2) And itr < 10 '
''                End If
'''                Debug.Assert itr < 10
''                itr = 0
''                HdAtIntake = False ' сбросим флаг, что нашли точку слома
''            End If
''
''            curve(str_Hd_Depend_p_wf).AddPoint pwf_temp, Hdyn_Pcas_.hdyn_m
''            curve(str_Pan_Depend_p_wf).AddPoint pwf_temp, p_an_atma
''
''            pwf_temp = pwf_temp + P_step
''
'''            Debug.Assert pwf_temp < 300
''            itr2 = itr2 + 1
''        Loop While (Not is_Hdyn_Larger_Hsp And Hdyn_Pcas_.hdyn_m > 0) And (itr2 < 100)
''
''        ' проверка условий продолжения цикла
''        If (curve(str_Hd_Depend_p_wf).num_points >= MinCountPoints_calc_pwf_pcas_hdyn_atma) Then
''            processing = False
''        Else
''            curve(str_Hd_Depend_p_wf).ClearPoints
''            P_step = P_step / 2
''
''            ' проверка корректности. Если шаг слишком мелкий при этом точек решения мало - то это не здоровая ситуация - надо показать ее
''            If P_step < 0.01 Then
''                add_log_msg "CWellESP.Build_Hdp_wfcurve: Не удалось построить кривую зависимости динамического уровня от забойного давления. шаг перебора точек менее 0.01 атм"
''                Err.Raise kErrBuildCurve, , "CWellESP.Build_Hdp_wfcurve нет получается построить кривую - мелкий шаг получился"
''            End If
''
''        End If
''        itr3 = itr3 + 1
''    Loop While (processing) And (itr3 < 5)
''
''    'восстановим после расчета необходимое распределение в скважине
''    PT_cas_.p_atma = p_an_atma
''    isCalcCasing = True
''    plin_temp = calc_plin_p_wf_atma(p_wf1_atma)
''
''    Set Build_Hdp_wfcurve = curve(str_Hd_Depend_p_wf)
''   ' переводим в состояние "целостность нарушена"
''  '  p_Calculated = False
''
''    Exit Function
''er1:
''  ' Debug.Assert False
''   Resume Next
''End Function
''
''Public Function Build_VLPcurve(p_line As Double, ByVal t_bh_C As Double, Optional maxQ As Double = 200, Optional Qnow As Double = -1) As CInterpolation
''' расчет кривой лифта
''' на выходе с расчета кривая лифта заданная в определенном формате кривой
'''
''    PT_lin_.p_atma = p_line
''    Const VLPNumPoints = 20
''    Dim i As Integer
''    Dim Qstep As Double
''    Dim p_wf As Double
''    Dim Qliq_reserv As Double
''    Qliq_reserv = q_liq_sm3day
''    Qstep = maxQ / VLPNumPoints
''
''    RaiseEvent ReportProgress("Build_VLPcurve. Начинаем строить кривую оттока. Точек =   " & VLPNumPoints)
''    For i = 0 To VLPNumPoints
''        q_liq_sm3day = i * Qstep
''        p_wf = calc_pwf_plin_atma(p_line, t_bh_C)
''        curve(str_VLPcurve).AddPoint q_liq_sm3day, p_wf
''        ' поднимем наверх событие по поводу длительного расчета
''        RaiseEvent ReportProgress("Build_VLPcurve   i= " & i & " из " & VLPNumPoints)
''    Next i
''    ' вернем состояние скважины в исходное значение
''    If Qnow = -1 Then
''        Qnow = maxQ * 1.1
''    End If
''
''    q_liq_sm3day = Qnow
''    p_wf = calc_pwf_plin_atma(p_line, t_bh_C)
''    curve(str_VLPcurve).AddPoint q_liq_sm3day, p_wf
''    Set Build_VLPcurve = curve(str_VLPcurve)
''End Function
'
'Property Get VLPCurve() As CInterpolation
'  Set VLPCurve = curve(str_VLPcurve)
'End Property
'
'Public Property Get ksep_total_d() As Double
'   If Not ESP_ Is Nothing Then
'       ksep_total_d = esp.separ.ksep_total_fr
'   Else
'       ksep_total_d = 0
'   End If
'End Property
'
''Public Sub set_ksep_total_d(calc_method As SEPAR_CALC_METHOD, _
''                                    ksep_nat_fr As Double, _
''                          Optional ksep_GS_fr As Double = 0, _
''                          Optional p_ksep_atma As Double = -1, _
''                          Optional t_ksep_C As Double = -1)
''   ' установка значения коэффициента сепарации извне
''   ' если значение равно = -1 то расчет по корреляции
''   ' если задано какое то значение, то оно будет использовано в расчете
''   ' если заданы значения давления и температуры, то они будут использоваться в расчете
''    Call esp.set_ksep_total(calc_method, ksep_nat_fr, ksep_GS_fr, p_ksep_atma, t_ksep_C)
''End Sub
'
'
'' function prepares output array for public functions
'' подготовим данные для вывода
'Public Function array_out(Optional ByVal num_points As Integer = 20, _
'                          Optional ByVal all_curves_out As Boolean = False)
'' данные выводятся в одну линию, чтобы, хотя бы теоретически, можно было вывести данные по скважине в таблице
'' во второй строке выводятся подписи параметров, если необходимо
'' первый параметр настраиваемый
'    Dim ar1, ar2, ar3, ar4, ar5, ar6
'    Dim res As New Dictionary  ' calculated properties to first line of results
'    Dim resAL As New Dictionary  ' AL specific secondary params
'    Dim resParam As New Dictionary ' calc params for third line of results (for calc check)
'
'    Const arr_len = 32
'On Error GoTo err1:
'    ReDim ar1(arr_len)
'    ReDim ar2(arr_len)
'    ReDim ar3(arr_len)
'    ReDim ar4(arr_len)
'    ReDim ar5(arr_len)
'    ReDim ar6(arr_len)
'
'    Dim i As Integer
'    Dim pcas_out As Double
'
'
'         pcas_out = PT_cas_.p_atma
'
'
'         ' first two reserved and can be overrided later
'         res.Add "p_reserve", PT_lin_.p_atma                              'i=1
'         res.Add "t_reserve", PT_lin_.t_C                                    'i=2
'         ' all pressures and temperateres along well from top to bottom
'         res.Add "p_line_atma", PT_lin_.p_atma                              'i=3
'         res.Add "t_line_C", PT_lin_.t_C                                    'i=4
'         res.Add "p_buf_atma", PT_buf_.p_atma                               'i=5
'         res.Add "t_buf_C", PT_buf_.t_C                                     'i=6
'         res.Add "p_cas_atma", PT_cas_.p_atma                               'i=7
'         res.Add "t_cas_C", PT_cas_.t_C                                     'i=8
'         res.Add "hdyn_m", h_dyn_m                                          'i=9
'         res.Add "p_dis_atma", PT_dis_.p_atma                               'i=10
'         res.Add "t_dis_C", PT_dis_.t_C                                     'i=11
'         res.Add "p_int_atma", PT_int_.p_atma                               'i=12
'         res.Add "t_int_C", PT_int_.t_C                                     'i=13
'         res.Add "p_wf_atma", PT_wf_.p_atma                                 'i=14
'         res.Add "t_wf_C", PT_wf_.t_C                                       'i=15
'
'         ' flow properties
'         res.Add "gas_frac_before", gas_frac_intake_before_separ_d          'i=16
'         res.Add "ksep_total", ksep_total_d                                 'i=17
'         res.Add "gas_frac_pump", gas_frac_intake_after_separ_d             'i=18
'         res.Add "qgas_cas_ sm3day", qgas_cas_sm3day                        'i=19
'         res.Add "qgas_tub_sm3day", qgas_tub_sm3day                         'i=20
'
'         ' control params
'         resParam.Add "q_liq_sm3day", q_liq_sm3day                            'i=1
'         resParam.Add "fw_perc", fw_perc                                    'i=2
'         resParam.Add "qgas_sm3day", q_gas_scm3day                          'i=3
'         resParam.Add "dchoke_mm", choke.d_choke_mm                         'i=4
'         resParam.Add "calibr_choke", choke.calibr_fr                   'i=5
'         resParam.Add "calibr_grav", calibr_grav_                       'i=6
'         resParam.Add "calibr_fric", calibr_fric_                       'i=7
'
'         If isCalcESP Then
'            With ESP_
'                resAL.Add "ESP.name", .name                                 'i=1
'                resAL.Add "ESP.length", .ESP_pump.length_m                  'i=1
'                resAL.Add "motor.length", .motor.length_m           'i=1
'                resAL.Add "ESP.od_mm", .ESP_pump.db.d_od_m * 1000                 'i=1
'                resAL.Add "motor.od_mm", .ESP_pump.db.d_motor_od_m * 1000                 'i=1
'                resAL.Add "ESP.d_cas_pump", d_cas_pump_mm_   'i=1
'                resAL.Add "ESP.d_cas_pump2", .d_cas_mm    'i=1
'                resAL.Add "ESP.CS.freq_Hz", .motor.f_Hz                        'i=2
'                resAL.Add "ESP.pump.freq_Hz", .ESP_pump.freq_Hz             'i=3
'                resAL.Add "ESP.motor.U_V", .motor.U_motor_V                             'i=4
'                resAL.Add "ESP.CS.U_V", .motor.U_trans_high_V                     'i=5
'                resAL.Add "ESP.I_A", .motor.I_lin_A                                   'i=6
'                resAL.Add "ESP.load_fr", .motor.load_d                           'i=7
'                resAL.Add "ESP.pump.eff_d", .ESP_pump.eff_ESP_d             'i=8
'                resAL.Add "ESPsys.eff_d", .eff_d                            'i=9
'                resAL.Add "ESP.CS.power_W", .motor.power_CS_calc_W                'i=10
'                resAL.Add "ESP.CS.power_fact_W", .power_CS_fact_W           'i=11
'
'                resAL.Add "ESP.ksep_total_fr", .separ.ksep_total_fr               'i=12
'                resAL.Add "ESP.ksep_nat_fr", .separ.ksep_nat_fr                   'i=13
'                resAL.Add "ESP.ksep_gassep_fr", .separ.ksep_gassep_fr             'i=14
'                resAL.Add "ESP.calibr_head", .calibr_head               'i=15
'                resAL.Add "ESP.calibr_rate", .calibr_rate               'i=16
'                resAL.Add "ESP.calibr_power", .calibr_power             'i=17
'                resAL.Add "hdyn_m", Hdyn_Pcas_.hdyn_m                       'i=18
'                resAL.Add "pcas_hdyn_atma", Hdyn_Pcas_.p_cas_atma           'i=19
'                resAL.Add "correct_hdyn", Hdyn_Pcas_.correct                'i=20
'            End With
'
'        End If
''
'        For i = 1 To res.Count
'            ar1(i - 1) = res.Items()(i - 1)
'            ar2(i - 1) = res.keys()(i - 1)
'        Next i
'
'        For i = 1 To resAL.Count
'            ar3(i - 1) = resAL.Items()(i - 1)
'            ar4(i - 1) = resAL.keys()(i - 1)
'        Next i
'
'        For i = 1 To resParam.Count
'            ar5(i - 1) = resParam.Items()(i - 1)
'            ar6(i - 1) = resParam.keys()(i - 1)
'        Next i
'
'        ' выведем дополнительно спасенные кривые по скважине
'        Dim arr()
'
'        Dim crv1 As CInterpolation
'        Dim crv_name As String
'        Dim offset As Integer
'        Dim N As Integer
'
'        offset = 7
'
'        ReDim Preserve arr(num_points + offset, arr_len)
'        For i = LBound(ar1) To UBound(ar1)
'            arr(0, i) = ar1(i)
'            arr(1, i) = ar2(i)
'            arr(2, i) = ar3(i)
'            arr(3, i) = ar4(i)
'            arr(4, i) = ar5(i)
'            arr(5, i) = ar6(i)
'            arr(6, i) = i
'        Next i
'
'        arr(offset, 0) = "num"
'        For i = 1 To num_points
'            arr(offset + i, 0) = i
'        Next i
'        N = 0
'
'        ' use copy paste below :)   ugly but works
'        crv_name = "c_udl_m": N = N + 1
'                                            Set crv1 = curve(crv_name).ClonePointsToNum(num_points)
'                                            arr(offset, N) = crv1.xName
'                                            arr(offset, N + 1) = crv1.yName
'                                            For i = 1 To num_points
'                                                arr(offset + i, N) = crv1.pointX(i)
'                                                arr(offset + i, N + 1) = crv1.PointY(i)
'                                            Next i
'
'        ' pressure and temperature distribution for all well length
'        crv_name = "P_curve": N = N + 2
'                                            Set crv1 = curve(crv_name).ClonePointsToNum(num_points)
'                                            arr(offset, N) = crv1.xName
'                                            arr(offset, N + 1) = crv1.yName
'                                            For i = 1 To num_points
'                                                arr(offset + i, N) = crv1.pointX(i)
'                                                arr(offset + i, N + 1) = crv1.PointY(i)
'                                            Next i
'        crv_name = "T_curve": N = N + 1 '+1
'                                            Set crv1 = curve(crv_name).ClonePointsToNum(num_points)
'                                            arr(offset, N + 1) = crv1.yName
'                                            For i = 1 To num_points
'                                                arr(offset + i, N + 1) = crv1.PointY(i)
'                                            Next i
'
'         crv_name = str_TambHmes_curve: N = N + 2
'                                            Set crv1 = curve(crv_name).ClonePointsToNum(num_points)
'                                            arr(offset, N) = crv1.xName
'                                            arr(offset, N + 1) = crv1.yName
'                                            For i = 1 To num_points
'                                                arr(offset + i, N) = crv1.pointX(i)
'                                                arr(offset + i, N + 1) = crv1.PointY(i)
'                                            Next i
'        ' pressure and temperature in tubing
'        crv_name = "PtubHmes_curve": N = N + 2
'                                            Set crv1 = curve(crv_name).ClonePointsToNum(num_points)
'                                            arr(offset, N) = crv1.xName
'                                            arr(offset, N + 1) = crv1.yName
'                                            For i = 1 To num_points
'                                                arr(offset + i, N) = crv1.pointX(i)
'                                                arr(offset + i, N + 1) = crv1.PointY(i)
'                                            Next i
'        crv_name = "TtubHmes_curve": N = N + 1 '+1
'                                            Set crv1 = curve(crv_name).ClonePointsToNum(num_points)
'                                            arr(offset, N + 1) = crv1.yName
'                                            For i = 1 To num_points
'                                                arr(offset + i, N + 1) = crv1.PointY(i)
'                                            Next i
'
'        If isCalcCasing Then
'            ' pressure and temperature in casing below pump
'             crv_name = "PcasDownHmes_curve": N = N + 2
'                                                Set crv1 = curve(crv_name).ClonePointsToNum(num_points)
'                                                arr(offset, N) = crv1.xName
'                                                arr(offset, N + 1) = crv1.yName
'                                                For i = 1 To num_points
'                                                    arr(offset + i, N) = crv1.pointX(i)
'                                                    arr(offset + i, N + 1) = crv1.PointY(i)
'                                                Next i
'            crv_name = "TcasDownHmes_curve": N = N + 1 '+1
'                                                Set crv1 = curve(crv_name).ClonePointsToNum(num_points)
'                                                arr(offset, N + 1) = crv1.yName
'                                                For i = 1 To num_points
'                                                    arr(offset + i, N + 1) = crv1.PointY(i)
'                                                Next i
'            ' pressure and temperature in casing above pump
'             crv_name = "PcasHmes_curve": N = N + 2
'                                                Set crv1 = curve(crv_name).ClonePointsToNum(num_points)
'                                                arr(offset, N) = crv1.xName
'                                                arr(offset, N + 1) = crv1.yName
'                                                For i = 1 To num_points
'                                                    arr(offset + i, N) = crv1.pointX(i)
'                                                    arr(offset + i, N + 1) = crv1.PointY(i)
'                                                Next i
'            crv_name = "TcasHmes_curve": N = N + 1 '+1
'                                                Set crv1 = curve(crv_name).ClonePointsToNum(num_points)
'                                                arr(offset, N + 1) = crv1.yName
'                                                For i = 1 To num_points
'                                                    arr(offset + i, N + 1) = crv1.PointY(i)
'                                                Next i
'            crv_name = "Pcas_Hd": N = N + 2
'                                                Set crv1 = curve(crv_name).ClonePointsToNum(num_points)
'                                                arr(offset, N) = crv1.xName
'                                                arr(offset, N + 1) = crv1.yName
'                                                For i = 1 To num_points
'                                                    arr(offset + i, N) = crv1.pointX(i)
'                                                    arr(offset + i, N + 1) = crv1.PointY(i)
'                                                Next i
'        End If
'' todo - добавить кривые распределения давления в насосе, доли газа в насосе, вязкости в насосое
''        добавить кривые - зависимости динамического уровня от забойного давления?
''        If Not ESP_ Is Nothing Then
''            ' ESP curves output start here
''            crv_name = "Pcas_Hl": n = n + 2
''                                                Set crv1 = curve(crv_name).ClonePointsToNum(num_points)
''                                                arr(offset, n) = crv1.xName
''                                                arr(offset, n + 1) = crv1.yName
''                                                For i = 1 To num_points
''                                                    arr(offset + i, n) = crv1.pointX(i)
''                                                    arr(offset + i, n + 1) = crv1.PointY(i)
''                                                Next i
''        End If
'
'
'        array_out = arr
'
'    ' можно еще добавить сюда вывод кривых распределения давления и температуры по стволу и еще 4 параметров  (потом)
'
'    Exit Function
'err1:
'    Dim msg As String
'    msg = "CWellESP.array_out: warning with crv_name " + crv_name
'    add_log_msg msg + sDELIM + Err.Description
'    Resume Next
'End Function
'

