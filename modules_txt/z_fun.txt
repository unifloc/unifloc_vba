''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Cephes Math Library Release 2.8:  June, 2000
'Copyright by Stephen L. Moshier
'
'Contributors:
'    * Sergey Bochkanov (ALGLIB project). Translation from C to
'      pseudocode.
'
'See subroutines comments for additional copyrights.
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Bessel function of order zero
'
'Returns Bessel function of order zero of the argument.
'
'The domain is divided into the intervals [0, 5] and
'(5, infinity). In the first interval the following rational
'approximation is used:
'
'
'       2         2
'(w - r  ) (w - r  ) P (w) / Q (w)
'      1         2    3       8
'
'           2
'where w = x  and the two r's are zeros of the function.
'
'In the second interval, the Hankel asymptotic expansion
'is employed with two rational functions of degree 6/6
'and 7/7.
'
'ACCURACY:
'
'                     Absolute error:
'arithmetic   domain     # trials      peak         rms
'   IEEE      0, 30       60000       4.2e-16     1.1e-16
'
'Cephes Math Library Release 2.8:  June, 2000
'Copyright 1984, 1987, 1989, 2000 by Stephen L. Moshier
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function BesselJ0(ByVal x As Double) As Double
    Dim Result As Double
    Dim XSq As Double
    Dim NN As Double
    Dim PZero As Double
    Dim QZero As Double
    Dim P1 As Double
    Dim Q1 As Double
    If x < 0# Then
        x = -x
    End If
    If x > 8# Then
        Call BesselAsympt0(x, PZero, QZero)
        NN = x - Pi() / 4#
        Result = Sqr(2# / Pi() / x) * (PZero * Cos(NN) - QZero * Sin(NN))
        BesselJ0 = Result
        Exit Function
    End If
    XSq = Square(x)
    P1 = 26857.8685698001
    P1 = -40504123.7183313 + XSq * P1
    P1 = 25071582855.3688 + XSq * P1
    P1 = -8085222034853.79 + XSq * P1
    P1 = 1.43435493914034E+15 + XSq * P1
    P1 = -1.36762035308817E+17 + XSq * P1
    P1 = 6.38205934107236E+18 + XSq * P1
    P1 = -1.17915762910761E+20 + XSq * P1
    P1 = 4.93378725179413E+20 + XSq * P1
    Q1 = 1#
    Q1 = 1363.06365232897 + XSq * Q1
    Q1 = 1114636.09846299 + XSq * Q1
    Q1 = 669998767.298224 + XSq * Q1
    Q1 = 312304311494.121 + XSq * Q1
    Q1 = 112775673967980# + XSq * Q1
    Q1 = 3.02463561670946E+16 + XSq * Q1
    Q1 = 5.42891838409228E+18 + XSq * Q1
    Q1 = 4.93378725179413E+20 + XSq * Q1
    Result = P1 / Q1
    BesselJ0 = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Bessel function of order one
'
'Returns Bessel function of order one of the argument.
'
'The domain is divided into the intervals [0, 8] and
'(8, infinity). In the first interval a 24 term Chebyshev
'expansion is used. In the second, the asymptotic
'trigonometric representation is employed using two
'rational functions of degree 5/5.
'
'ACCURACY:
'
'                     Absolute error:
'arithmetic   domain      # trials      peak         rms
'   IEEE      0, 30       30000       2.6e-16     1.1e-16
'
'Cephes Math Library Release 2.8:  June, 2000
'Copyright 1984, 1987, 1989, 2000 by Stephen L. Moshier
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function BesselJ1(ByVal x As Double) As Double
    Dim Result As Double
    Dim s As Double
    Dim XSq As Double
    Dim NN As Double
    Dim PZero As Double
    Dim QZero As Double
    Dim P1 As Double
    Dim Q1 As Double
    s = Sgn(x)
    If x < 0# Then
        x = -x
    End If
    If x > 8# Then
        Call BesselAsympt1(x, PZero, QZero)
        NN = x - 3# * Pi() / 4#
        Result = Sqr(2# / Pi() / x) * (PZero * Cos(NN) - QZero * Sin(NN))
        If s < 0# Then
            Result = -Result
        End If
        BesselJ1 = Result
        Exit Function
    End If
    XSq = Square(x)
    P1 = 2701.12271089232
    P1 = -4695753.530643 + XSq * P1
    P1 = 3413234182.3017 + XSq * P1
    P1 = -1322983480332.13 + XSq * P1
    P1 = 290879526383478# + XSq * P1
    P1 = -3.58881756991011E+16 + XSq * P1
    P1 = 2.316433580634E+18 + XSq * P1
    P1 = -6.67210656892492E+19 + XSq * P1
    P1 = 5.81199354001606E+20 + XSq * P1
    Q1 = 1#
    Q1 = 1606.93157348149 + XSq * Q1
    Q1 = 1501793.59499859 + XSq * Q1
    Q1 = 1013863514.35867 + XSq * Q1
    Q1 = 524371026216.765 + XSq * Q1
    Q1 = 208166122130761# + XSq * Q1
    Q1 = 6.09206139891752E+16 + XSq * Q1
    Q1 = 1.18577071219032E+19 + XSq * Q1
    Q1 = 1.16239870800321E+21 + XSq * Q1
    Result = s * x * P1 / Q1
    BesselJ1 = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Bessel function of integer order
'
'Returns Bessel function of order n, where n is a
'(possibly negative) integer.
'
'The ratio of jn(x) to j0(x) is computed by backward
'recurrence.  First the ratio jn/jn-1 is found by a
'continued fraction expansion.  Then the recurrence
'relating successive orders is applied until j0 or j1 is
'reached.
'
'If n = 0 or 1 the routine for j0 or j1 is called
'directly.
'
'ACCURACY:
'
'                     Absolute error:
'arithmetic   range      # trials      peak         rms
'   IEEE      0, 30        5000       4.4e-16     7.9e-17
'
'
'Not suitable for large n or x. Use jv() (fractional order) instead.
'
'Cephes Math Library Release 2.8:  June, 2000
'Copyright 1984, 1987, 2000 by Stephen L. Moshier
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function BesselJN(ByVal N As Long, ByVal x As Double) As Double
    Dim Result As Double
    Dim pkm2 As Double
    Dim pkm1 As Double
    Dim pk As Double
    Dim XK As Double
    Dim R As Double
    Dim ans As Double
    Dim K As Long
    Dim sg As Long
    If N < 0# Then
        N = -N
        If N Mod 2# = 0# Then
            sg = 1#
        Else
            sg = -1#
        End If
    Else
        sg = 1#
    End If
    If x < 0# Then
        If N Mod 2# <> 0# Then
            sg = -sg
        End If
        x = -x
    End If
    If N = 0# Then
        Result = sg * BesselJ0(x)
        BesselJN = Result
        Exit Function
    End If
    If N = 1# Then
        Result = sg * BesselJ1(x)
        BesselJN = Result
        Exit Function
    End If
    If N = 2# Then
        If x = 0# Then
            Result = 0#
        Else
            Result = sg * (2# * BesselJ1(x) / x - BesselJ0(x))
        End If
        BesselJN = Result
        Exit Function
    End If
    If x < MachineEpsilon Then
        Result = 0#
        BesselJN = Result
        Exit Function
    End If
    K = 53#
    pk = 2# * (N + K)
    ans = pk
    XK = x * x
    Do
        pk = pk - 2#
        ans = pk - XK / ans
        K = K - 1#
    Loop Until K = 0#
    ans = x / ans
    pk = 1#
    pkm1 = 1# / ans
    K = N - 1#
    R = 2# * K
    Do
        pkm2 = (pkm1 * R - pk * x) / x
        pk = pkm1
        pkm1 = pkm2
        R = R - 2#
        K = K - 1#
    Loop Until K = 0#
    If Abs(pk) > Abs(pkm1) Then
        ans = BesselJ1(x) / pk
    Else
        ans = BesselJ0(x) / pkm1
    End If
    Result = sg * ans
    BesselJN = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Bessel function of the second kind, order zero
'
'Returns Bessel function of the second kind, of order
'zero, of the argument.
'
'The domain is divided into the intervals [0, 5] and
'(5, infinity). In the first interval a rational approximation
'R(x) is employed to compute
'  y0(x)  = R(x)  +   2 * log(x) * j0(x) / PI.
'Thus a call to j0() is required.
'
'In the second interval, the Hankel asymptotic expansion
'is employed with two rational functions of degree 6/6
'and 7/7.
'
'
'
'ACCURACY:
'
' Absolute error, when y0(x) < 1; else relative error:
'
'arithmetic   domain     # trials      peak         rms
'   IEEE      0, 30       30000       1.3e-15     1.6e-16
'
'Cephes Math Library Release 2.8:  June, 2000
'Copyright 1984, 1987, 1989, 2000 by Stephen L. Moshier
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function BesselY0(ByVal x As Double) As Double
    Dim Result As Double
    Dim NN As Double
    Dim XSq As Double
    Dim PZero As Double
    Dim QZero As Double
    Dim P4 As Double
    Dim Q4 As Double
    If x > 8# Then
        Call BesselAsympt0(x, PZero, QZero)
        NN = x - Pi() / 4#
        Result = Sqr(2# / Pi() / x) * (PZero * Sin(NN) + QZero * Cos(NN))
        BesselY0 = Result
        Exit Function
    End If
    XSq = Square(x)
    P4 = -41370.3549793315
    P4 = 59152134.6568689 + XSq * P4
    P4 = -34363712229.7904 + XSq * P4
    P4 = 10255208596863.9 + XSq * P4
    P4 = -1.64860581718573E+15 + XSq * P4
    P4 = 1.37562431639934E+17 + XSq * P4
    P4 = -5.24706558111277E+18 + XSq * P4
    P4 = 6.58747327571955E+19 + XSq * P4
    P4 = -2.75028667862911E+19 + XSq * P4
    Q4 = 1#
    Q4 = 1282.45277247899 + XSq * Q4
    Q4 = 1001702.64128891 + XSq * Q4
    Q4 = 579512264.070073 + XSq * Q4
    Q4 = 261306575504.108 + XSq * Q4
    Q4 = 91620380340751.9 + XSq * Q4
    Q4 = 2.39288304349978E+16 + XSq * Q4
    Q4 = 4.19241704341084E+18 + XSq * Q4
    Q4 = 3.72645883898617E+20 + XSq * Q4
    Result = P4 / Q4 + 2# / Pi() * BesselJ0(x) * Log(x)
    BesselY0 = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Bessel function of second kind of order one
'
'Returns Bessel function of the second kind of order one
'of the argument.
'
'The domain is divided into the intervals [0, 8] and
'(8, infinity). In the first interval a 25 term Chebyshev
'expansion is used, and a call to j1() is required.
'In the second, the asymptotic trigonometric representation
'is employed using two rational functions of degree 5/5.
'
'ACCURACY:
'
'                     Absolute error:
'arithmetic   domain      # trials      peak         rms
'   IEEE      0, 30       30000       1.0e-15     1.3e-16
'
'Cephes Math Library Release 2.8:  June, 2000
'Copyright 1984, 1987, 1989, 2000 by Stephen L. Moshier
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function BesselY1(ByVal x As Double) As Double
    Dim Result As Double
    Dim NN As Double
    Dim XSq As Double
    Dim PZero As Double
    Dim QZero As Double
    Dim P4 As Double
    Dim Q4 As Double
    If x > 8# Then
        Call BesselAsympt1(x, PZero, QZero)
        NN = x - 3# * Pi() / 4#
        Result = Sqr(2# / Pi() / x) * (PZero * Sin(NN) + QZero * Cos(NN))
        BesselY1 = Result
        Exit Function
    End If
    XSq = Square(x)
    P4 = -2108847.54013312
    P4 = 3639488548.124 + XSq * P4
    P4 = -2580681702194.45 + XSq * P4
    P4 = 956993023992168# + XSq * P4
    P4 = -1.96588746272214E+17 + XSq * P4
    P4 = 2.1931073399178E+19 + XSq * P4
    P4 = -1.21229755541451E+21 + XSq * P4
    P4 = 2.65547383143485E+22 + XSq * P4
    P4 = -9.96375342430692E+22 + XSq * P4
    Q4 = 1#
    Q4 = 1612.361029677 + XSq * Q4
    Q4 = 1563282.75489958 + XSq * Q4
    Q4 = 1128686837.16944 + XSq * Q4
    Q4 = 646534088126.528 + XSq * Q4
    Q4 = 297663212564728# + XSq * Q4
    Q4 = 1.08225825940882E+17 + XSq * Q4
    Q4 = 2.95498793589715E+19 + XSq * Q4
    Q4 = 5.43531037718885E+21 + XSq * Q4
    Q4 = 5.08206736694124E+23 + XSq * Q4
    Result = x * P4 / Q4 + 2# / Pi() * (BesselJ1(x) * Log(x) - 1# / x)
    BesselY1 = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Bessel function of second kind of integer order
'
'Returns Bessel function of order n, where n is a
'(possibly negative) integer.
'
'The function is evaluated by forward recurrence on
'n, starting with values computed by the routines
'y0() and y1().
'
'If n = 0 or 1 the routine for y0 or y1 is called
'directly.
'
'ACCURACY:
'                     Absolute error, except relative
'                     when y > 1:
'arithmetic   domain     # trials      peak         rms
'   IEEE      0, 30       30000       3.4e-15     4.3e-16
'
'Cephes Math Library Release 2.8:  June, 2000
'Copyright 1984, 1987, 2000 by Stephen L. Moshier
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function BesselYN(ByVal N As Long, ByVal x As Double) As Double
    Dim Result As Double
    Dim i As Long
    Dim a As Double
    Dim b As Double
    Dim Tmp As Double
    Dim s As Double
    s = 1#
    If N < 0# Then
        N = -N
        If N Mod 2# <> 0# Then
            s = -1#
        End If
    End If
    If N = 0# Then
        Result = BesselY0(x)
        BesselYN = Result
        Exit Function
    End If
    If N = 1# Then
        Result = s * BesselY1(x)
        BesselYN = Result
        Exit Function
    End If
    a = BesselY0(x)
    b = BesselY1(x)
    For i = 1# To N - 1# Step 1
        Tmp = b
        b = 2# * i / x * b - a
        a = Tmp
    Next i
    Result = s * b
    BesselYN = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Modified Bessel function of order zero
'
'Returns modified Bessel function of order zero of the
'argument.
'
'The function is defined as i0(x) = j0( ix ).
'
'The range is partitioned into the two intervals [0,8] and
'(8, infinity).  Chebyshev polynomial expansions are employed
'in each interval.
'
'ACCURACY:
'
'                     Relative error:
'arithmetic   domain     # trials      peak         rms
'   IEEE      0,30        30000       5.8e-16     1.4e-16
'
'Cephes Math Library Release 2.8:  June, 2000
'Copyright 1984, 1987, 2000 by Stephen L. Moshier
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function BesselI0(ByVal x As Double) As Double
    Dim Result As Double
    Dim y As Double
    Dim V As Double
    Dim z As Double
    Dim b0 As Double
    Dim b1 As Double
    Dim b2 As Double
    If x < 0# Then
        x = -x
    End If
    If x <= 8# Then
        y = x / 2# - 2#
        Call BesselMFirstCheb(-4.41534164647934E-18, b0, b1, b2)
        Call BesselMNextCheb(y, 3.33079451882224E-17, b0, b1, b2)
        Call BesselMNextCheb(y, -2.43127984654795E-16, b0, b1, b2)
        Call BesselMNextCheb(y, 1.71539128555513E-15, b0, b1, b2)
        Call BesselMNextCheb(y, -1.16853328779935E-14, b0, b1, b2)
        Call BesselMNextCheb(y, 7.67618549860494E-14, b0, b1, b2)
        Call BesselMNextCheb(y, -4.85644678311193E-13, b0, b1, b2)
        Call BesselMNextCheb(y, 2.95505266312964E-12, b0, b1, b2)
        Call BesselMNextCheb(y, -1.72682629144156E-11, b0, b1, b2)
        Call BesselMNextCheb(y, 9.67580903537324E-11, b0, b1, b2)
        Call BesselMNextCheb(y, -5.18979560163526E-10, b0, b1, b2)
        Call BesselMNextCheb(y, 2.65982372468239E-09, b0, b1, b2)
        Call BesselMNextCheb(y, -1.30002500998625E-08, b0, b1, b2)
        Call BesselMNextCheb(y, 6.04699502254192E-08, b0, b1, b2)
        Call BesselMNextCheb(y, -2.67079385394061E-07, b0, b1, b2)
        Call BesselMNextCheb(y, 1.1173875391201E-06, b0, b1, b2)
        Call BesselMNextCheb(y, -4.41673835845875E-06, b0, b1, b2)
        Call BesselMNextCheb(y, 1.64484480707289E-05, b0, b1, b2)
        Call BesselMNextCheb(y, -5.7541950100821E-05, b0, b1, b2)
        Call BesselMNextCheb(y, 1.88502885095842E-04, b0, b1, b2)
        Call BesselMNextCheb(y, -5.76375574538582E-04, b0, b1, b2)
        Call BesselMNextCheb(y, 1.63947561694134E-03, b0, b1, b2)
        Call BesselMNextCheb(y, -4.32430999505058E-03, b0, b1, b2)
        Call BesselMNextCheb(y, 0.010546460394595, b0, b1, b2)
        Call BesselMNextCheb(y, -2.37374148058995E-02, b0, b1, b2)
        Call BesselMNextCheb(y, 4.93052842396707E-02, b0, b1, b2)
        Call BesselMNextCheb(y, -9.49010970480476E-02, b0, b1, b2)
        Call BesselMNextCheb(y, 0.171620901522209, b0, b1, b2)
        Call BesselMNextCheb(y, -0.304682672343198, b0, b1, b2)
        Call BesselMNextCheb(y, 0.676795274409476, b0, b1, b2)
        V = 0.5 * (b0 - b2)
        Result = Exp(x) * V
        BesselI0 = Result
        Exit Function
    End If
    z = 32# / x - 2#
    Call BesselMFirstCheb(-7.23318048787475E-18, b0, b1, b2)
    Call BesselMNextCheb(z, -4.83050448594418E-18, b0, b1, b2)
    Call BesselMNextCheb(z, 4.46562142029676E-17, b0, b1, b2)
    Call BesselMNextCheb(z, 3.46122286769746E-17, b0, b1, b2)
    Call BesselMNextCheb(z, -2.82762398051658E-16, b0, b1, b2)
    Call BesselMNextCheb(z, -3.42548561967722E-16, b0, b1, b2)
    Call BesselMNextCheb(z, 1.77256013305653E-15, b0, b1, b2)
    Call BesselMNextCheb(z, 3.81168066935262E-15, b0, b1, b2)
    Call BesselMNextCheb(z, -9.55484669882831E-15, b0, b1, b2)
    Call BesselMNextCheb(z, -4.15056934728722E-14, b0, b1, b2)
    Call BesselMNextCheb(z, 1.54008621752141E-14, b0, b1, b2)
    Call BesselMNextCheb(z, 3.85277838274214E-13, b0, b1, b2)
    Call BesselMNextCheb(z, 7.18012445138367E-13, b0, b1, b2)
    Call BesselMNextCheb(z, -1.79417853150681E-12, b0, b1, b2)
    Call BesselMNextCheb(z, -1.32158118404477E-11, b0, b1, b2)
    Call BesselMNextCheb(z, -3.14991652796324E-11, b0, b1, b2)
    Call BesselMNextCheb(z, 1.18891471078464E-11, b0, b1, b2)
    Call BesselMNextCheb(z, 4.94060238822497E-10, b0, b1, b2)
    Call BesselMNextCheb(z, 3.39623202570839E-09, b0, b1, b2)
    Call BesselMNextCheb(z, 2.26666899049818E-08, b0, b1, b2)
    Call BesselMNextCheb(z, 2.04891858946906E-07, b0, b1, b2)
    Call BesselMNextCheb(z, 2.89137052083476E-06, b0, b1, b2)
    Call BesselMNextCheb(z, 6.88975834691682E-05, b0, b1, b2)
    Call BesselMNextCheb(z, 3.36911647825569E-03, b0, b1, b2)
    Call BesselMNextCheb(z, 0.804490411014109, b0, b1, b2)
    V = 0.5 * (b0 - b2)
    Result = Exp(x) * V / Sqr(x)
    BesselI0 = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Modified Bessel function of order one
'
'Returns modified Bessel function of order one of the
'argument.
'
'The function is defined as i1(x) = -i j1( ix ).
'
'The range is partitioned into the two intervals [0,8] and
'(8, infinity).  Chebyshev polynomial expansions are employed
'in each interval.
'
'ACCURACY:
'
'                     Relative error:
'arithmetic   domain     # trials      peak         rms
'   IEEE      0, 30       30000       1.9e-15     2.1e-16
'
'Cephes Math Library Release 2.8:  June, 2000
'Copyright 1985, 1987, 2000 by Stephen L. Moshier
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function BesselI1(ByVal x As Double) As Double
    Dim Result As Double
    Dim y As Double
    Dim z As Double
    Dim V As Double
    Dim b0 As Double
    Dim b1 As Double
    Dim b2 As Double
    z = Abs(x)
    If z <= 8# Then
        y = z / 2# - 2#
        Call BesselM1FirstCheb(2.77791411276105E-18, b0, b1, b2)
        Call BesselM1NextCheb(y, -2.11142121435817E-17, b0, b1, b2)
        Call BesselM1NextCheb(y, 1.5536319577362E-16, b0, b1, b2)
        Call BesselM1NextCheb(y, -1.10559694773539E-15, b0, b1, b2)
        Call BesselM1NextCheb(y, 7.60068429473541E-15, b0, b1, b2)
        Call BesselM1NextCheb(y, -5.04218550472791E-14, b0, b1, b2)
        Call BesselM1NextCheb(y, 3.22379336594557E-13, b0, b1, b2)
        Call BesselM1NextCheb(y, -1.98397439776494E-12, b0, b1, b2)
        Call BesselM1NextCheb(y, 1.17361862988909E-11, b0, b1, b2)
        Call BesselM1NextCheb(y, -6.66348972350203E-11, b0, b1, b2)
        Call BesselM1NextCheb(y, 3.62559028155212E-10, b0, b1, b2)
        Call BesselM1NextCheb(y, -1.88724975172283E-09, b0, b1, b2)
        Call BesselM1NextCheb(y, 9.38153738649577E-09, b0, b1, b2)
        Call BesselM1NextCheb(y, -4.44505912879633E-08, b0, b1, b2)
        Call BesselM1NextCheb(y, 2.00329475355214E-07, b0, b1, b2)
        Call BesselM1NextCheb(y, -8.56872026469545E-07, b0, b1, b2)
        Call BesselM1NextCheb(y, 3.47025130813768E-06, b0, b1, b2)
        Call BesselM1NextCheb(y, -1.32731636560394E-05, b0, b1, b2)
        Call BesselM1NextCheb(y, 4.78156510755005E-05, b0, b1, b2)
        Call BesselM1NextCheb(y, -1.61760815825897E-04, b0, b1, b2)
        Call BesselM1NextCheb(y, 5.12285956168576E-04, b0, b1, b2)
        Call BesselM1NextCheb(y, -1.51357245063125E-03, b0, b1, b2)
        Call BesselM1NextCheb(y, 4.15642294431289E-03, b0, b1, b2)
        Call BesselM1NextCheb(y, -1.05640848946262E-02, b0, b1, b2)
        Call BesselM1NextCheb(y, 2.47264490306265E-02, b0, b1, b2)
        Call BesselM1NextCheb(y, -0.052945981208095, b0, b1, b2)
        Call BesselM1NextCheb(y, 0.102643658689847, b0, b1, b2)
        Call BesselM1NextCheb(y, -0.176416518357834, b0, b1, b2)
        Call BesselM1NextCheb(y, 0.252587186443634, b0, b1, b2)
        V = 0.5 * (b0 - b2)
        z = V * z * Exp(z)
    Else
        y = 32# / z - 2#
        Call BesselM1FirstCheb(7.51729631084211E-18, b0, b1, b2)
        Call BesselM1NextCheb(y, 4.41434832307171E-18, b0, b1, b2)
        Call BesselM1NextCheb(y, -4.65030536848936E-17, b0, b1, b2)
        Call BesselM1NextCheb(y, -3.20952592199342E-17, b0, b1, b2)
        Call BesselM1NextCheb(y, 2.96262899764595E-16, b0, b1, b2)
        Call BesselM1NextCheb(y, 3.30820231092093E-16, b0, b1, b2)
        Call BesselM1NextCheb(y, -1.88035477551078E-15, b0, b1, b2)
        Call BesselM1NextCheb(y, -3.81440307243701E-15, b0, b1, b2)
        Call BesselM1NextCheb(y, 1.04202769841288E-14, b0, b1, b2)
        Call BesselM1NextCheb(y, 4.27244001671195E-14, b0, b1, b2)
        Call BesselM1NextCheb(y, -2.10154184277266E-14, b0, b1, b2)
        Call BesselM1NextCheb(y, -4.0835511110922E-13, b0, b1, b2)
        Call BesselM1NextCheb(y, -7.19855177624591E-13, b0, b1, b2)
        Call BesselM1NextCheb(y, 2.03562854414709E-12, b0, b1, b2)
        Call BesselM1NextCheb(y, 1.41258074366138E-11, b0, b1, b2)
        Call BesselM1NextCheb(y, 3.25260358301549E-11, b0, b1, b2)
        Call BesselM1NextCheb(y, -1.89749581235054E-11, b0, b1, b2)
        Call BesselM1NextCheb(y, -5.58974346219658E-10, b0, b1, b2)
        Call BesselM1NextCheb(y, -3.83538038596424E-09, b0, b1, b2)
        Call BesselM1NextCheb(y, -2.63146884688952E-08, b0, b1, b2)
        Call BesselM1NextCheb(y, -2.51223623787021E-07, b0, b1, b2)
        Call BesselM1NextCheb(y, -3.88256480887769E-06, b0, b1, b2)
        Call BesselM1NextCheb(y, -1.10588938762624E-04, b0, b1, b2)
        Call BesselM1NextCheb(y, -9.76109749136147E-03, b0, b1, b2)
        Call BesselM1NextCheb(y, 0.77857623501828, b0, b1, b2)
        V = 0.5 * (b0 - b2)
        z = V * Exp(z) / Sqr(z)
    End If
    If x < 0# Then
        z = -z
    End If
    Result = z
    BesselI1 = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Modified Bessel function, second kind, order zero
'
'Returns modified Bessel function of the second kind
'of order zero of the argument.
'
'The range is partitioned into the two intervals [0,8] and
'(8, infinity).  Chebyshev polynomial expansions are employed
'in each interval.
'
'ACCURACY:
'
'Tested at 2000 random points between 0 and 8.  Peak absolute
'error (relative when K0 > 1) was 1.46e-14; rms, 4.26e-15.
'                     Relative error:
'arithmetic   domain     # trials      peak         rms
'   IEEE      0, 30       30000       1.2e-15     1.6e-16
'
'Cephes Math Library Release 2.8:  June, 2000
'Copyright 1984, 1987, 2000 by Stephen L. Moshier
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function BesselK0(ByVal x As Double) As Double
    Dim Result As Double
    Dim y As Double
    Dim z As Double
    Dim V As Double
    Dim b0 As Double
    Dim b1 As Double
    Dim b2 As Double
    If x <= 2# Then
        y = x * x - 2#
        Call BesselMFirstCheb(1.37446543561352E-16, b0, b1, b2)
        Call BesselMNextCheb(y, 4.25981614279661E-14, b0, b1, b2)
        Call BesselMNextCheb(y, 1.03496952576338E-11, b0, b1, b2)
        Call BesselMNextCheb(y, 1.90451637722021E-09, b0, b1, b2)
        Call BesselMNextCheb(y, 2.53479107902615E-07, b0, b1, b2)
        Call BesselMNextCheb(y, 2.28621210311945E-05, b0, b1, b2)
        Call BesselMNextCheb(y, 1.26461541144693E-03, b0, b1, b2)
        Call BesselMNextCheb(y, 3.59799365153615E-02, b0, b1, b2)
        Call BesselMNextCheb(y, 0.344289899924628, b0, b1, b2)
        Call BesselMNextCheb(y, -0.535327393233903, b0, b1, b2)
        V = 0.5 * (b0 - b2)
        V = V - Log(0.5 * x) * BesselI0(x)
    Else
        z = 8# / x - 2#
        Call BesselMFirstCheb(5.30043377268626E-18, b0, b1, b2)
        Call BesselMNextCheb(z, -1.64758043015242E-17, b0, b1, b2)
        Call BesselMNextCheb(z, 5.21039150503903E-17, b0, b1, b2)
        Call BesselMNextCheb(z, -1.67823109680541E-16, b0, b1, b2)
        Call BesselMNextCheb(z, 5.51205597852432E-16, b0, b1, b2)
        Call BesselMNextCheb(z, -1.84859337734378E-15, b0, b1, b2)
        Call BesselMNextCheb(z, 6.34007647740507E-15, b0, b1, b2)
        Call BesselMNextCheb(z, -2.22751332699167E-14, b0, b1, b2)
        Call BesselMNextCheb(z, 8.03289077536358E-14, b0, b1, b2)
        Call BesselMNextCheb(z, -2.98009692317273E-13, b0, b1, b2)
        Call BesselMNextCheb(z, 1.14034058820848E-12, b0, b1, b2)
        Call BesselMNextCheb(z, -4.51459788337394E-12, b0, b1, b2)
        Call BesselMNextCheb(z, 1.85594911495472E-11, b0, b1, b2)
        Call BesselMNextCheb(z, -7.95748924447711E-11, b0, b1, b2)
        Call BesselMNextCheb(z, 3.5773972814003E-10, b0, b1, b2)
        Call BesselMNextCheb(z, -1.69753450938906E-09, b0, b1, b2)
        Call BesselMNextCheb(z, 8.57403401741423E-09, b0, b1, b2)
        Call BesselMNextCheb(z, -4.66048989768795E-08, b0, b1, b2)
        Call BesselMNextCheb(z, 2.76681363944501E-07, b0, b1, b2)
        Call BesselMNextCheb(z, -1.83175552271912E-06, b0, b1, b2)
        Call BesselMNextCheb(z, 1.39498137188765E-05, b0, b1, b2)
        Call BesselMNextCheb(z, -1.28495495816278E-04, b0, b1, b2)
        Call BesselMNextCheb(z, 1.56988388573005E-03, b0, b1, b2)
        Call BesselMNextCheb(z, -3.14481013119645E-02, b0, b1, b2)
        Call BesselMNextCheb(z, 2.44030308206596, b0, b1, b2)
        V = 0.5 * (b0 - b2)
        V = V * Exp(-x) / Sqr(x)
    End If
    Result = V
    BesselK0 = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Modified Bessel function, second kind, order one
'
'Computes the modified Bessel function of the second kind
'of order one of the argument.
'
'The range is partitioned into the two intervals [0,2] and
'(2, infinity).  Chebyshev polynomial expansions are employed
'in each interval.
'
'ACCURACY:
'
'                     Relative error:
'arithmetic   domain     # trials      peak         rms
'   IEEE      0, 30       30000       1.2e-15     1.6e-16
'
'Cephes Math Library Release 2.8:  June, 2000
'Copyright 1984, 1987, 2000 by Stephen L. Moshier
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function BesselK1(ByVal x As Double) As Double
    Dim Result As Double
    Dim y As Double
    Dim z As Double
    Dim V As Double
    Dim b0 As Double
    Dim b1 As Double
    Dim b2 As Double
    z = 0.5 * x
    If x <= 2# Then
        y = x * x - 2#
        Call BesselM1FirstCheb(-7.02386347938629E-18, b0, b1, b2)
        Call BesselM1NextCheb(y, -2.42744985051937E-15, b0, b1, b2)
        Call BesselM1NextCheb(y, -6.66690169419933E-13, b0, b1, b2)
        Call BesselM1NextCheb(y, -1.41148839263353E-10, b0, b1, b2)
        Call BesselM1NextCheb(y, -2.21338763073473E-08, b0, b1, b2)
        Call BesselM1NextCheb(y, -2.43340614156597E-06, b0, b1, b2)
        Call BesselM1NextCheb(y, -1.73028895751305E-04, b0, b1, b2)
        Call BesselM1NextCheb(y, -6.97572385963986E-03, b0, b1, b2)
        Call BesselM1NextCheb(y, -0.122611180822657, b0, b1, b2)
        Call BesselM1NextCheb(y, -0.353155960776545, b0, b1, b2)
        Call BesselM1NextCheb(y, 1.52530022733895, b0, b1, b2)
        V = 0.5 * (b0 - b2)
        Result = Log(z) * BesselI1(x) + V / x
    Else
        y = 8# / x - 2#
        Call BesselM1FirstCheb(-5.75674448366502E-18, b0, b1, b2)
        Call BesselM1NextCheb(y, 1.79405087314756E-17, b0, b1, b2)
        Call BesselM1NextCheb(y, -5.68946255844286E-17, b0, b1, b2)
        Call BesselM1NextCheb(y, 1.83809354436664E-16, b0, b1, b2)
        Call BesselM1NextCheb(y, -6.05704724837332E-16, b0, b1, b2)
        Call BesselM1NextCheb(y, 2.03870316562433E-15, b0, b1, b2)
        Call BesselM1NextCheb(y, -7.01983709041831E-15, b0, b1, b2)
        Call BesselM1NextCheb(y, 2.4771544244813E-14, b0, b1, b2)
        Call BesselM1NextCheb(y, -8.97670518232499E-14, b0, b1, b2)
        Call BesselM1NextCheb(y, 3.34841966607843E-13, b0, b1, b2)
        Call BesselM1NextCheb(y, -1.28917396095103E-12, b0, b1, b2)
        Call BesselM1NextCheb(y, 5.13963967348173E-12, b0, b1, b2)
        Call BesselM1NextCheb(y, -2.12996783842757E-11, b0, b1, b2)
        Call BesselM1NextCheb(y, 9.21831518760501E-11, b0, b1, b2)
        Call BesselM1NextCheb(y, -4.1903547593419E-10, b0, b1, b2)
        Call BesselM1NextCheb(y, 2.01504975519703E-09, b0, b1, b2)
        Call BesselM1NextCheb(y, -1.03457624656781E-08, b0, b1, b2)
        Call BesselM1NextCheb(y, 5.74108412545005E-08, b0, b1, b2)
        Call BesselM1NextCheb(y, -3.50196060308781E-07, b0, b1, b2)
        Call BesselM1NextCheb(y, 2.40648494783722E-06, b0, b1, b2)
        Call BesselM1NextCheb(y, -1.93619797416608E-05, b0, b1, b2)
        Call BesselM1NextCheb(y, 1.95215518471352E-04, b0, b1, b2)
        Call BesselM1NextCheb(y, -2.85781685962278E-03, b0, b1, b2)
        Call BesselM1NextCheb(y, 0.103923736576817, b0, b1, b2)
        Call BesselM1NextCheb(y, 2.72062619048444, b0, b1, b2)
        V = 0.5 * (b0 - b2)
        Result = Exp(-x) * V / Sqr(x)
    End If
    BesselK1 = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Modified Bessel function, second kind, integer order
'
'Returns modified Bessel function of the second kind
'of order n of the argument.
'
'The range is partitioned into the two intervals [0,9.55] and
'(9.55, infinity).  An ascending power series is used in the
'low range, and an asymptotic expansion in the high range.
'
'ACCURACY:
'
'                     Relative error:
'arithmetic   domain     # trials      peak         rms
'   IEEE      0,30        90000       1.8e-8      3.0e-10
'
'Error is high only near the crossover point x = 9.55
'between the two expansions used.
'
'Cephes Math Library Release 2.8:  June, 2000
'Copyright 1984, 1987, 1988, 2000 by Stephen L. Moshier
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function BesselKN(ByVal NN As Long, ByVal x As Double) As Double
    Dim Result As Double
    Dim K As Double
    Dim KF As Double
    Dim nk1f As Double
    Dim nkf As Double
    Dim zn As Double
    Dim t As Double
    Dim s As Double
    Dim z0 As Double
    Dim z As Double
    Dim ans As Double
    Dim FN As Double
    Dim pn As Double
    Dim pk As Double
    Dim zmn As Double
    Dim tlg As Double
    Dim tox As Double
    Dim i As Long
    Dim N As Long
    Dim EUL As Double
    EUL = 0.577215664901533
    If NN < 0# Then
        N = -NN
    Else
        N = NN
    End If
    If x <= 9.55 Then
        ans = 0#
        z0 = 0.25 * x * x
        FN = 1#
        pn = 0#
        zmn = 1#
        tox = 2# / x
        If N > 0# Then
            pn = -EUL
            K = 1#
            For i = 1# To N - 1# Step 1
                pn = pn + 1# / K
                K = K + 1#
                FN = FN * K
            Next i
            zmn = tox
            If N = 1# Then
                ans = 1# / x
            Else
                nk1f = FN / N
                KF = 1#
                s = nk1f
                z = -z0
                zn = 1#
                For i = 1# To N - 1# Step 1
                    nk1f = nk1f / (N - i)
                    KF = KF * i
                    zn = zn * z
                    t = nk1f * zn / KF
                    s = s + t
                    zmn = zmn * tox
                Next i
                s = s * 0.5
                t = Abs(s)
                ans = s * zmn
            End If
        End If
        tlg = 2# * Log(0.5 * x)
        pk = -EUL
        If N = 0# Then
            pn = pk
            t = 1#
        Else
            pn = pn + 1# / N
            t = 1# / FN
        End If
        s = (pk + pn - tlg) * t
        K = 1#
        Do
            t = t * (z0 / (K * (K + N)))
            pk = pk + 1# / K
            pn = pn + 1# / (K + N)
            s = s + (pk + pn - tlg) * t
            K = K + 1#
        Loop Until Abs(t / s) <= MachineEpsilon
        s = 0.5 * s / zmn
        If N Mod 2# <> 0# Then
            s = -s
        End If
        ans = ans + s
        Result = ans
        BesselKN = Result
        Exit Function
    End If
    If x > Log(MaxRealNumber) Then
        Result = 0#
        BesselKN = Result
        Exit Function
    End If
    K = N
    pn = 4# * K * K
    pk = 1#
    z0 = 8# * x
    FN = 1#
    t = 1#
    s = t
    nkf = MaxRealNumber
    i = 0#
    Do
        z = pn - pk * pk
        t = t * z / (FN * z0)
        nk1f = Abs(t)
        If i >= N And nk1f > nkf Then
            Exit Do
        End If
        nkf = nk1f
        s = s + t
        FN = FN + 1#
        pk = pk + 2#
        i = i + 1#
    Loop Until Abs(t / s) <= MachineEpsilon
    Result = Exp(-x) * Sqr(Pi() / (2# * x)) * s
    BesselKN = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal subroutine
'
'Cephes Math Library Release 2.8:  June, 2000
'Copyright 1984, 1987, 2000 by Stephen L. Moshier
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub BesselMFirstCheb(ByVal c As Double, _
         ByRef b0 As Double, _
         ByRef b1 As Double, _
         ByRef b2 As Double)
    b0 = c
    b1 = 0#
    b2 = 0#
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal subroutine
'
'Cephes Math Library Release 2.8:  June, 2000
'Copyright 1984, 1987, 2000 by Stephen L. Moshier
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub BesselMNextCheb(ByVal x As Double, _
         ByVal c As Double, _
         ByRef b0 As Double, _
         ByRef b1 As Double, _
         ByRef b2 As Double)
    b2 = b1
    b1 = b0
    b0 = x * b1 - b2 + c
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal subroutine
'
'Cephes Math Library Release 2.8:  June, 2000
'Copyright 1984, 1987, 2000 by Stephen L. Moshier
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub BesselM1FirstCheb(ByVal c As Double, _
         ByRef b0 As Double, _
         ByRef b1 As Double, _
         ByRef b2 As Double)
    b0 = c
    b1 = 0#
    b2 = 0#
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal subroutine
'
'Cephes Math Library Release 2.8:  June, 2000
'Copyright 1984, 1987, 2000 by Stephen L. Moshier
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub BesselM1NextCheb(ByVal x As Double, _
         ByVal c As Double, _
         ByRef b0 As Double, _
         ByRef b1 As Double, _
         ByRef b2 As Double)
    b2 = b1
    b1 = b0
    b0 = x * b1 - b2 + c
End Sub
Private Sub BesselAsympt0(ByVal x As Double, _
         ByRef PZero As Double, _
         ByRef QZero As Double)
    Dim XSq As Double
    Dim P2 As Double
    Dim Q2 As Double
    Dim P3 As Double
    Dim Q3 As Double
    XSq = 64# / (x * x)
    P2 = 0#
    P2 = 2485.2719289574 + XSq * P2
    P2 = 153982.653262391 + XSq * P2
    P2 = 2016135.28304998 + XSq * P2
    P2 = 8413041.45655044 + XSq * P2
    P2 = 12332384.7681764 + XSq * P2
    P2 = 5393485.08386944 + XSq * P2
    Q2 = 1#
    Q2 = 2615.70073692084 + XSq * Q2
    Q2 = 156001.727694003 + XSq * Q2
    Q2 = 2025066.80157013 + XSq * Q2
    Q2 = 8426449.0506298 + XSq * Q2
    Q2 = 12338310.2278633 + XSq * Q2
    Q2 = 5393485.08386944 + XSq * Q2
    P3 = -0#
    P3 = -4.88719939584126 + XSq * P3
    P3 = -226.26306419337 + XSq * P3
    P3 = -2365.95617077911 + XSq * P3
    P3 = -8239.06631348561 + XSq * P3
    P3 = -10381.4169874846 + XSq * P3
    P3 = -3984.61735759522 + XSq * P3
    Q3 = 1#
    Q3 = 408.77146739835 + XSq * Q3
    Q3 = 15704.891915154 + XSq * Q3
    Q3 = 156021.320667929 + XSq * Q3
    Q3 = 533291.36342169 + XSq * Q3
    Q3 = 666745.423931983 + XSq * Q3
    Q3 = 255015.510886094 + XSq * Q3
    PZero = P2 / Q2
    QZero = 8# * P3 / Q3 / x
End Sub
Private Sub BesselAsympt1(ByVal x As Double, _
         ByRef PZero As Double, _
         ByRef QZero As Double)
    Dim XSq As Double
    Dim P2 As Double
    Dim Q2 As Double
    Dim P3 As Double
    Dim Q3 As Double
    XSq = 64# / (x * x)
    P2 = -1611.61664432461
    P2 = -109824.055434593 + XSq * P2
    P2 = -1523529.35118114 + XSq * P2
    P2 = -6603373.24836494 + XSq * P2
    P2 = -9942246.50507764 + XSq * P2
    P2 = -4435757.81679413 + XSq * P2
    Q2 = 1#
    Q2 = -1455.0094401905 + XSq * Q2
    Q2 = -107263.859911038 + XSq * Q2
    Q2 = -1511809.50663416 + XSq * Q2
    Q2 = -6585339.47972309 + XSq * Q2
    Q2 = -9934124.38993459 + XSq * Q2
    Q2 = -4435757.81679413 + XSq * Q2
    P3 = 35.265133846636
    P3 = 1706.37542902077 + XSq * P3
    P3 = 18494.2628732239 + XSq * P3
    P3 = 66178.8365812708 + XSq * P3
    P3 = 85145.1606753357 + XSq * P3
    P3 = 33220.9134098572 + XSq * P3
    Q3 = 1#
    Q3 = 863.836776960499 + XSq * Q3
    Q3 = 37890.2297457722 + XSq * Q3
    Q3 = 400294.43582267 + XSq * Q3
    Q3 = 1419460.66960372 + XSq * Q3
    Q3 = 1819458.042244 + XSq * Q3
    Q3 = 708712.819410287 + XSq * Q3
    PZero = P2 / Q2
    QZero = 8# * P3 / Q3 / x
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Cephes Math Library Release 2.8:  June, 2000
'Copyright by Stephen L. Moshier
'
'Contributors:
'    * Sergey Bochkanov (ALGLIB project). Translation from C to
'      pseudocode.
'
'See subroutines comments for additional copyrights.
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Beta function
'
'
'                  -     -
'                 | (a) | (b)
'beta( a, b )  =  -----------.
'                    -
'                   | (a+b)
'
'For large arguments the logarithm of the function is
'evaluated using lgam(), then exponentiated.
'
'ACCURACY:
'
'                     Relative error:
'arithmetic   domain     # trials      peak         rms
'   IEEE       0,30       30000       8.1e-14     1.1e-14
'
'Cephes Math Library Release 2.0:  April, 1987
'Copyright 1984, 1987 by Stephen L. Moshier
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function beta(ByVal a As Double, ByVal b As Double) As Double
    Dim Result As Double
    Dim y As Double
    Dim sg As Double
    Dim s As Double
    sg = 1#
    y = a + b
    If Abs(y) > 171.624376956303 Then
        y = LnGamma(y, s)
        sg = sg * s
        y = LnGamma(b, s) - y
        sg = sg * s
        y = LnGamma(a, s) + y
        sg = sg * s
        Result = sg * Exp(y)
        beta = Result
        Exit Function
    End If
    y = Gamma(y)
    If a > b Then
        y = Gamma(a) / y
        y = y * Gamma(b)
    Else
        y = Gamma(b) / y
        y = y * Gamma(a)
    End If
    Result = y
    beta = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Cephes Math Library Release 2.8:  June, 2000
'Copyright by Stephen L. Moshier
'
'Contributors:
'    * Sergey Bochkanov (ALGLIB project). Translation from C to
'      pseudocode.
'
'See subroutines comments for additional copyrights.
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Gamma function
'
'Input parameters:
'    X   -   argument
'
'Domain:
'    0 < X < 171.6
'    -170 < X < 0, X is not an integer.
'
'Relative error:
' arithmetic   domain     # trials      peak         rms
'    IEEE    -170,-33      20000       2.3e-15     3.3e-16
'    IEEE     -33,  33     20000       9.4e-16     2.2e-16
'    IEEE      33, 171.6   20000       2.3e-15     3.2e-16
'
'Cephes Math Library Release 2.8:  June, 2000
'Original copyright 1984, 1987, 1989, 1992, 2000 by Stephen L. Moshier
'Translated to AlgoPascal by Bochkanov Sergey (2005, 2006, 2007).
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function Gamma(ByVal x As Double) As Double
    Dim Result As Double
    Dim p As Double
    Dim PP As Double
    Dim q As Double
    Dim QQ As Double
    Dim z As Double
    Dim i As Long
    Dim SgnGam As Double
    SgnGam = 1#
    q = Abs(x)
    If q > 33# Then
        If x < 0# Then
            p = Int(q)
            i = Round(p)
            If i Mod 2# = 0# Then
                SgnGam = -1#
            End If
            z = q - p
            If z > 0.5 Then
                p = p + 1#
                z = q - p
            End If
            z = q * Sin(Pi() * z)
            z = Abs(z)
            z = Pi() / (z * GammaStirF(q))
        Else
            z = GammaStirF(x)
        End If
        Result = SgnGam * z
        Gamma = Result
        Exit Function
    End If
    z = 1#
    Do While x >= 3#
        x = x - 1#
        z = z * x
    Loop
    Do While x < 0#
        If x > -0.000000001 Then
            Result = z / ((1# + 0.577215664901533 * x) * x)
            Gamma = Result
            Exit Function
        End If
        z = z / x
        x = x + 1#
    Loop
    Do While x < 2#
        If x < 0.000000001 Then
            Result = z / ((1# + 0.577215664901533 * x) * x)
            Gamma = Result
            Exit Function
        End If
        z = z / x
        x = x + 1#
    Loop
    If x = 2# Then
        Result = z
        Gamma = Result
        Exit Function
    End If
    x = x - 2#
    PP = 1.60119522476752E-04
    PP = 1.19135147006586E-03 + x * PP
    PP = 1.04213797561762E-02 + x * PP
    PP = 4.76367800457137E-02 + x * PP
    PP = 0.207448227648436 + x * PP
    PP = 0.494214826801497 + x * PP
    PP = 1# + x * PP
    QQ = -2.3158187332412E-05
    QQ = 5.39605580493303E-04 + x * QQ
    QQ = -4.45641913851797E-03 + x * QQ
    QQ = 0.011813978522206 + x * QQ
    QQ = 3.58236398605499E-02 + x * QQ
    QQ = -0.234591795718243 + x * QQ
    QQ = 7.14304917030273E-02 + x * QQ
    QQ = 1# + x * QQ
    Result = z * PP / QQ
    Gamma = Result
    Exit Function
    Gamma = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Natural logarithm of gamma function
'
'Input parameters:
'    X       -   argument
'
'Result:
'    logarithm of the absolute value of the Gamma(X).
'
'Output parameters:
'    SgnGam  -   sign(Gamma(X))
'
'Domain:
'    0 < X < 2.55e305
'    -2.55e305 < X < 0, X is not an integer.
'
'ACCURACY:
'arithmetic      domain        # trials     peak         rms
'   IEEE    0, 3                 28000     5.4e-16     1.1e-16
'   IEEE    2.718, 2.556e305     40000     3.5e-16     8.3e-17
'The error criterion was relative when the function magnitude
'was greater than one but absolute when it was less than one.
'
'The following test used the relative error criterion, though
'at certain points the relative error could be much higher than
'indicated.
'   IEEE    -200, -4             10000     4.8e-16     1.3e-16
'
'Cephes Math Library Release 2.8:  June, 2000
'Copyright 1984, 1987, 1989, 1992, 2000 by Stephen L. Moshier
'Translated to AlgoPascal by Bochkanov Sergey (2005, 2006, 2007).
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function LnGamma(ByVal x As Double, ByRef SgnGam As Double) As Double
    Dim Result As Double
    Dim a As Double
    Dim b As Double
    Dim c As Double
    Dim p As Double
    Dim q As Double
    Dim U As Double
    Dim w As Double
    Dim z As Double
    Dim i As Long
    Dim LogPi As Double
    Dim LS2PI As Double
    Dim Tmp As Double
    SgnGam = 1#
    LogPi = 1.1447298858494
    LS2PI = 0.918938533204673
    If x < -34# Then
        q = -x
        w = LnGamma(q, Tmp)
        p = Int(q)
        i = Round(p)
        If i Mod 2# = 0# Then
            SgnGam = -1#
        Else
            SgnGam = 1#
        End If
        z = q - p
        If z > 0.5 Then
            p = p + 1#
            z = p - q
        End If
        z = q * Sin(Pi() * z)
        Result = LogPi - Log(z) - w
        LnGamma = Result
        Exit Function
    End If
    If x < 13# Then
        z = 1#
        p = 0#
        U = x
        Do While U >= 3#
            p = p - 1#
            U = x + p
            z = z * U
        Loop
        Do While U < 2#
            z = z / U
            p = p + 1#
            U = x + p
        Loop
        If z < 0# Then
            SgnGam = -1#
            z = -z
        Else
            SgnGam = 1#
        End If
        If U = 2# Then
            Result = Log(z)
            LnGamma = Result
            Exit Function
        End If
        p = p - 2#
        x = x + p
        b = -1378.25152569121
        b = -38801.6315134638 + x * b
        b = -331612.992738871 + x * b
        b = -1162370.97492762 + x * b
        b = -1721737.0082084 + x * b
        b = -853555.664245765 + x * b
        c = 1#
        c = -351.815701436523 + x * c
        c = -17064.2106651881 + x * c
        c = -220528.590553854 + x * c
        c = -1139334.44367983 + x * c
        c = -2532523.07177583 + x * c
        c = -2018891.41433533 + x * c
        p = x * b / c
        Result = Log(z) + p
        LnGamma = Result
        Exit Function
    End If
    q = (x - 0.5) * Log(x) - x + LS2PI
    If x > 100000000# Then
        Result = q
        LnGamma = Result
        Exit Function
    End If
    p = 1# / (x * x)
    If x >= 1000# Then
        q = q + ((7.93650793650794 * 0.0001 * p - 2.77777777777778 * 0.001) * p + 8.33333333333333E-02) / x
    Else
        a = 8.11614167470508 * 0.0001
        a = -(5.95061904284301 * 0.0001) + p * a
        a = 7.93650340457717 * 0.0001 + p * a
        a = -(2.777777777301 * 0.001) + p * a
        a = 8.33333333333332 * 0.01 + p * a
        q = q + a / x
    End If
    Result = q
    LnGamma = Result
End Function
Private Function GammaStirF(ByVal x As Double) As Double
    Dim Result As Double
    Dim y As Double
    Dim w As Double
    Dim V As Double
    Dim Stir As Double
    w = 1# / x
    Stir = 7.87311395793094E-04
    Stir = -2.29549961613378E-04 + w * Stir
    Stir = -2.68132617805781E-03 + w * Stir
    Stir = 3.47222221605459E-03 + w * Stir
    Stir = 8.33333333333482E-02 + w * Stir
    w = 1# + w * Stir
    y = Exp(x)
    If x > 143.01608 Then
        V = Power(x, 0.5 * x - 0.25)
        y = V * (V / y)
    Else
        y = Power(x, x - 0.5) / y
    End If
    Result = 2.506628274631 * y * w
    GammaStirF = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Cephes Math Library Release 2.8:  June, 2000
'Copyright by Stephen L. Moshier
'
'Contributors:
'    * Sergey Bochkanov (ALGLIB project). Translation from C to
'      pseudocode.
'
'See subroutines comments for additional copyrights.
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Exponential integral Ei(x)
'
'              x
'               -     t
'              | |   e
'   Ei(x) =   -|-   ---  dt .
'            | |     t
'             -
'            -inf
'
'Not defined for x <= 0.
'See also expn.c.
'
'
'
'ACCURACY:
'
'                     Relative error:
'arithmetic   domain     # trials      peak         rms
'   IEEE       0,100       50000      8.6e-16     1.3e-16
'
'Cephes Math Library Release 2.8:  May, 1999
'Copyright 1999 by Stephen L. Moshier
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function ExponentialIntegralEI(ByVal x As Double) As Double
    Dim Result As Double
    Dim EUL As Double
    Dim f As Double
    Dim F1 As Double
    Dim F2 As Double
    Dim w As Double
    EUL = 0.577215664901533
    If x <= 0# Then
        Result = 0#
        ExponentialIntegralEI = Result
        Exit Function
    End If
    If x < 2# Then
        F1 = -5.35044735781254
        F1 = F1 * x + 218.504916881661
        F1 = F1 * x - 4176.57238482669
        F1 = F1 * x + 55411.7675639356
        F1 = F1 * x - 331338.133117814
        F1 = F1 * x + 1592627.16338495
        F2 = 1#
        F2 = F2 * x - 52.5054795911286
        F2 = F2 * x + 1259.61618678679
        F2 = F2 * x - 17565.4958197353
        F2 = F2 * x + 149306.211700273
        F2 = F2 * x - 729494.923964053
        F2 = F2 * x + 1592627.16338495
        f = F1 / F2
        Result = EUL + Log(x) + x * f
        ExponentialIntegralEI = Result
        Exit Function
    End If
    If x < 4# Then
        w = 1# / x
        F1 = 1.98180850325969E-02
        F1 = F1 * w - 1.27164562598492
        F1 = F1 * w - 2.08816033568123
        F1 = F1 * w + 2.75554450918794
        F1 = F1 * w - 0.44095070487016
        F1 = F1 * w + 4.66562380593589E-02
        F1 = F1 * w - 1.54504267967349E-03
        F1 = F1 * w + 7.05998060529962E-05
        F2 = 1#
        F2 = F2 * w + 1.47649867091492
        F2 = F2 * w + 0.562917717482244
        F2 = F2 * w + 0.169901789787931
        F2 = F2 * w + 2.29164717903421E-02
        F2 = F2 * w + 4.45015043972875E-03
        F2 = F2 * w + 1.72743961220652E-04
        F2 = F2 * w + 3.95316719554967E-05
        f = F1 / F2
        Result = Exp(x) * w * (1# + w * f)
        ExponentialIntegralEI = Result
        Exit Function
    End If
    If x < 8# Then
        w = 1# / x
        F1 = -1.37321537587121
        F1 = F1 * w - 0.708455913374084
        F1 = F1 * w + 1.58080685554794
        F1 = F1 * w - 0.260150042742562
        F1 = F1 * w + 2.99467469411371E-02
        F1 = F1 * w - 1.03808604018874E-03
        F1 = F1 * w + 4.37106442075301E-05
        F1 = F1 * w + 2.1417836795226E-06
        F2 = 1#
        F2 = F2 * w + 0.858523142362203
        F2 = F2 * w + 0.4483285822874
        F2 = F2 * w + 7.68793215812448E-02
        F2 = F2 * w + 2.44986824102189E-02
        F2 = F2 * w + 8.8321659419278E-04
        F2 = F2 * w + 4.59095229951135E-04
        F2 = F2 * w + -4.72984835186652E-06
        F2 = F2 * w + 2.66519553739071E-06
        f = F1 / F2
        Result = Exp(x) * w * (1# + w * f)
        ExponentialIntegralEI = Result
        Exit Function
    End If
    If x < 16# Then
        w = 1# / x
        F1 = -2.10693460169192
        F1 = F1 * w + 1.73273386966469
        F1 = F1 * w - 0.242361917893584
        F1 = F1 * w + 2.32272418093757E-02
        F1 = F1 * w + 2.37288044049318E-04
        F1 = F1 * w - 8.34321956119255E-05
        F1 = F1 * w + 1.36340879560525E-05
        F1 = F1 * w - 3.65541232199925E-07
        F1 = F1 * w + 1.46494173397596E-08
        F1 = F1 * w + 6.17640786371036E-10
        F2 = 1#
        F2 = F2 * w - 0.229806223990168
        F2 = F2 * w + 0.110507704147404
        F2 = F2 * w - 1.56654296663079E-02
        F2 = F2 * w + 2.76110685081735E-03
        F2 = F2 * w - 2.08914801228405E-04
        F2 = F2 * w + 1.70852893880768E-05
        F2 = F2 * w - 4.45931179635669E-07
        F2 = F2 * w + 1.39463493035385E-08
        F2 = F2 * w + 6.15086593397734E-10
        f = F1 / F2
        Result = Exp(x) * w * (1# + w * f)
        ExponentialIntegralEI = Result
        Exit Function
    End If
    If x < 32# Then
        w = 1# / x
        F1 = -0.245811936767402
        F1 = F1 * w - 0.148338225332208
        F1 = F1 * w + 7.24829179573555E-02
        F1 = F1 * w - 1.34831568738094E-02
        F1 = F1 * w + 1.34277506978864E-03
        F1 = F1 * w - 7.94246563715971E-05
        F1 = F1 * w + 2.64417951898424E-06
        F1 = F1 * w - 4.23947365931377E-08
        F2 = 1#
        F2 = F2 * w - 0.104422590844387
        F2 = F2 * w - 0.26764531281014
        F2 = F2 * w + 9.69500025462198E-02
        F2 = F2 * w - 1.60174569271299E-02
        F2 = F2 * w + 1.49641489920591E-03
        F2 = F2 * w - 8.46245256377849E-05
        F2 = F2 * w + 2.72893840347673E-06
        F2 = F2 * w - 4.23946243181954E-08
        f = F1 / F2
        Result = Exp(x) * w * (1# + w * f)
        ExponentialIntegralEI = Result
        Exit Function
    End If
    If x < 64# Then
        w = 1# / x
        F1 = 0.121256111810546
        F1 = F1 * w - 0.582313317904389
        F1 = F1 * w + 0.234888731455702
        F1 = F1 * w - 3.04003431811325E-02
        F1 = F1 * w + 1.51008214686519E-03
        F1 = F1 * w - 2.52313709549957E-05
        F2 = 1#
        F2 = F2 * w - 1.00225215036585
        F2 = F2 * w + 0.292870969487222
        F2 = F2 * w - 3.33700433867401E-02
        F2 = F2 * w + 1.56054488112739E-03
        F2 = F2 * w - 2.52313709360323E-05
        f = F1 / F2
        Result = Exp(x) * w * (1# + w * f)
        ExponentialIntegralEI = Result
        Exit Function
    End If
    w = 1# / x
    F1 = -0.765784707828613
    F1 = F1 * w + 0.688619241556671
    F1 = F1 * w - 0.213259811354521
    F1 = F1 * w + 3.34610755238419E-02
    F1 = F1 * w - 3.07654147734476E-03
    F1 = F1 * w + 1.74711931645491E-04
    F1 = F1 * w - 6.10371168227417E-06
    F1 = F1 * w + 1.21803276542865E-07
    F1 = F1 * w - 1.08607610279329E-09
    F2 = 1#
    F2 = F2 * w - 1.88880286866231
    F2 = F2 * w + 1.06669168721141
    F2 = F2 * w - 0.275191598230638
    F2 = F2 * w + 3.93085268823382E-02
    F2 = F2 * w - 3.41468455860237E-03
    F2 = F2 * w + 1.86684437070356E-04
    F2 = F2 * w - 6.34514608313052E-06
    F2 = F2 * w + 1.23975428748321E-07
    F2 = F2 * w - 1.08607610279313E-09
    f = F1 / F2
    Result = Exp(x) * w * (1# + w * f)
    ExponentialIntegralEI = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Exponential integral En(x)
'
'Evaluates the exponential integral
'
'                inf.
'                  -
'                 | |   -xt
'                 |    e
'     E (x)  =    |    ----  dt.
'      n          |      n
'               | |     t
'                -
'                 1
'
'
'Both n and x must be nonnegative.
'
'The routine employs either a power series, a continued
'fraction, or an asymptotic formula depending on the
'relative values of n and x.
'
'ACCURACY:
'
'                     Relative error:
'arithmetic   domain     # trials      peak         rms
'   IEEE      0, 30       10000       1.7e-15     3.6e-16
'
'Cephes Math Library Release 2.8:  June, 2000
'Copyright 1985, 2000 by Stephen L. Moshier
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function ExponentialIntegralEN(ByVal x As Double, _
         ByVal N As Long) As Double
    Dim Result As Double
    Dim R As Double
    Dim t As Double
    Dim YK As Double
    Dim XK As Double
    Dim pk As Double
    Dim pkm1 As Double
    Dim pkm2 As Double
    Dim qk As Double
    Dim qkm1 As Double
    Dim qkm2 As Double
    Dim Psi As Double
    Dim z As Double
    Dim i As Long
    Dim K As Long
    Dim big As Double
    Dim EUL As Double
    EUL = 0.577215664901533
    big = 1.44115188075856 * Power(10#, 17#)
    If N < 0# Or x < 0# Or x > 170# Or x = 0# And N < 2# Then
        Result = -1#
        ExponentialIntegralEN = Result
        Exit Function
    End If
    If x = 0# Then
        Result = 1# / (N - 1#)
        ExponentialIntegralEN = Result
        Exit Function
    End If
    If N = 0# Then
        Result = Exp(-x) / x
        ExponentialIntegralEN = Result
        Exit Function
    End If
    If N > 5000# Then
        XK = x + N
        YK = 1# / (XK * XK)
        t = N
        Result = YK * t * (6# * x * x - 8# * t * x + t * t)
        Result = YK * (Result + t * (t - 2# * x))
        Result = YK * (Result + t)
        Result = (Result + 1#) * Exp(-x) / XK
        ExponentialIntegralEN = Result
        Exit Function
    End If
    If x <= 1# Then
        Psi = -EUL - Log(x)
        For i = 1# To N - 1# Step 1
            Psi = Psi + 1# / i
        Next i
        z = -x
        XK = 0#
        YK = 1#
        pk = 1# - N
        If N = 1# Then
            Result = 0#
        Else
            Result = 1# / pk
        End If
        Do
            XK = XK + 1#
            YK = YK * z / XK
            pk = pk + 1#
            If pk <> 0# Then
                Result = Result + YK / pk
            End If
            If Result <> 0# Then
                t = Abs(YK / Result)
            Else
                t = 1#
            End If
        Loop Until t < MachineEpsilon
        t = 1#
        For i = 1# To N - 1# Step 1
            t = t * z / i
        Next i
        Result = Psi * t - Result
        ExponentialIntegralEN = Result
        Exit Function
    Else
        K = 1#
        pkm2 = 1#
        qkm2 = x
        pkm1 = 1#
        qkm1 = x + N
        Result = pkm1 / qkm1
        Do
            K = K + 1#
            If K Mod 2# = 1# Then
                YK = 1#
                XK = N + (K - 1#) / 2#
            Else
                YK = x
                XK = K / 2#
            End If
            pk = pkm1 * YK + pkm2 * XK
            qk = qkm1 * YK + qkm2 * XK
            If qk <> 0# Then
                R = pk / qk
                t = Abs((Result - R) / R)
                Result = R
            Else
                t = 1#
            End If
            pkm2 = pkm1
            pkm1 = pk
            qkm2 = qkm1
            qkm1 = qk
            If Abs(pk) > big Then
                pkm2 = pkm2 / big
                pkm1 = pkm1 / big
                qkm2 = qkm2 / big
                qkm1 = qkm1 / big
            End If
        Loop Until t < MachineEpsilon
        Result = Result * Exp(-x)
    End If
    ExponentialIntegralEN = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Cephes Math Library Release 2.8:  June, 2000
'Copyright 1984, 1987, 1988, 1992, 2000 by Stephen L. Moshier
'
'Contributors:
'    * Sergey Bochkanov (ALGLIB project). Translation from C to
'      pseudocode.
'
'See subroutines comments for additional copyrights.
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Error function
'
'The integral is
'
'                          x
'                           -
'                2         | |          2
'  erf(x)  =  --------     |    exp( - t  ) dt.
'             sqrt(pi)   | |
'                         -
'                          0
'
'For 0 <= |x| < 1, erf(x) = x * P4(x**2)/Q5(x**2); otherwise
'erf(x) = 1 - erfc(x).
'
'
'ACCURACY:
'
'                     Relative error:
'arithmetic   domain     # trials      peak         rms
'   IEEE      0,1         30000       3.7e-16     1.0e-16
'
'Cephes Math Library Release 2.8:  June, 2000
'Copyright 1984, 1987, 1988, 1992, 2000 by Stephen L. Moshier
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function Erf(ByVal x As Double) As Double
    Dim Result As Double
    Dim XSq As Double
    Dim s As Double
    Dim p As Double
    Dim q As Double
    s = Sgn(x)
    x = Abs(x)
    If x < 0.5 Then
        XSq = x * x
        p = 7.54772803341863E-03
        p = 0.288805137207594 + XSq * p
        p = 14.3383842191748 + XSq * p
        p = 38.0140318123903 + XSq * p
        p = 3017.82788536508 + XSq * p
        p = 7404.07142710151 + XSq * p
        p = 80437.363096084 + XSq * p
        q = 0#
        q = 1# + XSq * q
        q = 38.0190713951939 + XSq * q
        q = 658.07015545924 + XSq * q
        q = 6379.60017324428 + XSq * q
        q = 34216.5257924629 + XSq * q
        q = 80437.363096084 + XSq * q
        Result = s * 1.12837916709551 * x * p / q
        Erf = Result
        Exit Function
    End If
    If x >= 10# Then
        Result = s
        Erf = Result
        Exit Function
    End If
    Result = s * (1# - ErfC(x))
    Erf = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Complementary error function
'
' 1 - erf(x) =
'
'                          inf.
'                            -
'                 2         | |          2
'  erfc(x)  =  --------     |    exp( - t  ) dt
'              sqrt(pi)   | |
'                          -
'                           x
'
'
'For small x, erfc(x) = 1 - erf(x); otherwise rational
'approximations are computed.
'
'
'ACCURACY:
'
'                     Relative error:
'arithmetic   domain     # trials      peak         rms
'   IEEE      0,26.6417   30000       5.7e-14     1.5e-14
'
'Cephes Math Library Release 2.8:  June, 2000
'Copyright 1984, 1987, 1988, 1992, 2000 by Stephen L. Moshier
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function ErfC(ByVal x As Double) As Double
    Dim Result As Double
    Dim p As Double
    Dim q As Double
    If x < 0# Then
        Result = 2# - ErfC(-x)
        ErfC = Result
        Exit Function
    End If
    If x < 0.5 Then
        Result = 1# - Erf(x)
        ErfC = Result
        Exit Function
    End If
    If x >= 10# Then
        Result = 0#
        ErfC = Result
        Exit Function
    End If
    p = 0#
    p = 0.56418778255074 + x * p
    p = 9.67580788298727 + x * p
    p = 77.0816173036843 + x * p
    p = 368.519615471001 + x * p
    p = 1143.26207070389 + x * p
    p = 2320.43959025164 + x * p
    p = 2898.02932921677 + x * p
    p = 1826.33488422951 + x * p
    q = 1#
    q = 17.1498094362761 + x * q
    q = 137.125596050062 + x * q
    q = 661.736120710765 + x * q
    q = 2094.38436778954 + x * q
    q = 4429.61280388368 + x * q
    q = 6089.54242327244 + x * q
    q = 4958.82756472114 + x * q
    q = 1826.33488422951 + x * q
    Result = Exp(-Square(x)) * p / q
    ErfC = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Normal distribution function
'
'Returns the area under the Gaussian probability density
'function, integrated from minus infinity to x:
'
'                           x
'                            -
'                  1        | |          2
'   ndtr(x)  = ---------    |    exp( - t /2 ) dt
'              sqrt(2pi)  | |
'                          -
'                         -inf.
'
'            =  ( 1 + erf(z) ) / 2
'            =  erfc(z) / 2
'
'where z = x/sqrt(2). Computation is via the functions
'erf and erfc.
'
'
'ACCURACY:
'
'                     Relative error:
'arithmetic   domain     # trials      peak         rms
'   IEEE     -13,0        30000       3.4e-14     6.7e-15
'
'Cephes Math Library Release 2.8:  June, 2000
'Copyright 1984, 1987, 1988, 1992, 2000 by Stephen L. Moshier
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function NormalDistribution(ByVal x As Double) As Double
    Dim Result As Double
    Result = 0.5 * (Erf(x / 1.4142135623731) + 1#)
    NormalDistribution = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Inverse of the error function
'
'Cephes Math Library Release 2.8:  June, 2000
'Copyright 1984, 1987, 1988, 1992, 2000 by Stephen L. Moshier
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function InvErf(ByVal e As Double) As Double
    Dim Result As Double
    Result = InvNormalDistribution(0.5 * (e + 1#)) / Sqr(2#)
    InvErf = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Inverse of Normal distribution function
'
'Returns the argument, x, for which the area under the
'Gaussian probability density function (integrated from
'minus infinity to x) is equal to y.
'
'
'For small arguments 0 < y < exp(-2), the program computes
'z = sqrt( -2.0 * log(y) );  then the approximation is
'x = z - log(z)/z  - (1/z) P(1/z) / Q(1/z).
'There are two rational functions P/Q, one for 0 < y < exp(-32)
'and the other for y up to exp(-2).  For larger arguments,
'w = y - 0.5, and  x/sqrt(2pi) = w + w**3 R(w**2)/S(w**2)).
'
'ACCURACY:
'
'                     Relative error:
'arithmetic   domain        # trials      peak         rms
'   IEEE     0.125, 1        20000       7.2e-16     1.3e-16
'   IEEE     3e-308, 0.135   50000       4.6e-16     9.8e-17
'
'Cephes Math Library Release 2.8:  June, 2000
'Copyright 1984, 1987, 1988, 1992, 2000 by Stephen L. Moshier
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function InvNormalDistribution(ByVal y0 As Double) As Double
    Dim Result As Double
    Dim Expm2 As Double
    Dim S2Pi As Double
    Dim x As Double
    Dim y As Double
    Dim z As Double
    Dim Y2 As Double
    Dim X0 As Double
    Dim X1 As Double
    Dim code As Long
    Dim P0 As Double
    Dim Q0 As Double
    Dim P1 As Double
    Dim Q1 As Double
    Dim P2 As Double
    Dim Q2 As Double
    Expm2 = 0.135335283236613
    S2Pi = 2.506628274631
    If y0 <= 0# Then
        Result = -MaxRealNumber
        InvNormalDistribution = Result
        Exit Function
    End If
    If y0 >= 1# Then
        Result = MaxRealNumber
        InvNormalDistribution = Result
        Exit Function
    End If
    code = 1#
    y = y0
    If y > 1# - Expm2 Then
        y = 1# - y
        code = 0#
    End If
    If y > Expm2 Then
        y = y - 0.5
        Y2 = y * y
        P0 = -59.9633501014108
        P0 = 98.0010754186 + Y2 * P0
        P0 = -56.676285746907 + Y2 * P0
        P0 = 13.931260938728 + Y2 * P0
        P0 = -1.23916583867381 + Y2 * P0
        Q0 = 1#
        Q0 = 1.95448858338142 + Y2 * Q0
        Q0 = 4.67627912898882 + Y2 * Q0
        Q0 = 86.3602421390891 + Y2 * Q0
        Q0 = -225.462687854119 + Y2 * Q0
        Q0 = 200.260212380061 + Y2 * Q0
        Q0 = -82.0372256168333 + Y2 * Q0
        Q0 = 15.9056225126212 + Y2 * Q0
        Q0 = -1.1833162112133 + Y2 * Q0
        x = y + y * Y2 * P0 / Q0
        x = x * S2Pi
        Result = x
        InvNormalDistribution = Result
        Exit Function
    End If
    x = Sqr(-(2# * Log(y)))
    X0 = x - Log(x) / x
    z = 1# / x
    If x < 8# Then
        P1 = 4.05544892305962
        P1 = 31.5251094599894 + z * P1
        P1 = 57.1628192246421 + z * P1
        P1 = 44.0805073893201 + z * P1
        P1 = 14.6849561928858 + z * P1
        P1 = 2.1866330685079 + z * P1
        P1 = -(1.40256079171354 * 0.1) + z * P1
        P1 = -(3.50424626827848 * 0.01) + z * P1
        P1 = -(8.57456785154685 * 0.0001) + z * P1
        Q1 = 1#
        Q1 = 15.7799883256467 + z * Q1
        Q1 = 45.3907635128879 + z * Q1
        Q1 = 41.3172038254672 + z * Q1
        Q1 = 15.0425385692908 + z * Q1
        Q1 = 2.50464946208309 + z * Q1
        Q1 = -(1.42182922854788 * 0.1) + z * Q1
        Q1 = -(3.80806407691578 * 0.01) + z * Q1
        Q1 = -(9.33259480895457 * 0.0001) + z * Q1
        X1 = z * P1 / Q1
    Else
        P2 = 3.23774891776946
        P2 = 6.91522889068984 + z * P2
        P2 = 3.93881025292474 + z * P2
        P2 = 1.33303460815808 + z * P2
        P2 = 2.01485389549179 * 0.1 + z * P2
        P2 = 1.2371663481782 * 0.01 + z * P2
        P2 = 3.01581553508235 * 0.0001 + z * P2
        P2 = 2.65806974686738 * 0.000001 + z * P2
        P2 = 6.23974539184983 * 0.000000001 + z * P2
        Q2 = 1#
        Q2 = 6.02427039364742 + z * Q2
        Q2 = 3.67983563856161 + z * Q2
        Q2 = 1.37702099489081 + z * Q2
        Q2 = 2.16236993594497 * 0.1 + z * Q2
        Q2 = 1.34204006088543 * 0.01 + z * Q2
        Q2 = 3.28014464682128 * 0.0001 + z * Q2
        Q2 = 2.89247864745381 * 0.000001 + z * Q2
        Q2 = 6.79019408009981 * 0.000000001 + z * Q2
        X1 = z * P2 / Q2
    End If
    x = X0 - X1
    If code <> 0# Then
        x = -x
    End If
    Result = x
    InvNormalDistribution = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Calculation of the value of the Hermite polynomial.
'
'Parameters:
'    n   -   degree, n>=0
'    x   -   argument
'
'Result:
'    the value of the Hermite polynomial Hn at x
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function HermiteCalculate(ByRef N As Long, ByRef x As Double) As Double
    Dim Result As Double
    Dim i As Long
    Dim a As Double
    Dim b As Double
    '
    ' Prepare A and B
    '
    a = 1#
    b = 2# * x
    '
    ' Special cases: N=0 or N=1
    '
    If N = 0# Then
        Result = a
        HermiteCalculate = Result
        Exit Function
    End If
    If N = 1# Then
        Result = b
        HermiteCalculate = Result
        Exit Function
    End If
    '
    ' General case: N>=2
    '
    For i = 2# To N Step 1
        Result = 2# * x * b - 2# * (i - 1#) * a
        a = b
        b = Result
    Next i
    HermiteCalculate = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Summation of Hermite polynomials using Clenshaws recurrence formula.
'
'This routine calculates
'    c[0]*H0(x) + c[1]*H1(x) + ... + c[N]*HN(x)
'
'Parameters:
'    n   -   degree, n>=0
'    x   -   argument
'
'Result:
'    the value of the Hermite polynomial at x
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function HermiteSum(ByRef c() As Double, _
         ByRef N As Long, _
         ByRef x As Double) As Double
    Dim Result As Double
    Dim b1 As Double
    Dim b2 As Double
    Dim i As Long
    b1 = 0#
    b2 = 0#
    For i = N To 0# Step -1
        Result = 2# * (x * b1 - (i + 1#) * b2) + c(i)
        b2 = b1
        b1 = Result
    Next i
    HermiteSum = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Representation of Hn as C[0] + C[1]*X + ... + C[N]*X^N
'
'Input parameters:
'    N   -   polynomial degree, n>=0
'
'Output parameters:
'    C   -   coefficients
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub HermiteCoefficients(ByRef N As Long, ByRef c() As Double)
    Dim i As Long
    ReDim c(0# To N)
    For i = 0# To N Step 1
        c(i) = 0#
    Next i
    c(N) = Exp(N * Log(2#))
    For i = 0# To N \ 2# - 1# Step 1
        c(N - 2# * (i + 1#)) = -(c(N - 2# * i) * (N - 2# * i) * (N - 2# * i - 1#) / 4# / (i + 1#))
    Next i
End Sub

