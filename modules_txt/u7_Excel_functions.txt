'=======================================================================================
'Unifloc 7.50 year 2024                             khabibullinra@gmail.com
'Petroleum engineering calculations modules (macroses)
'2000 - 2023
'
'=======================================================================================
'функции для проведения расчетов из интерфейса Excel
'многофазный поток в трубах и элементах инфраструктуры
Option Explicit
'description_to_manual      - для автогенерации
'расчет градиента давления
'с использованием многофазных корреляций
Public Function MF_dpdl_atmm(ByVal d_m As Double, _
             ByVal p_atma As Double, _
             ByVal Ql_rc_m3day As Double, _
             ByVal Qg_rc_m3day As Double, _
    Optional ByVal mu_oil_cP As Double = const_mu_o, _
    Optional ByVal mu_gas_cP As Double = const_mu_g, _
    Optional ByVal sigma_oil_gas_Nm As Double = const_sigma_oil_Nm, _
    Optional ByVal rho_lrc_kgm3 As Double = const_go_ * 1000, _
    Optional ByVal rho_grc_kgm3 As Double = const_gg_ * const_rho_air, _
    Optional ByVal eps_m As Double = 0.0001, _
    Optional ByVal theta_deg As Double = 90, _
    Optional ByVal hcorr As Integer = 1, _
    Optional ByVal param_out As Integer = 0, _
    Optional ByVal calibr_grav As Double = 1, _
    Optional ByVal calibr_fric As Double = 1)
' расчет градиента давления по одной из корреляций
' d_m - диаметр трубы в которой идет поток
' p_atma - давление в точке расчета
' Ql_rc_m3day - дебит жидкости в рабочих условиях
' Qg_rc_m3day - дебит газа в рабочих условиях
' mu_oil_cP - вязкость нефти в рабочих условиях
' mu_gas_cP - вязкость газа в рабочих условиях
' sigma_oil_gas_Nm - поверхностное натяжение
'              жидкость газ
' rho_lrc_kgm3 - плотность нефти
' rho_grc_kgm3 - плотность газа
' eps_m     - шероховатость
' theta_deg - угол от горизонтали
' hcorr  - тип корреляции
' param_out - параметр для вывода
' calibr_grav - калибровка гравитации
' calibr_fric - калибровка трения
'description_end
    
    Dim PrGrad
    
On Error GoTo er1:
    Select Case hcorr
        Case 0
        
                PrGrad = unf_BegsBrillGradient(d_m, theta_deg, eps_m, _
                                Ql_rc_m3day, Qg_rc_m3day, _
                                mu_oil_cP, mu_gas_cP, _
                                sigma_oil_gas_Nm, _
                                rho_lrc_kgm3, _
                                rho_grc_kgm3, , , calibr_grav, calibr_fric)
        Case 1
        
                PrGrad = unf_AnsariGradient(d_m, theta_deg, eps_m, _
                                Ql_rc_m3day, Qg_rc_m3day, _
                                mu_oil_cP, mu_gas_cP, _
                                sigma_oil_gas_Nm, _
                                rho_lrc_kgm3, _
                                rho_grc_kgm3, _
                                p_atma, calibr_grav, calibr_fric)
       Case 2
        
                PrGrad = unf_UnifiedTUFFPGradient(d_m, theta_deg, eps_m, _
                                Ql_rc_m3day, Qg_rc_m3day, _
                                mu_oil_cP, mu_gas_cP, _
                                sigma_oil_gas_Nm, _
                                rho_lrc_kgm3, _
                                rho_grc_kgm3, _
                                p_atma, calibr_grav, calibr_fric)
       Case 3
        
                PrGrad = unf_GrayModifiedGradient(d_m, theta_deg, eps_m, _
                                Ql_rc_m3day, Qg_rc_m3day, _
                                mu_oil_cP, mu_gas_cP, _
                                sigma_oil_gas_Nm, _
                                rho_lrc_kgm3, _
                                rho_grc_kgm3, _
                                , , , calibr_grav, calibr_fric)
       Case 4
        
                PrGrad = unf_HagedornandBrawnmodified(d_m, theta_deg, eps_m, _
                                Ql_rc_m3day, Qg_rc_m3day, _
                                mu_oil_cP, mu_gas_cP, _
                                sigma_oil_gas_Nm, _
                                rho_lrc_kgm3, _
                                rho_grc_kgm3, _
                                p_atma, , , , calibr_grav, calibr_fric)
    End Select
    
    If param_out = 0 Then
        MF_dpdl_atmm = PrGrad
    Else
        MF_dpdl_atmm = PrGrad(param_out)
    End If
    Exit Function
er1:
    MF_dpdl_atmm = -1
    add_log_msg "Error:MF_dpdl_atmm:" & Err.Description
End Function
'description_to_manual      - для автогенерации
' расчет корректирующего фактора (множителя) модели штуцера под замеры
' медленный расчет - калибровка подбирается
Public Function MF_choke_calibr( _
                     ByVal choke_json As String, _
                     ByVal feed_json As String, _
            Optional ByVal calibr_type As Integer = 0, _
            Optional ByVal p_in_atma As Double = -1, _
            Optional ByVal p_out_atma As Double = -1, _
            Optional ByVal t_choke_C As Double = 20, _
            Optional ByVal param As String = "", _
        Optional ByVal q_liq_sm3day = -1, _
        Optional ByVal fw_perc = -1, _
        Optional ByVal rp_m3m3 = -1, _
        Optional ByVal q_gas_free_sm3day = -1)
' choke_json  - параметры штуцера закодированные в строке
' feed_json   - параметры потока флюидов json строка. Используйте
'               функции encode_feed() или encode_feed_list()
' calibr_type тип калибровки: 0 - calibr, 1 - диаметра штуцера
'   2 - газовый фактор, 3 - обводненность, 4 - дебит жидкости
' , 5 - дебита свободного газа
' p_in_atma     - давление на входе (высокой стороне)
' p_out_atma    - давление на выходе (низкой стороне)
' t_choke_C     - температура, С.
' param        - параметры расчета json строка
' q_liq_sm3day - дебит жидкости, перекрывает feed если задан,
'                может быть вектором
' fw_perc - обводненность, перекрывает feed если задан,
'                может быть вектором
' rp_m3m3 - газовый фактор, перекрывает feed если задан,
'                может быть вектором
' q_gas_free_sm3day - доп дебит газа, перекрывает feed если задан,
'                может быть вектором
' результат     - число - калибровочный коэффициент для модели.
'                 штуцера  - множитель на дебит через штуцер
'description_end
' calibr_type - тип калибровки
'             0 - подбор параметра calibr
'             1 - подбор диаметра штуцера
'             2 - подбор газового фактор
'             3 - подбор обводненности
'             4 - подбор дебита жидкости
'             5 - подбор дебита газа свободного
On Error GoTo err1:
    Dim choke As New Cchoke
    Dim CoeffA(0 To 2)
    Dim Func As String
    Dim val_min As Double, val_max As Double
    Dim prm As New CSolveParam
    Dim cal_type_string As String
    Dim prmd As Dictionary
    Dim show_log As Boolean
    Dim show_array As Boolean
    Dim show_json As Boolean
    Dim resd As New Dictionary
    Dim res(0 To 1, 0 To 3) As String
    
    Call choke.init_from_json(choke_json)
    choke.fluid.init_feed (feed_json)
    
    'Call set_choke_data(choke, d_choke_mm, feed, d_pipe_mm, calibr, CDischarge)
    Call choke.fluid.update_feed(q_liq_sm3day, fw_perc, rp_m3m3, q_gas_free_sm3day)
    
    If choke.fluid.gas_only Then
        MF_choke_calibr = "not implemented yet"
        Exit Function
    End If
    
    ' читаем параметры чтобы настроить правильный вывод
    Set prmd = param_to_dict(param)
    'calibr_type = prmd(prm_choke_calibr_type)
    show_log = prmd(prm_show_log)
    show_array = prmd(prm_show_array)
    show_json = prmd(prm_show_json)
    
     ' prepare solution function
    Set CoeffA(0) = choke
        CoeffA(1) = p_in_atma
        CoeffA(2) = p_out_atma
        
    Select Case calibr_type
        Case 0
            Func = "calc_choke_dp_error_calibr_grav_atm"
            cal_type_string = "calibr"
            val_min = 0.5
            val_max = 1.5
        Case 1
            Func = "calc_choke_dp_error_diam_atm"
            cal_type_string = "diam_choke"
            val_min = choke.d_choke_m / 2
            val_max = choke.d_up_m
        Case 2
            Func = "calc_choke_dp_error_rp_atm"
            cal_type_string = "rp"
            val_min = 20
            val_max = choke.fluid.rp_m3m3 * 2
            ' Расширить диапазон поиска по газовому фактору может быть опасно
            ' так как возможна неоднозначность решения
            ' а текущий метод поиска работает только если есть одно решение
        Case 3
            Func = "calc_choke_dp_error_fw_atm"
            cal_type_string = "fw"
            val_min = 0
            val_max = 1
            If val_max > 1 Then val_max = 1
        Case 4
            Func = "calc_choke_dp_error_qliq_atm"
            cal_type_string = "qliq"
            val_min = 0
            val_max = choke.fluid.q_liq_sm3day * 1.5
        Case 5
            Func = "calc_choke_dp_error_qgas_atm"
            cal_type_string = "qgas_free"
            val_min = 0
            If choke.fluid.q_gas_free_sm3day > 0 Then
                val_max = choke.fluid.q_gas_free_sm3day * 2
            Else
                val_max = 10000
            End If
       Case Else
            ' solve_equation_bisection without initialasing func crashes excel
            MF_choke_calibr = "not implemented"
            Exit Function
    End Select
   
    prm.y_tolerance = const_pressure_tolerance
    If solve_equation_bisection(Func, val_min, val_max, CoeffA, prm) Then
        resd("x_solution") = prm.x_solution
        resd("y_solution") = prm.y_solution
    Else
        resd("x_solution") = "no solution"
        resd("y_solution") = "no solution"
    End If
    
    resd.Add "cal_type", cal_type_string
    resd.Add "iterations", prm.iterations
    resd.Add "description", prm.msg
    
    If show_json Then
         
        Dim resd2 As Dictionary
        Set resd2 = choke.get_result_dict
        
        resd.Add "p_intake_atma", resd2("p_intake_atma")
        resd.Add "p_out_atma", resd2("p_out_atma")
        resd.Add "t_choke_C", resd2("t_choke_C")
        resd.Add "calibr_fr", resd2("calibr_fr")
        resd.Add "q_liq_sm3day", resd2("q_liq_sm3day")
        resd.Add "q_gas_sm3day", resd2("q_gas_sm3day")
        resd.Add "q_gas_free_sm3day", resd2("q_gas_free_sm3day")
        resd.Add "rp_m3m3", resd2("rp_m3m3")
        resd.Add "fw_perc", resd2("fw_perc")
        resd.Add "t_choke_throat_C", resd2("t_choke_throat_C")
        resd.Add "sonic_vel_msec", resd2("sonic_vel_msec")
        resd.Add "q_liq_max_sm3day", resd2("q_liq_max_sm3day")
        
        MF_choke_calibr = ConvertToJson(resd)
    Else
        res(0, 0) = ConvertToJson(resd): res(1, 0) = "result"
        res(0, 1) = ConvertToJson(choke.get_result_dict): res(1, 1) = "last calc"
        res(0, 2) = choke.fluid.feed: res(1, 2) = "feed"
        res(0, 3) = choke.log_.get_str_safe(show_log): res(1, 3) = "log"
        
        If show_array Then
            MF_choke_calibr = res
        Else
            MF_choke_calibr = res(0, 0)
        End If
    End If
    
    Exit Function
err1:
    On Error Resume Next
    MF_choke_calibr = "Error:MF_choke_calibr:" & Err.Description
End Function
' pipe generation function from the standard data set
' includes and parameters of the flow in the pipe
' needed to simplify user functions
Private Function new_pipeline( _
        Optional ByVal construction As String = "", _
        Optional ByVal t_model As String = "", _
        Optional ByVal calc_along_coord As Boolean = True, _
        Optional ByVal flow_along_coord As Boolean = True, _
        Optional ByVal flow_correlation As Integer = 0, _
        Optional ByVal calibr_grav As Double = 1, _
        Optional ByVal calibr_fric As Double = 1, _
        Optional ByVal h_start_m As Double = -10000000000.1, _
        Optional ByVal h_end_m As Double = 10000000000.1 _
        ) As CPipe
    Dim pipe As New CPipe
On Error GoTo err1:
    ' check default values for some props
    If Len(t_model) < 2 Then t_model = encode_t_model()
    If Len(construction) < 2 Then construction = encode_pipe_construction()
    Call pipe.init_from_json(construction, t_model, h_start_m, h_end_m)
    Call pipe.set_calc_flow_param(calc_along_coord:=calc_along_coord, _
                                     flow_along_coord:=flow_along_coord, _
                                     hcor:=flow_correlation, _
                                     temp_method:=pipe.param.temp_method)
    pipe.calibr_grav = calibr_grav
    pipe.calibr_fric = calibr_fric
    Set new_pipeline = pipe
    Exit Function
err1:
    new_pipeline = Array(-1, "error")
    add_log_msg "Error:new_pipeline:" & Err.Description
End Function
' pipe generation function from the standard data set
' includes and parameters of the flow in the pipe
' needed to simplify user functions
Private Function new_pipeline2( _
        Optional ByVal pipe_object As String = "", _
        Optional ByVal calc_along_coord As Boolean = True _
        ) As CPipe
        
    Dim pipe As New CPipe
    Dim piped As Dictionary
    
On Error GoTo err1:
    
    Set piped = ParseJson(pipe_object)
    
    ' check default values for some props
    
    Dim h_start_m As Double
    Dim h_end_m As Double
    
    h_start_m = piped("h_start_m")
    h_end_m = piped("h_end_m")
    
    If h_start_m = 0 And h_end_m = 0 Then
        h_start_m = -10000000000#
        h_end_m = 10000000000#
    End If
    
    Call pipe.init_from_dict(piped("construction"), piped("t_model"), h_start_m, h_end_m)
    
    Call pipe.set_calc_flow_param(calc_along_coord:=calc_along_coord, _
                                     flow_along_coord:=piped("flow_along_coord"), _
                                     hcor:=piped("flow_correlation"), _
                                     temp_method:=pipe.param.temp_method)
    pipe.calibr_grav = piped("calibr_grav")
    pipe.calibr_fric = piped("calibr_fric")
    
    
    If piped("znlf") Then pipe.set_ZNLF
    
    Set new_pipeline2 = pipe
    
    Exit Function
err1:
    new_pipeline2 = Array(-1, "error")
    add_log_msg "Error:new_pipeline2:" & Err.Description
                         
End Function
'description_to_manual      - для автогенерации
'  расчет распределения давления и температуры в трубопроводе
'  выводит результат в виде таблицы значений
Public Function MF_pipe_p_atma( _
                 ByVal p_calc_from_atma, _
                 ByVal t_calc_from_C, _
        Optional ByVal pipe_object As String = "", _
        Optional ByVal feed As String = "", _
        Optional ByVal calc_along_coord As Boolean = True, _
        Optional ByVal param As String = "", _
        Optional ByVal q_liq_sm3day = -1, _
        Optional ByVal fw_perc = -1, _
        Optional ByVal rp_m3m3 = -1, _
        Optional ByVal q_gas_free_sm3day = -1)
 ' p_calc_from_atma  - давление с которого начинается расчет, атм
'           граничное значение для проведения расчета
' t_calc_from_C - температура в точке где задано давление расчета
' pipe_object - параметры конструкции json строка. Используйте
'           функцию encode_pipe_construction() для генерации
' feed      - параметры потока флюидов json строка. Используйте
'           функции encode_feed() или encode_feed_list()
' calc_along_coord - направление расчета относительно координат.
' param     - дополнительные параметры расчета потока
' q_liq_sm3day - дебит жидкости, перекрывает feed если задан,
'                может быть вектором
' fw_perc - обводненность, перекрывает feed если задан,
'                может быть вектором
' rp_m3m3 - газовый фактор, перекрывает feed если задан,
'                может быть вектором
' q_gas_free_sm3day - доп дебит газа, перекрывает feed если задан,
'                может быть вектором
' результат - число - давление на другом конце трубы atma.
'           и распределение параметров по трубе
'description_end
    Dim pipe As New CPipe
    Dim prmd As Dictionary
    Dim res1
    Dim num_value As Integer
    Dim out_points As Integer
    
    Dim show_log As Boolean
    Dim show_array As Boolean
    Dim show_json As Boolean
    
    Dim save_crv As CALC_RESULTS
    Dim ptq As PTQ_LIST
    Dim ptq_out As PTQ_LIST
    
    Dim i As Integer
 
    save_crv = noCurves
    out_points = 20 ' default number of points in output arrays
On Error GoTo err1:
    ' инициализируем трубу с первым фидом, который всегда есть
    Set pipe = new_pipeline2(pipe_object, _
                                      calc_along_coord)
                                      
    ' read vector input values if given
    Call read_PTQ(ptq, feed, p_calc_from_atma, t_calc_from_C, pipe.log_, 0, q_liq_sm3day, fw_perc, rp_m3m3, q_gas_free_sm3day)
    Call init_ptq(ptq_out, ptq)
                                      
    ' читаем параметры
    Set prmd = param_to_dict(param)
    
    show_log = prmd(prm_show_log)
    num_value = prmd(prm_num_value)
    show_array = prmd(prm_show_array)
    show_json = prmd(prm_show_json)
    
    If prmd.Exists(prm_out_points) Then out_points = prmd(prm_out_points)
    
    ' запускаем цикл по вектору потоков, даже если он один все сработает как надо
    For i = 1 To ptq.len
        ' get proper feed from input vectors
        Call pipe.init_feed(ptq.feed(i), ptq.ql(i), ptq.fw(i), ptq.rp(i), ptq.qg(i))
        
        If (show_array Or show_json Or (num_value > 0)) And ptq.len = 1 Then save_crv = mainCurves
       
        res1 = PT_to_array(pipe.calc_dPipe(ptq.p(i), ptq.t(i), save_crv))  ' main calc sub call
        
        ptq_out.p(i) = Round(res1(0), const_num_decimal_out)
        ptq_out.t(i) = Round(res1(1), const_num_decimal_out)
        ptq_out.feed(i) = pipe.fluid.feed
    Next i
    
    If ptq.len = 1 Then ' вывод отличается для вектора и для одного расчета
        If show_json Then
            MF_pipe_p_atma = ConvertToJson(pipe.get_result_dict(20, show_array, show_log))
        Else
            res1 = pipe.get_result_array(out_points, show_log)
            If show_array Then
                If num_value > 0 Then res1(0, 0) = res1(0, num_value)
                MF_pipe_p_atma = res1
            Else
                MF_pipe_p_atma = Round(res1(0, num_value), const_num_decimal_out)
            End If
        End If
    Else
        MF_pipe_p_atma = convert_to_json_ptq(ptq_out)
    End If
    
    Exit Function
err1:
    MF_pipe_p_atma = "Error:MF_pipe_p_atma :" & Err.Description
End Function
' ==============  функции для расчета штуцера ==========================
' =====================================================================
'description_to_manual      - для автогенерации
' расчет давления в штуцере
Public Function MF_choke_q_sm3day( _
                     ByVal choke_json As String, _
                     ByVal feed_json As String, _
                     ByVal p_in_atma As Double, _
                     ByVal p_out_atma As Double, _
            Optional ByVal t_choke_C = 20, _
            Optional ByVal param As String = "", _
        Optional ByVal q_liq_sm3day = -1, _
        Optional ByVal fw_perc = -1, _
        Optional ByVal rp_m3m3 = -1, _
        Optional ByVal q_gas_free_sm3day = -1)
' choke_json  - параметры штуцера закодированные в строке
' feed_json   - параметры потока флюидов json строка. Используйте
'               функции encode_feed() или encode_feed_list()
' p_in_atma    - давление на входе в штуцер, атм.
'                высокая сторона
' p_out_atma   - давление на выходе из штуцера, атм.
'                низкая сторона
' t_choke_C    - температура потока, С.
' param        - параметры расчета json строка
' q_liq_sm3day - дебит жидкости, перекрывает feed если задан,
'                может быть вектором
' fw_perc - обводненность, перекрывает feed если задан,
'                может быть вектором
' rp_m3m3 - газовый фактор, перекрывает feed если задан,
'                может быть вектором
' q_gas_free_sm3day - доп дебит газа, перекрывает feed если задан,
'                может быть вектором
' результат    - число - массив значений с параметрами штуцера
'                и давление на штуцере на расчетной стороне.
'description_end
On Error GoTo err1:
    Dim choke As Cchoke
    Dim num_value As Integer, nv As Integer
    Dim show_array As Boolean
    Dim show_log As Boolean
    Dim show_json As Boolean
    
    ' auxiliary variables
    Dim i As Integer
    Dim pres As Double
    Dim q As Double
    Dim prmd As Dictionary
    
    num_value = 3
    Set choke = New Cchoke
    Call choke.init_from_json(choke_json)
    choke.fluid.init_feed (feed_json)
'    Call set_choke_data(choke, d_choke_mm, feed, d_pipe_mm, calibr, CDischarge)
    Call choke.fluid.update_feed(q_liq_sm3day, fw_perc, rp_m3m3, q_gas_free_sm3day)
    
    q = choke.calc_choke_q_liq_sm3day(p_in_atma, p_out_atma, t_choke_C)
    choke.fluid.q_liq_sm3day = q
'    feed_out = choke.fluid.feed
    ' читаем параметры чтобы настроить правильный вывод
    Set prmd = param_to_dict(param)
    show_array = prmd(prm_show_array)
    show_json = prmd(prm_show_json)
    
    If prmd.Exists(prm_num_value) Then
        nv = prmd(prm_num_value)
        If nv > 0 And nv < 10 Then num_value = nv
    End If
    
    If show_json Then
        MF_choke_q_sm3day = ConvertToJson(choke.get_result_dict(show_log))
    Else
        If show_array Then
            show_log = prmd(prm_show_log)
            MF_choke_q_sm3day = choke.get_result_array(num_value, show_log)
        Else
            MF_choke_q_sm3day = q
        End If
    End If
    Exit Function
err1:
    On Error GoTo err2:
    MF_choke_q_sm3day = Array("error:MF_choke_q_sm3day:" & Err.Description, _
                              choke.log_.get_str)
    Exit Function
err2:
    MF_choke_q_sm3day = "error:MF_choke_q_sm3day:" & Err.Description
End Function
'description_to_manual      - для автогенерации
' расчет давления в штуцере (дросселе)
Public Function MF_choke_p_atma( _
                     ByVal choke_json As String, _
                     ByVal feed_json As String, _
                     ByVal p_calc_from_atma, _
            Optional ByVal t_choke_C = 20, _
            Optional ByVal calc_along_flow As Boolean = True, _
            Optional ByVal param As String = "", _
        Optional ByVal q_liq_sm3day = -1, _
        Optional ByVal fw_perc = -1, _
        Optional ByVal rp_m3m3 = -1, _
        Optional ByVal q_gas_free_sm3day = -1)
' choke_json  - параметры штуцера закодированные в строке
' feed_json   - параметры потока флюидов json строка. Используйте
'               функции encode_feed() или encode_feed_list()
' p_calc_from_atma - давление с которого начинается расчет, атм
'                  граничное значение для проведения расчета
'                  либо давление на входе, либо на выходе.
'                   может быть списком.
' t_choke_C       - температура потока, С.
'                   может быть списком.
' calc_along_flow - флаг направления расчета относительно потока
' param           - параметры расчета json строка
' q_liq_sm3day - дебит жидкости, перекрывает feed если задан,
'                может быть вектором
' fw_perc - обводненность, перекрывает feed если задан,
'                может быть вектором
' rp_m3m3 - газовый фактор, перекрывает feed если задан,
'                может быть вектором
' q_gas_free_sm3day - доп дебит газа, перекрывает feed если задан,
'                может быть вектором
' результат       - число или массив значений с параметрами штуцера
'                   и давление на штуцере на расчетной стороне.
'description_end
'Const nv = 9  ' output array dimension (number of columns)
On Error GoTo err1:
    Dim choke As Cchoke
    Dim num_value As Integer, nv As Integer
    Dim P_out As Double
    Dim show_array As Boolean
    Dim show_log As Boolean
    Dim show_json As Boolean
    Dim prmd As Dictionary
    
    
    Dim ptq As PTQ_LIST
    Dim ptq_out As PTQ_LIST
    Dim i As Integer
    
    ' один раз заводим объект, даже если считаем вектор
    ' потом в логе должна сохраниться вся история расчетов
    Set choke = New Cchoke
    
    Call read_PTQ(ptq, feed_json, p_calc_from_atma, t_choke_C, choke.log_, 0, q_liq_sm3day, fw_perc, rp_m3m3, q_gas_free_sm3day)
    Call init_ptq(ptq_out, ptq)
    
    ' цикл расчетов - срабатывает если пришел feed вектор, иначе считает только один раз
    For i = 1 To ptq.len
        Call choke.init_from_json(choke_json)
        Call choke.fluid.init_feed(ptq.feed(i))
       ' Call set_choke_data(choke, d_choke_mm, ptq.feed(i), d_pipe_mm, calibr, CDischarge)
        Call choke.fluid.update_feed(ptq.ql(i), ptq.fw(i), ptq.rp(i), ptq.qg(i))
        ' запускаем расчет в зависимости от опции направления расчета
        If calc_along_flow Then
            Call choke.calc_choke_p_lin(set_PT(ptq.p(i), ptq.t(i)))
            P_out = choke.p_out_atma
            num_value = 2
        Else
            Call choke.calc_choke_p_buf(set_PT(ptq.p(i), ptq.t(i)))
            P_out = choke.p_in_atma
            num_value = 1
        End If
      '  col_res.Add p_out
        
        ptq_out.p(i) = Round(P_out, const_num_decimal_out)
        ptq_out.t(i) = Round(ptq.t(i), const_num_decimal_out)
        ptq_out.feed(i) = choke.fluid.feed
    Next i
    
    ' читаем параметры чтобы настроить правильный вывод
    Set prmd = param_to_dict(param)
    show_array = prmd(prm_show_array)
    show_json = prmd(prm_show_json)
    show_log = prmd(prm_show_log)
    
    If prmd.Exists(prm_num_value) Then
        nv = prmd(prm_num_value)
        If nv > 0 And nv < 10 Then num_value = nv
    End If
    ' формируем вывод в зависимости от значений параметров
    
    If ptq.len = 1 Then
        If show_json Then
            MF_choke_p_atma = ConvertToJson(choke.get_result_dict(show_log))
        Else
            If show_array Then
                MF_choke_p_atma = choke.get_result_array(num_value, show_log)
            Else
                MF_choke_p_atma = P_out
            End If
        End If
    Else
        MF_choke_p_atma = convert_to_json_ptq(ptq_out)
    End If
    
    Exit Function
err1:
    MF_choke_p_atma = "error:MF_p_choke_atma:" & Err.Description
End Function
'description_to_manual      - для автогенерации
' расчет корректирующего фактора (множителя) модели штуцера под замеры
' быстрый расчет - калибровка вычисляется
Public Function MF_choke_calibr_fast( _
                     ByVal choke_json As String, _
                     ByVal feed_json As String, _
            Optional ByVal p_in_atma As Double = -1, _
            Optional ByVal p_out_atma As Double = -1, _
            Optional ByVal t_choke_C As Double = 20, _
            Optional ByVal param As String = "", _
        Optional ByVal q_liq_sm3day = -1, _
        Optional ByVal fw_perc = -1, _
        Optional ByVal rp_m3m3 = -1, _
        Optional ByVal q_gas_free_sm3day = -1)
' choke_json  - параметры штуцера закодированные в строке
' feed_json   - параметры потока флюидов json строка. Используйте
'               функции encode_feed() или encode_feed_list()
' p_in_atma     - давление на входе (высокой стороне)
' p_out_atma    - давление на выходе (низкой стороне)
' t_choke_C     - температура, С.
' param        - параметры расчета json строка
' q_liq_sm3day - дебит жидкости, перекрывает feed если задан,
'                может быть вектором
' fw_perc - обводненность, перекрывает feed если задан,
'                может быть вектором
' rp_m3m3 - газовый фактор, перекрывает feed если задан,
'                может быть вектором
' q_gas_free_sm3day - доп дебит газа, перекрывает feed если задан,
'                может быть вектором
' результат     - число - калибровочный коэффициент для модели.
'                 штуцера  - множитель на дебит через штуцер
'description_end
On Error GoTo err1:
    Dim choke As New Cchoke
    Dim num_value As Integer, nv As Integer
    Dim arr_out
    Dim out As String, out_desc As String
    Dim show_log As Boolean
    Dim show_array As Boolean
    Dim show_json As Boolean
    Dim prmd As Dictionary
    Dim res
    
    Call choke.init_from_json(choke_json)
    choke.fluid.init_feed (feed_json)
    
  '  Call set_choke_data(choke, d_choke_mm, feed, d_pipe_mm, 1, CDischarge)
    Call choke.fluid.update_feed(q_liq_sm3day, fw_perc, rp_m3m3, q_gas_free_sm3day)
    
    If choke.fluid.gas_only Then
        MF_choke_calibr_fast = "not implemented yet"
        Exit Function
    End If
    
    If p_in_atma > p_out_atma And p_out_atma >= 1 Then
        Call choke.calc_choke_calibration(p_in_atma, p_out_atma, t_choke_C)
        out = choke.calibr_fr
        out_desc = "calibr_fr"
    End If
    
    
    ' читаем параметры чтобы настроить правильный вывод
    Set prmd = param_to_dict(param)
    show_array = prmd(prm_show_array)
    show_log = prmd(prm_show_log)
    show_json = prmd(prm_show_json)
    
    If prmd.Exists(prm_num_value) Then
        nv = prmd(prm_num_value)
        If nv > 0 And nv < 5 Then num_value = nv
    End If
    
    If show_json Then
        Dim resd As New Dictionary
        resd.Add "calibr_fr", out
        resd.Add "p_intake_atma", p_in_atma
        resd.Add "p_out_atma", p_out_atma
        resd.Add "t_choke_C", t_choke_C
        If show_log Then
            resd.Add "log", choke.log_.get_str_safe(show_log)
        End If
        
        MF_choke_calibr_fast = ConvertToJson(resd)
    Else
        If show_array Then
            arr_out = Array(Array(out, p_in_atma, p_out_atma, t_choke_C, choke.calibr_fr, choke.log_.get_str_safe(show_log)), _
                            Array(out_desc, "p_intake_atma", "p_out_atma", "t_choke_C", "calibr_fr", "log")) ' на выходе выдаем массив
            res = array_join(arr_out)
            If num_value > 0 Then
                res(1, 1) = res(1, num_value + 1)
                res(2, 1) = res(2, num_value + 1)
            End If
            MF_choke_calibr_fast = res
            
        Else
            MF_choke_calibr_fast = out
        End If
    End If
    
    Exit Function
err1:
    choke.add_log_msg "Error:MF_choke_calibr_fast:" & Err.Description
    arr_out = Array(Array(-1, "", "", "", "", choke.log_.get_str_safe), _
                    Array(out_desc, "p_intake_atma", "p_out_atma", "t_choke_C", "calibr_fr", "log")) ' на выходе выдаем массив
    MF_choke_calibr_fast = array_join(arr_out)
End Function
' инициализация штуцера по исходным данным
' чтобы не повторять код несколько раз для разных функций работы со штуцером
Private Sub set_choke_data( _
                           choke As Cchoke, _
                     ByVal d_choke_mm As Double, _
                     ByVal feed As String, _
            Optional ByVal d_pipe_mm As Double = 70, _
            Optional ByVal calibr As Double = 1, _
            Optional ByVal cd As Double = 0.826)
' d_choke_mm      - диаметр штуцера (эффективный)
' feed            - закодированная строка с параметрами потока.
' p_calc_from_atma - давление с которого начинается расчет, атм
'                  граничное значение для проведения расчета
'                  либо давление на входе, либо на выходе
' t_choke_C       - температура потока, С.
' d_pipe_mm       - диаметр трубы до и после штуцера
' param           - параметры расчета json строка
' результат       - число - массив значений с параметрами штуцера
'                   и давление на штуцере на расчетной стороне.
    'Dim choke As New Cchoke
    
    With choke
        Call .fluid.init_feed(feed)
        .d_down_m = d_pipe_mm / 1000
        .d_up_m = d_pipe_mm / 1000
        .d_choke_m = d_choke_mm / 1000
        .calibr_fr = calibr
        .k = cd
    End With
    
End Sub
'description_to_manual      - для автогенерации
' расчет кривой - характеристики штуцера
' pq - давление дебит
Public Function json_choke_pq_crv( _
                     ByVal d_choke_mm As Double, _
                     ByVal feed As String, _
                     ByVal p_calc_from_atma As Double, _
            Optional ByVal t_choke_C As Double = 20, _
            Optional ByVal d_pipe_mm As Double = 70, _
            Optional ByVal calc_along_flow As Boolean = True, _
            Optional ByVal calibr As Double = 1, _
            Optional ByVal param As String = "", _
            Optional ByVal CDischarge As Double = 0.826, _
        Optional ByVal q_liq_sm3day = -1, _
        Optional ByVal fw_perc = -1, _
        Optional ByVal rp_m3m3 = -1, _
        Optional ByVal q_gas_free_sm3day = -1)
' d_choke_mm      - диаметр штуцера (эффективный)
' feed            - закодированная строка с параметрами потока.
' p_calc_from_atma - давление с которого начинается расчет, атм
'                  граничное значение для проведения расчета
'                  либо давление на входе, либо на выходе
' t_choke_C       - температура потока, С.
' d_pipe_mm       - диаметр трубы до и после штуцера
' calc_along_flow - флаг направления расчета относительно потока
' param           - параметры расчета json строка
' CDischarge      - коэффициент совершенства штуцера
' q_liq_sm3day - дебит жидкости, перекрывает feed если задан,
'                может быть вектором
' fw_perc - обводненность, перекрывает feed если задан,
'                может быть вектором
' rp_m3m3 - газовый фактор, перекрывает feed если задан,
'                может быть вектором
' q_gas_free_sm3day - доп дебит газа, перекрывает feed если задан,
'                может быть вектором
' результат       - число или массив значений с параметрами штуцера
'                   и давление на штуцере на расчетной стороне.
'description_end
'Const nv = 9  ' output array dimension (number of columns)
On Error GoTo err1:
    Dim i As Integer
    Dim num As Integer
    Dim crv_choke As New CInterpolation
    Dim p_i As Double
    Dim q_i As Double
    Dim p_cr As Double
    
    Dim choke As New Cchoke
    
    Dim p_max As Double
    Dim show_log As Boolean
    Dim prmd As Dictionary
    
    Set prmd = param_to_dict(param)
    num = prmd(prm_num_value) - 1
    If num <= 1 Then
        num = 19
    End If
    
    Call set_choke_data(choke, d_choke_mm, feed, d_pipe_mm, calibr, CDischarge)
    Call choke.fluid.update_feed(q_liq_sm3day, fw_perc, rp_m3m3, q_gas_free_sm3day)
    ' расчет штуцера всегда будет как зависимость дебита от давления -
    ' это надо для того, чтобы всегда было однозначное значение итоговой кривой
    
    ' запускаем расчет в зависимости от опции направления расчета
    If calc_along_flow Then
        p_i = 1
        q_i = choke.calc_choke_q_liq_sm3day(p_calc_from_atma, p_i, t_choke_C)
        crv_choke.AddPoint p_i, q_i
       
        p_cr = choke.p_ratio_crit * p_calc_from_atma
        For i = 0 To num - 1
            p_i = p_cr + (p_calc_from_atma - p_cr) / (num - 1) * i
            q_i = choke.calc_choke_q_liq_sm3day(p_calc_from_atma, p_i, t_choke_C)
            crv_choke.AddPoint p_i, q_i
            
        Next i
        crv_choke.xName = "p_out_atma"
        crv_choke.yName = "q_liq_sm3day"
    Else
        p_max = p_calc_from_atma * 2
        For i = 0 To num
            p_i = p_calc_from_atma + (p_max - p_calc_from_atma) / num * i  '+ 0.06 * Exp(i * 0.25) * i
            If p_i > p_max Or i = num Then p_i = p_max
            q_i = choke.calc_choke_q_liq_sm3day(p_i, p_calc_from_atma, t_choke_C)
            crv_choke.AddPoint p_i, q_i
            
        Next i
        crv_choke.xName = "p_in_atma"
        crv_choke.yName = "q_liq_sm3day"
    End If
    json_choke_pq_crv = ConvertToJson(crv_choke.getDict)
    Exit Function
err1:
    json_choke_pq_crv = "error:MF_choke_pq_crv:" & Err.Description
End Function
'description_to_manual      - для автогенерации
' Функция кодирования параметров PVT в строку,
' для передачи PVT свойств в прикладные функции Унифлок.
Public Function encode_PVT( _
                    Optional ByVal gamma_gas As Double = const_gg_, _
                    Optional ByVal gamma_oil As Double = const_go_, _
                    Optional ByVal gamma_wat As Double = const_gw_, _
                    Optional ByVal rsb_m3m3 = const_rsb_default, _
                    Optional ByVal pb_atma = 0, _
                    Optional ByVal t_res_C = 80, _
                    Optional ByVal bob_m3m3 = 0, _
                    Optional ByVal muob_cP = 0, _
                    Optional ByVal PVT_corr_set = 0 _
                    )
' gamma_gas - удельная плотность газа, по воздуху.
'             По умолчанию const_gg_ = 0.6
' gamma_oil - удельная плотность нефти, по воде.
'             По умолчанию const_go_ = 0.86
' gamma_wat - удельная плотность воды, по воде.
'             По умолчанию const_gw_ = 1
' rsb_m3m3  - газосодержание при давлении насыщения, м3/м3.
'             По умолчанию const_rsb_default = 100
' pb_atma - давление насыщения при заданной температуре, атма.
'           Опциональный калибровочный параметр,
'           если не задан или = 0, то рассчитается по корреляции.
' t_res_C  - пластовая температура, С.
'           Учитывается при расчете давления насыщения.
'           По умолчанию  const_tres_default = 90
' bob_m3m3 - объемный коэффициент нефти при давлении насыщения
'            и пластовой температуре, м3/м3.
'            По умолчанию рассчитывается по корреляции.
' muob_cP  - вязкость нефти при давлении насыщения.
'            и пластовой температуре, сП.
'            По умолчанию рассчитывается по корреляции.
' PVT_corr_set - номер набора PVT корреляций для расчета:
'           0 - на основе корреляции Стендинга;
'           1 - на основе кор-ии Маккейна;
'           2 - на основе упрощенных зависимостей.
' результат - закодированная строка
'description_end
    
    Dim str As String
    Dim frmt As String
    Dim frmt_int As String
    
    Dim pvt_dict As New Dictionary
    
    pvt_dict.Add "gamma_gas", Round(gamma_gas, const_num_decimal_out)
    pvt_dict.Add "gamma_oil", Round(gamma_oil, const_num_decimal_out)
    pvt_dict.Add "gamma_wat", Round(gamma_wat, const_num_decimal_out)
    pvt_dict.Add "rsb_m3m3", Round(rsb_m3m3, const_num_decimal_out)
    
    If pb_atma > 0 Then
        pvt_dict.Add "pb_atma", Round(pb_atma, const_num_decimal_out)
        pvt_dict.Add "t_res_C", Round(t_res_C, const_num_decimal_out)
    End If
    If bob_m3m3 > 0 Then pvt_dict.Add "bob_m3m3", Round(bob_m3m3, const_num_decimal_out)
    If muob_cP > 0 Then pvt_dict.Add "muob_cP", Round(muob_cP, const_num_decimal_out)
    If PVT_corr_set >= 0 And PVT_corr_set <= 2 Then
        pvt_dict.Add "PVT_corr_set", PVT_corr_set
    End If
    encode_PVT = ConvertToJson(pvt_dict)
End Function
'description_to_manual      - для автогенерации
' calculate all PVT properties of oil at a given
' pressure and temperature
Public Function PVT_calc( _
            ByVal p_atma As Double, _
            ByVal t_C As Double, _
            ByVal PVT_prop As String, _
   Optional ByVal show_log As Boolean = False) As String
' p_atma - pressure, atm
' t_C - temperature, C.
' PVT_prop - static fluid properties - densities rsb, etc.
' use encode_PVT to generate
'
' Returns values of all PVT properties in json string
' for the given thermobaric conditions.
'description_end
    Const nv = 1
On Error GoTo err1:
    Dim resd As New Dictionary
    ' auxiliary variables
    Dim i As Integer
    Dim fluid As New CPVT
    
    
    Call fluid.init_feed(PVT_prop)
    Call fluid.calc_PVT(p_atma, t_C)
    
On Error Resume Next
' trying to pack all params in dictionary
    With fluid
        resd.Add "rs_m3m3", Round(.rs_m3m3, 3)
        resd.Add "pb_atma", Round(.pb_calc_atma, 3)
        resd.Add "bo_m3m3", Round(.bo_m3m3, 3)
        resd.Add "bg_m3m3", Round(.bg_m3m3, 3)
        resd.Add "bw_m3m3", Round(.bw_m3m3, 3)
        resd.Add "mu_oil_cP", Round(.mu_oil_cP, 3)
        resd.Add "mu_gas_cP", Round(.mu_gas_cP, 3)
        resd.Add "mu_wat_cP", Round(.mu_wat_cP, 3)
        resd.Add "rho_oil_rc_kgm3", Round(.rho_oil_rc_kgm3, 3)
        resd.Add "rho_gas_rc_kgm3", Round(.rho_gas_rc_kgm3, 3)
        resd.Add "rho_wat_rc_kgm3", Round(.rho_wat_rc_kgm3, 3)
        resd.Add "compressibility_oil_1atm", Round(.compressibility_oil_1atm, 6)
        resd.Add "compressibility_gas_1atm", Round(.compressibility_gas_1atm, 6)
        resd.Add "compressibility_wat_1atm", Round(.compressibility_wat_1atm, 6)
        resd.Add "sigma_liq_Nm", Round(.sigma_liq_Nm, 3)
        resd.Add "sigma_oil_gas_Nm", Round(.sigma_oil_gas_Nm, 3)
        resd.Add "sigma_wat_gas_Nm", Round(.sigma_wat_gas_Nm, 3)
        resd.Add "cp_oil_JkgC", Round(.cp_oil_JkgC, 3)
        resd.Add "cp_gas_JkgC", Round(.cp_gas_JkgC, 3)
        resd.Add "cv_gas_JkgC", Round(.cv_gas_JkgC, 3)
        resd.Add "cp_wat_JkgC", Round(.cp_wat_JkgC, 3)
        resd.Add "z", Round(.z, 3)
        resd.Add "sal_ppm", Round(.sal_ppm, 3)
        If show_log Then resd.Add "log", .log_.get_str_safe
    End With
    
On Error GoTo err1:
    PVT_calc = ConvertToJson(resd)
    Exit Function
err1:
    PVT_calc = "{""error"": "" " & Err.Description & " ""}"
    Call fluid.add_log_msg("{error: " & Chr(34) & Err.Description & Chr(34) & "}")
End Function
'description_to_manual      - для автогенерации
' расчет объемного коэффициента газа
Public Function PVT_bg_m3m3( _
            ByVal p_atma As Double, _
            ByVal t_C As Double, _
   Optional ByVal PVT_prop As String = "")
                    
' p_atma  - давление, атм
' t_C     - температура, С.
' PVT_prop - строка с параметрами флюида,
'           используйте encode_pvt для ее генерации,
'           если задана перекрывает остальные параметры
'description_end
On Error GoTo er1:
    Dim fluid As New CPVT
    Call fluid.init_feed(PVT_prop)
    Call fluid.calc_PVT(p_atma, t_C)
    PVT_bg_m3m3 = fluid.bg_m3m3
    Exit Function
er1:
On Error GoTo er2:
    PVT_bg_m3m3 = Array("error " & Err.Description, fluid.log_.get_str)
    Exit Function
er2:
    PVT_bg_m3m3 = "error " & Err.Description
End Function
'description_to_manual      - для автогенерации
' расчет объемного коэффициента нефти
Public Function PVT_bo_m3m3( _
            ByVal p_atma As Double, _
            ByVal t_C As Double, _
   Optional ByVal PVT_prop As String = "")
                    
' p_atma  - давление, атм
' t_C     - температура, С.
' PVT_prop - строка с параметрами флюида,
'           используйте encode_pvt для ее генерации,
'           если задана перекрывает остальные параметры
'description_end
On Error GoTo er1:
    Dim fluid As New CPVT
    Call fluid.init_feed(PVT_prop)
    Call fluid.calc_PVT(p_atma, t_C)
    PVT_bo_m3m3 = fluid.bo_m3m3
    Exit Function
er1:
On Error GoTo er2:
    PVT_bo_m3m3 = Array("error " & Err.Description, fluid.log_.get_str)
    Exit Function
er2:
    PVT_bo_m3m3 = "error " & Err.Description
End Function
'description_to_manual      - для автогенерации
' расчет объемного коэффициента воды
Public Function PVT_bw_m3m3( _
            ByVal p_atma As Double, _
            ByVal t_C As Double, _
   Optional ByVal PVT_prop As String = "")
                    
' p_atma  - давление, атм
' t_C     - температура, С.
' PVT_prop - строка с параметрами флюида,
'           используйте encode_pvt для ее генерации,
'           если задана перекрывает остальные параметры
'description_end
On Error GoTo er1:
    Dim fluid As New CPVT
    Call fluid.init_feed(PVT_prop)
    Call fluid.calc_PVT(p_atma, t_C)
    PVT_bw_m3m3 = fluid.bw_m3m3
    
    Exit Function
er1:
On Error GoTo er2:
    PVT_bw_m3m3 = Array("error " & Err.Description, fluid.log_.get_str)
    Exit Function
er2:
    PVT_bw_m3m3 = "error " & Err.Description
End Function
'description_to_manual      - для автогенерации
' расчет солености воды
Public Function PVT_salinity_ppm( _
            ByVal p_atma As Double, _
            ByVal t_C As Double, _
   Optional ByVal PVT_prop As String = "")
                    
' p_atma  - давление, атм
' t_C     - температура, С.
' PVT_prop - строка с параметрами флюида,
'           используйте encode_pvt для ее генерации,
'           если задана перекрывает остальные параметры
'description_end
On Error GoTo er1:
    Dim fluid As New CPVT
    Call fluid.init_feed(PVT_prop)
    Call fluid.calc_PVT(p_atma, t_C)
    PVT_salinity_ppm = fluid.sal_ppm
    
    Exit Function
er1:
On Error GoTo er2:
    PVT_salinity_ppm = Array("error " & Err.Description, fluid.log_.get_str)
    Exit Function
er2:
    PVT_salinity_ppm = "error " & Err.Description
End Function
'description_to_manual      - для автогенерации
' расчет вязкости нефти
Public Function PVT_mu_oil_cP( _
            ByVal p_atma As Double, _
            ByVal t_C As Double, _
   Optional ByVal PVT_prop As String = "")
                    
' p_atma  - давление, атм
' t_C     - температура, С.
' PVT_prop - строка с параметрами флюида,
'           используйте encode_pvt для ее генерации,
'           если задана перекрывает остальные параметры
'description_end
On Error GoTo er1:
    Dim fluid As New CPVT
    Call fluid.init_feed(PVT_prop)
    Call fluid.calc_PVT(p_atma, t_C)
    PVT_mu_oil_cP = fluid.mu_oil_cP
    
    Exit Function
er1:
On Error GoTo er2:
    PVT_mu_oil_cP = Array("error " & Err.Description, fluid.log_.get_str)
    Exit Function
er2:
    PVT_mu_oil_cP = "error " & Err.Description
    
End Function
'description_to_manual      - для автогенерации
' расчет вязкости газа
Public Function PVT_mu_gas_cP( _
            ByVal p_atma As Double, _
            ByVal t_C As Double, _
   Optional ByVal PVT_prop As String = "")
                    
' p_atma  - давление, атм
' t_C     - температура, С.
' PVT_prop - строка с параметрами флюида,
'           используйте encode_pvt для ее генерации,
'           если задана перекрывает остальные параметры
'description_end
On Error GoTo er1:
    Dim fluid As New CPVT
    Call fluid.init_feed(PVT_prop)
    Call fluid.calc_PVT(p_atma, t_C)
    PVT_mu_gas_cP = fluid.mu_gas_cP
    
    Exit Function
er1:
On Error GoTo er2:
    PVT_mu_gas_cP = Array("error " & Err.Description, fluid.log_.get_str)
    Exit Function
er2:
    PVT_mu_gas_cP = "error " & Err.Description
    
End Function
'description_to_manual      - для автогенерации
' расчет вязкости воды
Public Function PVT_mu_wat_cP( _
            ByVal p_atma As Double, _
            ByVal t_C As Double, _
   Optional ByVal PVT_prop As String = "")
                    
' p_atma  - давление, атм
' t_C     - температура, С.
' PVT_prop - строка с параметрами флюида,
'           используйте encode_pvt для ее генерации,
'           если задана перекрывает остальные параметры
'description_end
On Error GoTo er1:
    Dim fluid As New CPVT
    Call fluid.init_feed(PVT_prop)
    Call fluid.calc_PVT(p_atma, t_C)
    PVT_mu_wat_cP = fluid.mu_wat_cP
    
    Exit Function
er1:
On Error GoTo er2:
    PVT_mu_wat_cP = Array("error " & Err.Description, fluid.log_.get_str)
    Exit Function
er2:
    PVT_mu_wat_cP = "error " & Err.Description
    
End Function
'description_to_manual      - для автогенерации
' расчет газосодержания при заданных p,t
Public Function PVT_rs_m3m3( _
            ByVal p_atma As Double, _
            ByVal t_C As Double, _
   Optional ByVal PVT_prop As String = "")
                    
' p_atma  - давление, атм
' t_C     - температура, С.
' PVT_prop - строка с параметрами флюида,
'           используйте encode_pvt для ее генерации,
'           если задана перекрывает остальные параметры
'description_end
On Error GoTo er1:
    Dim fluid As New CPVT
    Call fluid.init_feed(PVT_prop)
    Call fluid.calc_PVT(p_atma, t_C)
    PVT_rs_m3m3 = fluid.rs_m3m3
    
    Exit Function
er1:
On Error GoTo er2:
    PVT_rs_m3m3 = Array("error " & Err.Description, fluid.log_.get_str)
    Exit Function
er2:
    PVT_rs_m3m3 = "error " & Err.Description
    
End Function
'description_to_manual      - для автогенерации
' расчет коэффициента сверхсжимаемости газа
Public Function PVT_z( _
            ByVal p_atma As Double, _
            ByVal t_C As Double, _
   Optional ByVal PVT_prop As String = "")
                    
' p_atma  - давление, атм
' t_C     - температура, С.
' PVT_prop - строка с параметрами флюида,
'           используйте encode_pvt для ее генерации,
'           если задана перекрывает остальные параметры
'description_end
On Error GoTo er1:
    Dim fluid As New CPVT
    Call fluid.init_feed(PVT_prop)
    Call fluid.calc_PVT(p_atma, t_C)
    PVT_z = fluid.z
    
    Exit Function
er1:
On Error GoTo er2:
    PVT_z = Array("error " & Err.Description, fluid.log_.get_str)
    Exit Function
er2:
    PVT_z = "error " & Err.Description
    
End Function
'description_to_manual      - для автогенерации
' расчет плотности нефти в рабочих условиях
Public Function PVT_rho_oil_kgm3( _
            ByVal p_atma As Double, _
            ByVal t_C As Double, _
   Optional ByVal PVT_prop As String = "")
                    
' p_atma  - давление, атм
' t_C     - температура, С.
' PVT_prop - строка с параметрами флюида,
'           используйте encode_pvt для ее генерации,
'           если задана перекрывает остальные параметры
'description_end
On Error GoTo er1:
    Dim fluid As New CPVT
    Call fluid.init_feed(PVT_prop)
    Call fluid.calc_PVT(p_atma, t_C)
    PVT_rho_oil_kgm3 = fluid.rho_oil_rc_kgm3
    
    Exit Function
er1:
On Error GoTo er2:
    PVT_rho_oil_kgm3 = Array("error " & Err.Description, fluid.log_.get_str)
    Exit Function
er2:
    PVT_rho_oil_kgm3 = "error " & Err.Description
    
End Function
'description_to_manual      - для автогенерации
' расчет плотности газа в рабочих условиях
Public Function PVT_rho_gas_kgm3( _
            ByVal p_atma As Double, _
            ByVal t_C As Double, _
   Optional ByVal PVT_prop As String = "")
                    
' p_atma  - давление, атм
' t_C     - температура, С.
' PVT_prop - строка с параметрами флюида,
'           используйте encode_pvt для ее генерации,
'           если задана перекрывает остальные параметры
'description_end
On Error GoTo er1:
    Dim fluid As New CPVT
    Call fluid.init_feed(PVT_prop)
    Call fluid.calc_PVT(p_atma, t_C)
    PVT_rho_gas_kgm3 = fluid.rho_gas_rc_kgm3
    Exit Function
er1:
On Error GoTo er2:
    PVT_rho_gas_kgm3 = Array("error " & Err.Description, fluid.log_.get_str)
    Exit Function
er2:
    PVT_rho_gas_kgm3 = "error " & Err.Description
End Function
'description_to_manual      - для автогенерации
' расчет плотности воды в рабочих условиях
Public Function PVT_rho_wat_kgm3( _
            ByVal p_atma As Double, _
            ByVal t_C As Double, _
   Optional ByVal PVT_prop As String = "")
                    
' p_atma  - давление, атм
' t_C     - температура, С.
' PVT_prop - строка с параметрами флюида,
'           используйте encode_pvt для ее генерации,
'           если задана перекрывает остальные параметры
'description_end
On Error GoTo er1:
    Dim fluid As New CPVT
    Call fluid.init_feed(PVT_prop)
    Call fluid.calc_PVT(p_atma, t_C)
    PVT_rho_wat_kgm3 = fluid.rho_wat_rc_kgm3
    
    Exit Function
er1:
On Error GoTo er2:
    PVT_rho_wat_kgm3 = Array("error " & Err.Description, fluid.log_.get_str)
    Exit Function
er2:
    PVT_rho_wat_kgm3 = "error " & Err.Description
    
End Function
'description_to_manual      - для автогенерации
' Расчет давления насыщения по известному
' газосодержанию при давлении насыщения
Public Function PVT_pb_atma( _
            ByVal t_C As Double, _
   Optional ByVal PVT_prop As String = "")
' t_C     - температура, С.
' PVT_prop - строка с параметрами флюида,
'           используйте encode_pvt для ее генерации,
'           если задана перекрывает остальные параметры
' результат - число - давление насыщения.
'description_end
On Error GoTo er1:
    Dim fluid As New CPVT
    Call fluid.init_feed(PVT_prop)
    
    Call fluid.calc_PVT(1, t_C)
    PVT_pb_atma = fluid.pb_calc_atma
    
    Exit Function
er1:
On Error GoTo er2:
    PVT_pb_atma = Array("error " & Err.Description, fluid.log_.get_str)
    Exit Function
er2:
    PVT_pb_atma = "error " & Err.Description
    
End Function
'description_to_manual      - для автогенерации
' Расчет газосодержания при давлении насыщения
' по известному давлению насыщения
Public Function PVT_rsb_m3m3( _
            ByVal pb_atma As Double, _
            ByVal t_C As Double, _
   Optional ByVal PVT_prop As String = "")
                    
' pb_atma  - давление насыщения, атм
' t_C     - температура, С.
' PVT_prop - строка с параметрами флюида,
'           используйте encode_pvt для ее генерации,
'           если задана перекрывает остальные параметры
'description_end
On Error GoTo er1:
    Dim fluid As New CPVT
    Call fluid.init_feed(PVT_prop)
    
    fluid.set_rp_rsb 500, 500
    fluid.pb_atma = -1
    Call fluid.calc_PVT(pb_atma, t_C)
    PVT_rsb_m3m3 = fluid.rs_m3m3
    
    Exit Function
er1:
On Error GoTo er2:
    PVT_rsb_m3m3 = Array("error " & Err.Description, fluid.log_.get_str)
    Exit Function
er2:
    PVT_rsb_m3m3 = "error " & Err.Description
    
End Function
'description_to_manual      - для автогенерации
' расчет коэффициента поверхностного натяжения нефть - газ
Public Function PVT_ST_oilgas_Nm( _
            ByVal p_atma As Double, _
            ByVal t_C As Double, _
   Optional ByVal PVT_prop As String = "")
                    
' p_atma  - давление, атм
' t_C     - температура, С.
' PVT_prop - строка с параметрами флюида,
'           используйте encode_pvt для ее генерации,
'           если задана перекрывает остальные параметры
'description_end
On Error GoTo er1:
    Dim fluid As New CPVT
    Call fluid.init_feed(PVT_prop)
    Call fluid.calc_PVT(p_atma, t_C)
    PVT_ST_oilgas_Nm = fluid.sigma_oil_gas_Nm
    
    Exit Function
er1:
On Error GoTo er2:
    PVT_ST_oilgas_Nm = Array("error " & Err.Description, fluid.log_.get_str)
    Exit Function
er2:
    PVT_ST_oilgas_Nm = "error " & Err.Description
    
End Function
'description_to_manual      - для автогенерации
' расчет коэффициента поверхностного натяжения вода - газ
Public Function PVT_ST_watgas_Nm( _
            ByVal p_atma As Double, _
            ByVal t_C As Double, _
   Optional ByVal PVT_prop As String = "")
                    
' p_atma  - давление, атм
' t_C     - температура, С.
' PVT_prop - строка с параметрами флюида,
'           используйте encode_pvt для ее генерации,
'           если задана перекрывает остальные параметры
'description_end
On Error GoTo er1:
    Dim fluid As New CPVT
    Call fluid.init_feed(PVT_prop)
    Call fluid.calc_PVT(p_atma, t_C)
    PVT_ST_watgas_Nm = fluid.sigma_wat_gas_Nm
    
    Exit Function
er1:
On Error GoTo er2:
    PVT_ST_watgas_Nm = Array("error " & Err.Description, fluid.log_.get_str)
    Exit Function
er2:
    PVT_ST_watgas_Nm = "error " & Err.Description
    
End Function
'description_to_manual      - для автогенерации
' расчет коэффициента поверхностного натяжения жидкость - газ
Public Function feed_ST_liqgas_Nm( _
            ByVal p_atma As Double, _
            ByVal t_C As Double, _
            ByVal feed As String)
                    
' p_atma  - давление, атм
' t_C     - температура, С.
' feed - строка с параметрами флюида,
'           используйте encode_pvt для ее генерации,
'           если задана перекрывает остальные параметры
'description_end
On Error GoTo er1:
    Dim fluid As New CPVT
    Call fluid.init_feed(feed)
    Call fluid.calc_PVT(p_atma, t_C)
    feed_ST_liqgas_Nm = fluid.sigma_liq_Nm
    
    Exit Function
er1:
On Error GoTo er2:
    feed_ST_liqgas_Nm = Array("error " & Err.Description, fluid.log_.get_str)
    Exit Function
er2:
    feed_ST_liqgas_Nm = "error " & Err.Description
    
End Function
'description_to_manual      - для автогенерации
' расчет теплоемкости нефти при постоянном давлении cp
Public Function PVT_cp_oil_JkgC( _
            ByVal p_atma As Double, _
            ByVal t_C As Double, _
   Optional ByVal PVT_prop As String = "")
                    
' p_atma  - давление, атм
' t_C     - температура, С.
' PVT_prop - строка с параметрами флюида,
'           используйте encode_pvt для ее генерации,
'           если задана перекрывает остальные параметры
'description_end
On Error GoTo er1:
    Dim fluid As New CPVT
    Call fluid.init_feed(PVT_prop)
    Call fluid.calc_PVT(p_atma, t_C)
    PVT_cp_oil_JkgC = fluid.cp_oil_JkgC
    
    Exit Function
er1:
On Error GoTo er2:
    PVT_cp_oil_JkgC = Array("error " & Err.Description, fluid.log_.get_str)
    Exit Function
er2:
    PVT_cp_oil_JkgC = "error " & Err.Description
    
End Function
'description_to_manual      - для автогенерации
' расчет теплоемкости газа при постоянном давлении cp
Public Function PVT_cp_gas_JkgC( _
            ByVal p_atma As Double, _
            ByVal t_C As Double, _
   Optional ByVal PVT_prop As String = "", _
   Optional ByVal gamma_gas As Double = const_gg_, _
   Optional ByVal gamma_oil As Double = const_go_, _
   Optional ByVal gamma_wat As Double = const_gw_, _
   Optional ByVal rsb_m3m3 = const_rsb_default, _
   Optional ByVal pb_atma = 0, _
   Optional ByVal t_res_C = 80, _
   Optional ByVal bob_m3m3 = 0, _
   Optional ByVal muob_cP = 0, _
   Optional ByVal PVT_corr_set = 0)
                    
' p_atma  - давление, атм
' t_C     - температура, С.
' PVT_prop - строка с параметрами флюида,
'           используйте encode_pvt для ее генерации,
'           если задана перекрывает остальные параметры
' gamma_gas - удельная плотность газа, по воздуху.
'             По умолчанию const_gg_ = 0.6
' gamma_oil - удельная плотность нефти, по воде.
'             По умолчанию const_go_ = 0.86
' gamma_wat - удельная плотность воды, по воде.
'             По умолчанию const_gw_ = 1
' rsb_m3m3  - газосодержание при давлении насыщения, м3/м3.
'             По умолчанию const_rsb_default = 100
' pb_atma - давление насыщения при заданной температуре, атма.
'           Опциональный калибровочный параметр,
'           если не задан или = 0, то рассчитается по корреляции.
' t_res_C  - пластовая температура, С.
'           Учитывается при расчете давления насыщения.
'           По умолчанию  const_tres_default = 90
' bob_m3m3 - объемный коэффициент нефти при давлении насыщения
'            и пластовой температуре, м3/м3.
'            По умолчанию рассчитывается по корреляции.
' muob_cP  - вязкость нефти при давлении насыщения.
'            и пластовой температуре, сП.
'            По умолчанию рассчитывается по корреляции.
' PVT_corr_set - номер набора PVT корреляций для расчета:
'           0 - на основе корреляции Стендинга;
'           1 - на основе кор-ии Маккейна;
'           2 - на основе упрощенных зависимостей.
'description_end
On Error GoTo er1:
    Dim fluid As New CPVT
    If Len(PVT_prop) > 2 Then
        Call fluid.init_feed(PVT_prop)
    Else
        Call fluid.init(gamma_gas, gamma_oil, gamma_wat, rsb_m3m3, pb_atma, bob_m3m3, PVT_corr_set, t_res_C, muob_cP)
    End If
    Call fluid.calc_PVT(p_atma, t_C)
    PVT_cp_gas_JkgC = fluid.cp_gas_JkgC
    
    Exit Function
er1:
On Error GoTo er2:
    PVT_cp_gas_JkgC = Array("error " & Err.Description, fluid.log_.get_str)
    Exit Function
er2:
    PVT_cp_gas_JkgC = "error " & Err.Description
    
End Function
'description_to_manual      - для автогенерации
' расчет теплоемкости газа при постоянном объеме cv
Public Function PVT_cv_gas_JkgC( _
            ByVal p_atma As Double, _
            ByVal t_C As Double, _
   Optional ByVal PVT_prop As String = "")
                    
' p_atma  - давление, атм
' t_C     - температура, С.
' PVT_prop - строка с параметрами флюида,
'           используйте encode_pvt для ее генерации,
'           если задана перекрывает остальные параметры
'description_end
On Error GoTo er1:
    Dim fluid As New CPVT
    Call fluid.init_feed(PVT_prop)
    Call fluid.calc_PVT(p_atma, t_C)
    PVT_cv_gas_JkgC = fluid.cv_gas_JkgC
    
    Exit Function
er1:
On Error GoTo er2:
    PVT_cv_gas_JkgC = Array("error " & Err.Description, fluid.log_.get_str)
    Exit Function
er2:
    PVT_cv_gas_JkgC = "error " & Err.Description
    
End Function
'description_to_manual      - для автогенерации
' расчет теплоемкости воды при постоянном давлении cp
Public Function PVT_cp_wat_JkgC( _
            ByVal p_atma As Double, _
            ByVal t_C As Double, _
   Optional ByVal PVT_prop As String = "")
                    
' p_atma  - давление, атм
' t_C     - температура, С.
' PVT_prop - строка с параметрами флюида,
'           используйте encode_pvt для ее генерации,
'           если задана перекрывает остальные параметры
'description_end
On Error GoTo er1:
    Dim fluid As New CPVT
    Call fluid.init_feed(PVT_prop)
    Call fluid.calc_PVT(p_atma, t_C)
    PVT_cp_wat_JkgC = fluid.cp_wat_JkgC
    
    Exit Function
er1:
On Error GoTo er2:
    PVT_cp_wat_JkgC = Array("error " & Err.Description, fluid.log_.get_str)
    Exit Function
er2:
    PVT_cp_wat_JkgC = "error " & Err.Description
    
End Function
'description_to_manual      - для автогенерации
' расчет сжимаемости воды
Public Function PVT_compressibility_wat_1atm( _
            ByVal p_atma As Double, _
            ByVal t_C As Double, _
   Optional ByVal PVT_prop As String = "")
                    
' p_atma  - давление, атм
' t_C     - температура, С.
' PVT_prop - строка с параметрами флюида,
'           используйте encode_pvt для ее генерации,
'           если задана перекрывает остальные параметры
'description_end
On Error GoTo er1:
    Dim fluid As New CPVT
    Call fluid.init_feed(PVT_prop)
    Call fluid.calc_PVT(p_atma, t_C)
    PVT_compressibility_wat_1atm = fluid.compressibility_wat_1atm
    
    Exit Function
er1:
On Error GoTo er2:
    PVT_compressibility_wat_1atm = Array("error " & Err.Description, fluid.log_.get_str)
    Exit Function
er2:
    PVT_compressibility_wat_1atm = "error " & Err.Description
    
End Function
'description_to_manual      - для автогенерации
' расчет сжимаемости нефти
Public Function PVT_compressibility_oil_1atm( _
            ByVal p_atma As Double, _
            ByVal t_C As Double, _
   Optional ByVal PVT_prop As String = "")
                    
' p_atma  - давление, атм
' t_C     - температура, С.
' PVT_prop - строка с параметрами флюида,
'           используйте encode_pvt для ее генерации,
'           если задана перекрывает остальные параметры
'description_end
On Error GoTo er1:
    Dim fluid As New CPVT
    Call fluid.init_feed(PVT_prop)
    Call fluid.calc_PVT(p_atma, t_C)
    PVT_compressibility_oil_1atm = fluid.compressibility_oil_1atm
    
    Exit Function
er1:
On Error GoTo er2:
    PVT_compressibility_oil_1atm = Array("error " & Err.Description, fluid.log_.get_str)
    Exit Function
er2:
    PVT_compressibility_oil_1atm = "error " & Err.Description
    
End Function
'description_to_manual      - для автогенерации
' расчет сжимаемости газа
Public Function PVT_compressibility_gas_1atm( _
            ByVal p_atma As Double, _
            ByVal t_C As Double, _
   Optional ByVal PVT_prop As String = "")
                    
' p_atma  - давление, атм
' t_C     - температура, С.
' PVT_prop - строка с параметрами флюида,
'           используйте encode_pvt для ее генерации,
'           если задана перекрывает остальные параметры
'description_end
On Error GoTo er1:
    Dim fluid As New CPVT
    Call fluid.init_feed(PVT_prop)
    Call fluid.calc_PVT(p_atma, t_C)
    PVT_compressibility_gas_1atm = fluid.compressibility_gas_1atm
    
    Exit Function
er1:
On Error GoTo er2:
    PVT_compressibility_gas_1atm = Array("error " & Err.Description, fluid.log_.get_str)
    Exit Function
er2:
    PVT_compressibility_gas_1atm = "error " & Err.Description
    
End Function
'description_to_manual      - для автогенерации
'Функция кодирования параметров потока флюидов в строку,
Public Function encode_feed( _
          Optional ByVal q_liq_sm3day As Double = 10, _
          Optional ByVal fw_perc As Double = -1, _
          Optional ByVal rp_m3m3 As Double = -1, _
          Optional ByVal q_gas_free_sm3day As Double = -1, _
          Optional ByVal fluid As String = PVT_DEFAULT)
' q_liq_sm3day  - дебит жидкости в ст.условиях.
' fw_perc       - ободненность, %
' rp_m3m3       - газовый фактор, м3/м3:
' q_gas_free_sm3day - расход свободного газа, ст. м3/сут
' fluid         -  закодированная PVT строка
'                  с параметрами флюида
' результат - закодированная строка
'description_end
    
    Dim str As String
    Dim frmt As String
    Dim frmt_int As String
    
    Dim dict As Dictionary
    Set dict = ParseJson(fluid)
    
    dict("q_liq_sm3day") = Round(q_liq_sm3day, const_num_decimal_out)
    If fw_perc >= 0 Then dict("fw_perc") = Round(fw_perc, const_num_decimal_out)
    If rp_m3m3 > 0 Then dict("rp_m3m3") = Round(rp_m3m3, const_num_decimal_out)
    If q_gas_free_sm3day > 0 Then dict("q_gas_free_sm3day") = Round(q_gas_free_sm3day, const_num_decimal_out)
    
    encode_feed = ConvertToJson(dict)
End Function
'description_to_manual      - для автогенерации
' расчет всех параметров потока с выводом в json
Public Function feed_calc( _
               ByVal p_atma As Double, _
               ByVal t_C As Double, _
               ByVal feed As String, _
      Optional ByVal show_log As Boolean = False)
' p_atma     - давление, атм
' t_C        - температура, С.
' feed - параметры потока флюидов, дебит, обводненность и пр
'              используйте encode_feed для генерации
' show_log   - показывать ли лог
' результат  - массив всех расчетных значений,
'              с подписями во второй строке
'description_end
    Const nv = 1
On Error GoTo err1:
    Dim fluid_stream As New CPVT
    Dim resd As New Dictionary
    Dim i As Integer
    
    With fluid_stream
        Call .init_feed(feed)
        
        On Error GoTo err1:
            Call .calc_PVT(p_atma, t_C)
        On Error Resume Next
        
            ' prepare output
            resd.Add "q_mix_rc_m3day", .q_mix_rc_m3day
            resd.Add "q_oil_rc_m3day", .q_oil_rc_m3day
            resd.Add "q_wat_rc_m3day", .q_wat_rc_m3day
            resd.Add "q_gas_rc_m3day", .q_gas_rc_m3day
            resd.Add "gas_fraction_d", .gas_fraction_d
            resd.Add "rho_mix_rc_kgm3", .rho_mix_rc_kgm3
            resd.Add "mu_mix_cP", .mu_mix_cP
            resd.Add "mo_kgsec", .mo_kgsec
            resd.Add "mw_kgsec", .mw_kgsec
            resd.Add "mg_kgsec", .mg_kgsec
            resd.Add "mg_kgmol", .mg_kgmol
            resd.Add "cmix_JkgC", .cmix_JkgC
            resd.Add "cJT_Katm", .cJT_Katm
            resd.Add "log", .log_.get_str_safe(show_log)
                        
err1done:
            feed_calc = ConvertToJson(resd)
            Exit Function
err1:
            Call fluid_stream.add_log_msg("error: " & Err.Description)
            Resume err1done:
err2:
            Call fluid_stream.add_log_msg("warning: some error while param read detected " & Err.Description)
            Resume Next:
        End With
End Function
'description_to_manual      - для автогенерации
' расчета доли газа в потоке (объемная, расходная доля газа)
Public Function feed_gas_fraction_d( _
               ByVal p_atma As Double, _
               ByVal t_C As Double, _
               ByVal feed As String, _
      Optional ByVal ksep_add_fr As Double = 0)
' p_atma     - давление, атм
' t_C        - температура, С.
' feed - параметры потока флюидов, дебит, обводненность и пр
'              используйте encode_feed для генерации
' ksep_add_fr - коэффициент сепарации газа из потока
' результат  - значение доли газа в потоке (расходна доля)
'description_end
 On Error GoTo er1:
    Dim pvt As New CPVT
    Call pvt.init_feed(feed)
    Call pvt.calc_PVT(p_atma, t_C)
    feed_gas_fraction_d = pvt.gas_fraction_d(ksep_add_fr)
    Exit Function
er1:
On Error GoTo er2:
    feed_gas_fraction_d = Array("error " & Err.Description, pvt.log_.get_str)
    Exit Function
er2:
    feed_gas_fraction_d = "error " & Err.Description
End Function
'description_to_manual      - для автогенерации
' расчет давления при котором
' достигается заданная доля газа в потоке
Public Function feed_p_gas_fraction_atma( _
               ByVal free_gas_d As Double, _
               ByVal t_C As Double, _
               ByVal feed As String, _
      Optional ByVal ksep_add_fr As Double = 0)
' free_gas_d - допустимая доля газа в потоке;
' t_C        - температура, С.
' feed - параметры потока флюидов, дебит, обводненность и пр
'              используйте encode_feed для генерации
' ksep_add_fr - коэффициент сепарации газа из потока
' результат  - число - давление
'description_end
On Error GoTo er1:
    Dim pvt As New CPVT
    Call pvt.init_feed(feed)
    feed_p_gas_fraction_atma = pvt.p_gas_fraction_atma(free_gas_d, t_C, ksep_add_fr)
    Exit Function
er1:
On Error GoTo er2:
    feed_p_gas_fraction_atma = Array("error " & Err.Description, pvt.log_.get_str)
    Exit Function
er2:
    feed_p_gas_fraction_atma = "error " & Err.Description
End Function
'description_to_manual      - для автогенерации
' расчет газового фактора
' при котором достигается заданная доля газа в потоке
Public Function feed_rp_gas_fraction_m3m3( _
               ByVal free_gas_d As Double, _
               ByVal p_atma As Double, _
               ByVal t_C As Double, _
               ByVal feed As String, _
      Optional ByVal ksep_add_fr As Double = 0)
' free_gas_d - допустимая доля газа в потоке;
' t_C        - температура, С.
' feed - параметры потока флюидов, дебит, обводненность и пр
'              используйте encode_feed для генерации
' ksep_add_fr - коэффициент сепарации газа из потока
' результат  - число - давление,
'              подпись, и лог расчета если подключен
'description_end
      
On Error GoTo er1:
    Dim pvt As New CPVT
    
    Call pvt.init_feed(feed)
    feed_rp_gas_fraction_m3m3 = pvt.rp_gas_fraction_m3m3(free_gas_d, p_atma, t_C, ksep_add_fr)
    
    Exit Function
er1:
On Error GoTo er2:
    feed_rp_gas_fraction_m3m3 = Array("error " & Err.Description, pvt.log_.get_str)
    Exit Function
er2:
    feed_rp_gas_fraction_m3m3 = "error " & Err.Description
End Function
'description_to_manual      - для автогенерации
' функция расчета коэффициента Джоуля Томсона
Public Function feed_cJT_Katm( _
               ByVal p_atma As Double, _
               ByVal t_C As Double, _
               ByVal feed As String)
' p_atma     - давление, атм
' t_C        - температура, С.
' feed - параметры потока флюидов, дебит, обводненность и пр
'              используйте encode_feed для генерации
' результат  - массив, значение коэффициента Джоуля Томсона потока,
'              подпись, и лог расчета если подключен
'description_end
 On Error GoTo er1:
    Dim pvt As New CPVT
    Call pvt.init_feed(feed)
    Call pvt.calc_PVT(p_atma, t_C)
    feed_cJT_Katm = pvt.cJT_Katm
    Exit Function
er1:
On Error GoTo er2:
    feed_cJT_Katm = Array("error " & Err.Description, pvt.log_.get_str)
    Exit Function
er2:
    feed_cJT_Katm = "error " & Err.Description
    
End Function
'description_to_manual      - для автогенерации
' функция расчета расхода газо жидкостной смеси (ГЖС)
Public Function feed_q_mix_rc_m3day( _
               ByVal p_atma As Double, _
               ByVal t_C As Double, _
               ByVal feed As String)
' p_atma     - давление, атм
' t_C        - температура, С.
' feed - параметры потока флюидов, дебит, обводненность и пр
'              используйте encode_feed для генерации
' результат  - массив, расход ГЖС в рабочих условиях,
'              подпись, и лог расчета если подключен
'description_end
 On Error GoTo er1:
    Dim pvt As New CPVT
    Call pvt.init_feed(feed)
    Call pvt.calc_PVT(p_atma, t_C)
    feed_q_mix_rc_m3day = pvt.q_mix_rc_m3day
    Exit Function
er1:
On Error GoTo er2:
    feed_q_mix_rc_m3day = Array("error " & Err.Description, pvt.log_.get_str)
    Exit Function
er2:
    feed_q_mix_rc_m3day = "error " & Err.Description
End Function
'description_to_manual      - для автогенерации
' функция расчета расхода жидкости
Public Function feed_q_liq_rc_m3day( _
               ByVal p_atma As Double, _
               ByVal t_C As Double, _
               ByVal feed As String)
' p_atma     - давление, атм
' t_C        - температура, С.
' feed - параметры потока флюидов, дебит, обводненность и пр
'              используйте encode_feed для генерации
' результат  - массив, расход ГЖС в рабочих условиях,
'              подпись, и лог расчета если подключен
'description_end
 On Error GoTo er1:
    Dim pvt As New CPVT
    Call pvt.init_feed(feed)
    Call pvt.calc_PVT(p_atma, t_C)
    feed_q_liq_rc_m3day = pvt.qliq_rc_m3day
    Exit Function
er1:
On Error GoTo er2:
    feed_q_liq_rc_m3day = Array("error " & Err.Description, pvt.log_.get_str)
    Exit Function
er2:
    feed_q_liq_rc_m3day = "error " & Err.Description
End Function
'description_to_manual      - для автогенерации
' функция расчета расхода газа в рабочих условиях
Public Function feed_q_gas_rc_m3day( _
               ByVal p_atma As Double, _
               ByVal t_C As Double, _
               ByVal feed As String)
' p_atma     - давление, атм
' t_C        - температура, С.
' feed - параметры потока флюидов, дебит, обводненность и пр
'              используйте encode_feed для генерации
' результат  - массив, расход ГЖС в рабочих условиях,
'              подпись, и лог расчета если подключен
'description_end
 On Error GoTo er1:
    Dim pvt As New CPVT
    Call pvt.init_feed(feed)
    Call pvt.calc_PVT(p_atma, t_C)
    feed_q_gas_rc_m3day = pvt.q_gas_rc_m3day
    Exit Function
er1:
On Error GoTo er2:
    feed_q_gas_rc_m3day = Array("error " & Err.Description, pvt.log_.get_str)
    Exit Function
er2:
    feed_q_gas_rc_m3day = "error " & Err.Description
End Function
'description_to_manual      - для автогенерации
' функция расчета расхода свободного газа в потоке
Public Function feed_q_gas_free_sm3day( _
               ByVal p_atma As Double, _
               ByVal t_C As Double, _
               ByVal feed As String)
' p_atma     - давление, атм
' t_C        - температура, С.
' feed - параметры потока флюидов, дебит, обводненность и пр
'              используйте encode_feed для генерации
' результат  - массив, расход ГЖС в рабочих условиях,
'              подпись, и лог расчета если подключен
'description_end
 On Error GoTo er1:
    Dim pvt As New CPVT
    Call pvt.init_feed(feed)
    Call pvt.calc_PVT(p_atma, t_C)
    feed_q_gas_free_sm3day = pvt.q_gas_insitu_sm3day
    Exit Function
er1:
On Error GoTo er2:
    feed_q_gas_free_sm3day = Array("error " & Err.Description, pvt.log_.get_str)
    Exit Function
er2:
    feed_q_gas_free_sm3day = "error " & Err.Description
End Function
'description_to_manual      - для автогенерации
' функция расчета плотности газо жидкостной смеси (ГЖС)
Public Function feed_rho_mix_kgm3( _
               ByVal p_atma As Double, _
               ByVal t_C As Double, _
               ByVal feed As String)
' p_atma     - давление, атм
' t_C        - температура, С.
' feed - параметры потока флюидов, дебит, обводненность и пр
'              используйте encode_feed для генерации
' результат  - массив, расход ГЖС в рабочих условиях,
'              подпись, и лог расчета если подключен
'description_end
 On Error GoTo er1:
    Dim pvt As New CPVT
    Call pvt.init_feed(feed)
    Call pvt.calc_PVT(p_atma, t_C)
    feed_rho_mix_kgm3 = pvt.rho_mix_rc_kgm3
    Exit Function
er1:
On Error GoTo er2:
    feed_rho_mix_kgm3 = Array("error " & Err.Description, pvt.log_.get_str)
    Exit Function
er2:
    feed_rho_mix_kgm3 = "error " & Err.Description
End Function
'description_to_manual      - для автогенерации
' функция расчета плотности жидкости
Public Function feed_rho_liq_kgm3( _
               ByVal p_atma As Double, _
               ByVal t_C As Double, _
               ByVal feed As String)
' p_atma     - давление, атм
' t_C        - температура, С.
' feed - параметры потока флюидов, дебит, обводненность и пр
'              используйте encode_feed для генерации
' результат  - массив, расход ГЖС в рабочих условиях,
'              подпись, и лог расчета если подключен
'description_end
 On Error GoTo er1:
    Dim pvt As New CPVT
    Call pvt.init_feed(feed)
    Call pvt.calc_PVT(p_atma, t_C)
    feed_rho_liq_kgm3 = pvt.rho_liq_rc_kgm3
    Exit Function
er1:
On Error GoTo er2:
    feed_rho_liq_kgm3 = Array("error " & Err.Description, pvt.log_.get_str)
    Exit Function
er2:
    feed_rho_liq_kgm3 = "error " & Err.Description
End Function
'description_to_manual      - для автогенерации
' функция расчета плотности газо жидкостной смеси (ГЖС)
Public Function feed_mu_mix_cP( _
               ByVal p_atma As Double, _
               ByVal t_C As Double, _
               ByVal feed As String)
' p_atma     - давление, атм
' t_C        - температура, С.
' feed - параметры потока флюидов, дебит, обводненность и пр
'              используйте encode_feed для генерации
' результат  - массив, расход ГЖС в рабочих условиях,
'              подпись, и лог расчета если подключен
'description_end
 On Error GoTo er1:
    Dim pvt As New CPVT
    Call pvt.init_feed(feed)
    Call pvt.calc_PVT(p_atma, t_C)
    feed_mu_mix_cP = pvt.mu_mix_cP
    Exit Function
er1:
On Error GoTo er2:
    feed_mu_mix_cP = Array("error " & Err.Description, pvt.log_.get_str)
    Exit Function
er2:
    feed_mu_mix_cP = "error " & Err.Description
End Function
'description_to_manual      - для автогенерации
' функция расчета вязкости жидкости
Public Function feed_mu_liq_cP( _
               ByVal p_atma As Double, _
               ByVal t_C As Double, _
               ByVal feed As String)
' p_atma     - давление, атм
' t_C        - температура, С.
' feed - параметры потока флюидов, дебит, обводненность и пр
'              используйте encode_feed для генерации
' результат  - массив, расход ГЖС в рабочих условиях,
'              подпись, и лог расчета если подключен
'description_end
 On Error GoTo er1:
    Dim pvt As New CPVT
    Call pvt.init_feed(feed)
    Call pvt.calc_PVT(p_atma, t_C)
    feed_mu_liq_cP = pvt.mu_liq_cP
    Exit Function
er1:
On Error GoTo er2:
    feed_mu_liq_cP = Array("error " & Err.Description, pvt.log_.get_str)
    Exit Function
er2:
    feed_mu_liq_cP = "error " & Err.Description
End Function
'description_to_manual      - для автогенерации
' function for calculating flow properties after gas separation
Public Function feed_mod_separate_gas( _
               ByVal k_sep, _
               ByVal p_atma, _
               ByVal t_C, _
               ByVal feed As String, _
      Optional ByVal sol_factor As Double = 0)
' k_sep - gas separation factor, fraction, number or list
' p_atma - pressure, atm, number or list
' t_C - temperature, C, number or list
' feed - json encoded fluid flow parameters,
' use encode_feed to generate
' sol_factor - gas solution factor
' result - json encoded feed string
'description_end
    Const nv = 1
    Dim fluid_stream As New CPVT
    
    Dim res(0 To 1, 0 To nv) As Variant
    ' param dictionary and settings variables with default values
    Dim gas_goes_into_solution As Double
    Dim ptq As PTQ_LIST
    Dim ptq_out As PTQ_LIST
 
    ' auxiliary variables
    Dim log_str As String
    Dim i As Integer
    Dim d As Dictionary
    
    On Error GoTo er1:
    gas_goes_into_solution = 0
    If sol_factor >= 0 And sol_factor <= 1 Then gas_goes_into_solution = sol_factor
    Call read_PTQ(ptq, feed, p_atma, t_C, fluid_stream.log_, k_sep, 0, 0, 0, 0)
    Call init_ptq(ptq_out, ptq)
    For i = 1 To ptq.len
        
        With fluid_stream
            Call .init_feed(ptq.feed(i))
            
            Call fluid_stream.mod_after_separation(ptq.p(i), ptq.t(i), ptq.val(i), gas_goes_into_solution)
            
            ptq_out.feed(i) = (fluid_stream.feed)
            ptq_out.p(i) = Round(ptq.p(i), const_num_decimal_out)
            ptq_out.t(i) = Round(ptq.t(i), const_num_decimal_out)
            ptq_out.val(i) = Round(ptq.val(i), const_num_decimal_out)
            
        End With
    Next i
      
    Set d = convert_to_dict_ptq(ptq_out)
    d("k_sep") = ptq_out.val
    
    If ptq.len = 1 Then
        feed_mod_separate_gas = ptq_out.feed(1)
    Else
        feed_mod_separate_gas = ConvertToJson(d)
    End If
    
    Exit Function
er1:
On Error GoTo er2:
    feed_mod_separate_gas = Array("error " & Err.Description, fluid_stream.log_.get_str)
    Exit Function
er2:
    feed_mod_separate_gas = "error " & Err.Description
End Function
'description_to_manual - for autogeneration
' function for calculating the properties of the separated fluid flow
Public Function feed_mod_split( _
               ByVal k_sep_gas As Double, _
               ByVal k_sep_oil As Double, _
               ByVal k_sep_wat As Double, _
               ByVal p_atma As Double, _
               ByVal t_C As Double, _
               ByVal feed As String)
' k_sep_gas - gas separation factor
' k_sep_oil - oil separation factor
' k_sep_wat - water separation factor
' p_atma - pressure, atm
' t_C - temperature, C.
' feed - fluid flow parameters, flow rate, watercut, etc.
' use encode_feed for generation
' result - array, GJS flow rate in working conditions,
' signature, and log of calculation if it is connected
' description_end
On Error GoTo er1:
    Dim feed_sep_gas As String
    Dim feed1 As New CPVT, feed2 As New CPVT, feed_in As New CPVT
    
    
    feed_sep_gas = feed_mod_separate_gas(k_sep_gas, p_atma, t_C, feed)
    
    Call feed_in.init_feed(feed)
    Call feed_in.calc_PVT(p_atma, t_C)
    Call feed1.init_feed(feed_sep_gas)
    Call feed2.init_feed(feed_sep_gas)
    
    Dim qo1 As Double, qw1 As Double
    qo1 = feed1.q_oil_sm3day
    qw1 = feed1.q_wat_sm3day
    
    feed2.q_liq_sm3day = qo1 * k_sep_oil + qw1 * k_sep_wat
    If (qo1 * k_sep_oil + qw1 * k_sep_wat) > 0 Then
        feed2.fw_fr = qw1 * k_sep_wat / (qo1 * k_sep_oil + qw1 * k_sep_wat)
    End If
    
    feed1.q_liq_sm3day = qo1 * (1 - k_sep_oil) + qw1 * (1 - k_sep_wat)
    If (qo1 * (1 - k_sep_oil) + qw1 * (1 - k_sep_wat)) > 0 Then
        feed1.fw_fr = qw1 * (1 - k_sep_wat) / (qo1 * (1 - k_sep_oil) + qw1 * (1 - k_sep_wat))
    End If
    ' весь газ после сепарации добавим во второй поток как свободный газ
    feed2.q_gas_free_sm3day = feed_in.q_gas_free_sm3day - feed1.q_gas_free_sm3day + _
                              (feed_in.rp_m3m3 - feed1.rp_m3m3) * feed_in.q_oil_sm3day
    
    Dim d As New Dictionary
    
    d("feed1") = ParseJson(feed1.feed)
    d("feed2") = ParseJson(feed2.feed)
    
    feed_mod_split = ConvertToJson(d)
Exit Function
er1:
On Error GoTo er2:
    feed_mod_split = Array("error " & Err.Description, feed_in.log_.get_str)
    Exit Function
er2:
    feed_mod_split = "error " & Err.Description
End Function
Public Function feed_mod_mix_obj(feed1 As CPVT, feed2 As CPVT) As CPVT
' feed1 - feed 1 object
' feed2 - feed 2 object
' result - json encoded feed string
On Error GoTo er1:
    
    Dim gg_mix As Double
    Dim go_mix As Double
    Dim gw_mix As Double
    Dim qo_mix_surf_sm3day As Double
    Dim qg_mix_surf_sm3day As Double
    Dim qw_mix_surf_sm3day As Double
    Dim ql_mix_surf_sm3day As Double
    Dim GOR_mix As Double
    Dim fw_mix As Double
    Dim pb_mix As Double
    Dim rsb_mix As Double
    Dim tres_mix As Double
    Dim muob_mix As Double
    Dim bob_mix As Double
    Dim qgas_free_mix As Double
    Dim corr_mix As Integer
    
    Dim fg1 As Double
    Dim fo1 As Double
    Dim fw1 As Double
    
    Dim feed_out As New CPVT
    
    'дебиты на поверхности можно просто сложить и получить итоговые
    qo_mix_surf_sm3day = feed1.q_oil_sm3day + feed2.q_oil_sm3day
    qw_mix_surf_sm3day = feed1.q_wat_sm3day + feed2.q_wat_sm3day
    qg_mix_surf_sm3day = feed1.q_gas_sm3day - feed1.q_gas_free_sm3day + _
                         feed2.q_gas_sm3day - feed2.q_gas_free_sm3day
    qgas_free_mix = feed1.q_gas_free_sm3day + feed2.q_gas_free_sm3day
    ql_mix_surf_sm3day = qo_mix_surf_sm3day + qw_mix_surf_sm3day
    
    ' оценим объемные доли первого флюида в общем потоке
    If qo_mix_surf_sm3day > 0 Then
        fo1 = feed1.q_oil_sm3day / qo_mix_surf_sm3day
    Else
        fo1 = 1
    End If
    If qw_mix_surf_sm3day > 0 Then
        fw1 = feed1.q_wat_sm3day / qw_mix_surf_sm3day
    Else
        fw1 = 1
    End If
    If qg_mix_surf_sm3day > 0 Then
        fg1 = feed1.q_gas_sm3day / qg_mix_surf_sm3day
    Else
        fg1 = 1
    End If
    
    ' удельные плотности определим как средневзвешенные по объем плотности долей (как в мануале Пайпсима)
    gg_mix = feed1.gamma_g * fg1 + feed2.gamma_g * (1 - fg1)
    go_mix = feed1.gamma_o * fo1 + feed2.gamma_o * (1 - fo1)
    gw_mix = feed1.gamma_w * fw1 + feed2.gamma_w * (1 - fw1)
    ' определим соотношения фаз
    If qo_mix_surf_sm3day > 0 Then
        GOR_mix = qg_mix_surf_sm3day / qo_mix_surf_sm3day
    Else
        GOR_mix = 0
    End If
    If ql_mix_surf_sm3day > 0 Then
        fw_mix = qw_mix_surf_sm3day / ql_mix_surf_sm3day * 100
    Else
        fw_mix = fw1
    End If
    ' выбираем корреляцию по потоку где дебит больше (для определенности)
    If feed1.q_liq_sm3day > feed2.q_liq_sm3day Then
        corr_mix = feed1.PVT_correlation
    Else
        corr_mix = feed2.PVT_correlation
    End If
    
    ' далее надо определить давление насыщения, газосодержание при давлении насыщения и другие параметры
    ' для упрощения - берем все калибровочные параметры как средне взвешенные по объемной доли нефти в потоке
    ' потенциально надо сделать методику лучше
    pb_mix = feed1.pb_atma * fo1 + feed2.pb_atma * (1 - fo1)
    tres_mix = feed1.t_res_C * fo1 + feed2.t_res_C * (1 - fo1)
    rsb_mix = feed1.rsb_m3m3 * fo1 + feed2.rsb_m3m3 * (1 - fo1)
    bob_mix = feed1.bob_m3m3 * fo1 + feed2.bob_m3m3 * (1 - fo1)
    muob_mix = feed1.muob_cP * fo1 + feed2.muob_cP * (1 - fo1)
    
    With feed_out
        Call .init(gg_mix, go_mix, gw_mix, rsb_mix, pb_mix, bob_mix, corr_mix, tres_mix, muob_mix)
        .q_liq_sm3day = ql_mix_surf_sm3day
        .fw_perc = fw_mix
        .rp_m3m3 = GOR_mix
        .q_gas_free_sm3day = qgas_free_mix
    End With
    
    Set feed_mod_mix_obj = feed_out
Exit Function
er1:
On Error GoTo er2:
    feed_mod_mix_obj = Array("error " & Err.Description, feed1.log_.get_str, , feed2.log_.get_str)
    Exit Function
er2:
    feed_mod_mix_obj = "error " & Err.Description
End Function
'description_to_manual - for autogenerating the description - puts the function header and surrounding comments in the manual (from the next line)
' calculates two feeds mixture properties
Public Function feed_mod_mix( _
               ByVal feed_1 As String, _
               ByVal feed_2 As String) As String
' feed_1 - feed 1 encoded string
' feed_2 - feed 2 encoded string
' result - json encoded feed string
'description_end
On Error GoTo er1:
        
    Dim feed1 As New CPVT
    Dim feed2 As New CPVT
    Dim feed_out As CPVT
        
    Call feed1.init_feed(feed_1)
    Call feed2.init_feed(feed_2)
    
    Set feed_out = feed_mod_mix_obj(feed1, feed2)
    feed_mod_mix = feed_out.feed
    
Exit Function
er1:
On Error GoTo er2:
    feed_mod_mix = Array("error " & Err.Description, feed1.log_.get_str, , feed2.log_.get_str)
    Exit Function
er2:
    feed_mod_mix = "error " & Err.Description
End Function
'description_to_manual      - для автогенерации
' функция расчета массового расхода нефти
Public Function feed_m_oil_kgsec( _
               ByVal p_atma As Double, _
               ByVal t_C As Double, _
               ByVal feed As String)
' p_atma     - давление, атм
' t_C        - температура, С.
' feed - параметры потока флюидов, дебит, обводненность и пр
'              используйте encode_feed для генерации
' результат  - число - массовый расход нефти
'description_end
 On Error GoTo er1:
    Dim pvt As New CPVT
    Call pvt.init_feed(feed)
    Call pvt.calc_PVT(p_atma, t_C)
    feed_m_oil_kgsec = pvt.mo_kgsec
    Exit Function
er1:
On Error GoTo er2:
    feed_m_oil_kgsec = Array("error " & Err.Description, pvt.log_.get_str)
    Exit Function
er2:
    feed_m_oil_kgsec = "error " & Err.Description
End Function
'description_to_manual      - для автогенерации
' функция расчета массового расхода газа
Public Function feed_m_gas_kgsec( _
               ByVal p_atma As Double, _
               ByVal t_C As Double, _
               ByVal feed As String)
' p_atma     - давление, атм
' t_C        - температура, С.
' feed - параметры потока флюидов, дебит, обводненность и пр
'              используйте encode_feed для генерации
' результат  - число - массовый расход свободного газа
'description_end
 On Error GoTo er1:
    Dim pvt As New CPVT
    Call pvt.init_feed(feed)
    Call pvt.calc_PVT(p_atma, t_C)
    feed_m_gas_kgsec = pvt.mg_kgsec
    Exit Function
er1:
On Error GoTo er2:
    feed_m_gas_kgsec = Array("error " & Err.Description, pvt.log_.get_str)
    Exit Function
er2:
    feed_m_gas_kgsec = "error " & Err.Description
End Function
'description_to_manual      - для автогенерации
' функция расчета массового расхода воды
Public Function feed_m_wat_kgsec( _
               ByVal p_atma As Double, _
               ByVal t_C As Double, _
               ByVal feed As String)
' p_atma     - давление, атм
' t_C        - температура, С.
' feed - параметры потока флюидов, дебит, обводненность и пр
'              используйте encode_feed для генерации
' результат  - число - массовый расход свободного воды
'description_end
 On Error GoTo er1:
    Dim pvt As New CPVT
    Call pvt.init_feed(feed)
    Call pvt.calc_PVT(p_atma, t_C)
    feed_m_wat_kgsec = pvt.mw_kgsec
    Exit Function
er1:
On Error GoTo er2:
    feed_m_wat_kgsec = Array("error " & Err.Description, pvt.log_.get_str)
    Exit Function
er2:
    feed_m_wat_kgsec = "error " & Err.Description
End Function
'
' =====================================================================
'    функции для расчета пласта, индикаторной кривой
' =====================================================================
'description_to_manual      - для автогенерации
' кодирование параметров пласта в json строку
Public Function encode_ipr(Optional ByVal p_res_atma As Double = 250, _
                           Optional ByVal q_test_sm3day As Double = 50, _
                           Optional ByVal pwf_test_atma As Double = 100, _
                           Optional ByVal pi_sm3dayatm As Double = -1, _
                           Optional ByVal feed_json As String = "")
' p_res_atma - пластовое давление, атма
' q_test_sm3day - тестовый дебит, ст.м3/сут
' pwf_test_atma - тестовое забойное давление, атм
' pi_sm3dayatm - коэффициент продуктивности, м3/сут/атм
' если не задан, то рассчитывается из тестовых замеров
' feed_json - json c pvt свойствами, используйте encode_pvt() для генерации
'description_end
        
    On Error GoTo er1:
    Dim res As New CReservoirVogel
    
    res.init_from_feed p_res_atma, feed_json, pi_sm3dayatm
    If pi_sm3dayatm > 0 Then
        res.pi_sm3dayatm = pi_sm3dayatm
    Else
        Call res.calc_pi_from_feed_sm3dayatm(q_test_sm3day, pwf_test_atma)
    End If
    encode_ipr = res.get_json()
    Exit Function
er1:
    encode_ipr = "error"
End Function
'description_to_manual      - для автогенерации
' расчет коэффициента продуктивности пласта
' по данным тестовой эксплуатации
Public Function IPR_pi_sm3dayatm(ByVal IPR_json As String, _
                                 ByVal q_liq_sm3day As Double, _
                                 ByVal pwf_test_atma As Double)
' IPR_json - json строка кодирующая IPR
' q_liq_sm3day - тестовый дебит жидкости
' pwf_test_atma - тестовое забойное давление
'description_end
On Error GoTo er1:
    Dim res As New CReservoirVogel
    
    Call res.init_json(IPR_json)
    Call res.calc_pi_from_feed_sm3dayatm(q_liq_sm3day, pwf_test_atma)
    IPR_pi_sm3dayatm = res.pi_sm3dayatm
    
    Exit Function
er1:
    IPR_pi_sm3dayatm = "error"
End Function
'description_to_manual      - для автогенерации
' расчет забойного давления по дебиту и продуктивности
Public Function IPR_pwf_atma(ByVal IPR_json As String, _
                    Optional ByVal q_liq_sm3day = 0)
' IPR_json - json строка кодирующая IPR' p_res_atma      - пластовое давление, абс. атм
' q_liq_sm3day    - дебит жидкости скважины на поверхности, ст.м3/сут, число или массив
'description_end
On Error GoTo err1:
    Dim cl As Collection
    Dim cl_q_out As New Collection
    Dim cl_p_out As New Collection
    Dim cl_t_out As New Collection
    Dim dic_out As New Dictionary
    Dim ql
    Dim pwf As Double
    Dim res As New CReservoirVogel
    
    Call res.init_json(IPR_json)
     
    ' разберемся со значением дебита
    
    Select Case VBA.VarType(q_liq_sm3day)
        Case vbDouble
            If q_liq_sm3day > 0 Then
                IPR_pwf_atma = res.calc_p_wf_atma(q_liq_sm3day)
            Else
                IPR_pwf_atma = res.calc_p_wf_from_feed_atma
            End If
        Case vbString
            Select Case VBA.Mid$(q_liq_sm3day, 1, 1)
                Case "["
                    Set cl = ParseJson(q_liq_sm3day)
                    For Each ql In cl
                        cl_q_out.Add ql
                        pwf = Round(res.calc_p_wf_atma(ql), const_num_decimal_out)
                        cl_p_out.Add pwf
                        If pwf > 0 Then
                            cl_t_out.Add Round(res.calc_t_fluid_C(res.calc_p_wf_atma(ql)), const_num_decimal_out)
                        Else
                            cl_t_out.Add 0
                        End If
                    Next
                    Set dic_out("p_atma") = cl_p_out
                    Set dic_out("t_C") = cl_t_out
                    Set dic_out("q_liq_sm3day") = cl_q_out
                    IPR_pwf_atma = ConvertToJson(dic_out)
                Case Else
                    ql = Cdbl_(q_liq_sm3day)
                    IPR_pwf_atma = res.calc_p_wf_atma(ql)
            End Select
    End Select
    
    Set res = Nothing
    
    Exit Function
err1:
    IPR_pwf_atma = "error:IPR_pwf_atma:" & Err.Description
   
End Function
'description_to_manual      - для автогенерации
' расчет дебита по давлению и продуктивности
Public Function IPR_q_liq_sm3day( _
                 ByVal IPR_json As String, _
                 ByVal p_wf_atma)
' IPR_json - json строка кодирующая IPR
' p_wf_atma      - забойное давление, абс. атм.
'                  можно задать список [],
'                  тогда результат будет в виде списка
'description_end
On Error GoTo err1:
    Dim cl As Collection
    Dim cl_q_out As New Collection
    Dim cl_p_out As New Collection
    Dim cl_t_out As New Collection
    Dim dic_out As New Dictionary
    
    Dim pwf
    Dim res As New CReservoirVogel
    
    Call res.init_json(IPR_json)
    
    ' разберемся со значением забойного давления
    
    Select Case VBA.VarType(p_wf_atma)
        Case vbDouble
             IPR_q_liq_sm3day = res.calc_q_liq_sm3day(p_wf_atma)
        Case vbString
            Select Case VBA.Mid$(p_wf_atma, 1, 1)
                Case "["
                    Set cl = ParseJson(p_wf_atma)
                    For Each pwf In cl
                        cl_q_out.Add Round(res.calc_q_liq_sm3day(pwf), const_num_decimal_out)
                        cl_p_out.Add pwf
                        If pwf > 0 Then
                            cl_t_out.Add Round(res.calc_t_fluid_C(pwf), const_num_decimal_out)
                        Else
                            cl_t_out.Add 0
                        End If
                    Next
                    Set dic_out("p_atma") = cl_p_out
                    Set dic_out("t_C") = cl_t_out
                    Set dic_out("q_liq_sm3day") = cl_q_out
                    IPR_q_liq_sm3day = ConvertToJson(dic_out)
                Case Else
                    pwf = Cdbl_(p_wf_atma)
                    IPR_q_liq_sm3day = res.calc_q_liq_sm3day(pwf)
            End Select
    End Select
        
    Set res = Nothing
    
    Exit Function
err1:
    IPR_q_liq_sm3day = "Error:IPR_q_liq_sm3day:" & Err.Description
End Function
'description_to_manual      - для автогенерации
' построение кривой IPR в json формате
Public Function IPR_crv(IPR_json As String, _
                    Optional num_points As Integer = 20)
' IPR_json - json строка кодирующая IPR
' num_points - количество точек в графике
'description_end
On Error GoTo err1:
    Dim res As New CReservoirVogel
    Dim i As Integer
    Dim crvp As New CInterpolation
    Dim crvt As New CInterpolation
    
    Dim p As Double
    Dim t As Double
    Dim q As Double
    
    Call res.init_json(IPR_json)
    
    
    For i = 1 To num_points
        p = 1 + res.p_res_atma / (num_points - 1) * (i - 1)
        q = res.calc_q_liq_sm3day(p)
        t = res.calc_t_fluid_C(p)
        crvp.AddPoint q, p
        crvp.xName = "q_liq (IPR)"
        crvp.yName = "p_wf (IPR)"
        crvt.AddPoint q, t
        crvt.xName = "q_liq (IPR)"
        crvt.yName = "t_fluid (IPR)"
    Next i
    Dim d As New Dictionary
    d.Add "pcrv", crvp.getDict
    d.Add "tcrv", crvt.getDict
    IPR_crv = ConvertToJson(d)
    
    
    Exit Function
err1:
    IPR_crv = "Error:IPR_crv:" & Err.Description
End Function
''=======================================================
''--------------------- ЭЦН -----------------------
''=======================================================
'
'description_to_manual      - для автогенерации
' номинальный напор ЭЦН (на основе каталога ЭЦН)
' учитывается поправка на вязкость и калибровки
Public Function ESP_head_m( _
                 ByVal qliq_m3day As Double, _
        Optional ByVal esp_json As String, _
        Optional ByVal freq_Hz As Double = 50, _
        Optional ByVal mu_cSt As Double = -1)
' qliq_m3day - дебит жидкости в условиях насоса (стенд)
' esp_json  - параметры ЭЦН
' freq_Hz    - частота вращения насоса
' mu_cSt     - вязкость жидкости, сСт;
'description_end
On Error GoTo err1:
    Dim esp As New CESPpump
    
    Call esp.init_json(esp_json)
    
    With esp
        .freq_Hz = freq_Hz
        qliq_m3day = qliq_m3day / .calibr_rate
        ESP_head_m = .get_ESP_head_m(qliq_m3day, .stage_num, mu_cSt)
        ESP_head_m = ESP_head_m * .calibr_head
    End With
    Exit Function
err1:
    ESP_head_m = "Error:ESP_head_m:" & Err.Description
End Function
'description_to_manual      - для автогенерации
' номинальная мощность потребляемая ЭЦН с вала (на основе каталога ЭЦН)
' учитывается поправка на вязкость
Public Function ESP_power_W( _
                 ByVal qliq_m3day As Double, _
        Optional ByVal esp_json As String, _
        Optional ByVal freq_Hz As Double = 50, _
        Optional ByVal mu_cSt As Double = -1)
' qliq_m3day - дебит жидкости в условиях насоса (стенд)
' esp_json  - параметры ЭЦН
' freq_Hz    - частота вращения насоса
' mu_cSt     - вязкость жидкости, сСт;
'description_end
On Error GoTo err1:
    Dim esp As New CESPpump
    Call esp.init_json(esp_json)
    
    With esp
        .freq_Hz = freq_Hz
        qliq_m3day = qliq_m3day / .calibr_rate
        ESP_power_W = .get_ESP_power_W(qliq_m3day, .stage_num, mu_cSt)
        ESP_power_W = ESP_power_W * .calibr_power
    End With
    Exit Function
err1:
    ESP_power_W = -1
    add_log_msg "Error:ESP_power_W:" & Err.Description
End Function
'description_to_manual      - для автогенерации
' номинальный КПД ЭЦН (на основе каталога ЭЦН)
' учитывается поправка на вязкость
Public Function ESP_eff_fr( _
                 ByVal qliq_m3day As Double, _
        Optional ByVal esp_json As String, _
        Optional ByVal freq_Hz As Double = 50, _
        Optional ByVal mu_cSt As Double = -1)
' qliq_m3day - дебит жидкости в условиях насоса (стенд)
' esp_json  - параметры ЭЦН
' freq_Hz    - частота вращения насоса
' mu_cSt     - вязкость жидкости, сСт;
'description_end
On Error GoTo err1:
    Dim esp As New CESPpump
    Call esp.init_json(esp_json)
    
    With esp
        .freq_Hz = freq_Hz
        qliq_m3day = qliq_m3day / .calibr_rate
        esp.correct_visc = True
        ESP_eff_fr = .get_ESP_effeciency_fr(qliq_m3day, mu_cSt)
        ESP_eff_fr = ESP_eff_fr * .calibr_head * .calibr_rate / .calibr_power
    End With
    Exit Function
err1:
    ESP_eff_fr = -1
    add_log_msg "Error:ESP_eff_fr:" & Err.Description
End Function
'description_to_manual      - для автогенерации
' название ЭЦН по номеру
Public Function ESP_name(Optional ByVal pump_id As Long) As String
' pump_id    - идентификатор насоса в базе данных
' результат - название насоса
'description_end
On Error GoTo err1:
    Dim esp As New CESPpump
    Call esp.set_ID(pump_id)
    If esp Is Nothing Then
        ESP_name = "no name"
        Exit Function
    End If
    ESP_name = esp.db.name
    Exit Function
err1:
    ESP_name = -1
    add_log_msg "Error:ESP_name:" & Err.Description
End Function
'' номинальная частота УЭЦН
'Public Function ESP_freq_nom(Optional ByVal pump_id As Long)
'' pump_id    - идентификатор насоса в базе данных
'' результат - номинальная частота
'
'On Error GoTo err1:
'    Dim esp As New CESPpump
'    Call esp.set_ID(pump_id)
'    If esp Is Nothing Then
'        ESP_freq_nom = "no name"
'        Exit Function
'    End If
'
'    ESP_freq_nom = esp.db.freq_Hz
'
'    Exit Function
'err1:
'    ESP_freq_nom = -1
'    add_log_msg "Error:ESP_freq_nom:" & Err.Description
'End Function
'description_to_manual      - для автогенерации
' оценка количества ступеней по напору с учетом номинальной частоты
Public Function ESP_calc_stages_num(Optional ByVal pump_id As Long = 1006, _
                                    Optional ByVal head As Double = 1000, _
                                    Optional ByVal f_nom_Hz As Double = 0, _
                                    Optional ByVal q_nom_sm3day As Double = -1)
' pump_id   - идентификатор насоса в базе данных
' head - номинальный напор установки
' f_nom_Hz - номинальная частота, если отлична от 50 Гц
' q_nom_sm3day - номиналный дебит, если частота отлична от 50 Гц
'description_end
' результат - количество ступеней
On Error GoTo err1:
    Dim esp As New CESPpump
    'Dim f_ratio As Double
    Call esp.set_ID(pump_id, f_nom_Hz)
    If esp Is Nothing Then
        
        Exit Function
    End If
    With esp
'        f_ratio = .db.freq_Hz / f_nom_Hz
        If q_nom_sm3day <= 0 Then q_nom_sm3day = .db.rate_nom_sm3day
        .freq_Hz = esp.freq_nom_Hz
        ESP_calc_stages_num = Round(head / .get_ESP_head_m(q_nom_sm3day, 1, 1), 0)
    End With
    Exit Function
err1:
    ESP_calc_stages_num = -1
    add_log_msg "Error:ESP_freq_nom:" & Err.Description
End Function
'description_to_manual      - для автогенерации
' максимальный дебит ЭЦН для заданной частоты
' по номинальной кривой РНХ
Public Function ESP_rate_max_sm3day( _
             ByVal esp_json As String, _
    Optional ByVal freq_Hz As Double = 50, _
    Optional ByVal mu_cSt As Double = -1) As Double
' freq_Hz   - частота вращения ЭЦН
' pump_id    - идентификатор насоса в базе данных
' mu_cSt - вязкость для расчета поправок
' calibr_rate - калибровка на расход
'description_end
On Error GoTo err1:
    Dim esp As New CESPpump
    Call esp.init_json(esp_json)
    esp.freq_Hz = freq_Hz
    ESP_rate_max_sm3day = esp.rate_max_sm3day(mu_cSt)
    Exit Function
err1:
    ESP_rate_max_sm3day = -1
    add_log_msg "Error:ESP_rate_max_sm3day:" & Err.Description
End Function
'description_to_manual      - для автогенерации
' оптимальный дебит ЭЦН для заданной частоты
' по номинальной кривой РНХ
Public Function ESP_optRate_m3day( _
             ByVal esp_json As String, _
    Optional ByVal freq_Hz As Double = 50, _
    Optional ByVal mu_cSt As Double = -1) As Double
' freq_Hz   - частота вращения ЭЦН
' pump_id    - идентификатор насоса в базе данных
'description_end
On Error GoTo err1:
    Dim esp As New CESPpump
    Call esp.init_json(esp_json)
    esp.freq_Hz = freq_Hz
    ESP_optRate_m3day = esp.rate_nom_sm3day(mu_cSt)
    Exit Function
err1:
    ESP_optRate_m3day = -1
    add_log_msg "Error:ESP_optRate_m3day:" & Err.Description
End Function
'description_to_manual      - для автогенерации
' функция возвращает идентификатор типового насоса по значению
' номинального дебита
Public Function ESP_id_by_rate(ByVal q As Double, _
                      Optional ByVal size5 As Boolean = True)
' Q - номинальный дебит
' f_nom_Hz - номинальная частота для нестандартных насосов
' size5 - габарит, 5 если да, 5А если нет
'description_end
' возвращает ID в зависимости от номинального дебита.
' насосы подобраны вручную из текущей базы.
' все насосы в тестовой базе приведены для 50 Гц
' поэтому надо скорректировать частоты для них
    
    
If size5 And q < 150 Then
'738 legacy  Generic ЭЦН5-15 555 15  10  20  33
'1003    legacy  Generic ЭЦН5-20 600 20  15  25  38
'739 legacy  Generic ЭЦН5-25 651 25  18  35  57
'740 legacy  Generic ЭЦН5-30 591 30  20  45  58
'1004    legacy  Generic ЭЦН5-35 591 35  22  50  66
'741 legacy  Generic ЭЦН5-44 541 44  32  60  95
'1005    legacy  Generic ЭЦН5-50 582 50  35  65  95
'743 legacy  Generic ЭЦН5-59 522 59  40  72  124
'744 legacy  Generic ЭЦН5-79 459 79  60  105 184
'1006    legacy  Generic ЭЦН5-80 489 80  60  105 175
'1007    legacy  Generic ЭЦН5-100    514 100 80  120 183
'737 legacy  Generic ЭЦН5-125    517 125 80  160 230
'799 legacy  Generic ЭЦН5-125    358 150 96  192 267
'742 legacy  Generic ЭЦН5-500    539 500 350 600 840
    If q > 10 And q < 18 Then ESP_id_by_rate = 738: ' ЭЦН5-15
    If q >= 18 And q < 23 Then ESP_id_by_rate = 1003: ' ЭЦН5-20
    If q >= 23 And q < 28 Then ESP_id_by_rate = 739: ' ЭЦН5-25
    If q >= 28 And q < 33 Then ESP_id_by_rate = 740: ' ЭЦН5-30
    If q >= 23 And q < 39 Then ESP_id_by_rate = 1004: ' ЭЦН5-35
    If q >= 39 And q < 47 Then ESP_id_by_rate = 741: ' ЭЦН5-44
    If q >= 47 And q < 55 Then ESP_id_by_rate = 1005: ' ЭЦН5-50
    If q >= 55 And q < 65 Then ESP_id_by_rate = 743: ' ЭЦН5-59
    If q >= 65 And q < 79.5 Then ESP_id_by_rate = 744: ' ЭЦН5-79
    If q >= 79.5 And q < 90 Then ESP_id_by_rate = 1006: ' ЭЦН5-80
    If q >= 90 And q < 110 Then ESP_id_by_rate = 1006: ' ЭЦН5-100
    If q >= 110 And q < 150 Then ESP_id_by_rate = 737: ' ЭЦН5-125
    If q > 150 Then ESP_id_by_rate = 758
Else
'1008    legacy  Generic ЭЦН5А-25    364 25  18  35  58
'1009    legacy  Generic ЭЦН5А-34    426 34  20  45  60
'751 legacy  Generic ЭЦН5А-35    404 35  20  60  85
'752 legacy  Generic ЭЦН5А-50    450 50  35  70  100
'745 legacy  Generic ЭЦН5А-100   380 100 70  140 185
'1025    legacy  Generic ЭЦН5А-100Э  660 100 70  140 200
'746 legacy  Generic ЭЦН5А-124   354 124 95  160 261
'747 legacy  Generic ЭЦН5А-159   372 159 130 205 355
'748 legacy  Generic ЭЦН5А-199   388 199 150 255 380
'749 legacy  Generic ЭЦН5А-240   374 240 190 280 410
'750 legacy  Generic ЭЦН5А-280   368 280 220 350 500
'753 legacy  Generic ЭЦН5А-500   510 500 350 600 780
'754 legacy  Generic ЭЦН5А-700   552 700 550 840 1050
    If q > 10 And q < 30 Then ESP_id_by_rate = 1008: ' ЭЦН5А-25
    If q >= 30 And q < 34.5 Then ESP_id_by_rate = 1009: ' ЭЦН5А-34
    If q >= 34.5 And q < 40 Then ESP_id_by_rate = 751: ' ЭЦН5А-35
    If q >= 40 And q < 70 Then ESP_id_by_rate = 752: ' ЭЦН5А-50
    If q >= 70 And q < 110 Then ESP_id_by_rate = 1025: ' ЭЦН5А-100
    If q >= 110 And q < 135 Then ESP_id_by_rate = 746: ' ЭЦН5А-124
    If q >= 135 And q < 180 Then ESP_id_by_rate = 747: ' ЭЦН5А-159
    If q >= 180 And q < 220 Then ESP_id_by_rate = 748: '  ЭЦН5А-199
    If q >= 220 And q < 260 Then ESP_id_by_rate = 749: ' ЭЦН5А-240
    If q >= 260 And q < 350 Then ESP_id_by_rate = 750: ' ЭЦН5А-280
    If q >= 350 And q < 600 Then ESP_id_by_rate = 753: ' ЭЦН5А-500
    If q >= 600 And q < 800 Then ESP_id_by_rate = 753: ' ЭЦН5А-700
    If q >= 800 And q < 1100 Then ESP_id_by_rate = 755: ' ЭЦН6-1000
    If q >= 1100 And q < 1200 Then ESP_id_by_rate = 755: ' ЭЦН6-1250
    If q > 1200 Then ESP_id_by_rate = 758 ' ЭЦН7-2000
End If
End Function
'description_to_manual      - для автогенерации
'функция расчета давления на выходе/входе ЭЦН в рабочих условиях
'большинство параметров задается явно
Public Function ESP_p_atma( _
                 ByVal p_calc_atma, _
        Optional ByVal t_intake_C = 50, _
        Optional ByVal t_dis_C = 50, _
        Optional ByVal feed As String = "", _
        Optional ByVal esp_json As String = "", _
        Optional ByVal freq_Hz As Double = 50, _
        Optional ByVal calc_along_flow As Boolean = True, _
        Optional ByVal param As String = "", _
        Optional ByVal h_mes_top As Double = 1000, _
        Optional ByVal q_liq_sm3day = -1, _
        Optional ByVal fw_perc = -1, _
        Optional ByVal rp_m3m3 = -1, _
        Optional ByVal q_gas_free_sm3day = -1)
' p_calc_atma      - давление для которого делается расчет
'                    либо давление на приеме насоса
'                    либо давление на выкиде насоса
'                    определяется параметром calc_along_flow
' t_intake_C       - температура на приеме насоcа
' t_dis_C          - температура на выкиде насоса.
'             если = 0 и calc_along_flow = 1 то рассчитывается
' feed     - параметры потока флюидов json строка. Используйте
'            функцию encode_feed() для генерации
' esp_json          - параметры насоса насоса
' freq_Hz - частота тока
' calc_along_flow  - режим расчета снизу вверх или сверху вниз
'          calc_along_flow = True => p_atma давление на приеме
'          calc_along_flow = False => p_atma давление на выкиде
' param     - дополнительные параметры расчета потока
' h_mes_top - глубина установки ЭЦН (верх ЭЦН)
' q_liq_sm3day - дебит жидкости, перекрывает feed если задан,
'                может быть вектором
' fw_perc - обводненность, перекрывает feed если задан,
'                может быть вектором
' rp_m3m3 - газовый фактор, перекрывает feed если задан,
'                может быть вектором
' q_gas_free_sm3day - доп дебит газа, перекрывает feed если задан,
'                может быть вектором
' результат   - массив значений включающий
'description_end
'    Dim d As Dictionary
    Dim prmd As Dictionary
    Dim arr
    Dim esp As New CESPpump
    Dim out_points As Integer
    Dim show_log As Boolean
    Dim show_array As Boolean
    Dim show_json As Boolean
    Dim num_value As Integer
    Dim ptq As PTQ_LIST
    Dim ptq_out As PTESP_LIST
    Dim i As Integer
    
 On Error GoTo er1:
    
    Call read_PTQ(ptq, feed, p_calc_atma, t_intake_C, esp.log_, t_dis_C, q_liq_sm3day, fw_perc, rp_m3m3, q_gas_free_sm3day)
    Call init_ptesp(ptq_out, ptq)
    If Len(feed) < 2 Then feed = encode_feed()
    Set prmd = param_to_dict(param)
    show_log = prmd(prm_show_log)
    num_value = prmd(prm_num_value)
    show_array = prmd(prm_show_array)
    show_json = prmd(prm_show_json)
    If prmd.Exists(prm_out_points) Then
        out_points = prmd(prm_out_points)
    Else
        out_points = 20
    End If
    
    With esp
        Call .init_json(esp_json)
        .h_mes_top_m = h_mes_top
        .freq_Hz = freq_Hz
        For i = 1 To ptq.len
            Call .fluid.init_feed(ptq.feed(i))   ' initialize PVT properties
            Call .fluid.update_feed(ptq.ql(i), ptq.fw(i), ptq.rp(i), ptq.qg(i))
            
            Call .calc_ESP(ptq.p(i), ptq.t(i), ptq.val(i), calc_along_flow, saveCurve:=show_array)
            If ptq.len > 1 Then
                    ptq_out.feed(i) = ptq.feed(i)
                    ptq_out.p_dis(i) = .p_dis_atma
                    ptq_out.t_dis(i) = .t_dis_C
                    ptq_out.p_intake(i) = .p_int_atma
                    ptq_out.t_intake(i) = .t_int_C
            End If
        Next i
        
        If ptq.len = 1 Then
            If show_json Then
                ESP_p_atma = ConvertToJson(.get_result_dict(0, show_array, show_log, 2))
            Else
                arr = .get_results_array(out_points, show_log)
                If calc_along_flow Then
                    arr(0, 0) = .p_dis_atma
                    arr(1, 0) = "p_dis_atma"
                Else
                    arr(0, 0) = .p_int_atma
                    arr(1, 0) = "p_intake_atma"
                End If
                arr(0, 0) = arr(0, num_value)
                arr(1, 0) = arr(1, num_value)
                
                If show_array Then
                    ESP_p_atma = arr
                Else
                    ESP_p_atma = arr(0, 0)
                End If
            End If
        Else
            ESP_p_atma = convert_to_json_ptesp(ptq_out)
        End If
    End With
    Exit Function
er1:
    ESP_p_atma = "error:ESP_p_atma: " & Err.Description
End Function
'=======================================================
'
'=======================================================
'
' корректировка напора развиваемого ЭЦН из влияния газа
' на основе стендовых испытаний Горидько К в 2020 - 2021 году 26.04.2021
Public Function gas_corr(Optional gf As Double = 1, Optional q As Double = 50)
'
'
'
    Dim arr(1 To 12, 1 To 20) As Double
    Dim X(1 To 12, 1 To 1) As Double
    Dim y(1 To 1, 1 To 20) As Double
    
    Dim a As Variant
    Dim x_ As Variant
    Dim y_ As Variant
    
    a = Array(Array(1, 0.94488189, 0.535433071, 0.322834646, 0.299212598, 0.291338583, 0.267716535, 0.251968504, 0.220472441, 0.196850394, 0.173228346, 0.141732283), _
    Array(1, 0.952380952, 0.634920635, 0.428571429, 0.396825397, 0.380952381, 0.357142857, 0.333333333, 0.293650794, 0.261904762, 0.23015873, 0.19047619), _
    Array(1, 0.96, 0.736, 0.536, 0.496, 0.472, 0.448, 0.416, 0.368, 0.328, 0.288, 0.24), _
    Array(1, 0.97199341, 0.827018122, 0.658978583, 0.601317957, 0.57660626, 0.551894563, 0.510708402, 0.461285008, 0.39538715, 0.345963756, 0.28830313), _
    Array(1, 0.979831933, 0.87394958, 0.722689076, 0.655462185, 0.621848739, 0.596638655, 0.554621849, 0.487394958, 0.428571429, 0.369747899, 0.305882353), _
    Array(1, 0.982905983, 0.907692308, 0.774358974, 0.700854701, 0.666666667, 0.632478632, 0.581196581, 0.514529915, 0.444444444, 0.384615385, 0.290598291), _
    Array(1, 0.98540146, 0.948905109, 0.857664234, 0.775547445, 0.708029197, 0.638686131, 0.565693431, 0.501824818, 0.419708029, 0.328467153, 0.200729927), _
    Array(1, 0.983935743, 0.963855422, 0.893574297, 0.799196787, 0.698795181, 0.592369478, 0.512048193, 0.441767068, 0.335341365, 0.200803213, -1.11468E-17), _
    Array(1, 0.985324948, 0.964360587, 0.903563941, 0.807127883, 0.693920335, 0.58490566, 0.503144654, 0.419287212, 0.299790356, 0.146750524, -0.1), _
    Array(1, 0.983796296, 0.965277778, 0.909722222, 0.805555556, 0.659722222, 0.546296296, 0.428240741, 0.300925926, 0.122685185, -0.162037037, -0.6), _
    Array(1, 0.987951807, 0.963855422, 0.910843373, 0.8, 0.648192771, 0.530120482, 0.397590361, 0.240963855, 0.024096386, -0.361445783, -1.1), _
    Array(1, 0.986842105, 0.960526316, 0.907894737, 0.784210526, 0.626315789, 0.497368421, 0.342105263, 0.131578947, -0.263157895, -0.789473684, -1.789473684), _
    Array(1, 0.984615385, 0.950769231, 0.892307692, 0.753846154, 0.584615385, 0.415384615, 0.215384615, -0.307692308, -1, -2, -3), _
    Array(1, 0.98245614, 0.936842105, 0.870175439, 0.698245614, 0.526315789, 0.333333333, -0.070175439, -1, -2, -3, -4), _
    Array(1, 0.980392157, 0.921568627, 0.843137255, 0.654901961, 0.470588235, 0.254901961, -0.392156863, -2, -3, -4, -5), _
    Array(1, 0.980392157, 0.892156863, 0.794117647, 0.56372549, 0.367647059, 0, -1.5, -5, -6, -7, -8), _
    Array(1, 0.981818182, 0.848484848, 0.727272727, 0.478787879, 0.181818182, -0.363636364, -3, -7, -8, -9, -10), _
    Array(1, 0.954545455, 0.718181818, 0.536363636, 0.227272727, -0.454545455, -1.818181818, -6, -10, -11, -12, -13), _
    Array(1, 0.9, 0.2, 0.05, -0.5, -2, -5, -11, -15, -16, -17, -18), _
    Array(1, 0.7, -0.5, -0.7, -1.5, -5, -10, -17, -20, -21, -22, -24))
    
    
    x_ = Array(0, 1, 2, 3, 5, 7, 9, 12, 15, 18, 21, 25)
    y_ = Array(0, 11, 21, 32, 37, 42, 53, 63, 65, 72, 74, 77, 81, 84, 86, 89, 92, 95, 100, 105)
    
    
    Dim i As Integer
    Dim j As Integer
    
    For i = 1 To 12
        X(i, 1) = x_(i - 1)
        For j = 1 To 20
            arr(i, j) = a(j - 1)(i - 1)
            If i = 1 Then y(1, j) = y_(j - 1)
        Next j
    Next i
    
    Dim arg(1 To 1, 1 To 2) As Double
    arg(1, 1) = q
    arg(1, 2) = gf
    gas_corr = crv_interpolation_2D(y, X, arr, arg)(1, 1)
End Function
'======================================================================
'description_to_manual      - для автогенерации
' функция расчета параметров двигателя по заданному моменту на валу
Public Function ESP_motor_calc_mom(ByVal mom_Nm As Double, _
                          Optional ByVal freq_Hz As Double = 50, _
                          Optional ByVal U_V As Double = -1, _
                          Optional ByVal motor_json As String = "", _
                          Optional ByVal cable_json As String = "", _
                          Optional ByVal param As String = "")
                          
' mom_Nm      - момент развиваемый двигателем на валу, Нм
' freq_Hz     - частота вращения внешнего поля
' U_V         - напряжение рабочее, на поверхности, линейное, В
'               если задана кабельная линия, то учитывается
' motor_json  - строка с закодированными данными ПЭД
' cable_json  - строка с закодированными параметрами кабеля
' param       - строка с закодированными параметрами
'description_end
On Error GoTo er1:
    Dim prmd As Dictionary
    Dim motor As New CESPMotor
    Dim show_log As Boolean
    Dim show_array As Boolean
     
    Call motor.init_json(motor_json, cable_json)
    Set prmd = param_to_dict(param)
    show_log = prmd(prm_show_log)
    show_array = prmd(prm_show_array)
    Call motor.calc_motor_mom_surf_Nm(mom_Nm, freq_Hz, U_V)
    
    With motor.data
        If show_array Then
            ESP_motor_calc_mom = motor.get_result_array(show_log)
        Else
            ESP_motor_calc_mom = ConvertToJson(motor.get_result_dict(show_log))
        End If
    End With
    Exit Function
er1:
On Error GoTo er2:
    motor.add_log_msg "Error:ESP_motor_calc_mom: exit function "
    ESP_motor_calc_mom = motor.log_.get_str_safe(show_log)
    Exit Function
    
er2:
    ESP_motor_calc_mom = "error"
End Function
'description_to_manual      - для автогенерации
' функция выдает номинальные параметры ПЭД, корректированные на частоту
Public Function ESP_motor_nameplate( _
                          Optional ByVal motor_json As String = "", _
                          Optional ByVal cable_json As String = "", _
                          Optional ByVal freq_Hz As Double = 50, _
                          Optional ByVal param As String = "")
' опциональные параметры
' motor_json  - строка с закодированными данными ПЭД
' cable_json  - строка с закодированными параметрами кабеля
' freq_Hz     - частота тока, Гц
' param       - строка с закодированными параметрами
'   результат   - json c номинальными параметрами
'description_end
On Error GoTo er1:
    Dim prmd As Dictionary
    Dim motor As New CESPMotor
    Dim show_log As Boolean
     
    Call motor.init_json(motor_json, cable_json)
    Set prmd = param_to_dict(param)
    show_log = prmd(prm_show_log)
    ESP_motor_nameplate = ConvertToJson(motor.get_result_nom_dict(show_log, freq_Hz))
    Exit Function
    
er1:
On Error GoTo er2:
    ESP_motor_nameplate = "Error:ESP_motor_calc_mom: exit function." & motor.log_.get_str_safe(show_log)
    Exit Function
    
er2:
    ESP_motor_nameplate = "error"
End Function
'description_to_manual      - для автогенерации
' расчет полной характеристики двигателя от проскальзования
' по заданной величине скольжения (на основе схемы замещения)
Public Function ESP_motor_calc_slip(ByVal s As Double, _
                          Optional ByVal freq_Hz As Double = 50, _
                          Optional ByVal U_V As Double = -1, _
                          Optional ByVal motor_json As String = "", _
                          Optional ByVal cable_json As String = "", _
                          Optional ByVal param As String = "")
                          
' s           - проскальзывание,
' freq_Hz     - частота вращения внешнего поля
' U_V         - напряжение рабочее, на поверхности, линейное, В
'               если задана кабельная линия, то учитывается
' motor_json  - строка с закодированными данными ПЭД
' cable_json  - строка с закодированными параметрами кабеля
' param       - строка с закодированными параметрами
'description_end
On Error GoTo er1:
    Dim arr, arr_name
    Dim prmd As Dictionary
    Dim resd As Dictionary
    
    Dim motor As New CESPMotor
    Dim show_log As Boolean
    Dim show_array As Boolean
     
    Dim sk
    Call motor.init_json(motor_json, cable_json)
    
    Set prmd = param_to_dict(param)
         
    show_log = prmd(prm_show_log)
    show_array = prmd(prm_show_array)
    
    If motor.ID < 2 Then
        ESP_motor_calc_slip = "Error: Motor ID must be 2 to calc from slip"
        Exit Function
    End If
    
    sk = motor.calc_s_M_krit(U_V, freq_Hz)
   ' motor.calc_motor_slip s, freq_Hz, U_V
    
    Call motor.calc_motor_mom_surf_Nm(1, freq_Hz, U_V, s)
    
    With motor.data
        If show_array Then
            ESP_motor_calc_slip = motor.get_result_array(show_log)
        Else
            ESP_motor_calc_slip = ConvertToJson(motor.get_result_dict(show_log))
        End If
    End With
    Exit Function
er1:
On Error GoTo er2:
    motor.add_log_msg "Error:ESP_motor_calc_mom: exit function "
    ESP_motor_calc_slip = motor.log_.get_str_safe(show_log)
    Exit Function
    
er2:
    ESP_motor_calc_slip = "error"
End Function
'description_to_manual      - для автогенерации
' расчет коэффициента сепарации газосепаратора
' по результатам стендовых испытаний РГУ нефти и газа
Public Function ESP_gassep_name( _
                ByVal gsep_type_TYPE As Integer) As String
' MY_SEPFACTOR - Вычисление коэффициента сепрации в точке
'   gsep_type_TYPE    - тип сепаратора (номер от 1 до 29)
'    1  - 'GDNK5'
'    2  - 'VGSA (VORTEX)'
'    3  - 'GDNK5A'
'    4  - 'GSA5-1'
'    5  - 'GSA5-3'
'    6  - 'GSA5-4'
'    7  - 'GSAN-5A'
'    8  - 'GSD-5A'
'    9  - 'GSD5'
'    10 - '3MNGB5'
'    11 - '3MNGB5A'
'    12 - '3MNGDB5'
'    13 - '3MNGDB5A'
'    14 - 'MNGSL5A-M'
'    15 - 'MNGSL5A-TM'
'    16 - 'MNGSL5-M'
'    17 - 'MNGSL5-TM'
'    18 - 'MNGSLM 5'
'    19 - 'MNGD 5'
'    20 - 'GSIK 5A'
'    21 - '338DSR'
'    22 - '400GSR'
'    23 - '400GSV'
'    24 - '400GSVHV'
'    25 - '538 GSR'
'    26 - '538 GSVHV'
'    27 - '400FSR(OLD)'
'    28 - '513GRS(OLD)'
'    29 - '675HRS'
'
'   gas_frac_d       - газосодержание на входе в газосепаратор
'   qliq_sm3day      - дебит жидкости в стандартных условиях
'   freq_Hz          - частота врашения, Гц
'description_end
    Dim GS As New CESPGasSep
    ESP_gassep_name = GS.Separator_Name(gsep_type_TYPE)
    
End Function
'description_to_manual      - для автогенерации
' расчет коэффициента сепарации газосепаратора
' по результатам стендовых испытаний РГУ нефти и газа
Public Function ESP_gassep_ksep_d( _
                ByVal gsep_type_TYPE As Integer, _
                ByVal gas_frac_d As Double, _
                ByVal qliq_sm3day As Double, _
       Optional ByVal freq_Hz As Double = 50) As Double
' MY_SEPFACTOR - Вычисление коэффициента сепрации в точке
'   gsep_type_TYPE    - тип сепаратора (номер от 1 до 29)
'    1  - 'GDNK5'
'    2  - 'VGSA (VORTEX)'
'    3  - 'GDNK5A'
'    4  - 'GSA5-1'
'    5  - 'GSA5-3'
'    6  - 'GSA5-4'
'    7  - 'GSAN-5A'
'    8  - 'GSD-5A'
'    9  - 'GSD5'
'    10 - '3MNGB5'
'    11 - '3MNGB5A'
'    12 - '3MNGDB5'
'    13 - '3MNGDB5A'
'    14 - 'MNGSL5A-M'
'    15 - 'MNGSL5A-TM'
'    16 - 'MNGSL5-M'
'    17 - 'MNGSL5-TM'
'    18 - 'MNGSLM 5'
'    19 - 'MNGD 5'
'    20 - 'GSIK 5A'
'    21 - '338DSR'
'    22 - '400GSR'
'    23 - '400GSV'
'    24 - '400GSVHV'
'    25 - '538 GSR'
'    26 - '538 GSVHV'
'    27 - '400FSR(OLD)'
'    28 - '513GRS(OLD)'
'    29 - '675HRS'
'
'   gas_frac_d       - газосодержание на входе в газосепаратор
'   qliq_sm3day      - дебит жидкости в стандартных условиях
'   freq_Hz          - частота врашения, Гц
'description_end
    Dim GS As New CESPGasSep
    ESP_gassep_ksep_d = GS.my_sepfactor(gsep_type_TYPE, gas_frac_d * 100, qliq_sm3day, freq_Hz * 60) / 100
    
End Function
'description_to_manual      - для автогенерации
' расчет производительности системы УЭЦН
' считает перепад давления, электрические параметры и деградацию КПД
Public Function ESP_system_calc( _
                 ByVal p_calc_atma, _
        Optional ByVal U_surf_high_lin_V As Double, _
        Optional ByVal f_surf_Hz As Double, _
        Optional ByVal power_fact_kW As Double, _
        Optional ByVal t_intake_C = 50, _
        Optional ByVal t_dis_C = 50, _
        Optional ByVal feed As String = "", _
        Optional ByVal pump_json As String = "", _
        Optional ByVal motor_json As String = "", _
        Optional ByVal cable_json As String = "", _
        Optional ByVal gassep_json As String = "", _
        Optional ByVal calc_along_flow As Boolean = True, _
        Optional ByVal param As String = "", _
        Optional ByVal q_liq_sm3day = -1, _
        Optional ByVal fw_perc = -1, _
        Optional ByVal rp_m3m3 = -1, _
        Optional ByVal q_gas_free_sm3day = -1)
' p_calc_atma        - давление для которого делается расчет
'                     либо давление на приеме насоса
'                     либо давление на выкиде насоса
'                     определяется параметром calc_along_flow
' U_surf_high_lin_V - напряжение питания
' f_surf_Hz         - фактическая частота
' power_fact_kW     - фактическое потребление энергии
' t_intake_C       - температура на приеме насоcа
' t_dis_C          - температура на выкиде насоса.
'             если = 0 и calc_along_flow = 1 то рассчитывается
' feed     - параметры потока флюидов json строка. Используйте
'            функцию encode_feed() для генерации
' pump_json - строка с параметрами насоса
' motor_json - строка с параметрами ПЭД
' cable_json - строка с параметрами кабеля ПЭД
' gassep_json - строка с параметрами сепарации флюида на приеме
' calc_along_flow  - режим расчета снизу вверх или сверху вниз
'          calc_along_flow = True => p_atma давление на приеме
'          calc_along_flow = False => p_atma давление на выкиде
' param     - дополнительные параметры расчета потока
' результат   - массив значений включающий
'            перепад давления
'            перепад температур
'            мощность потребляемая с вала, Вт
'            мощность гидравлическая по перекачке жидкости, Вт
'            КПД ЭЦН
'            список неполон
'description_end
    Dim i As Integer
    Dim ptq As PTQ_LIST
    Dim ptq_out As PTESP_LIST
    
On Error GoTo er1:
    Dim ESPsys As New CESPsystem
    
    Call read_PTQ(ptq, feed, p_calc_atma, t_intake_C, ESPsys.log_, t_dis_C, q_liq_sm3day, fw_perc, rp_m3m3, q_gas_free_sm3day)
    Call init_ptesp(ptq_out, ptq)
    Dim col As New Collection
    
    For i = 1 To ptq.len
        With ESPsys
            Call .fluid.init_feed(ptq.feed(i))  ' initialize PVT properties
            Call .fluid.update_feed(ptq.ql(i), ptq.fw(i), ptq.rp(i), ptq.qg(i))
            Call .init_json(pump_json, motor_json, cable_json, gassep_json)
            Call .calc_ESPsys(ptq.p(i), ptq.t(i), ptq.val(i), U_surf_high_lin_V, f_surf_Hz, power_fact_kW, calc_along_flow, saveCurve:=True)
            col.Add ESPsys.get_result_dict
        End With
    Next i
    If ptq.len = 1 Then
        ESP_system_calc = ConvertToJson(ESPsys.get_result_dict)
    Else
        ESP_system_calc = ConvertToJson(col)
    End If
    Exit Function
er1:
    ESP_system_calc = "error:" & Err.Description
    
End Function
'==========================================================================
' функции расчета газлифта
'==========================================================================
' function to calculated gas passage trough orifice or gas valve
' link in K Brawn AL 2A - Craft, Holden, Graves (p.111)
' also found in Mischenko book
'description_to_manual      - для автогенерации
' функция расчета расхода газа через газлифтный клапан/штуцер
' результат массив значений и подписей
Public Function GLV_q_gas_sm3day(ByVal d_mm As Double, _
                                 ByVal p_in_atma As Double, _
                                 ByVal p_out_atma As Double, _
                                 ByVal gamma_g As Double, _
                                 ByVal t_C As Double, _
                        Optional ByVal c_calibr As Double = 1)
' d_mm        - диаметр основного порта клапана, мм
' p_in_atma   - давление на входе в клапан (затруб), атма
' p_out_atma  - давление на выходе клапана (НКТ), атма
' gamma_g     - удельная плотность газа
' t_C         - температура клапана, С
'description_end
On Error GoTo err1:
    Dim k As Double
    Dim d_in As Double
    Dim Pu_psi As Double
    Dim Pd_psi As Double
    Dim Tu_F As Double
    Dim Pd_Pu_crit As Double
    Dim cd As Double  ' discharge coefficient
    Dim g As Double
    Dim C0 As Double, C1 As Double, C2 As Double
    Dim a As Double
    Dim Qg_crit As Double
    Dim qg As Double
    Dim Pd_Pu As Double
    Dim crit As Boolean
    Dim p_crit_out_atma  As Double
    
    crit = False
    Pd_Pu = p_out_atma / p_in_atma
    
    If Pd_Pu >= 1 Then
        GLV_q_gas_sm3day = Array(Array(0, 0, crit), _
                             Array("q_gas_sm3day", "p_crit_atma", "critical flow"))
        Exit Function
    End If
    
    If Pd_Pu <= 0 Then
        GLV_q_gas_sm3day = 0
        Exit Function
    End If
    
    k = 1.31   ' = Cp/Cv (approx 1.31 for natural gases(R Brown) or 1.25 (Mischenko) )
    k = unf_pvt_gas_heat_capacity_ratio(gamma_g, t_C + const_t_K_zero_C)
    
    d_in = d_mm * 0.03937
    a = const_Pi * d_in ^ 2 / 4         'area of choke, sq in.
    Pu_psi = p_in_atma * 14.2233          'upstream pressure, psi
    Pd_psi = p_out_atma * 14.2233          'downstream pressure, psi
    Tu_F = t_C / 100 * 180 + 32
    Pd_Pu_crit = (2 / (k + 1)) ^ (k / (k - 1))
    cd = 0.865
    g = 32.17 'ft/sec^2
    
    C1 = (Pd_Pu_crit ^ (2 / k) - Pd_Pu_crit ^ (1 + 1 / k)) ^ 0.5
    C2 = (2 * g * k / (k - 1)) ^ 0.5
    Qg_crit = 155.5 * cd * a * Pu_psi * C1 * C2 / (gamma_g * (Tu_F + 460)) ^ 0.5 'critical flow ratio, Mcf/d
    Qg_crit = Qg_crit * c_calibr
    p_crit_out_atma = p_in_atma * Pd_Pu_crit
    
    If Pd_Pu <= Pd_Pu_crit Then
        qg = Qg_crit * 28.31993658
        p_out_atma = p_crit_out_atma
        crit = True
    Else
        C0 = ((Pd_Pu ^ (2 / k) - Pd_Pu ^ (1 + 1 / k))) ^ 0.5
        qg = Qg_crit * 28.31993658 * C0 / C1
        crit = False
    End If
    
    GLV_q_gas_sm3day = Array(Array(qg, p_crit_out_atma, crit), _
                             Array("q_gas_sm3day", "p_crit_atma", "critical flow"))
    
    Exit Function
err1:
    
    GLV_q_gas_sm3day = "GLV_q_gas_sm3day:error in function "
End Function
'description_to_manual      - для автогенерации
' функция расчета расхода газа через газлифтный клапан
' с учетом наличия вкруток на выходе клапана.
' результат массив значений и подписей.
Public Function GLV_q_gas_vkr_sm3day(d_port_mm As Double, _
                                     d_vkr_mm As Double, _
                                     p_in_atma As Double, _
                                     p_out_atma As Double, _
                                     gamma_g As Double, _
                                     t_C As Double)
' d_port_mm - диаметр основного порта клапана, мм
' d_vkr_mm  - эффективный диаметр вкруток на выходе, мм
' p_in_atma   - давление на входе в клапан (затруб), атма
' p_out_atma   - давление на выходе клапана (НКТ), атма
' gamma_g   - удельная плотность газа
' t_C       - температура клапана, С
'description_end
    Dim prm As New CSolveParam
    Dim CoeffA(5) As Double
    Dim Func As String
    Dim pv_atma As Double
    Dim q_gas_sm3day As Double
    Dim res1
    Dim res2
    Dim crit1 As Boolean
    Dim crit2 As Boolean
    
    Func = "calc_dq_gas_pv_vkr_valve"
     
    CoeffA(0) = d_port_mm
    CoeffA(1) = d_vkr_mm
    CoeffA(2) = p_in_atma
    CoeffA(3) = p_out_atma
    CoeffA(4) = gamma_g
    CoeffA(5) = t_C
    prm.y_tolerance = 0.01
    
    Call solve_equation_bisection(Func, p_out_atma, p_in_atma, CoeffA, prm)
    pv_atma = prm.x_solution
    res1 = GLV_q_gas_sm3day(d_port_mm, p_in_atma, pv_atma, gamma_g, t_C)
    res2 = GLV_q_gas_sm3day(d_vkr_mm, pv_atma, p_out_atma, gamma_g, t_C)
    q_gas_sm3day = res1(0)(0)
    crit1 = res1(0)(2)
    crit2 = res2(0)(2)
    
    GLV_q_gas_vkr_sm3day = Array(Array(q_gas_sm3day, p_in_atma, pv_atma, p_out_atma, q_gas_sm3day, crit1, crit2), _
                                 Array("q_gas_sm3day", "p_in_atma", "pv_atma", "p_out_atma", "q_gas_sm3day", "crit1", "crit2"))
End Function
'description_to_manual      - для автогенерации
' функция расчета давления на входе или на выходе
' газлифтного клапана (простого) при закачке газа.
' результат массив значений и подписей
Public Function GLV_p_vkr_atma(ByVal d_port_mm As Double, _
                               ByVal d_vkr_mm As Double, _
                               ByVal p_calc_atma As Double, _
                               ByVal q_gas_sm3day As Double, _
                     Optional ByVal gamma_g As Double = 0.6, _
                     Optional ByVal t_C As Double = 25, _
                     Optional ByVal calc_along_flow As Boolean = False)
' d_port_mm     - диаметр порта клапана, мм
' d_vkr_mm      - диаметр вкрутки клапана, мм
' p_calc_atma   - давление на входе (выходе) клапана, атма
' q_gas_sm3day  - расход газа, ст. м3/сут
' gamma_g       - удельная плотность газа
' t_C           - температура в точке установки клапана
' calc_along_flow - направление расчета:
'              0 - против потока (расчет давления на входе);
'              1 - по потоку (расчет давления на выходе).
'description_end
    ' ищем давление внутри клапана
    Dim p_v_atma As Double
    Dim P_in As Double
    Dim P_out As Double
    Dim p_atma As Double
    Dim p2
    Dim p1
    Dim crit1 As Boolean
    Dim crit2 As Boolean
    Dim qg0 As Double
    qg0 = q_gas_sm3day
    
On Error GoTo er1:
    crit1 = False
    crit2 = False
    If calc_along_flow Then
        P_in = p_calc_atma
        p1 = GLV_p_atma(d_port_mm, P_in, q_gas_sm3day, gamma_g, t_C, True)
        p_v_atma = p1(0)(0)
        If p_v_atma < 0 Then
        ' critical flow through the port achived
            q_gas_sm3day = p1(0)(1)
            p_v_atma = p1(0)(2)
            crit1 = True
        End If
    
        If d_vkr_mm > 0 Then
            p2 = GLV_p_atma(d_vkr_mm, p_v_atma, q_gas_sm3day, gamma_g, t_C, True)
            p_atma = p2(0)(0)
            If p_atma < 0 Then
            ' critical flow through the vkrutka achived
                q_gas_sm3day = p2(0)(1)
                p_atma = p2(0)(2)
                crit2 = True
            End If
        Else
            p_atma = p_v_atma
        End If
        P_out = p_atma
        If q_gas_sm3day < qg0 Then
            p_atma = -1
        End If
    Else
        P_out = p_calc_atma
        If d_vkr_mm > 0 Then
            p1 = GLV_p_atma(d_vkr_mm, p_calc_atma, q_gas_sm3day, gamma_g, t_C, False)
            p_v_atma = p1(0)(0)
            If p_v_atma < 0 Then
            ' critical flow through the vkrutka achived
                q_gas_sm3day = p1(0)(1)
                p_v_atma = p1(0)(2)
                crit2 = True
            End If
        Else
            p_v_atma = p_calc_atma
        End If
        p2 = GLV_p_atma(d_port_mm, p_v_atma, q_gas_sm3day, gamma_g, t_C, False)
        p_atma = p2(0)(0)
        If p_atma < 0 Then
        ' critical flow through the port achived
            q_gas_sm3day = p2(0)(1)
            p_atma = p2(0)(2)
            crit1 = True
        End If
        P_in = p_atma
    End If
    GLV_p_vkr_atma = Array(Array(p_atma, P_in, p_v_atma, P_out, q_gas_sm3day, crit1, crit2), _
                           Array("p_atma", "p_in_atma", "p_v_atma", "p_out_atma", "q_gas_sm3day", "port critical flow", "vkrutka critical flow"))
    Exit Function
er1:
    
    GLV_p_vkr_atma = "GLV_p_vkr_atma:error in function : GLV_p_vkr_atma"
End Function
'description_to_manual      - для автогенерации
' функция расчета давления на входе или на выходе
' газлифтного клапана (простого) при закачке газа.
' результат массив значений и подписей
Public Function GLV_p_atma(ByVal d_mm As Double, _
                           ByVal p_calc_atma As Double, _
                           ByVal q_gas_sm3day As Double, _
                           Optional ByVal gamma_g As Double = 0.6, _
                           Optional ByVal t_C As Double = 25, _
                           Optional ByVal calc_along_flow As Boolean = False, _
                           Optional ByVal p_open_atma As Double = 0, _
                           Optional ByVal c_calibr As Double = 1)
' d_mm          - диаметр клапана, мм
' p_calc_atma   - давление на входе (выходе) клапана, атма
' q_gas_sm3day  - расход газа, ст. м3/сут
' gamma_g       - удельная плотность газа
' t_C           - температура в точке установки клапана
' calc_along_flow - направление расчета:
'              0 - против потока (расчет давления на входе);
'              1 - по потоку (расчет давления на выходе).
' p_open_atma    - давление открытия/закрытия клапана, атм
'description_end
On Error GoTo err1:
    Dim Qmax_m3day As Double
    Dim qres
    Dim pd As Double
    Dim Pu As Double
    Dim Pcrit As Double
    Dim k As Double
    Dim Pd_Pu_crit As Double
    Dim crit As Boolean
    
    Dim prm As New CSolveParam
    Dim CoeffA(5) As Double
    Dim Func As String
    
    k = 1.31   ' = Cp/Cv (approx 1.31 for natural gases(R Brown) or 1.25 (Mischenko) )
    Pd_Pu_crit = (2 / (k + 1)) ^ (k / (k - 1))
    CoeffA(0) = q_gas_sm3day
    CoeffA(1) = d_mm
    CoeffA(3) = gamma_g
    CoeffA(4) = t_C
    CoeffA(5) = c_calibr
    prm.y_tolerance = 0.1
    
    If calc_along_flow Then
        Pu = p_calc_atma
        pd = 1
        qres = GLV_q_gas_sm3day(d_mm, Pu, pd, gamma_g, t_C)
        Qmax_m3day = qres(0)(0)
        Pcrit = pd
        If Qmax_m3day > q_gas_sm3day And Pu > p_open_atma Then
            Func = "calc_dq_gas_pd_valve"
            CoeffA(2) = Pu
            crit = False
            Call solve_equation_bisection(Func, Pd_Pu_crit * Pu, Pu, CoeffA, prm)
            GLV_p_atma = Array(Array(prm.x_solution, Qmax_m3day, Pcrit, crit), _
                               Array("p", "Qmax_m3day", "Pcrit", "critical flow"))
        Else
            crit = True
            GLV_p_atma = Array(Array(-1, Qmax_m3day, Pcrit, crit), _
                               Array("p, atma", "Qmax_m3day", "Pcrit", "critical flow"))
        End If
    Else
        Qmax_m3day = q_gas_sm3day
        pd = p_calc_atma
        Pu = 500
        Func = "calc_dq_gas_pu_valve"
        CoeffA(2) = pd
        crit = False
        Call solve_equation_bisection(Func, pd, Pu, CoeffA, prm)
        Dim sol As Double
        sol = prm.x_solution
        If sol < p_open_atma Then
            sol = p_open_atma
        End If
        GLV_p_atma = Array(Array(sol, prm.x_solution, prm.y_solution, Pu, crit), _
                           Array("p_opo_atma", "p, atma", "Q_m3day", "Pu max", "critical flow"))
    End If
        
    Exit Function
err1:
    
    GLV_p_atma = "GLV_p_atma:error in function : GLV_p_atma"
End Function
    
'description_to_manual      - для автогенерации
' функция расчета давления зарядки сильфона на стенде при
' стандартной температуре по данным рабочих давления и температуры
Public Function GLV_p_bellow_atma(ByVal p_atma As Double, _
                                  ByVal t_C As Double) As Double
' p_atma - рабочее давление открытия клапана в скважине, атм
' t_C   - рабочая температура открытия клапана в скважине, С
'description_end
Dim t_F As Double
Dim Ct As Double
Dim M As Double
Dim Pb_psia As Double
    If p_atma > 1 Then
        Pb_psia = p_atma * 14.696
        t_F = t_C * 9 / 5 + 32
        If Pb_psia < 1238 Then
            M = 0.0000003054 * Pb_psia ^ 2 + 0.001934 * Pb_psia - 0.00226
        Else
            M = 0.000000184 * Pb_psia ^ 2 + 0.002298 * Pb_psia - 0.267
        End If
        Ct = 1 / (1 + (t_F - 60) * M / Pb_psia)
        GLV_p_bellow_atma = p_atma * Ct
    End If
End Function
'description_to_manual      - для автогенерации
' фукнция расчета давления в сильфоне с азотом
' в рабочих условиях при заданной температуре
Public Function GLV_p_close_atma(ByVal p_bellow_atm As Double, _
                                 ByVal t_C As Double) As Double
' p_bellow_atm  - давление зарядки сильфона при стандартных условиях
' t_C           - температура рабочая
'description_end
On Error GoTo End1:
'Dim p_psi As Double
Dim t_F As Double
Dim Ct As Double
Dim M As Double
Dim Pb_psia As Double
    
    Pb_psia = p_bellow_atm * 14.696
    t_F = t_C * 9 / 5 + 32
    
    If Pb_psia < 1238 Then
        M = 0.0000003054 * Pb_psia ^ 2 + 0.001934 * Pb_psia - 0.00226
    Else
        M = 0.000000184 * Pb_psia ^ 2 + 0.002298 * Pb_psia - 0.267
    End If
    
    Ct = 1 / (1 + (t_F - 60) * M / Pb_psia)
    
    GLV_p_close_atma = p_bellow_atm / Ct
Exit Function
End1:
GLV_p_close_atma = 0
End Function
'description_to_manual      - для автогенерации
'Функция расчета диаметра порта клапана
'на основе уравнения Thornhill-Crave
Public Function GLV_d_choke_mm(ByVal q_gas_sm3day As Double, _
                               ByVal p_in_atma As Double, _
                               ByVal p_out_atma As Double, _
                               Optional ByVal gamma_g As Double = 0.6, _
                               Optional ByVal t_C As Double = 25)
' q_gas_sm3day  - расход газа, ст. м3/сут
' p_in_atma   - давление на входе в клапан (затруб), атма
' p_out_atma   - давление на выходе клапана (НКТ), атма
' gamma_g   - удельная плотность газа
' t_C       - температура клапана, С
'description_end
On Error GoTo err1:
    If q_gas_sm3day <= 0 Then
        GLV_d_choke_mm = 0
        Exit Function
    End If
    
    If p_in_atma < p_out_atma Then
        GLV_d_choke_mm = -1
        Exit Function
    End If
    Dim k As Double
    k = 1.31   ' = Cp/Cv (approx 1.31 for natural gases(R Brown) or 1.25 (Mischenko) )
    
    Dim Pu_psi As Double
    Dim Pd_psi As Double
    Pu_psi = p_in_atma * 14.2233 'upstream pressure, psi
    Pd_psi = p_out_atma * 14.2233 'downstream pressure, psi
    
    Dim Tu_F As Double
    Tu_F = t_C / 100 * 180 + 32
    
    Dim cd As Double  ' discharge coefficient
    cd = 0.865
    
    Dim g As Double
    g = 32.17 'ft/sec^2
    
    Dim Qg_Mcfd As Double
    Qg_Mcfd = q_gas_sm3day / 28.31993658
    
    Dim Pd_Pu_crit As Double
    Pd_Pu_crit = (2 / (k + 1)) ^ (k / (k - 1))
    
    Dim Pd_Pu As Double
    Pd_Pu = p_out_atma / p_in_atma
    
    Dim C0 As Double, C1 As Double, C2 As Double
    C0 = ((Pd_Pu ^ (2 / k) - Pd_Pu ^ (1 + 1 / k))) ^ 0.5
    C1 = (Pd_Pu_crit ^ (2 / k) - Pd_Pu_crit ^ (1 + 1 / k)) ^ 0.5
    C2 = (2 * g * k / (k - 1)) ^ 0.5
    
    Dim a As Double
    
    If Pd_Pu <= Pd_Pu_crit Then
        a = Qg_Mcfd / (155.5 * cd * Pu_psi * C1 * C2 / (gamma_g * (Tu_F + 460)) ^ 0.5)
    Else
        a = Qg_Mcfd / (155.5 * cd * Pu_psi * C0 * C2 / (gamma_g * (Tu_F + 460)) ^ 0.5)
    End If
    
    Dim d_in As Double
    d_in = (a * 4 / Application.pi) ^ 0.5
    
    GLV_d_choke_mm = d_in / 0.03937
    
    
    Exit Function
err1:
    GLV_d_choke_mm = "error in function : GL_dchoke_mm"
End Function
'description_to_manual      - для автогенерации
'Функция расчета давления открытия газлифтного клапана R1
Public Function GLV_IPO_p_open(ByVal p_bellow_atma As Double, _
                          ByVal p_out_atma As Double, _
                          ByVal t_C As Double, _
                 Optional ByVal GLV_type As Integer = 0, _
                 Optional ByVal d_port_mm As Double = 5, _
                 Optional ByVal d_vkr1_mm As Double = -1, _
                 Optional ByVal d_vkr2_mm As Double = -1, _
                 Optional ByVal d_vkr3_mm As Double = -1, _
                 Optional ByVal d_vkr4_mm As Double = -1, _
                 Optional ByVal gamma_gas As Double = 0.8)
' p_bellow_atma - давление зарядки сильфона на стенде, атма
' p_out_atma    - давление на выходе клапана (НКТ), атма
' t_C           - температура клапана в рабочих условиях, С
' GLV_type      - тип газлифтного клапана (сейчас только R1)
' d_port_mm     - диаметр порта клапана
' d_vkr1_mm     - диаметр вкрутки 1, если есть
' d_vkr2_mm     - диаметр вкрутки 2, если есть
' d_vkr3_mm     - диаметр вкрутки 3, если есть
' d_vkr4_mm     - диаметр вкрутки 4, если есть
' gamma_gas     - плотность газа
'description_end
    Dim GLV As New CGLvalve
    GLV.gamma_gas = gamma_gas
    Call GLV.set_GLV_R1(True, d_port_mm, d_vkr1_mm, d_vkr2_mm, d_vkr3_mm, d_vkr4_mm)
    GLV.p_bellow_sc_atma = p_bellow_atma
    GLV.p_out_atma = p_out_atma
    GLV.t_C = t_C
    GLV_IPO_p_open = GLV.p_open_atma
End Function
'description_to_manual      - для автогенерации
'Функция расчета давления открытия газлифтного клапана R1
Public Function GLV_IPO_p_atma(ByVal p_bellow_atma As Double, _
                          ByVal d_port_mm As Double, _
                          ByVal p_calc_atma As Double, _
                          ByVal q_gas_sm3day As Double, _
                          ByVal t_C As Double, _
                 Optional ByVal calc_along_flow As Boolean = False, _
                 Optional ByVal GLV_type As Integer = 0, _
                 Optional ByVal d_vkr1_mm As Double = -1, _
                 Optional ByVal d_vkr2_mm As Double = -1, _
                 Optional ByVal d_vkr3_mm As Double = -1, _
                 Optional ByVal d_vkr4_mm As Double = -1, _
                 Optional ByVal gamma_gas As Double = 0.8)
' p_bellow_atma - давление зарядки сильфона на стенде, атма
' d_port_mm     - диаметр порта клапана
' p_calc_atma   - давление на выходе клапана (НКТ), атма
' q_gas_sm3day  - расход газа
' t_C           - температура клапана в рабочих условиях, С
' calc_along_flow - направление расчета
' GLV_type      - тип газлифтного клапана (сейчас только R1)
' d_vkr1_mm     - диаметр вкрутки 1, если есть
' d_vkr2_mm     - диаметр вкрутки 2, если есть
' d_vkr3_mm     - диаметр вкрутки 3, если есть
' d_vkr4_mm     - диаметр вкрутки 4, если есть
' gamma_gas     - плотность газа
'description_end
    Dim GLV As New CGLvalve
    GLV.gamma_gas = gamma_gas
    
    Call GLV.set_GLV_R1(True, d_port_mm, d_vkr1_mm, d_vkr2_mm, d_vkr3_mm, d_vkr4_mm)
    GLV.p_bellow_sc_atma = p_bellow_atma
    Dim res
    If calc_along_flow Then
        res = GLV.calc_p_out_atma(p_calc_atma, q_gas_sm3day)
    Else
        res = GLV.calc_p_in_atma(p_calc_atma, q_gas_sm3day)
    End If
    GLV.t_C = t_C
    GLV_IPO_p_atma = GLV.p_open_atma
End Function
'description_to_manual      - для автогенерации
'Функция расчета давления закрытия газлифтного клапана R1
Public Function GLV_IPO_p_close(ByVal p_bellow_atma As Double, _
                              ByVal p_out_atma As Double, _
                              ByVal t_C As Double, _
                 Optional ByVal GLV_type As Integer = 0, _
                 Optional ByVal d_port_mm As Double = 5, _
                 Optional ByVal d_vkr1_mm As Double = -1, _
                 Optional ByVal d_vkr2_mm As Double = -1, _
                 Optional ByVal d_vkr3_mm As Double = -1, _
                 Optional ByVal d_vkr4_mm As Double = -1, _
                 Optional ByVal gamma_gas As Double = 0.8)
' p_bellow_atma - давление зарядки сильфона на стенде, атма
' p_out_atma    - давление на выходе клапана (НКТ), атма
' t_C           - температура клапана в рабочих условиях, С
' GLV_type      - тип газлифтного клапана (сейчас только R1)
' d_port_mm     - диаметр порта клапана
' d_vkr1_mm     - диаметр вкрутки 1, если есть
' d_vkr2_mm     - диаметр вкрутки 2, если есть
' d_vkr3_mm     - диаметр вкрутки 3, если есть
' d_vkr4_mm     - диаметр вкрутки 4, если есть
' gamma_gas     - плотность газа
'description_end
    Dim GLV As New CGLvalve
    GLV.gamma_gas = gamma_gas
    
    Call GLV.set_GLV_R1(True, d_port_mm, d_vkr1_mm, d_vkr2_mm, d_vkr3_mm, d_vkr4_mm)
    GLV.p_bellow_sc_atma = p_bellow_atma
    GLV.t_C = t_C
    GLV_IPO_p_close = GLV.p_open_atma
End Function
'
'Function GL_dPgasPipe_atmg(ByVal h_m As Double, ByVal P_atmg As Double, ByVal t_C As Double, _
'                               Optional ByVal d_cas_mm As Double = 125, _
'                               Optional ByVal dtub_mm As Double = 73, _
'                               Optional ByVal gamma_gas As Double = 0.8, _
'                               Optional ByVal q_gas_scm3day As Double = 10000, _
'                               Optional ByVal roughness As Double = 0.001, _
'                               Optional ByVal THETA As Double = 90 _
'                               ) As Double
'
''de - external diameter, m
''di - interior diameter, m
''gamma_gas - relative density of gas
''qg_sc - gas flow, m3/d
''eps - pipe roughness, m
''theta - ,degree
''length - pipe length, m
''T - temperature, C
''P - pressure, atma
'On Error GoTo err1:
'Dim de, Di, qg_sc, eps, length, t, p
'de = d_cas_mm / 1000
'Di = dtub_mm / 1000
'
'qg_sc = q_gas_scm3day
'eps = roughness
'length = h_m
't = t_C
'p = P_atmg
'
'    'convert m3/d to scf/d
'    qg_sc = qg_sc * 3.28 ^ 3
'
'    Dim p_MPa As Double, p_psi As Double
'    p_MPa = p * 0.1013 'convert atma to Mpa
'    p_psi = p * 14.696 ' convert atma to psi
'
'
'    Dim t_K As Double, t_F As Double
'    t_K = t + 273 'convert Celcsius to Kelvin
'    t_F = (9 / 5) * t + 32 'convert Celcsius to Fahrengheit
'
'    Dim T_pc As Double
'    Dim p_pc As Double
'    Dim z As Double
'
''        T_pc = PseudoTemperatureStanding(gamma_gas)
''        p_pc = PseudoPressureStanding(gamma_gas)
''        Z = ZFactorDranchuk(T_K / T_pc, P_MPa / p_pc)
'    z = unf_pvt_Zgas_d(t_K, p_MPa, gamma_gas)
'
'    eps = eps * 39.3701 'convert m to in
'
'    Dim de_in As Double, di_in As Double
'    di_in = Di * 39.3701 'convert m to in
'    de_in = de * 39.3701 'convert m to in
'
'    Dim dh As Double, DA As Double, deq As Double
'    dh = de_in - di_in
'    DA = (de_in ^ 2 - di_in ^ 2) ^ 0.5
'
'    If di_in = 0 Then
'        deq = de_in
'    Else
'        deq = (de_in ^ 2 + di_in ^ 2 - (de_in ^ 2 - di_in ^ 2) / Log(de_in / di_in)) / (de_in - di_in)
'    End If
'
'
'    Dim mu_g As Double
'    mu_g = unf_pvt_viscosity_gas_cP(t_K, p_MPa, z, gamma_gas)
'
'    Dim Re As Double
'    Re = 0.020107 * gamma_gas * Abs(qg_sc) * deq / mu_g / DA ^ 2
'
'
'    Dim a As Double, B As Double
'    a = (2.457 * Log(1 / ((7 / Re) ^ 0.9 + 0.27 * eps / deq))) ^ 16
'    B = (37530 / Re) ^ 16
'
'    Dim f_moody As Double
'    f_moody = 8 * ((8 / Re) ^ 12 + 1 / ((a + B) ^ 1.5)) ^ (1 / 12)
'
'    Dim gradP As Double
'
'    gradP = -0.018786 * gamma_gas * (p_psi + 14.7) * Sin(THETA * Application.pi / 180) / (t_F + 460) / z + (1.2595 * 10 ^ (-11)) * f_moody * (t_F + 460) * z * gamma_gas * (qg_sc ^ 2) / (p_psi + 14.7) / dh / DA ^ 4
'    gradP = gradP * 0.068 / 0.3048 'convert psi/ft to atma/m
'
'    GL_dPgasPipe_atmg = p + gradP * length
'
'    Exit Function
'err1:
'
'    GL_dPgasPipe_atmg = "GL_dPgasPipe_atmg: error in function : GL_dPgasPipe_atmg"
'
'
'End Function
'=======================================================================
' расчет скважины
'=======================================================================
'description_to_manual      - для автогенерации
' расчет натуральной сепарации газа на приеме насоса
Public Function well_ksep_natural_d( _
             ByVal feed As String, _
             ByVal p_intake_atma, _
    Optional ByVal t_intake_C = 50, _
    Optional ByVal d_intake_mm As Double = 90, _
    Optional ByVal d_cas_mm As Double = 120, _
    Optional ByVal model As Integer = 0, _
    Optional ByVal pkv_prod_period_ratio As Double = 0.5, _
    Optional ByVal h_intake_m As Double = 0.1, _
    Optional ByVal h_perf_m As Double = 1, _
    Optional param As String = "")
' feed          - закодированные параметры потока флюидов
' p_intake_atma - давление сепарации
' t_intake_C    - температура сепарации
' d_intake_mm   - диаметр приемной сетки
' d_cas_mm      - диаметр эксплуатационной колонны
' model - тип модели: 0 - упрощенная Маркеса для ЭЦН, 1 - механистическая Маркеса для ЭЦН,
'               2  - механистическая с ЭЦН ниже перфорации,
'               3  - механистическая для скважин ПКВ.
' pkv_prod_period_ratio - для ПКВ отношение времени работы к времени цикла
' h_intake_m - высота приемной сейти насоса, м
' h_perf_m - высота интервала перфорации (для модели ЭЦН ниже перфорации), м
' param       - дополнительные параметры расчета
' результат     - число - естественная сепарация
'description_end
On Error GoTo err1:
    Dim prmd As Dictionary
    Dim show_array As Boolean
    Dim show_json As Boolean
    Dim calibr_li As Double
    Dim calibr_st As Double
  '  Dim gas_goes_into_solution As Double
    
    Dim fluid As New CPVT
    
    Dim fluid_annular As CPVT
    Dim fluid_pump As CPVT
    
    ' переменные для чтения списков данных
    Dim ptq As PTQ_LIST
    Dim ptq_out As PTQ_LIST
    
    Dim col_res As New Collection
    Dim i As Integer
    Dim ksep_ As Double
    Dim resksep
    
    Call read_PTQ(ptq, feed, p_intake_atma, t_intake_C, fluid.log_, 0, 0, 0, 0, 0)
    Call init_ptq(ptq_out, ptq)
    
    ' читаем параметры
    Set prmd = param_to_dict(param)
    show_array = prmd(prm_show_array)
    show_json = prmd(prm_show_json)
   ' gas_goes_into_solution = prmd(prm_gas_goes_into_solution)
    calibr_li = 1
    calibr_st = 1
    If prmd.Exists("calibr_li") Then calibr_li = prmd("calibr_li")
    If prmd.Exists("calibr_st") Then calibr_st = prmd("calibr_st")
    For i = 1 To ptq.len
        
        Call fluid.init_feed(ptq.feed(i))
        
        Call fluid.calc_PVT(ptq.p(i), ptq.t(i))
        
        Set fluid_pump = fluid.clone
        
        With fluid
            Select Case model
                Case 0
                
                    ksep_ = unf_ksep_ESP_natural_simplified_Marquez(d_intake_mm / 1000, d_cas_mm / 1000, .qliq_rc_m3day, .q_gas_rc_m3day, _
                                                    .sigma_liq_Nm, .rho_liq_rc_kgm3, .rho_gas_rc_kgm3)
                    Call fluid_pump.mod_after_separation(ptq.p(i), ptq.t(i), ksep_, gas_goes_into_solution:=1)
                Case 1
                
                    ksep_ = unf_ksep_ESP_natural_mechanistic_Marquez(d_intake_mm / 1000, d_cas_mm / 1000, .qliq_rc_m3day, .q_gas_rc_m3day, _
                                                     .sigma_liq_Nm, .rho_liq_rc_kgm3, .rho_gas_rc_kgm3, _
                                                     .mu_liq_cP, .mu_gas_cP, 1, h_intake_m, calibr_li, calibr_st)
                    Call fluid_pump.mod_after_separation(ptq.p(i), ptq.t(i), ksep_, gas_goes_into_solution:=1)
                Case 2
                
                    ksep_ = unf_ksep_ESP_natural_mechanistic_pump_below_perf(d_intake_mm / 1000, d_cas_mm / 1000, .qliq_rc_m3day, .q_gas_rc_m3day, _
                                                     .sigma_liq_Nm, .rho_liq_rc_kgm3, .rho_gas_rc_kgm3, _
                                                     .mu_liq_cP, .mu_gas_cP, 1, h_perf_m, calibr_li, calibr_st)
                    Call fluid_pump.mod_after_separation(ptq.p(i), ptq.t(i), ksep_, gas_goes_into_solution:=1)
                Case 3
                    resksep = unf_ksep_ESP_natural_mechanistic_pkv(d_intake_mm / 1000, d_cas_mm / 1000, .qliq_rc_m3day, .q_gas_rc_m3day, _
                                                     .sigma_liq_Nm, .rho_liq_rc_kgm3, .rho_gas_rc_kgm3, _
                                                     .mu_liq_cP, .mu_gas_cP, 0, h_intake_m, calibr_li, calibr_st, pkv_prod_period_ratio)
                    ' для пкв режима поток поступающий в насос состоит из двух - из пласта и из затруба
                    ' подготовим далее параметры этих потоков и смешаем их, чтобы получить для расчетов смешанный поток для насоса
                    ksep_ = resksep(0)(0)
                    Dim ksep_av As Double
                    Dim ksep_ann As Double
                    
                    ksep_av = resksep(0)(7)
                    
                    If ksep_av > 0 Then
                    
                        If ksep_ < 0.01 And ksep_av < 0.1 Then
                            ksep_ann = 0.1
                        Else
                            ksep_ann = 0.99
                        End If
                        Set fluid_annular = fluid.clone
                        
                        ' для флюида из затруба уберем весь газ из потока (ксеп = 1)
                        Call fluid_annular.mod_after_separation(ptq.p(i), ptq.t(i), ksep_ann, gas_goes_into_solution:=1)
                        ' учтем, что из затруба объем жидкости определяется пкв отношением
                        fluid_annular.q_liq_sm3day = fluid.q_liq_sm3day * 1 / (pkv_prod_period_ratio) * (1 - pkv_prod_period_ratio)
                        ' может быть можно было бы учесть, что поменяется обводненность - но пока не будем
                        
                        fluid_annular.rp_m3m3 = fluid_annular.rsb_m3m3
                        
                        Call fluid_annular.calc_PVT(ptq.p(i), ptq.t(i))
                        Call fluid_pump.calc_PVT(ptq.p(i), ptq.t(i))
                        
                        Dim qgf1 As Double, qgf2 As Double
                        
                        qgf1 = fluid_annular.q_gas_rc_m3day
                        qgf2 = fluid_pump.q_gas_rc_m3day
                        
                        Call fluid_pump.mod_after_separation(ptq.p(i), ptq.t(i), ksep_, gas_goes_into_solution:=1)
                        
                        
                        Call fluid_annular.calc_PVT(ptq.p(i), ptq.t(i))
                        Call fluid_pump.calc_PVT(ptq.p(i), ptq.t(i))
                        
                        qgf1 = fluid_annular.q_gas_rc_m3day
                        qgf2 = fluid_pump.q_gas_rc_m3day
                        
                        Set fluid_pump = feed_mod_mix_obj(fluid_pump, fluid_annular)
                    Else
                        ksep_ = 0
                        Call fluid_pump.mod_after_separation(ptq.p(i), ptq.t(i), ksep_, gas_goes_into_solution:=1)
                    End If
            End Select
            
            ptq_out.val(i) = Round(ksep_, 5)
            ptq_out.feed(i) = fluid_pump.feed
            ptq_out.p(i) = ptq.p(i)
            ptq_out.t(i) = ptq.t(i)
        End With
    Next i
    
    
    Dim d As Dictionary
    Set d = convert_to_dict_ptq(ptq_out)
    d("k_sep") = ptq_out.val
    
    If ptq.len = 1 Then
        If show_array Then
            Dim res, resd
            res = Array(ptq_out.val(1), ptq_out.feed(1), ptq_out.p(1), ptq_out.t(1))
            resd = Array("ksep", "feed pump", "p, atma", "t, C")
            well_ksep_natural_d = Array(res, resd)
        ElseIf show_json Then
            Dim dd As New Dictionary
            dd("k_sep") = ptq_out.val(1)
            Set dd("feed") = ParseJson(ptq_out.feed(1))
            dd("p") = ptq_out.p(1)
            dd("t") = ptq_out.t(1)
            well_ksep_natural_d = ConvertToJson(dd)
        Else
            well_ksep_natural_d = ptq_out.val(1)
        End If
    Else
        well_ksep_natural_d = ConvertToJson(d)
    End If
    Exit Function
err1:
    well_ksep_natural_d = Err.Description
End Function
'description_to_manual      - для автогенерации
' расчет общей сепарации на приеме насоса
Public Function well_ksep_total_d( _
        ByVal SepNat, _
        ByVal SepGasSep As Double)
' SepNat        - естественная сепарация
' SepGasSep     - искусственная сепарация (газосепаратор)
'description_end
    Dim sep_nat
    Dim i As Integer
    Dim c As New Collection
    
    sep_nat = parse_list(SepNat)
    If UBound(sep_nat) - LBound(sep_nat) + 1 = 1 Then
        well_ksep_total_d = SepNat + (1 - SepNat) * SepGasSep
    Else
        For i = LBound(sep_nat) To UBound(sep_nat)
            c.Add sep_nat(i) + (1 - sep_nat(i)) * SepGasSep
        Next i
        well_ksep_total_d = ConvertToJson(c)
    End If
End Function
'description_end
'description_to_manual      - для автогенерации
'расчет распределения давления и температуры в скважине
'на основе забойного давления (расчет снизу вверх)
Public Function well_calc_from_pwf(ByVal p_wf_atma As Double, _
                                   ByVal t_wf_C, _
                                   ByVal feed_json As String, _
                                   ByVal construction_json As String, _
                                   ByVal esp_json As String, _
                                   ByVal t_model_json As String, _
                                   ByVal h_perf_m As Double, _
                                   ByVal h_esp_m As Double, _
                          Optional ByVal calibr_grav As Double = 1, _
                          Optional ByVal calibr_fric As Double = 1, _
                          Optional ByVal ksep As Double = 0.5, _
                          Optional ByVal IPR_json As String = "", _
                          Optional ByVal t_crit_C As Double = 0, _
                          Optional ByVal p_cas_atma = 0, _
                          Optional ByVal flow_corr As Integer = 0, _
                          Optional ByVal fast As Boolean = False, _
                          Optional ByVal pkv_ratio As Double = 0.5, _
                          Optional ByVal dcas_mm As Double = 125, _
                          Optional ByVal dint_mm As Double = 110)
'p_wf_atma - забойное давление
't_wf_C - температура флюида на забое скважины
'feed_json - параметры потока в скважине (с забоя)
'construction_json - конструкция скважины (как для трубы)
'esp_json - параметры ЭЦН, используйте encode_esp_pump
'           если не заданы, то скважина фонтанирующая
't_model_json - температурная модель, рекомендуется модель 2
'h_perf_m - глубина верхних дыр перфорации, точка расчета забойного
'           давления
'h_esp_m - глубина спуска ЭЦН. Длина ЭЦН игнорируется
'          в конструкции диаметры должны учитывать глубину спуска ЭЦН
'calibr_grav - калибровка для гидравлической корреляции по гравитации
'calibr_fric - калибровка для гидравлической корреляции по трению
'ksep - общий коэффициент сепарации газа на приеме ЭЦН, если 0 то
'       будет рассчитываться
'ipr_json - параметры пласта, используйте encode_ipr
'           если не заданы, считается для постоянного дебита из feed_json
't_crit_C - критическая температура для АСПО
'          в результатах будет вычислена глубина достижения t_crit_C
'p_cas_atma - затрубное давление, если задано будет рассчитан h_dyn_m
'flow_corr - номер гидравлической корреляции, как для трубы
'fast - флаг, если 1 то будет рассчитано только давление,
'       если 0 - то результат json с кривыми
'pkv_ratio - отношение ПКВ (работа на цикл). Если больше 0 будет учитываться
'description_end
On Error GoTo er1:
    Const calc_along_coord = False
    Const flow_along_coord = False
    
    Dim esp As New CESPpump
    Dim pipe_below_esp As New CPipe
    Dim pipe_above_esp As New CPipe
    Dim pipe_casing_liq As New CPipe
    Dim pipe_casing_gas As New CPipe
    Dim ipr_vogel As New CReservoirVogel
    
    Dim res1 As PTtype
    Dim p_intake_atma As Double
    Dim t_intake_C As Double
    Dim p_dis_atma As Double
    Dim t_dis_C As Double
    Dim p_buf_atma As Double
    Dim t_buf_C As Double
    Dim q_liq_sm3day As Double
    
    Dim feed_sep As String
    Dim gas_fraction As Double
    Dim qgas_cas_sm3day As Double
    
    Dim f As Dictionary
    Dim dout As New Dictionary
    
    Dim crv_p As New CInterpolation
    Dim crv_t As New CInterpolation
    Dim crv_cas_p As New CInterpolation
    
    Dim n_sol As Integer
    Dim h_crit
    
' расчет снизу вверх по заданному забойному давлению
    Set f = ParseJson(feed_json)
    q_liq_sm3day = f("q_liq_sm3day")
' 0. если задана IPR  то пытаемся оценить дебит
    If Len(IPR_json) > 0 Then
        Call ipr_vogel.init_json(IPR_json)
        q_liq_sm3day = ipr_vogel.calc_q_liq_sm3day(p_wf_atma)
        
        f("q_liq_sm3day") = q_liq_sm3day
        feed_json = ConvertToJson(f)
        
    End If
' 1. расчет участка э/к от забоя до приема насоса
' инициализируем трубу с первым фидом, который всегда есть
    
    Set pipe_below_esp = new_pipeline(construction_json, _
                                                t_model_json, _
                                                calc_along_coord, _
                                                flow_along_coord, _
                                                flow_corr, _
                                                calibr_grav, _
                                                calibr_fric, _
                                                h_esp_m + 1, h_perf_m)
    If fast Then
        res1 = pipe_below_esp.calc_dPipe(p_wf_atma, t_wf_C, noCurves)
    Else
        res1 = pipe_below_esp.calc_dPipe(p_wf_atma, t_wf_C, mainCurves)
    End If
    p_intake_atma = res1.p_atma
    t_intake_C = res1.t_C
    
    
                Dim rksep As String
                Dim dcasep As Dictionary
 
    
    If Len(esp_json) > 1 Then
        ' если данные по ЭЦН есть - пытаемся их анализировать
        ' 2. расчет свойств потока с учетом сепарации газа
        If ksep > 0 Then
            feed_sep = feed_mod_separate_gas(ksep, p_intake_atma, t_intake_C, feed_json)
        Else
            ' если ксеп не задан - пытаемся оценить по корреляции
            If pkv_ratio = 0 Then
                rksep = well_ksep_natural_d(feed_json, p_intake_atma, t_intake_C, dint_mm, dcas_mm, 1, , , , "{""show_json"":1,""calibr_li"":2}")
                Set dcasep = ParseJson(rksep)
                feed_sep = ConvertToJson(dcasep("feed"))
            Else
                rksep = well_ksep_natural_d(feed_json, p_intake_atma, t_intake_C, dint_mm, dcas_mm, 3, pkv_ratio, , , "{""show_json"":1,""calibr_li"":2}")
                Set dcasep = ParseJson(rksep)
                feed_sep = ConvertToJson(dcasep("feed"))
            End If
            ksep = dcasep("k_sep")
        End If
        gas_fraction = feed_gas_fraction_d(p_intake_atma, t_intake_C, feed_sep)
        qgas_cas_sm3day = feed_q_gas_free_sm3day(p_intake_atma, t_intake_C, feed_json) * ksep
        ' 3. расчет перепада давления в ЭЦН
        Call esp.init_json(esp_json)
        Call esp.fluid.init_feed(feed_sep)
        Call esp.calc_ESP(p_intake_atma, t_intake_C)
        
        p_dis_atma = esp.p_dis_atma
        t_dis_C = esp.t_dis_C
    Else
        ' если данных по ЭЦН нет - тогда это фонтанирующая скважина
        feed_sep = feed_json
       p_dis_atma = p_intake_atma
       t_dis_C = t_intake_C
    End If
 ' 4. расчет распределения давления в НКТ
    Set pipe_above_esp = new_pipeline(construction_json, _
                                                t_model_json, _
                                                calc_along_coord, _
                                                flow_along_coord, _
                                                flow_corr, _
                                                calibr_grav, _
                                                calibr_fric, _
                                                0, h_esp_m)
    If fast Then
        res1 = pipe_above_esp.calc_dPipe(p_dis_atma, t_dis_C, noCurves)
    Else
        res1 = pipe_above_esp.calc_dPipe(p_dis_atma, t_dis_C, mainCurves)
    End If
    p_buf_atma = res1.p_atma
    t_buf_C = res1.t_C
    
 ' 5. если задано затрубное давление построим распределение давления в затрубе
    If p_cas_atma > 0 And Not fast And Len(esp_json) > 1 Then
        Set f = ParseJson(feed_sep)
        f("q_gas_free_sm3day") = qgas_cas_sm3day
        feed_sep = ConvertToJson(f)
        Set pipe_casing_liq = new_pipeline(construction_json, _
                                                    t_model_json, _
                                                    calc_along_coord, _
                                                    flow_along_coord, _
                                                    flow_corr, _
                                                    calibr_grav, _
                                                    calibr_fric, _
                                                    0, h_esp_m)
        Call pipe_casing_liq.set_ZNLF
        res1 = pipe_casing_liq.calc_dPipe(p_intake_atma, t_intake_C, mainCurves)
        'построим распределение давления для газа
        
        Set pipe_casing_gas = new_pipeline(construction_json, _
                                                    t_model_json, _
                                                    Not calc_along_coord, _
                                                    flow_along_coord, _
                                                    10, _
                                                    calibr_grav, _
                                                    calibr_fric, _
                                                    0, h_esp_m)
        res1 = pipe_casing_gas.calc_dPipe(p_cas_atma, t_intake_C, mainCurves)
        
        ' найдем динамический уровень и построим совместное распределения для газа и жидкости
        Dim h_dyn_m As Double
        h_dyn_m = intersection(pipe_casing_liq.curve("c_P"), pipe_casing_gas.curve("c_P"))(1)
        If h_dyn_m < 0 Then h_dyn_m = 0
        Dim i As Integer
        Set crv_cas_p = pipe_casing_liq.curve("c_P")
        For i = 1 To crv_cas_p.num_points
            Call crv_cas_p.AddPoint(h_dyn_m, crv_cas_p.getPoint(h_dyn_m), True)
            If crv_cas_p.pointX(i) < h_dyn_m Then
                Call crv_cas_p.AddPoint(crv_cas_p.pointX(i), pipe_casing_gas.curve("c_P").getPoint(crv_cas_p.pointX(i)))
            End If
        Next i
        
    End If
    
' подготовим кривые для вывода результатов
    If Not fast Then
        Call crv_p.AddPointsCurve(pipe_above_esp.curve("c_P").ClonePointsToNum(25), pipe_below_esp.curve("c_P").ClonePointsToNum(10))
        Call crv_t.AddPointsCurve(pipe_above_esp.curve("c_T").ClonePointsToNum(25), pipe_below_esp.curve("c_T").ClonePointsToNum(10))
        
    
        h_crit = 0
        n_sol = crv_t.FindSolutions(t_crit_C, TS_NO_EXTRPOLATION)
        If n_sol > 0 Then h_crit = crv_t.SolutionPointX(1)
        If t_crit_C > crv_t.maxy Then h_crit = crv_t.maxx
    End If
    
    
    
    If Not fast Then
        
        dout.Add "q_liq_sm3day", Round(q_liq_sm3day, 2)
        dout.Add "p_wf_atma", Round(p_wf_atma, 2)
        dout.Add "p_intake_atma", Round(p_intake_atma, 2)
        dout.Add "p_dis_atma", Round(p_dis_atma, 2)
        dout.Add "p_buf_atma", Round(p_buf_atma, 2)
        dout.Add "h_crit_m", h_crit
        crv_p.xName = "h_mes,m"
        crv_p.yName = "p,atma"
        dout.Add "c_P", crv_p.getDict
        crv_t.xName = "h_mes,m"
        crv_t.yName = "t,C"
        dout.Add "c_T", crv_t.getDict
        If p_cas_atma > 0 Then
            pipe_casing_liq.curve("c_P").xName = "h_mes,m"
            pipe_casing_liq.curve("c_P").yName = "p,atma"
            dout.Add "c_cas_P", pipe_casing_liq.curve("c_P").ClonePointsToNum(25).getDict
        End If
        
        dout.Add "h_dyn_m", Round(h_dyn_m, 2)
        dout.Add "gas_fraction at pump", Round(gas_fraction, 4)
        dout.Add "q_gas_cas_sm3day", Round(qgas_cas_sm3day, 2)
        
        dout.Add "ksep", Round(ksep, 2)
        dout.Add "t_intake_C", Round(t_intake_C, 2)
        dout.Add "t_dis_C", Round(t_dis_C, 2)
        
        Set f = ParseJson(feed_sep)
        
        dout.Add "q_liq_esp_sm3day", Round(f("q_liq_sm3day"), 2)
        
        well_calc_from_pwf = ConvertToJson(dout)
    Else
        well_calc_from_pwf = p_buf_atma
    End If
     
    Exit Function
er1:
    well_calc_from_pwf = "error " & Err.Description
 
End Function
' функция расчета ошибки оценки забойного давления
Private Function calc_well_pwf(ByVal p_wf As Double, _
                                   CoeffA As Variant) As Double
   
    
    Dim p_wh_atma As Double
    Dim res As Double
    
    Dim t_wf_C, feed_json, construction_json, esp_json, t_model_json, h_perf_m, h_esp_m, calibr_grav, calibr_fric, ksep, IPR_json, t_crit_C, p_cas_atma, flow_corr, pkv_ratio, dcas_mm, dint_mm
    
    p_wh_atma = CoeffA(0)
    
    t_wf_C = CoeffA(1)
    feed_json = CoeffA(2)
    construction_json = CoeffA(3)
    esp_json = CoeffA(4)
    t_model_json = CoeffA(5)
    h_perf_m = CoeffA(6)
    h_esp_m = CoeffA(7)
    calibr_grav = CoeffA(8)
    calibr_fric = CoeffA(9)
    ksep = CoeffA(10)
    IPR_json = CoeffA(11)
    t_crit_C = CoeffA(12)
    p_cas_atma = CoeffA(13)
    flow_corr = CoeffA(14)
    pkv_ratio = CoeffA(15)
    dcas_mm = CoeffA(16)
    dint_mm = CoeffA(17)
    
    res = well_calc_from_pwf(p_wf, t_wf_C, feed_json, construction_json, esp_json, t_model_json, h_perf_m, h_esp_m, calibr_grav, calibr_fric, ksep, IPR_json, t_crit_C, p_cas_atma, flow_corr, True, pkv_ratio, dcas_mm, dint_mm) - p_wh_atma
    calc_well_pwf = res
End Function
'description_to_manual      - для автогенерации
'расчет распределения давления и температуры в скважине
'на основе устьевого (буферного) давления (расчет  сверху вниз)
Public Function well_calc_from_pwh(ByVal p_wh_atma As Double, _
                                   ByVal t_wf_C, _
                                   ByVal feed_json As String, _
                                   ByVal construction_json As String, _
                                   ByVal esp_json As String, _
                                   ByVal t_model_json As String, _
                                   ByVal h_perf_m As Double, _
                                   ByVal h_esp_m As Double, _
                          Optional ByVal calibr_grav As Double = 1, _
                          Optional ByVal calibr_fric As Double = 1, _
                          Optional ByVal ksep As Double = 0.5, _
                          Optional ByVal IPR_json As String = "", _
                          Optional ByVal t_crit_C As Double = 0, _
                          Optional ByVal p_cas_atma = 0, _
                          Optional ByVal flow_corr As Integer = 0, _
                          Optional ByVal pkv_ratio As Double = 0, _
                          Optional ByVal dcas_mm As Double = 130, _
                          Optional ByVal dint_mm As Double = 102)
'p_wh_atma - устьевое (буферное) давление
't_wf_C - температура флюида на забое скважины
'feed_json - параметры потока в скважине (с забоя)
'construction_json - конструкция скважины (как для трубы)
'esp_json - параметры ЭЦН, используйте encode_esp_pump
'           если не заданы, то скважина фонтанирующая
't_model_json - температурная модель, рекомендуется модель 2
'h_perf_m - глубина верхних дыр перфорации, точка расчета забойного
'           давления
'h_esp_m - глубина спуска ЭЦН. Длина ЭЦН игнорируется
'          в конструкции диаметры должны учитывать глубину спуска ЭЦН
'calibr_grav - калибровка для гидравлической корреляции по гравитации
'calibr_fric - калибровка для гидравлической корреляции по трению
'ksep - общий коэффициент сепарации газа на приеме ЭЦН
'ipr_json - параметры пласта, используйте encode_ipr
'           если не заданы, считается для постоянного дебита из feed_json
't_crit_C - критическая температура для АСПО
'          в результатах будет вычислена глубина достижения t_crit_C
'p_cas_atma - затрубное давление, если задано будет рассчитан h_dyn_m
'flow_corr - номер гидравлической корреляции, как для трубы
'pkv_ratio - отношение ПКВ (работа на цикл). Если больше 0 будет учитываться
'description_end
        
' расчет сверху вниз по заданному буферному давлению
    Dim p_wf_max As Double
    Dim res As String
    Dim CoeffA(0 To 17)
    Dim prm As New CSolveParam
    Dim i As Integer
On Error GoTo er1:
    p_wf_max = 500
    
' 0. если задана IPR  то пытаемся оценить граничное забойное давление
    If Len(IPR_json) > 0 Then
        Dim d As Dictionary
        Set d = ParseJson(IPR_json)
        p_wf_max = d("p_res_atma")
    End If
        
    
    CoeffA(0) = p_wh_atma
    CoeffA(1) = t_wf_C
    CoeffA(2) = feed_json
    CoeffA(3) = construction_json
    CoeffA(4) = esp_json
    CoeffA(5) = t_model_json
    CoeffA(6) = h_perf_m
    CoeffA(7) = h_esp_m
    CoeffA(8) = calibr_grav
    CoeffA(9) = calibr_fric
    CoeffA(10) = ksep
    CoeffA(11) = IPR_json
    CoeffA(12) = t_crit_C
    CoeffA(13) = p_cas_atma
    CoeffA(14) = flow_corr
    CoeffA(15) = pkv_ratio
    CoeffA(16) = dcas_mm
    CoeffA(17) = dint_mm
    
    prm.y_tolerance = 0.01
    
    If solve_equation_bisection("calc_well_pwf", 1, p_wf_max, CoeffA, prm) Then
        res = well_calc_from_pwf(prm.x_solution, t_wf_C, feed_json, construction_json, esp_json, t_model_json, h_perf_m, h_esp_m, calibr_grav, calibr_fric, ksep, IPR_json, t_crit_C, p_cas_atma, flow_corr, , pkv_ratio, dcas_mm, dint_mm)
        well_calc_from_pwh = res
    Else
        ' здесь может оказаться, что решениий несколько и надо искать их посреди интервала
        For i = 1 To 10
            If solve_equation_bisection("calc_well_pwf", 1 + (p_wf_max / 10) * (i - 1), 1 + (p_wf_max / 10) * i, CoeffA, prm) Then
                res = well_calc_from_pwf(prm.x_solution, t_wf_C, feed_json, construction_json, esp_json, t_model_json, h_perf_m, h_esp_m, calibr_grav, calibr_fric, ksep, IPR_json, t_crit_C, p_cas_atma, flow_corr, , pkv_ratio, dcas_mm, dint_mm)
                well_calc_from_pwh = res
                Exit Function
            Else
                well_calc_from_pwh = "not found"
            End If
        Next i
    End If
    Exit Function
er1:
    well_calc_from_pwh = "error" & Err.Description
End Function
Private Function update(json As String, val As Double) As String
    Dim d As Dictionary
 ' оценим границу сверху
    If Len(json) > 0 Then
        Set d = ParseJson(json)
        d("calibr_head") = val
        json = ConvertToJson(d)
    End If
    update = json
End Function
              
Public Function unf_well_calc_pintake_from_pwf( _
                                   ByVal p_wf_atma As Double, _
                                   ByVal t_wf_C, _
                                   ByVal feed_json As String, _
                                   ByVal construction_json As String, _
                                   ByVal t_model_json As String, _
                                   ByVal h_perf_m As Double, _
                                   ByVal h_esp_m As Double, _
                          Optional ByVal calibr_grav As Double = 1, _
                          Optional ByVal calibr_fric As Double = 1, _
                          Optional ByVal IPR_json As String = "", _
                          Optional ByVal flow_corr As Integer = 0)
    Const calc_along_coord = False
    Const flow_along_coord = False
    Dim pipe_below_esp As New CPipe
    Dim ipr_vogel As New CReservoirVogel
    Dim res1 As PTtype
    Dim p_res_atma As Double
    Dim pi_m3dayatm As Double
    Dim pb_atma As Double
    Dim fw_perc As Double
    Dim q_liq_sm3day As Double
    Dim f As Dictionary
    
' расчет снизу вверх по заданному забойному давлению
    Set f = ParseJson(feed_json)
    q_liq_sm3day = f("q_liq_sm3day")
' 0. если задана IPR  то пытаемся оценить дебит
    If Len(IPR_json) > 0 Then
        Dim d As Dictionary
        Set d = ParseJson(IPR_json)
        p_res_atma = d("p_res_atma")
        pi_m3dayatm = d("pi_m3dayatm")
        pb_atma = d("pb_atma")
        fw_perc = d("fw_perc")
        
'        Call ipr_vogel.InitProp(p_res_atma, pb_atma, fw_perc)
        ipr_vogel.pi_sm3dayatm = pi_m3dayatm
        q_liq_sm3day = ipr_vogel.calc_q_liq_sm3day(p_wf_atma)
        
        f("q_liq_sm3day") = q_liq_sm3day
        feed_json = ConvertToJson(f)
        
    End If
' 1. расчет участка э/к от забоя до приема насоса
' инициализируем трубу с первым фидом, который всегда есть
    Set pipe_below_esp = new_pipeline(construction_json, _
                                                t_model_json, _
                                                calc_along_coord, _
                                                flow_along_coord, _
                                                flow_corr, _
                                                calibr_grav, _
                                                calibr_fric, _
                                                h_esp_m + 1, h_perf_m)
    
    res1 = pipe_below_esp.calc_dPipe(p_wf_atma, t_wf_C, noCurves)
    unf_well_calc_pintake_from_pwf = res1.p_atma
End Function
              
' функция расчета ошибки оценки забойного давления
Private Function calc_well_pwf_from_pint(ByVal p_wf As Double, _
                                   CoeffA As Variant) As Double
   
    
    Dim p_int_atma As Double
    
    Dim t_wf_C, feed_json, construction_json, t_model_json, h_perf_m, h_esp_m, calibr_grav, calibr_fric, IPR_json, flow_corr
    
    p_int_atma = CoeffA(0)
    
    t_wf_C = CoeffA(1)
    feed_json = CoeffA(2)
    construction_json = CoeffA(3)
    t_model_json = CoeffA(4)
    h_perf_m = CoeffA(5)
    h_esp_m = CoeffA(6)
    calibr_grav = CoeffA(7)
    calibr_fric = CoeffA(8)
    IPR_json = CoeffA(9)
    flow_corr = CoeffA(10)
    
    Dim res As String
    Dim dres As Dictionary
    
    res = unf_well_calc_pintake_from_pwf(p_wf, t_wf_C, feed_json, construction_json, t_model_json, h_perf_m, h_esp_m, calibr_grav, calibr_fric, IPR_json, flow_corr)
    
    calc_well_pwf_from_pint = res - p_int_atma
    
    
End Function
              
' функция расчета ошибки оценки забойного давления
Private Function calc_well_calibr_esp(ByVal calibr_esp As Double, _
                                   CoeffA As Variant) As Double
   
    
    Dim p_wh_atma As Double
    
    Dim p_wf_atma, t_wf_C, feed_json, construction_json, esp_json As String, t_model_json, h_perf_m, h_esp_m, calibr_grav, calibr_fric, ksep, IPR_json, t_crit_C, p_cas_atma, flow_corr
    
    p_wh_atma = CoeffA(0)
    
    p_wf_atma = CoeffA(1)
    t_wf_C = CoeffA(2)
    feed_json = CoeffA(3)
    construction_json = CoeffA(4)
    esp_json = CoeffA(5)
    t_model_json = CoeffA(6)
    h_perf_m = CoeffA(7)
    h_esp_m = CoeffA(8)
    calibr_grav = CoeffA(9)
    calibr_fric = CoeffA(10)
    ksep = CoeffA(11)
    IPR_json = CoeffA(12)
    t_crit_C = CoeffA(13)
    p_cas_atma = CoeffA(14)
    flow_corr = CoeffA(15)
    
    esp_json = update(esp_json, calibr_esp)
    
    calc_well_calibr_esp = well_calc_from_pwf(p_wf_atma, t_wf_C, feed_json, construction_json, esp_json, t_model_json, h_perf_m, h_esp_m, calibr_grav, calibr_fric, ksep, IPR_json, t_crit_C, p_cas_atma, flow_corr, fast:=True) - p_wh_atma
    
End Function
'description_to_manual      - для автогенерации
'расчет распределения давления и температуры в скважине
'на основе устьевого (буферного) и забойного давления
'модель калибруется деградацией ЭЦН
Public Function well_calc_from_pintake( _
                                   ByVal p_intake_atma As Double, _
                                   ByVal t_wf_C, _
                                   ByVal feed_json As String, _
                                   ByVal construction_json As String, _
                                   ByVal esp_json As String, _
                                   ByVal t_model_json As String, _
                                   ByVal h_perf_m As Double, _
                                   ByVal h_esp_m As Double, _
                          Optional ByVal calibr_grav As Double = 1, _
                          Optional ByVal calibr_fric As Double = 1, _
                          Optional ByVal ksep As Double = 0.5, _
                          Optional ByVal IPR_json As String = "", _
                          Optional ByVal t_crit_C As Double = 0, _
                          Optional ByVal p_cas_atma = 0, _
                          Optional ByVal p_wh_atma As Double = 10, _
                          Optional ByVal flow_corr As Integer = 0)
'p_intake_atma - давление на приеме насоса
't_wf_C - температура флюида на забое скважины
'feed_json - параметры потока в скважине (с забоя)
'construction_json - конструкция скважины (как для трубы)
'esp_json - параметры ЭЦН, используйте encode_esp_pump
'           если не заданы, то скважина фонтанирующая
't_model_json - температурная модель, рекомендуется модель 2
'h_perf_m - глубина верхних дыр перфорации, точка расчета забойного
'           давления
'h_esp_m - глубина спуска ЭЦН. Длина ЭЦН игнорируется
'          в конструкции диаметры должны учитывать глубину спуска ЭЦН
'calibr_grav - калибровка для гидравлической корреляции по гравитации
'calibr_fric - калибровка для гидравлической корреляции по трению
'ksep - общий коэффициент сепарации газа на приеме ЭЦН
'ipr_json - параметры пласта, используйте encode_ipr
'           если не заданы, считается для постоянного дебита из feed_json
't_crit_C - критическая температура для АСПО
'          в результатах будет вычислена глубина достижения t_crit_C
'p_cas_atma - затрубное давление, если задано будет рассчитан h_dyn_m
'p_wh_atma - устьевое (буферное) давление
'flow_corr - номер гидравлической корреляции, как для трубы
'description_end
    
    Dim p_wf_max As Double
    Dim p_wf_atma As Double
    Dim res As String
    Dim dres As Dictionary
    
    Dim CoeffA(0 To 10)
    Dim prm As New CSolveParam
    Dim CoeffB(0 To 15)
    
On Error GoTo er1:
    If Len(esp_json) < 2 Then
        well_calc_from_pintake = "esp data needed"
        Exit Function
    End If
    
    p_wf_max = 300
' 0. если задана IPR  то пытаемся оценить граничное забойное давление
    If Len(IPR_json) > 0 Then
        Dim d As Dictionary
        Set d = ParseJson(IPR_json)
        p_wf_max = d("p_res_atma")
    End If
        
' 1. Оценим давление на забое по известному давлению на приеме
'    чтобы снизить погрешность из за влияния температуры считаем итерациями
'    используя внутри расчет снизу вверх, при котором температура корректно оценивается
    CoeffA(0) = p_intake_atma
    CoeffA(1) = t_wf_C
    CoeffA(2) = feed_json
    CoeffA(3) = construction_json
    CoeffA(4) = t_model_json
    CoeffA(5) = h_perf_m
    CoeffA(6) = h_esp_m
    CoeffA(7) = calibr_grav
    CoeffA(8) = calibr_fric
    CoeffA(9) = IPR_json
    CoeffA(10) = flow_corr
    
    prm.y_tolerance = 0.01
    
    If solve_equation_bisection("calc_well_pwf_from_pint", 1, p_wf_max, CoeffA, prm) Then
        p_wf_atma = prm.x_solution
    Else
        well_calc_from_pintake = "not found"
        Exit Function
    End If
' 2. Далее оцениваем деградацию ЭЦН в заданном диапазоне от 0.01 до 1.99
'    исходя из найденного забойного давления и давления на устье
    CoeffB(0) = p_wh_atma
    CoeffB(1) = p_wf_atma
    CoeffB(2) = t_wf_C
    CoeffB(3) = feed_json
    CoeffB(4) = construction_json
    CoeffB(5) = esp_json
    CoeffB(6) = t_model_json
    CoeffB(7) = h_perf_m
    CoeffB(8) = h_esp_m
    CoeffB(9) = calibr_grav
    CoeffB(10) = calibr_fric
    CoeffB(11) = ksep
    CoeffB(12) = IPR_json
    CoeffB(13) = t_crit_C
    CoeffB(14) = p_cas_atma
    CoeffB(15) = flow_corr
    
    prm.y_tolerance = 0.01
    
    If solve_equation_bisection("calc_well_calibr_esp", 0.01, 1.99, CoeffB, prm) Then
        ' если решение нашлось, пересчитаем распределение давления ради графиков и добавим в выходной json значение деградации
        esp_json = update(esp_json, prm.x_solution)
        res = well_calc_from_pwf(p_wf_atma, t_wf_C, feed_json, construction_json, esp_json, t_model_json, h_perf_m, h_esp_m, calibr_grav, calibr_fric, ksep, IPR_json, t_crit_C, p_cas_atma, flow_corr)
        Set dres = ParseJson(res)
        dres.Add "calibr_esp_head", prm.x_solution
        res = ConvertToJson(dres)
        well_calc_from_pintake = res
    Else
        well_calc_from_pintake = "not found"
    End If
     
    Exit Function
er1:
    well_calc_from_pintake = "error " & Err.Description
    
End Function
' функция расчета ошибки в оценке давления для штуцера
' в зависимости от поправки на калибровочный параметр
Private Function calc_choke_dp_error_calibr_grav_atm(ByVal calibr As Double, _
                                                    CoeffA As Variant) As Double
    Dim PT As PTtype
    Dim pt0 As PTtype
    Dim choke As Cchoke
    Dim p_in_atma As Double
    Dim p_out_atma As Double
    
    ' read coeffA - parameters
    Set choke = CoeffA(0)
    p_in_atma = CoeffA(1)
    p_out_atma = CoeffA(2)
    
    With choke
        .calibr_fr = calibr
        pt0.p_atma = p_out_atma
        pt0.t_C = .t_choke_C
        PT = .calc_choke_p(pt0, calc_p_down:=0)
        calc_choke_dp_error_calibr_grav_atm = (PT.p_atma - p_in_atma)
    End With
    
End Function
' функция расчета ошибки в оценке давления для штуцера
' в зависимости от диаметра
Private Function calc_choke_dp_error_diam_atm(ByVal diam_m As Double, _
                                                    CoeffA As Variant) As Double
    Dim PT As PTtype
    Dim pt0 As PTtype
    Dim choke As Cchoke
    Dim p_in_atma As Double
    Dim p_out_atma As Double
    
    ' read coeffA - parameters
    Set choke = CoeffA(0)
    p_in_atma = CoeffA(1)
    p_out_atma = CoeffA(2)
    
    'On Error Resume Next
    On Error GoTo er1
    ' low diam can be unstable - trying eliminate it
    
    With choke
        .d_choke_m = diam_m
        pt0.p_atma = p_out_atma
        pt0.t_C = .t_choke_C
        PT = .calc_choke_p(pt0, calc_p_down:=0)
        If PT.p_atma < 0 Then PT.p_atma = 0
        calc_choke_dp_error_diam_atm = (PT.p_atma - p_in_atma)
    End With
    Exit Function
er1:
    Dim str1 As String
    str1 = "calc_choke_dp_error_diam_atm:  error " & Err.Description & " processed. calc continue"
    
    On Error Resume Next
    Call choke.add_log_msg(str1)
    
    On Error GoTo er1
    Resume Next
    
End Function
' функция расчета ошибки в оценке давления для штуцера
' в зависимости от газового фактора
Private Function calc_choke_dp_error_rp_atm(ByVal rp As Double, _
                                                    CoeffA As Variant) As Double
    Dim PT As PTtype
    Dim pt0 As PTtype
    Dim choke As Cchoke
    Dim p_in_atma As Double
    Dim p_out_atma As Double
    
    ' read coeffA - parameters
    Set choke = CoeffA(0)
    p_in_atma = CoeffA(1)
    p_out_atma = CoeffA(2)
    
    With choke
        .fluid.rp_m3m3 = rp
        pt0.p_atma = p_out_atma
        pt0.t_C = .t_choke_C
        PT = .calc_choke_p(pt0, calc_p_down:=0)
        calc_choke_dp_error_rp_atm = (PT.p_atma - p_in_atma)
    End With
    
End Function
' функция расчета ошибки в оценке давления для штуцера
' в зависимости от обводненности
Private Function calc_choke_dp_error_fw_atm(ByVal fw_fr As Double, _
                                                    CoeffA As Variant) As Double
    Dim PT As PTtype
    Dim pt0 As PTtype
    Dim choke As Cchoke
    Dim p_in_atma As Double
    Dim p_out_atma As Double
    
    ' read coeffA - parameters
    Set choke = CoeffA(0)
    p_in_atma = CoeffA(1)
    p_out_atma = CoeffA(2)
    
    With choke
        .fluid.fw_fr = fw_fr
        pt0.p_atma = p_out_atma
        pt0.t_C = .t_choke_C
        PT = .calc_choke_p(pt0, calc_p_down:=0)
        calc_choke_dp_error_fw_atm = (PT.p_atma - p_in_atma)
    End With
    
End Function
' функция расчета ошибки в оценке давления для штуцера
' в зависимости от обводненности
Private Function calc_choke_dp_error_qliq_atm(ByVal qliq As Double, _
                                                    CoeffA As Variant) As Double
    Dim PT As PTtype
    Dim pt0 As PTtype
    Dim choke As Cchoke
    Dim p_in_atma As Double
    Dim p_out_atma As Double
    
    ' read coeffA - parameters
    Set choke = CoeffA(0)
    p_in_atma = CoeffA(1)
    p_out_atma = CoeffA(2)
    
    With choke
        .fluid.q_liq_sm3day = qliq
        pt0.p_atma = p_out_atma
        pt0.t_C = .t_choke_C
        PT = .calc_choke_p(pt0, calc_p_down:=0)
        calc_choke_dp_error_qliq_atm = (PT.p_atma - p_in_atma)
    End With
    
End Function
' функция расчета ошибки в оценке давления для штуцера
' в зависимости от обводненности
Private Function calc_choke_dp_error_qgas_atm(ByVal qgas As Double, _
                                                    CoeffA As Variant) As Double
    Dim PT As PTtype
    Dim pt0 As PTtype
    Dim choke As Cchoke
    Dim p_in_atma As Double
    Dim p_out_atma As Double
    
    ' read coeffA - parameters
    Set choke = CoeffA(0)
    p_in_atma = CoeffA(1)
    p_out_atma = CoeffA(2)
    
    With choke
        .fluid.q_gas_free_sm3day = qgas
        pt0.p_atma = p_out_atma
        pt0.t_C = .t_choke_C
        PT = .calc_choke_p(pt0, calc_p_down:=0)
        calc_choke_dp_error_qgas_atm = (PT.p_atma - p_in_atma)
    End With
    
End Function

