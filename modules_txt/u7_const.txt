'=======================================================================================
'Unifloc 7.50 year 2024                                  khabibullinra@gmail.com
'Petroleum engineering calculations modules (macroses)
'2000 - 2023
'
'=======================================================================================
' constant definition module and some usefull functions
Option Explicit
Public Const const_unifloc_version = "7.50"
Public Const esp_db_name = "\ESP_json.db"
 
' only database as global variable here
' in order to reduce db file read
Public ESP_base_dictionary As Dictionary
Public Const prm_gas_goes_into_solution     As String = "gas_goes_into_solution"
Public Const prm_PVT_correlation            As String = "PVT_correlation"
Public Const prm_show_log                   As String = "show_log"
Public Const prm_show_info                  As String = "show_info"
Public Const prm_num_value                  As String = "num_value"
Public Const prm_show_array                 As String = "show_array"
Public Const prm_show_json                  As String = "show_json"
Public Const prm_show_all                   As String = "show_all"
Public Const prm_pipe_calibr_grav           As String = "pipe_calibr_grav"
Public Const prm_pipe_calibr_fric           As String = "pipe_calibr_fric"
Public Const prm_pipe_temp_method           As String = "pipe_temp_method"
Public Const prm_pipe_znlf                  As String = "pipe_znlf"
Public Const prm_esp_calibr_head            As String = "esp_calibr_head"
Public Const prm_esp_calibr_rate            As String = "esp_calibr_rate"
Public Const prm_esp_calibr_power           As String = "esp_calibr_power"
Public Const prm_esp_gas_correct            As String = "esp_gas_correct"
Public Const prm_esp_gas_correct_model      As String = "esp_gas_correct_model"
Public Const prm_esp_gas_correct_stage_by_stage      As String = "esp_gas_correct_model"
Public Const prm_dnum_stages_integrate      As String = "dnum_stages_integrate"
Public Const prm_out_points                 As String = "out_points"
Public Const prm_thermal_conductivity_formation_WmC     As String = "thermal_conductivity_formation_WmC"
Public Const prm_specific_heat_capacity_formation_JkgC  As String = "specific_heat_capacity_formation_JkgC"
Public Const prm_thermal_conductivity_cement_WmC        As String = "thermal_conductivity_cement_WmC"
Public Const prm_thermal_conductivity_tubing_WmC        As String = "thermal_conductivity_tubing_WmC"
Public Const prm_thermal_conductivity_casing_WmC        As String = "thermal_conductivity_casing_WmC"
Public Const prm_heat_transfer_casing_liquid_Wm2C       As String = "heat_transfer_casing_liquid_Wm2C"
Public Const prm_heat_transfer_casing_gas_Wm2C          As String = "heat_transfer_casing_gas_Wm2C"
Public Const prm_heat_transfer_fluid_convection_Wm2C    As String = "heat_transfer_fluid_convection_Wm2C "
Public Const prm_time_calc_hr                           As String = "time_calc_hr"
Public Const prm_t_start_C                  As String = "t_start_C"
Public Const prm_t_end_C                    As String = "t_end_C"
Public Const prm_t_model                    As String = "t_model"
Public Const const_name_h_list_m            As String = "h_list_m"
Public Const const_name_diam_list_mm        As String = "diam_list_mm"
Public Const const_name_t_list_C            As String = "t_list_C"
Public Const const_name_roughness_m         As String = "roughness_m"
Public Const const_name_hmes_m              As String = "hmes_m"
Public Const const_name_hvert_m             As String = "hvert_m"
Public Const const_name_t_C                 As String = "t_C"
Public Const const_name_diam_int_mm         As String = "diam_int_mm"
Public Const str_VLPcurve = "VLPcurve"                      ' кривая оттока -  зависимость забойного давления от дебита жидкости
Public Const str_TambHmes_curve = "TambHmes_curve"           ' профиль температуры окружающего простраства от измеренный координаты
Public Const str_PtubHmes_curve = "PtubHmes_curve"           ' профиль давления по стволу скважины по ниже НКТ и по НКТ до устья
Public Const str_TtubHmes_curve = "TtubHmes_curve"           ' профиль температуры по стволу скважины по НКТ
Public Const str_PcasHmes_curve = "PcasHmes_curve"           ' профиль давления по стволу скважины по ниже НКТ и по затрубу до устья
Public Const str_TcasHmes_curve = "TcasHmes_curve"           ' профиль температуры по стволу скважины ниже насоса и выше насоса по затрубу
Public Const str_RstubHmes_curve = "RstubHmes_curve"         ' профиль остаточного содержания газа в нефти по потоку в НКТ
Public Const str_RscasHmes_curve = "RscasHmes_curve"         ' профиль остаточного содержания газа в нефти по потоку по затрубу
Public Const str_GasFracTubHmes_curve = "GasFracTubHmes_curve" ' расходное содержание газа в потоке в НКТ
Public Const str_GasFracCasHmes_curve = "GasFracCasHmes_curve" ' расходное содержание газа в потоке по затрубу
Public Const str_HlHmes_curve = "HlHmes_curve"         ' Liquid holdup (содержание жидкости) в потоке через НКТ
Public Const str_HLtubHmes_curve = "HLtubHmes_curve"         ' Liquid holdup (содержание жидкости) в потоке через НКТ
Public Const str_HLcasHmes_curve = "HLcasHmes_curve"         ' Liquid holdup (содержание жидкости) в потоке по затрубу
Public Const str_muoTubCurve = "muoTubCurve" '
Public Const str_muwTubCurve = "muwTubCurve" '
Public Const str_mugTubCurve = "mugTubCurve" '
Public Const str_mumixTubCurve = "mumixTubCurve" '
Public Const str_rhooTubCurve = "rhooTubCurve" '
Public Const str_rhowTubCurve = "rhowTubCurve" '
Public Const str_rholTubCurve = "rholTubCurve" '
Public Const str_rhogTubCurve = "rhogTubCurve" '
Public Const str_rhomixTubCurve = "rhomixTubCurve" '
Public Const str_qoTubCurve = "qoTubCurve" '
Public Const str_qwTubCurve = "qwTubCurve" '
Public Const str_qgTubCurve = "qgTubCurve" '
Public Const str_moTubCurve = "moTubCurve" '
Public Const str_mwTubCurve = "mwTubCurve" '
Public Const str_mgTubCurve = "mgTubCurve" '
Public Const str_vlTubCurve = "vlTubCurve" '
Public Const str_vgTubCurve = "vgTubCurve" '
Public Const str_muoCasCurve = "muoCasCurve" '
Public Const str_muwCasCurve = "muwCasCurve" '
Public Const str_mugCasCurve = "mugCasCurve" '
Public Const str_mumixCasCurve = "mumixCasCurve" '
Public Const str_rhooCasCurve = "rhooCasCurve" '
Public Const str_rhowCasCurve = "rhowCasCurve" '
Public Const str_rholCasCurve = "rholCasCurve" '
Public Const str_rhogCasCurve = "rhogCasCurve" '
Public Const str_rhomixCasCurve = "rhomixCasCurve" '
Public Const str_qoCasCurve = "qoCasCurve" '
Public Const str_qwCasCurve = "qwCasCurve" 'a's
Public Const str_qgCasCurve = "qgCasCurve" '
Public Const str_moCasCurve = "moCasCurve" '
Public Const str_mwCasCurve = "mwCasCurve" '
Public Const str_mgCasCurve = "mgCasCurve" '
Public Const str_vlCasCurve = "vlCasCurve" '
Public Const str_vgCasCurve = "vgCasCurve" '
Public Const PVT_DEFAULT = "{""gamma_gas"":0.6,""gamma_oil"":0.86,""gamma_wat"":1,""rsb_m3m3"":100}"
Public Const WELL_DEFAULT = "{""h_perf_m"":1600,""h_tub_m"":1000,""rough_m"":0.0001,""d_choke_mm"":15,""t_val_C"":[[25]],""h_list_m"":[[2000]],""d_tub_list_mm"":[[62]],""d_cas_list_mm"":[[125]]}"
Public Const const_t_K_min = 273         ' ниже нуля ничего не считаем?
Public Const const_tMcCain_K_min = 289   ' ниже нуля ничего не считаем?
Public Const const_t_K_max = 573         ' выше тоже ничего не считаем?
Public Const const_t_K_zero_C = 273
Public Const const_t_C_min = const_t_K_min - const_t_K_zero_C
Public Const const_t_C_max = const_t_K_max - const_t_K_min
Public Const const_Pi As Double = 3.14159265358979
Public Const const_tsc_C = 20
Public Const const_tsc_K As Double = const_tsc_C + const_t_K_zero_C ' температура стандартных условиях, К
Public Const const_psc_atma As Double = 1
Public Const const_r As Double = 8.31 'Universal gas constant
Public Const const_g = 9.81
Public Const const_rho_air = 1.2217
Public Const const_gamma_w = 1
Public Const const_rho_ref = 1000
Public Const const_ZNLF_rate = 0.1
Public Const const_m_a_kgmol As Double = 0.029 'Air molar mass
Public Const const_sigma_wat_gas_Nm = 0.01 ' поверхностное натяжение на границе с воздухом (газом) - типовые значения для дефолтных параметров  Н/м
Public Const const_sigma_oil_Nm = 0.025
Public Const const_mu_w = 0.36
Public Const const_mu_g = 0.0122
Public Const const_mu_o = 0.7
Public Const const_gg_ = 0.6
Public Const const_gw_ = 1
Public Const const_go_ = 0.86
Public Const const_rsb_default = 100
Public Const const_Bob_default = 1.2
Public Const const_tres_default = 90
Public Const const_Roughness_default = 0.0001
' набор констант для общих ограничений значений переменных
Public Const const_gamma_gas_min = 0.5   ' плотность метана 0.59 - предпологаем легче газов не будет
Public Const const_gamma_gas_max = 2     ' плотность углеводородных газов (гексан) может доходить до 4, но мы считаем что в смеси таких не много должно быть
Public Const const_gamma_water_min = 0.9 ' плотность воды от 0.9 до 1.5
Public Const const_gamma_water_max = 1.5
Public Const const_gamma_oil_min = 0.5   ' плотность нефти
Public Const const_gamma_oil_max = 1.5
Public Const const_P_MPa_min = 0
Public Const const_P_MPa_max = 50
Public Const const_Salinity_ppm_min = 0
Public Const const_Salinity_ppm_max = 265000  ' equal to weigh percent salinity 26.5%.  Ограничение по границам применимости корреляций МакКейна
Public Const const_rsb_m3m3_min = 0
Public Const const_rsb_m3m3_max = 100000 ' rsb more that 100 000 not allowed
Public Const const_Ppr_min = 0.002
Public Const const_Ppr_max = 30
Public Const const_Tpr_min = 0.7
Public Const const_Tpr_max = 3
Public Const const_Z_min = 0.05
Public Const const_Z_max = 5
Public Const const_TGeoGrad_C100m = 3   ' геотермальный градиент в градусах на 100 м
Public Const const_Heps_m = 0.001       ' дельта для корретировки кривой трубы, - примерно соответствует длине сочленения труб
Public Const const_ESP_length = 1      ' длина УЭЦН по умолчанию
Public Const const_pipe_diam_default_mm = 62
' набор констант для перевода единиц измерений в различных размерностях
Public Const const_convert_atma_Pa = 101325
Public Const const_convert_Pa_atma = 1 / const_convert_atma_Pa
Public Const const_convert_kgfcm2_Pa = 98066.5
Public Const const_convert_m3day_bbl = 6.289810569
Public Const const_convert_gpm_m3day = 5.450992992     ' (US) gallon per minute
Public Const const_convert_m3day_gpm = 1 / const_convert_gpm_m3day
Public Const const_convert_m3m3_scfbbl = 5.614583544
Public Const const_convert_scfbbl_m3m3 = 1 / const_convert_m3m3_scfbbl
Public Const const_convert_bbl_m3day = 1 / const_convert_m3day_bbl
Public Const const_conver_day_sec = 86400   ' updated for test  rnt21
Public Const const_convert_hr_sec = 3600
Public Const const_convert_m3day_m3sec = 1 / const_conver_day_sec
Public Const const_conver_sec_day = 1 / const_conver_day_sec
Public Const const_convert_atma_psi = 14.7
Public Const const_convert_psi_atma = 1 / const_convert_atma_psi
Public Const const_convert_ft_m = 0.3048
Public Const const_convert_m_ft = 1 / const_convert_ft_m
Public Const const_convert_m_mm = 1000
Public Const const_convert_mm_m = 1 / const_convert_m_mm
Public Const const_convert_cP_Pasec = 1 / 1000
Public Const const_convert_HP_W = 745.69987  ' 735.49875  ' метрическая лошадиная сила. следует учесть, что иногда может применяться механическя лошадиная сила (1.013 метрической)
Public Const const_convert_W_HP = 1 / const_convert_HP_W
Public Const const_convert_Nm_dynescm = 1000
Public Const const_convert_lbmft3_kgm3 = 16.01846
Public Const const_convert_kgm3_lbmft3 = 1 / const_convert_lbmft3_kgm3
Public Const const_convert_psift_atmm = 1 / const_convert_atma_psi / const_convert_ft_m ' pressure gradient conversion factor
Public Const const_convert_MPa_atma = 1000000 / const_convert_atma_Pa  ' 9.8692
Public Const const_convert_MPa_psia = const_convert_MPa_atma * const_convert_atma_psi
Public Const const_convert_atma_MPa = 1 / const_convert_MPa_atma ' 0.101325' константа для конверсии единиц давления из Мпа в atma
Public Const const_p_atma_min = const_P_MPa_min * const_convert_MPa_atma
Public Const const_p_atma_max = const_P_MPa_max * const_convert_MPa_atma
Public Const MAXIT = 100
' константы для расчета многофазного потока
Public Const const_MaxSegmLen = 100
Public Const const_n_n = 20
Public Const const_MaxdP = 10
Public Const const_minPpipe_atma = 0.9
Public Const const_decimal_output = 3
Public Const const_pressure_tolerance = 0.0051
' эта константа используется при интегрировании трубы
' попытка увеличить точность может при определенных обстоятельствах привести к тому
' что расчет по корреляции Ансари не будет сходиться из-за скачкой градиента давления 13.09.2021
' следует обращаться осторожно с этими параметрами
Public Const const_num_decimal_out = 3
Public Const const_well_P_tolerance = 0.01     ' допустимая погрешность при расчете забойного давления в скважине
Public Const const_P_difference = 0.0001       ' допустимая погрешность при сравнении (в основном) давлений
Public Const ang_max = 5
Public Const const_OutputCurveNumPoints = 50
Public Const DEFAULT_PAN_STEP = 15
Public Const kErrWellConstruction = 513 + vbObjectError
Public Const kErrPVTinput = 514 + vbObjectError
Public Const kErrNodalCalc = 515 + vbObjectError
Public Const kErrInitCalc = 516 + vbObjectError
Public Const kErrESPbase = 517 + vbObjectError
Public Const kErrPVTcalc = 518 + vbObjectError
Public Const kErrESPcalc = 519 + vbObjectError
Public Const kErrGradcalc = 520 + vbObjectError
Public Const kErrArraySize = 701 + vbObjectError
Public Const kErrBuildCurve = 702 + vbObjectError
Public Const kErrcurvestablePointIndex = 703 + vbObjectError
Public Const kErrCurvePointIndex = 704 + vbObjectError
Public Const kErrReadDataFromWorksheet = 705 + vbObjectError
Public Const kErrWriteDataFromWorksheet = 706 + vbObjectError
Public Const kStrConversion = 707 + vbObjectError
Public Const kErrDegradationNotFound = 708 + vbObjectError
Public Const kErrDegradationError = 709 + vbObjectError
Public Const kreadRangeError = 710 + vbObjectError
Public Const kErrCInterpolation = 711 + vbObjectError
Public Const kErrTester = 712 + vbObjectError
Public Const kErrBisection = 713 + vbObjectError
Public Const kreadJsonError = 714 + vbObjectError
Public Const kErrNatSeparation = 715 + vbObjectError
Public Const sDELIM As String = vbNewLine
Public Const MinCountPoints_calc_pwf_pcas_hdyn_atma = 5
Public Const root3 = 3 ^ 0.5
' hydraulic correlations types
Public Enum H_CORRELATION
    BeggsBrill = 0
    Ansari = 1
    Unified = 2
    Gray = 3
    HagedornBrown = 4
    SakharovMokhov = 5
    gas = 10
    Water = 11
End Enum
' PVT correlations set to be used
Public Enum PVT_correlation
    Standing_based = 0 '
    McCain_based = 1 '
    straigth_line = 2
End Enum
' z factor (gas compressibility) options
Public Enum Z_CORRELATION
    z_BB = 0
    z_Dranchuk = 1
    z_Kareem = 2
End Enum
' type determines the method of temperature calculation in well
Public Enum TEMP_CALC_METHOD
    StartEndTemp = 0
    GeoGradTemp = 1
    AmbientTemp = 2
    LengthTemp = 3    ' temperature along measured length
End Enum
' gas separation in well at pump intake. calculation method
Public Enum SEPAR_CALC_METHOD
    fullyManual = 3
    valueManual = 2
    pressureManual = 1
    byCorrealation = 0
End Enum
' standard port sizes for whetherford r1 glv
Public Enum GLV_R1_PORT_SIZE
    R1_port_1_8 = 3.18
    R1_port_5_32 = 3.97
    R1_port_3_16 = 4.76
    R1_port_1_4 = 6.35
    R1_port_5_16 = 7.94
End Enum
' multiphase flow in pipe and well calculation method
Public Type PARAMCALC
     correlation As H_CORRELATION         ' multiphase hydraulic correlation
     calc_along_coord As Boolean            ' calculation direction flag
                                          ' if True - pressure at lowest coordinate is given
                                          '           pressure at higher coordinate calculated
                                          '           for well (0 coord at top, hmes at bottom)
                                          '           equal to calc from top to bottom
                                          '    False - otherwise
     flow_along_coord As Boolean            ' flow direction flag
     temp_method As TEMP_CALC_METHOD      ' temperature caclulation method
     length_gas_m As Double               ' length in pipe where correlation changes.
                                          ' for points with cooed less then  length_gas_m
                                          ' gas correlation applied,
                                          ' other points - multiphase correlation applied
                                          ' allows to model easily static level in well
    start_length_gas_m As Double
End Type
' type to describe thermobaric conditions (for calculations)
Public Type PTtype
    p_atma As Double
    t_C As Double
End Type
' type for storing data about dynamic level
Public Type PCAS_HDYN_type
    p_cas_atma As Double
    hdyn_m As Double
    self_flow_condition As Boolean
    pump_off_condition As Boolean
    correct As Boolean
End Type
' Type for describing the operation of an electric motor
Public Type MOTOR_DATA
    U_lin_V As Double       ' voltage linear (between phases)
    I_lin_A As Double       ' Linear current (in line)
    U_phase_V As Double     ' phase voltage (between phase and zero)
    I_phase_A As Double     ' phase current (in winding)
    f_Hz As Double          ' frequency synchronous (field rotation)
    eff_d As Double         ' Efficiency
    cosphi As Double        ' power factor
    s_d As Double           ' slippage
    Pshaft_kW As Double     ' mechanical power on the shaft
    Pelectr_kW As Double    ' power supply electric
    Mshaft_Nm As Double     ' torque on the shaft - mechanical
    load_d As Double        ' motor load
    eff_full_d As Double
'    cable_dU_V As Double
'    U_trans_high_V As Double
    power_fact_kW As Double
    power_CS_calc_W As Double        ' мощность на входе в станцию управления (с учетом корректировки) факт
    power_CS_teor_calc_W As Double   ' мощность на входе в станцию управления  расчетная без корректировки
End Type
Public Type CABLE_DATA
    type_num As Integer    ' номер кабеля todo сделать базу кабелей
    name As String         ' название кабеля
    manufacturer As String
    d_mm As Double
    R_Omkm As Double       ' удельное сопротивление
    X_Omkm As Double       ' удельное реактивое сопротивление
    Tmax_C As Double       ' температурный рейтинг  todo сделать проверки на температурный рейтинг
    dU_V As Double         ' падение напряжения на кабеле
    dPower_W As Double     ' мощность потребляемая кабелем
    power_W As Double      ' мощность на входе в кабель
End Type
' ESP description to be loaded from DB
' combined in type to decrease a mess in CESPpump
Public Type ESP_PARAMS
     ID As String                    ' ID from database
     source As String
     manufacturer As String
     name As String
     stages_max As Integer           ' максимальной количество ступеней в насосе (из базы)
     rate_max_sm3day As Double       ' максимальный дебит насос (из базы) - хорошо бы для надежности определять параметр из характеристики
     rate_nom_sm3day As Double
     rate_opt_min_sm3day As Double   ' границы оптимального диапазона для насоса - минимум
     rate_opt_max_sm3day As Double   ' границы оптимального диапазона  - максимум
     freq_Hz As Double               ' частота насоса для номинальной характеристики в базе
     
     ' характеристика заданные по точкам
     head_points() As Double
     rate_points() As Double
     power_points() As Double
     eff_points() As Double
      
     height_stage_m As Double        ' примерная высота ступени
     d_od_m As Double                ' внешний диаметр ЭЦН
     d_motor_od_m As Double         ' внешний диаметр ПЭД
     d_cas_min_m As Double           ' минимальный диаметр обсадной колонны, заданный производителем оборудования
     d_shaft_m As Double             ' диаметр вала для насоса
     area_shaft_m2 As Double         ' площадь поперечного сечения вала   (дублирует диаметр, но задается производителем)
     
     power_limit_shaft_kW As Double ' максимальная мощность передаваемая валом на номинальной частоте
     power_limit_shaft_high_kW As Double
     power_limit_shaft_max_kW As Double ' максимальная мощность передаваемая валом на номинальной частоте для высокопрочного вала
     pressure_limit_housing_atma As Double ' максимальное давление на корпус
     slip_nom_rpm As Double
     eff_max As Double
End Type
' type of extended description of multiphase flow parameters at a point
Public Type PIPE_FLOW_PARAMS
  md_m As Double         ' pipe measured depth (from start - top)
  vd_m As Double         ' pipe vertical depth from start - top
  diam_mm As Double      ' pipe diam
  p_atma As Double       ' pipe pressure at measured depth
  t_C As Double          ' pipe temp at measured depth
  
  dp_dl As Double
  dt_dl As Double
  
  dpdl_g_atmm As Double  ' gravity gradient at measured depth
  dpdl_f_atmm As Double  ' friction gradient at measured depth
  dpdl_a_atmm As Double  ' acceleration gradient at measured depth
  v_sl_msec As Double    ' superficial liquid velosity
  v_sg_msec As Double    ' superficial gas velosity
  h_l_d As Double        ' liquid hold up
  fpat As Double         ' flow pattern code
  thete_deg As Double
  roughness_m As Double
  
  rs_m3m3 As Double     ' dissolved gas in oil in the stream
  gasfrac As Double     ' gas flow rate
  
  mu_oil_cP As Double   ' oil viscosity in flow
  mu_wat_cP As Double   ' water viscosity in the flow
  mu_gas_cP As Double   ' gas viscosity in flow
  mu_mix_cP As Double   ' viscosity of the mixture in the flow
  
  Rhoo_kgm3 As Double   ' oil Density
  Rhow_kgm3 As Double   ' water Density
  rhol_kgm3 As Double   ' liquid density
  Rhog_kgm3 As Double   ' gas Density
  rhomix_kgm3 As Double ' density of the mixture in the thread
  
  q_oil_m3day As Double ' oil consumption in working conditions
  qw_m3day As Double    ' water consumption in working conditions
  Qg_m3day As Double    ' gas flow rate under operating conditions
  
  mo_kgsec As Double    ' mass flow rate of oil in working conditions
  mw_kgsec As Double    ' mass flow rate in working conditions
  mg_kgsec As Double    ' mass flow rate of gas under operating conditions
  
  vl_msec As Double     ' fluid velocity is real
  vg_msec As Double     ' real gas velocity
End Type
' type showing the way of saving the extended calculation results
' determines which set of calculated distribution curves will be saved
Public Enum CALC_RESULTS
    noCurves = 0
    mainCurves = 1
    allCurves = 2
End Enum
Public Type PTESP_LIST
    feed() As String
    p_intake() As Double
    t_intake() As Double
    p_dis() As Double
    t_dis() As Double
    d As Dictionary
    len As Integer
End Type
' list data for UDF calculations
Public Type PTQ_LIST
    feed() As String
    p() As Double
    t() As Double
    val() As Double
    ql() As Double
    fw() As Double
    rp() As Double
    qg() As Double
    len As Integer
End Type
Dim lm As New CLogger           ' лог который накапливает все сообщения. поддерживает сохранение сообщений в файл
Private Function MakeLogMsg(msg, Optional msg1, Optional msg2, Optional msg3) As String
 Dim msg_str As String
 msg_str = Format(Date, "Short Date") & " : " & Format(Time, "Long Time") & " : " & sDELIM
 
 If Not IsMissing(msg) Then
    msg_str = msg_str & msg
 End If
 If Not IsMissing(msg1) Then
    msg_str = msg_str & " : " & msg1
 End If
 If Not IsMissing(msg2) Then
    msg_str = msg_str & " : " & msg2
 End If
 If Not IsMissing(msg3) Then
    msg_str = msg_str & " : " & msg3
 End If
 Debug.Print msg_str                                        '   пишем в окно отладки
 MakeLogMsg = msg_str          '  сохраняем строку
End Function
Public Function add_log_msg(msg As String, Optional msg1, Optional msg2, Optional msg3)
' вывод сообщения в лог и в окно отладки
' можно задать до 3 строк, которые автоматически склеиваются в одну перед выводом
 lm.add_msg MakeLogMsg(msg, msg1, msg2, msg3)          '  пишем в лог
End Function
Public Function getLogObject() As CLogger
  Set getLogObject = lm
End Function
'=========================================================================================
'types support functions
'=========================================================================================
Public Function sum_PT(PT1 As PTtype, PT2 As PTtype) As PTtype
    sum_PT.p_atma = PT1.p_atma + PT2.p_atma
    sum_PT.t_C = PT1.t_C + PT2.t_C
End Function
Public Function subtract_PT(PT1 As PTtype, PT2 As PTtype) As PTtype
    subtract_PT.p_atma = PT1.p_atma - PT2.p_atma
    subtract_PT.t_C = PT1.t_C - PT2.t_C
End Function
Public Function set_PT(ByVal p As Double, ByVal t As Double) As PTtype
    set_PT.p_atma = p
    set_PT.t_C = t
End Function
Public Function PT_to_array(PT As PTtype)
    PT_to_array = Array(PT.p_atma, PT.t_C)
End Function
'=======================================================================================
'simple math function (additional to alglib)
Public Function cosd(ang) As Double
 cosd = Cos(ang / 180 * const_Pi)
End Function
Public Function sind(ang) As Double
 sind = Sin(ang / 180 * const_Pi)
End Function
Public Function isEqual(a As Double, B As Double) As Double
    Const eps = const_P_difference
    isEqual = False
    If Abs(a - B) < eps Then isEqual = True
End Function
Public Function isGreater(a As Double, B As Double) As Double
    Const eps = const_P_difference
    isGreater = False
    If (a - B) > eps Then isGreater = True
End Function
Public Function isBetween(a As Double, a0 As Double, a1 As Double)
    isBetween = False
    If ((a <= a0) And (a >= a1)) Or ((a >= a0) And (a <= a1)) Then isBetween = True
End Function
Public Function SplitTrim(ByVal s As String, ByVal SEP As String) As String()
    Dim SPrev As String
    s = Trim(s)
    Do
        SPrev = s
        s = Replace(s, "  ", " ")
    Loop Until s = SPrev
    SplitTrim = Split(s, SEP)
End Function
Public Function s(val As Double) As String
    s = Format(val, "0##.########")
End Function
Public Function Cdbl_(str_ As Variant) As Double
On Error GoTo er11:
    Dim dec_sep As String
    Dim s_ As String
    dec_sep = Application.International(xlDecimalSeparator)
    If dec_sep = "." Then
        s_ = Replace(str_, ",", ".")
    ElseIf dec_sep = "," Then
        s_ = Replace(str_, ".", ",")
    End If
    Cdbl_ = CDbl(s_)
    Exit Function
On Error GoTo erl2:
er11: ' Исключение возникает при ошибки типа Cdbl_
        If dec_sep = "." Then
            s_ = Replace(str_, ".", ",")
        ElseIf dec_sep = "," Then
            s_ = Replace(str_, ",", ".")
        End If
        Cdbl_ = CDbl(s_)
        Exit Function
erl2: ' Добавлено исключение
    Dim errmsg As String
    errmsg = "Cdbl_ string number conversion: str =" & str_ & ":" & Err.Description
    add_log_msg errmsg
    Err.Raise kStrConversion, Err.source, errmsg
End Function
Public Function CDbl_safe(str_ As Variant)
On Error GoTo err1:
    CDbl_safe = Cdbl_(str_)
Exit Function
err1:
    CDbl_safe = str_
End Function
'=============== array manipulation functions =========================
Public Function array_from_range(var_input, _
                            Optional transpose As Boolean = False, _
                            Optional key_crv As String = "", _
                            Optional key_x As String = "x", _
                            Optional key_y As String = "y")
' return array from range or from array or from number
    Dim ar() As Variant
    Dim rng As range
    Dim col As Collection
    Dim d As Long
    Dim i As Integer, j As Integer
    Dim done As Boolean
    
        Dim cl As Collection
            Dim ST As String
On Error GoTo err1:
    done = False
    
    If VarType(var_input) = vbString Then
        If Mid(var_input, 1, 1) = "[" Then
            Set var_input = ParseJson(var_input)
        ElseIf Mid(var_input, 1, 1) = "{" Then
            Dim dict As Dictionary
            Set dict = ParseJson(var_input)
            Set dict = dict(key_crv)
            ReDim ar(1 To dict(key_x).Count, 1 To 2)
            For i = 1 To dict(key_x).Count
                ar(i, 1) = dict(key_x).Item(i)
                ar(i, 2) = dict(key_y).Item(i)
            Next i
            
            var_input = ar
        End If
    End If
    
    If (TypeOf var_input Is range) Then
        Set rng = var_input
        If rng.Cells.Count = 1 Then
            ST = CStr(rng.Value2)
            If Mid(ST, 1, 1) = "[" Then
                Set var_input = ParseJson(ST)
            Else
                ReDim ar(1 To 1, 1 To 1)
                ar(1, 1) = rng.Value
                done = True
            End If
        Else
            ar = rng.Value2
            done = True
        End If
    End If
    
    
    If Not done Then
        If (TypeOf var_input Is Collection) Then
            Set col = var_input
            ar = collection_to_array_2d(col)
        'elseif typeof
        ElseIf IsArray(var_input) Then
            d = getDimension(var_input)
            If d = 2 Then
                ReDim ar(1 To UBound(var_input, 1) - LBound(var_input, 1) + 1, 1 To UBound(var_input, 2) - LBound(var_input, 2) + 1)
                For i = 1 To UBound(var_input, 1) - LBound(var_input, 1) + 1
                    For j = 1 To UBound(var_input, 2) - LBound(var_input, 2) + 1
                        ar(i, j) = var_input(i + LBound(var_input, 1) - 1, j + LBound(var_input, 2) - 1)
                    Next
                Next
            ElseIf d = 1 Then
                
                ReDim ar(1 To UBound(var_input, 1) - LBound(var_input, 1) + 1, 1 To 1)
                For i = 1 To UBound(var_input, 1) - LBound(var_input, 1) + 1
                    ar(i, 1) = var_input(i + LBound(var_input, 1) - 1)
                Next
            Else
                GoTo err1:
            End If
        Else
            ReDim ar(1 To 1, 1 To 1)
            ar(1, 1) = var_input
        End If
    End If
    If transpose Then
        array_from_range = array_transpose_(ar)
    Else
        array_from_range = ar
    End If
    Exit Function
err1:
    Dim errmsg As String
    errmsg = "Error:array_from_range:" & Err.Description
    add_log_msg (errmsg)
    Err.Raise kreadRangeError, "array_from_range", errmsg
End Function
Public Function array_transpose(var_input)
    array_transpose = array_transpose_(array_from_range(var_input))
End Function
Private Function array_transpose_(var_input)
    Dim i As Integer, j As Integer
    Dim ard
    
    ReDim ard(1 To UBound(var_input, 2), 1 To UBound(var_input, 1))
    For i = LBound(var_input, 1) To UBound(var_input, 1)
        For j = LBound(var_input, 2) To UBound(var_input, 2)
            ard(j, i) = var_input(i, j)
        Next
    Next
    array_transpose_ = ard
End Function
Public Function array_num_from_dictionary(dict As Dictionary, _
                                          x_key As String, y_key As String)
    ' extract array from dictionary - where stored as vectors
    Dim arr_out() As Double
    Dim i As Integer
    Dim xarr
    Dim yarr
    
    If dict.Exists(x_key) Then
        xarr = collection_to_array_1d(dict(x_key))
    End If
    If dict.Exists(y_key) Then
        yarr = collection_to_array_1d(dict(y_key))
    End If
    ReDim arr_out(LBound(xarr) To UBound(xarr), 1 To 2)
    For i = LBound(xarr) To UBound(xarr)
        arr_out(i, 1) = xarr(i)
        arr_out(i, 2) = yarr(i)
    Next i
    array_num_from_dictionary = arr_out
End Function
Public Function array_num_from_range(var_input, _
                            Optional remove_zeros As Boolean = False, _
                            Optional remove_only_rows As Boolean = False, _
                            Optional transpose As Boolean = False, _
                            Optional key_crv As String = "", _
                            Optional key_x As String = "x", _
                            Optional key_y As String = "y")
    Dim ar() As Variant
    Dim ard() As Double
    Dim ard2() As Double
    Dim val As Double
    Dim i As Integer, j As Integer
    
    ar = array_from_range(var_input, transpose, key_crv, key_x, key_y)
    
On Error GoTo err1:
    ReDim ard(1 To (UBound(ar, 1) - LBound(ar, 1) + 1), 1 To (UBound(ar, 2) - LBound(ar, 2) + 1))
    For i = LBound(ar, 1) To UBound(ar, 1)
        For j = LBound(ar, 2) To UBound(ar, 2)
            val = Cdbl_(CStr(ar(i, j)))
            ard(i, j) = val
        Next
    Next
    Dim M As Double
    If remove_zeros Then
On Error GoTo err2:
        ' transpose to delete zeros rows
        ReDim ard2(1 To UBound(ard, 2), 1 To UBound(ard, 1))
        For i = UBound(ard, 1) To LBound(ard, 1) Step -1
            For j = UBound(ard, 2) To LBound(ard, 2) Step -1
                ard2(j, i) = ard(i, j)
            Next
        Next
        ' delete zero rows
        For i = UBound(ard2, 2) To LBound(ard2, 2) Step -1
            M = 0
            For j = UBound(ard2, 1) To LBound(ard2, 1) Step -1
                M = M + Abs(ard2(j, i))
            Next
            If M = 0 And i > 1 Then
                ReDim Preserve ard2(1 To UBound(ard2, 1), 1 To i - 1)
            Else
                Exit For
            End If
        Next
        ' transpose back
        
        ReDim ard(1 To UBound(ard2, 2), 1 To UBound(ard2, 1))
        For i = UBound(ard2, 1) To LBound(ard2, 1) Step -1
            For j = UBound(ard2, 2) To LBound(ard2, 2) Step -1
                ard(j, i) = ard2(i, j)
            Next
        Next
        If Not remove_only_rows Then
        ' when array used for pipe trajectory
        ' zeros in columns can have meaning
        ' delete zero cols
            For i = UBound(ard, 2) To LBound(ard, 2) Step -1
                M = 0
                For j = UBound(ard, 1) To LBound(ard, 1) Step -1
                    M = M + Abs(ard(j, i))
                Next
                If M = 0 And i > 1 Then
                    ReDim Preserve ard(1 To UBound(ard, 1), 1 To i - 1)
                Else
                    Exit For
                End If
            Next
        End If
    End If
    array_num_from_range = ard
    Exit Function
err1:
    val = 0
    Resume Next
err2:
    Dim errmsg As String
    errmsg = "Error:array_num_from_range:" & Err.Description
    add_log_msg (errmsg)
    Err.Raise kreadRangeError, "array_num_from_range", errmsg
End Function
Public Function array1d_from_range(var_input, _
                        Optional ByVal num_only As Boolean = False, _
                        Optional ByVal no_zero As Boolean = False)
' return 1 d array from range or from array or from number
    Dim ar
    Dim arout() As Variant
    Dim rng As range
    Dim i As Integer
    Dim j As Integer
    Dim k As Integer
    Dim num As Integer
On Error GoTo err1:
    If num_only And no_zero Then
        ar = array_num_from_range(var_input, remove_zeros:=True)
    ElseIf num_only Then
        ar = array_num_from_range(var_input, remove_zeros:=False)
    Else
        ar = array_from_range(var_input)
    End If
    num = (UBound(ar, 1) - LBound(ar, 1) + 1) * (UBound(ar, 2) - LBound(ar, 2) + 1)
    ReDim arout(1 To num)
    k = 1
    For i = LBound(ar, 1) To UBound(ar, 1)
        For j = LBound(ar, 2) To UBound(ar, 2)
            arout(k) = ar(i, j)
            k = k + 1
        Next
    Next
    array1d_from_range = arout
    Exit Function
err1:
    Dim errmsg As String
    errmsg = "Error:array1d_from_range:" & Err.Description
    add_log_msg (errmsg)
    Err.Raise kreadRangeError, "array1d_from_range", errmsg
End Function
Public Function collection_to_array_1d(myCol As Collection)
    Dim ncol As Integer
    Dim i As Integer
    Dim res() As Variant
    
    ncol = myCol.Count
    ReDim res(1 To ncol)
    For i = 1 To ncol
        res(i) = myCol(i)
    Next i
    collection_to_array_1d = res
End Function
Public Function collection_to_array_2d(myCol As Collection, _
                           Optional transpose As Boolean = False) As Variant
' на входе должно быть двумерная коллекция - коллекция коллекций
    Dim Result  As Variant
    Dim cnt     As Long
    Dim ncol As Integer
    Dim nrow As Integer
    Dim j As Long
    
    ncol = myCol.Count
    If ncol >= 1 Then
        If TypeOf myCol(1) Is Collection Then
            nrow = myCol(1).Count
        Else
            nrow = 1
        End If
    
    Else
        Err.Raise kErrArraySize, , "collection_to_array_2d error - wrong dimension"
    End If
    
    If transpose Then
        ReDim Result(1 To nrow, 1 To ncol)
        For cnt = 1 To myCol.Count
            For j = 1 To nrow
                If TypeOf myCol(1) Is Collection Then
                    If Not IsNull(myCol(cnt)(j)) Then
                        Result(j, cnt) = myCol(cnt)(j)
                    Else
                        Result(j, cnt) = "null"
                    End If
                Else
                    Result(j, cnt) = myCol(cnt)
                End If
            Next j
        Next cnt
    Else
        ReDim Result(1 To ncol, 1 To nrow)
        For cnt = 1 To myCol.Count
            For j = 1 To nrow
                If TypeOf myCol(1) Is Collection Then
                    If Not IsNull(myCol(cnt)(j)) Then
                        Result(cnt, j) = myCol(cnt)(j)
                    Else
                        Result(cnt, j) = "null"
                    End If
                Else
                    Result(cnt, j) = myCol(cnt)
                End If
            Next j
        Next cnt
    End If
    collection_to_array_2d = Result
End Function
Public Function array_join(arr_in As Variant)
' get one two dimensional array from array of arrays
' needed to support array output to range from VBA
    Dim arr_out As Variant
    Dim num_rows As Integer
    Dim num_cols As Integer
    Dim l As Integer, U As Integer
    Dim i As Integer, j As Integer
    l = LBound(arr_in)
    U = UBound(arr_in)
    num_cols = UBound(arr_in(l)) - LBound(arr_in(l)) + 1
    num_rows = UBound(arr_in) - LBound(arr_in) + 1
    ReDim arr_out(1 To num_rows, 1 To num_cols)
    For i = 1 To num_rows
        For j = 1 To num_cols
            arr_out(i, j) = arr_in(i - 1 + l)(j - 1 + l)
        Next j
    Next i
    array_join = arr_out
End Function
Private Function getDimension(var As Variant) As Long
    On Error GoTo Err
    Dim i As Long
    Dim tmp As Long
    i = 0
    Do While True
        i = i + 1
        tmp = UBound(var, i)
    Loop
Err:
    getDimension = i - 1
End Function
' унифицированная расшифровка строки параметров расчета
Public Function param_to_dict(param As String) As Dictionary
        
    Dim prmd As Dictionary ' param dictionary and settings variables with default values
On Error GoTo err1:
    If Len(param) > 1 Then
        Set prmd = ParseJson(param)
    Else
        Set prmd = New Dictionary
    End If
    
    If prmd Is Nothing Then
        Set prmd = New Dictionary
    End If
    Set param_to_dict = prmd
    Exit Function
err1:
    Set prmd = New Dictionary
    Set param_to_dict = prmd
End Function
' чтение исходных данных в виде списков
Public Sub read_PTQ(ptq As PTQ_LIST, feed, p, t, log_, _
                     ByVal val1, _
                     ByVal q_liq_sm3day, _
                     ByVal fw_perc, _
                     ByVal rp_m3m3, _
                     ByVal q_gas_free_sm3day _
                    )
    Dim M As Integer
    Dim n As Integer
    Dim i As Integer
    Dim len_feed As Integer
    Dim len_p As Integer
    Dim len_t As Integer
    Dim len_ksep As Integer
    Dim len_ql As Integer
    Dim len_fw As Integer
    Dim len_rp As Integer
    Dim len_qg As Integer
    
' здесь читаем и причесываем потенциально списочные входных данных расчетных функций
    With ptq
         ' определяем что на входе - один поток или вектор потоков и складываем все в коллекцию
        .feed = parse_feed_list(feed)
        .p = parse_list(p)
        .t = parse_list(t)
        .val = parse_list(val1)
        .ql = parse_list(q_liq_sm3day)
        .fw = parse_list(fw_perc)
        .rp = parse_list(rp_m3m3)
        .qg = parse_list(q_gas_free_sm3day)
        
        len_feed = UBound(.feed) - LBound(.feed) + 1
        len_p = UBound(.p) - LBound(.p) + 1
        len_t = UBound(.t) - LBound(.t) + 1
        len_ksep = UBound(.val) - LBound(.val) + 1
        len_ql = UBound(.ql) - LBound(.ql) + 1
        len_fw = UBound(.fw) - LBound(.fw) + 1
        len_rp = UBound(.rp) - LBound(.rp) + 1
        len_qg = UBound(.qg) - LBound(.qg) + 1
        
        'далее проверим что длины были везде одинаковые
        If len_feed <> len_p Or _
           len_feed <> len_t Or _
           len_feed <> len_ql Or _
           len_feed <> len_fw Or _
           len_feed <> len_rp Or _
           len_feed <> len_qg Or _
           len_feed <> len_ksep Then
        ' надо выровнять
        
            M = MaxInt(len_feed, len_p)
            M = MaxInt(M, len_t)
            M = MaxInt(M, len_ksep)
            M = MaxInt(M, len_ql)
            M = MaxInt(M, len_fw)
            M = MaxInt(M, len_rp)
            M = MaxInt(M, len_qg)
            
            If len_feed < M Then
                n = UBound(.feed)
                If n > 1 Then log_.add_msg "warning: input list feed length > 1 but less that max length"
                ReDim Preserve .feed(1 To M)
                For i = n + 1 To M
                    .feed(i) = .feed(n)
                Next i
            End If
            If len_p < M Then
                n = UBound(.p)
                If n > 1 Then log_.add_msg "warning: input list p length > 1 but less that max length"
                ReDim Preserve .p(1 To M)
                For i = n + 1 To M
                    .p(i) = .p(n)
                Next i
            End If
            If len_t < M Then
                n = UBound(.t)
                If n > 1 Then log_.add_msg "warning: input list t length > 1 but less that max length"
                ReDim Preserve .t(1 To M)
                For i = n + 1 To M
                    .t(i) = .t(n)
                Next i
            End If
            If len_ksep < M Then
                n = UBound(.val)
                If n > 1 Then log_.add_msg "warning: input list ksep length > 1 but less that max length"
                ReDim Preserve .val(1 To M)
                For i = n + 1 To M
                    .val(i) = .val(n)
                Next i
            End If
            If len_ql < M Then
                n = UBound(.ql)
                If n > 1 Then log_.add_msg "warning: input list ql length > 1 but less that max length"
                ReDim Preserve .ql(1 To M)
                For i = n + 1 To M
                    .ql(i) = .ql(n)
                Next i
            End If
            If len_fw < M Then
                n = UBound(.fw)
                If n > 1 Then log_.add_msg "warning: input list fw length > 1 but less that max length"
                ReDim Preserve .fw(1 To M)
                For i = n + 1 To M
                    .fw(i) = .fw(n)
                Next i
            End If
            If len_rp < M Then
                n = UBound(.rp)
                If n > 1 Then log_.add_msg "warning: input list rp length > 1 but less that max length"
                ReDim Preserve .rp(1 To M)
                For i = n + 1 To M
                    .rp(i) = .rp(n)
                Next i
            End If
            If len_qg < M Then
                n = UBound(.qg)
                If n > 1 Then log_.add_msg "warning: input list qg length > 1 but less that max length"
                ReDim Preserve .qg(1 To M)
                For i = n + 1 To M
                    .qg(i) = .qg(n)
                Next i
            End If
        End If
        len_feed = UBound(.feed) - LBound(.feed) + 1
        len_p = UBound(.p) - LBound(.p) + 1
        len_t = UBound(.t) - LBound(.t) + 1
        len_ksep = UBound(.val) - LBound(.val) + 1
        len_ql = UBound(.ql) - LBound(.ql) + 1
        len_fw = UBound(.fw) - LBound(.fw) + 1
        len_rp = UBound(.rp) - LBound(.rp) + 1
        len_qg = UBound(.qg) - LBound(.qg) + 1
        
         If len_feed <> len_p Or _
           len_feed <> len_t Or _
           len_feed <> len_ql Or _
           len_feed <> len_fw Or _
           len_feed <> len_rp Or _
           len_feed <> len_qg Or _
           len_feed <> len_ksep Then
            Err.Raise 1000
        End If
        .len = len_feed
    End With
End Sub
Public Sub init_ptq(ptq As PTQ_LIST, ptq_from As PTQ_LIST)
    ReDim ptq.feed(LBound(ptq_from.feed) To UBound(ptq_from.feed))
    ReDim ptq.p(LBound(ptq_from.p) To UBound(ptq_from.p))
    ReDim ptq.t(LBound(ptq_from.t) To UBound(ptq_from.t))
    ReDim ptq.val(LBound(ptq_from.val) To UBound(ptq_from.val))
    
    ReDim ptq.ql(LBound(ptq_from.ql) To UBound(ptq_from.ql))
    ReDim ptq.fw(LBound(ptq_from.fw) To UBound(ptq_from.fw))
    ReDim ptq.rp(LBound(ptq_from.val) To UBound(ptq_from.rp))
    ReDim ptq.qg(LBound(ptq_from.val) To UBound(ptq_from.qg))
    
    ptq.len = ptq_from.len
End Sub
Public Sub init_ptesp(ptq As PTESP_LIST, ptq_from As PTQ_LIST)
    ReDim ptq.feed(LBound(ptq_from.feed) To UBound(ptq_from.feed))
    ReDim ptq.p_intake(LBound(ptq_from.p) To UBound(ptq_from.p))
    ReDim ptq.p_dis(LBound(ptq_from.p) To UBound(ptq_from.p))
    ReDim ptq.t_intake(LBound(ptq_from.t) To UBound(ptq_from.t))
    ReDim ptq.t_dis(LBound(ptq_from.t) To UBound(ptq_from.t))
    Set ptq.d = New Dictionary
    ptq.len = ptq_from.len
End Sub
Public Function convert_to_json_ptq(ptq As PTQ_LIST)
    convert_to_json_ptq = ConvertToJson(convert_to_dict_ptq(ptq))
End Function
Public Function convert_to_json_ptesp(ptq As PTESP_LIST)
    convert_to_json_ptesp = ConvertToJson(convert_to_dict_ptesp(ptq))
End Function
Public Function convert_to_dict_ptq(ptq As PTQ_LIST)
    Dim d As New Dictionary
    Dim i As Integer
    Dim c As New Collection
    
    d("p_atma") = ptq.p
    d("t_C") = ptq.t
    For i = LBound(ptq.feed) To UBound(ptq.feed)
        c.Add ParseJson(ptq.feed(i))
    Next i
    d("feed") = c
    Set convert_to_dict_ptq = d
End Function
Public Function convert_to_dict_ptesp(ptesp As PTESP_LIST)
    Dim d As New Dictionary
    Dim i As Integer
    Dim c As New Collection
    
    d("p_intake_atma") = ptesp.p_intake
    d("p_dis_atma") = ptesp.p_dis
    d("t_intake_C") = ptesp.t_intake
    d("t_dis_C") = ptesp.t_dis
    For i = LBound(ptesp.feed) To UBound(ptesp.feed)
        c.Add ParseJson(ptesp.feed(i))
    Next i
    d("feed") = c
    Set convert_to_dict_ptesp = d
End Function
Public Function parse_feed_list(ByVal feed As String) As Variant
    Dim col As Collection
    Dim c
    Dim res() As String
    Dim i As Integer
    
    If Mid(feed, 1, 1) = "[" Then
        Set col = ParseJson(feed)
        ReDim res(1 To col.Count)
        i = 1
        For Each c In col
            res(i) = ConvertToJson(c)
            i = i + 1
        Next
    Else
        ReDim res(1 To 1)
        res(1) = feed
    End If
    parse_feed_list = res
End Function
Public Function parse_list(val) As Variant
' convert input argument to array for UDF
' from number
' or from json sting
    Dim col As New Collection
    Dim c
    Dim res() As Double
    Dim i As Integer
    
    Select Case VarType(val)
        Case vbDouble, vbLong, vbInteger
            ReDim res(1 To 1)
            res(1) = val
        Case vbString
            Set col = ParseJson(val)
            ReDim res(1 To col.Count)
            i = 1
            For Each c In col
                res(i) = c
                i = i + 1
            Next
        Case vbEmpty
            ReDim res(1 To 1)
            res(1) = -1E+20
    End Select
    parse_list = res
End Function
'=======================================================================================
' набор функций для решения ДУ и уравнений для различных классов и процедур
' функция градиента давления для одномерной задачи расчета
' распределения давления в трубопроводе
'Public Function calc_grad_1d(l_m As Double, _
'                              y() As Double, _
'                              pipe As CPipe) As Double()
'    Dim out(0 To 0) As Double
'    Dim res As PIPE_FLOW_PARAMS
'    With pipe
'        res = pipe.calc_grad(l_m, y(0), pipe.t_h_mes_C(l_m), calc_dtdl:=False)
'    End With
'    out(0) = res.dp_dl
'    calc_grad_1d = out
'End Function
'
'' функция градиента давления для двухмерной задачи расчета
'' распределения давления в трубопроводе
'Public Function calc_grad_2d(l_m As Double, _
'                             y() As Double, _
'                             pipe As CPipe) As Double()
'    Dim out(0 To 1) As Double
'    Dim res As PIPE_FLOW_PARAMS
'    With pipe
'        res = pipe.calc_grad(l_m, y(0), y(1))
'    End With
'    out(0) = res.dp_dl
'    out(1) = res.dt_dl
'    calc_grad_2d = out
'End Function
' функция расчета ошибки в оценке давления для ЭЦН
' в зависимости от поправки на напор насоса
Public Function calc_ESP_dp_error_calibr_head_atm(ByVal calibr_head As Double, _
                                   CoeffA As Variant) As Double
    
    Dim pump As CESPpump
    Dim p_in_atma As Double
    Dim p_out_atma As Double
    Dim t_in_C As Double
    Dim t_dis_C As Double
    ' read coeffA - parameters
    Set pump = CoeffA(0)
    p_in_atma = CoeffA(1)
    p_out_atma = CoeffA(2)
    t_in_C = CoeffA(3)
    t_dis_C = CoeffA(4)
    
    With pump
        .calibr_head = calibr_head
        Call .calc_ESP(p_in_atma, t_in_C, t_dis_C, True, False)
        calc_ESP_dp_error_calibr_head_atm = (.p_dis_atma - p_out_atma)
    End With
    
End Function
' функция расчета ошибки в оценке давления для ЭЦН
' в зависимости от поправки на напор насоса
Public Function calc_ESP_dp_error_calibr_rate_atm(ByVal calibr_rate As Double, _
                                   CoeffA As Variant) As Double
    
    Dim pump As CESPpump
    Dim p_in_atma As Double
    Dim p_out_atma As Double
    Dim t_in_C As Double
    Dim t_dis_C As Double
    ' read coeffA - parameters
    Set pump = CoeffA(0)
    p_in_atma = CoeffA(1)
    p_out_atma = CoeffA(2)
    t_in_C = CoeffA(3)
    t_dis_C = CoeffA(4)
    
    With pump
        .calibr_rate = calibr_rate
        Call .calc_ESP(p_in_atma, t_in_C, t_dis_C, True, False)
        calc_ESP_dp_error_calibr_rate_atm = (.p_dis_atma - p_out_atma)
    End With
    
End Function
' расчет параметров трубы
' функция расчета ошибки в оценке давления для трубы
' в зависимости от поправки на гравитационную составляющую градиента
Public Function calc_pipe_dp_error_calibr_grav_atm(ByVal calibr_grav As Double, _
                                   CoeffA As Variant) As Double
    Dim PT As PTtype
    Dim pipe As CPipe
    Dim p_in_atma As Double
    Dim p_out_atma As Double
    ' read coeffA - parameters
    Set pipe = CoeffA(0)
    p_in_atma = CoeffA(1)
    p_out_atma = CoeffA(2)
    
    With pipe
        .calibr_grav = calibr_grav
        PT = .calc_dPipe(p_in_atma)
        calc_pipe_dp_error_calibr_grav_atm = (PT.p_atma - p_out_atma)
    End With
    
End Function
' функция расчета ошибки в оценке давления для трубы
' в зависимости от поправки на составляющую градиента по трению
Public Function calc_pipe_dp_error_calibr_fric_atm(ByVal calibr_fric As Double, _
                                   CoeffA As Variant) As Double
    Dim PT As PTtype
    Dim pipe As CPipe
    Dim p_in_atma As Double
    Dim p_out_atma As Double
    ' read coeffA - parameters
    Set pipe = CoeffA(0)
    p_in_atma = CoeffA(1)
    p_out_atma = CoeffA(2)
    
    With pipe
        .calibr_fric = calibr_fric
        PT = .calc_dPipe(p_in_atma)
        calc_pipe_dp_error_calibr_fric_atm = (PT.p_atma - p_out_atma)
    End With
    
End Function
' функция расчета ошибки в оценке давления для трубы
' в зависимости от газового фактора
Public Function calc_pipe_dp_error_rp_atm(ByVal rp As Double, _
                                   CoeffA As Variant) As Double
    Dim PT As PTtype
    Dim pipe As CPipe
    Dim p_in_atma As Double
    Dim p_out_atma As Double
    ' read coeffA - parameters
    Set pipe = CoeffA(0)
    p_in_atma = CoeffA(1)
    p_out_atma = CoeffA(2)
    
    With pipe
        .fluid.rp_m3m3 = rp
        PT = .calc_dPipe(p_in_atma)
        calc_pipe_dp_error_rp_atm = (PT.p_atma - p_out_atma)
    End With
    
End Function
' функция расчета ошибки в оценке давления для трубы
' в зависимости от обводненности
Public Function calc_pipe_dp_error_fw_atm(ByVal fw As Double, _
                                   CoeffA As Variant) As Double
    Dim PT As PTtype
    Dim pipe As CPipe
    Dim p_in_atma As Double
    Dim p_out_atma As Double
    ' read coeffA - parameters
    Set pipe = CoeffA(0)
    p_in_atma = CoeffA(1)
    p_out_atma = CoeffA(2)
    
    With pipe
        .fluid.fw_fr = fw
        PT = .calc_dPipe(p_in_atma)
        calc_pipe_dp_error_fw_atm = (PT.p_atma - p_out_atma)
    End With
    
End Function
' функция расчета ошибки в оценке давления для трубы
' в зависимости от дебита жидкости
Public Function calc_pipe_dp_error_qliq_atm(ByVal q_liq_sm3day As Double, _
                                   CoeffA As Variant) As Double
    Dim PT As PTtype
    Dim pipe As CPipe
    Dim p_in_atma As Double
    Dim p_out_atma As Double
    ' read coeffA - parameters
    Set pipe = CoeffA(0)
    p_in_atma = CoeffA(1)
    p_out_atma = CoeffA(2)
    
    With pipe
        .fluid.q_liq_sm3day = q_liq_sm3day
        PT = .calc_dPipe(p_in_atma)
        calc_pipe_dp_error_qliq_atm = (PT.p_atma - p_out_atma)
    End With
    
End Function
' функция расчета ошибки в оценке давления для трубы
' в зависимости от дебита газа
Public Function calc_pipe_dp_error_qgas_atm(ByVal qgas_sm3day As Double, _
                                   CoeffA As Variant) As Double
    Dim PT As PTtype
    Dim pipe As CPipe
    Dim p_in_atma As Double
    Dim p_out_atma As Double
    ' read coeffA - parameters
    Set pipe = CoeffA(0)
    p_in_atma = CoeffA(1)
    p_out_atma = CoeffA(2)
    
    With pipe
        .fluid.q_gas_free_sm3day = qgas_sm3day
        PT = .calc_dPipe(p_in_atma)
        calc_pipe_dp_error_qgas_atm = (PT.p_atma - p_out_atma)
    End With
    
End Function
Function calc_pipe_val(XA() As Double, CoeffA() As Double, RtnType As Long) As Variant
    Dim a As Double, B As Double, c As Double, d As Double, e As Double, f As Double, Slopea As Variant, X1 As Double, X2 As Double
    Dim Th As Double, t As Double
'    A = CoeffA(0)
'    B = CoeffA(1)
'    C = CoeffA(2)
'    D = CoeffA(3)
'
'    Th = XA(0)
'    T = XA(1)
'
'    Select Case RtnType
'    Case 1
'        CreepFD1 = A * Log(B * T) - C * T - D * Th
'    Case 2
'        CreepFD1 = GradientA("CreepFD1", CoeffA, XA, 4, 2)
'    End Select
End Function
' примеры функций для подгонки
Function ExpFunc1(XA() As Double, CoeffA() As Double, RtnType As Long) As Variant
    Dim a As Double, B As Double, c As Double, Slopea(0 To 2) As Double, X As Double
    a = CoeffA(0)
    B = CoeffA(1)
    c = CoeffA(2)
    X = XA(0)
    Select Case RtnType
    Case 1
        ExpFunc1 = a + c * Exp(-B * X)
    Case 2
        Slopea(0) = 1
        Slopea(1) = -c * X * Exp(-B * X)
        Slopea(2) = Exp(-B * X)
        ExpFunc1 = Slopea
    End Select
End Function
Function ExpFunc2(XA() As Double, CoeffA() As Double, RtnType As Long) As Variant
    Dim a As Double, B As Double, c As Double, Slopea(0 To 2) As Double, X1 As Double, X2 As Double
    a = CoeffA(0)
    B = CoeffA(1)
    c = CoeffA(2)
    X1 = XA(0)
    X2 = XA(1)
    Select Case RtnType
    Case 1
        ExpFunc2 = a * X2 + c * Exp(-B * X1)
    Case 2
        Slopea(0) = X2
        Slopea(1) = -c * X1 * Exp(-B * X1)
        Slopea(2) = Exp(-B * X1)
        ExpFunc2 = Slopea
    End Select
End Function
Function ExpFuncFD(XA() As Double, CoeffA() As Double, RtnType As Long) As Variant
    Dim a As Double, B As Double, c As Double, Slopea As Variant, X1 As Double, X2 As Double
    a = CoeffA(0)
    B = CoeffA(1)
    c = CoeffA(2)
    X1 = XA(0)
    X2 = XA(1)
    Select Case RtnType
    Case 1
        ExpFuncFD = a * X2 + c * Exp(-B * X1)
    Case 2
        ExpFuncFD = GradientA("ExpFuncFD", CoeffA, XA, 3, 3)
    End Select
End Function
Private Function GradientA(Func As Variant, Pvaluea0() As Double, _
                   XvalueA0() As Double, NumP As Long, NumX As Long, Optional dp As Double = 0.000001) As Variant
    Dim Eform As String, Eform2 As String, i As Long, j As Long, k As Long, ResA() As Double
    Dim res1 As Double, res2 As Double
    ' Evaluate the gradient vector (vector of partial first differentials, wrt each parameter)
    ' for the function specified in Func, using finite difference method.
    ReDim ResA(0 To NumP - 1)
    For i = 0 To NumP - 1
        Pvaluea0(i) = Pvaluea0(i) + dp
        res1 = Application.Run(Func, XvalueA0, Pvaluea0, 1)
        Pvaluea0(i) = Pvaluea0(i) - dp * 2
        res2 = Application.Run(Func, XvalueA0, Pvaluea0, 1)
        ResA(i) = (res1 - res2) / (dp * 2)
        Pvaluea0(i) = Pvaluea0(i) + dp
    Next i
    GradientA = ResA
End Function
Function ExpFunc2H(XA() As Double, CoeffA() As Double, RtnType As Long) As Variant
    Dim a As Double, B As Double, c As Double, Slopea(0 To 2) As Double, X1 As Double, X2 As Double
    Dim HessA(0 To 2, 0 To 2) As Double
    a = CoeffA(0)
    B = CoeffA(1)
    c = CoeffA(2)
    X1 = XA(0)
    X2 = XA(1)
    Select Case RtnType
    Case 1
        ExpFunc2H = a * X2 + c * Exp(-B * X1)
    Case 2
        Slopea(0) = X2
        Slopea(1) = -c * X1 * Exp(-B * X1)
        Slopea(2) = Exp(-B * X1)
        ExpFunc2H = Slopea
    Case 3
        HessA(0, 0) = 0
        HessA(0, 1) = 0
        HessA(0, 2) = 0
        HessA(1, 0) = 0
        HessA(1, 1) = c * X1 ^ 2 * Exp(-B * X1)
        HessA(1, 2) = -X1 * Exp(-B * X1)
        HessA(2, 0) = 0
        HessA(2, 1) = -X1 * Exp(-B * X1)
        HessA(2, 2) = 0
        ExpFunc2H = HessA
    End Select
End Function
Function PolyFunc(XA() As Double, CoeffA() As Double, RtnType As Long) As Variant
    Dim a As Double, B As Double, c As Double, Slopea(0 To 2) As Double, X As Double
    a = CoeffA(0)
    B = CoeffA(1)
    ' C = CoeffA(2)
    X = XA(0)
    ' X2 = XA(1)
    Select Case RtnType
    Case 1
        PolyFunc = a * X ^ 4 + B * X ^ 3 + a * X ^ 2 + B * X
    Case 2
        Slopea(0) = X ^ 4
        Slopea(1) = X ^ 3
        ' Slopea(2) = Exp(-B * X1)
        PolyFunc = Slopea
    End Select
End Function
Function CreepFD1(XA() As Double, CoeffA() As Double, RtnType As Long) As Variant
    Dim a As Double, B As Double, c As Double, d As Double, e As Double, f As Double, Slopea As Variant, X1 As Double, X2 As Double
    Dim Th As Double, t As Double
    a = CoeffA(0)
    B = CoeffA(1)
    c = CoeffA(2)
    d = CoeffA(3)
    
    Th = XA(0)
    t = XA(1)
    Select Case RtnType
    Case 1
        CreepFD1 = a * Log(B * t) - c * t - d * Th
    Case 2
        CreepFD1 = GradientA("CreepFD1", CoeffA, XA, 4, 2)
    End Select
End Function
Function CreepFD2(XA() As Double, CoeffA() As Double, RtnType As Long) As Variant
    Dim a As Double, B As Double, c As Double, d As Double, e As Double, f As Double, Slopea As Variant, X1 As Double, X2 As Double
    Dim Th As Double, t As Double
    a = CoeffA(0)
    B = CoeffA(1)
    c = CoeffA(2)
    d = CoeffA(3)
    e = CoeffA(4)
    f = CoeffA(5)
    Th = XA(0)
    t = XA(1)
    Select Case RtnType
    Case 1
        CreepFD2 = (a + B * Exp(c * Th)) * t ^ d / (t ^ e + f * Th)
    Case 2
        CreepFD2 = GradientA("CreepFD2", CoeffA, XA, 6, 2)
    End Select
End Function
' функция для поиска решения по расчету давления в клапане
Public Function calc_dq_gas_pu_valve(Pu As Double, CoeffA)
   Dim Q_gas As Double, d_mm As Double, pd As Double, gg As Double, t As Double
   Dim calibr As Double
   Q_gas = CoeffA(0)
   d_mm = CoeffA(1)
   pd = CoeffA(2)
   gg = CoeffA(3)
   t = CoeffA(4)
   calibr = CoeffA(5)
   
   calc_dq_gas_pu_valve = Q_gas - GLV_q_gas_sm3day(d_mm, Pu, pd, gg, t, calibr)(0)(0)
End Function
Public Function calc_dq_gas_pd_valve(pd As Double, CoeffA)
   Dim Q_gas As Double, d_mm As Double, Pu As Double, gg As Double, t As Double
   Dim calibr As Double
   Q_gas = CoeffA(0)
   d_mm = CoeffA(1)
   Pu = CoeffA(2)
   gg = CoeffA(3)
   t = CoeffA(4)
   calibr = CoeffA(5)
   
   calc_dq_gas_pd_valve = Q_gas - GLV_q_gas_sm3day(d_mm, Pu, pd, gg, t, calibr)(0)(0)
End Function
' функция расчета ошибки в расходе газа при произвольном давлении внутри клапана
Public Function calc_dq_gas_pv_vkr_valve(PV As Double, CoeffA)
   Dim Q_gas As Double, d_mm As Double, Pu As Double, pd As Double, gg As Double, t As Double
   Dim d_vkr As Double
   Dim calibr As Double
   
   d_mm = CoeffA(0)
   d_vkr = CoeffA(1)
   Pu = CoeffA(2)
   pd = CoeffA(3)
   gg = CoeffA(4)
   t = CoeffA(5)
   calibr = CoeffA(5)
   
   calc_dq_gas_pv_vkr_valve = GLV_q_gas_sm3day(d_mm, Pu, PV, gg, t, calibr)(0)(0) - GLV_q_gas_sm3day(d_vkr, PV, pd, gg, t, calibr)(0)(0)
End Function
' функция ищет корни уравнения вида
' f(x) = 0 на отрезке [x1..x2]
Public Function solve_equation_bisection(func_name As String, _
                                         ByVal X1 As Double, _
                                         ByVal X2 As Double, _
                                         CoeffA, _
                                         prm As CSolveParam) As Boolean
' func_name             - название функции для которой ищем решение
' x1                    - левая граница аргумента для поиска решения
' x2                    - правая граница аргумента для поиска решения
' coeffA                - параметры функции для которой ищем решение
' prm                   - объект с настройками поиска решения
'                         через этот же объект возвращаются решение и его параметры
    Dim Y1 As Double
    Dim Y2 As Double
    Dim y_temp As Double
    Dim x_temp As Double
    Dim i As Long
    Dim err_msg As String
    i = 0
On Error GoTo err1:
    ' определим значения параметров на границе
    Y1 = Application.Run(func_name, X1, CoeffA)
    Y2 = Application.Run(func_name, X2, CoeffA)
    With prm
        If Y1 * Y2 > 0 Then
            ' если значения на границе одного знака - то метод поиска решения не работает
            ' возможно решения нет и найти его не получится
            .iterations = 0
            .found_solution = False
            .msg = "solve_equation_bisection: values at segment's ends must have a different sign"
            solve_equation_bisection = False
            Exit Function
        End If
        ' начинаем цикл поиска решений (итерации)
        Do
            i = i + 1
            ' делим отрезок пополам
            x_temp = (X1 + X2) / 2
            y_temp = Application.Run(func_name, x_temp, CoeffA)
            If Abs(y_temp) < .y_tolerance Then
                solve_equation_bisection = True
                .x_solution = x_temp
                .y_solution = y_temp
                .iterations = i
                .found_solution = True
                .msg = "solve_equation_bisection: done by  " + CStr(i) + " iterations, tolerance " + CStr(.y_tolerance)
                Exit Function
            ElseIf (Abs(y_temp) < .y_tolerance * 10) And (i > 10) Then
                ' если почти угадали решение
                ' можно попробовать его найти за счет линейной аппроксимации
                ' (позволяет иногда меньше считать и избегать ошибок из за грубых расчетов)
                solve_equation_bisection = True
                .x_solution = X1 + (X2 - X1) * Y1 / Y2
                .y_solution = 0
                .iterations = i
                .found_solution = True
                .msg = "solve_equation_bisection: almost done by  " + CStr(i) + " iterations, tolerance " + CStr(.y_tolerance)
                Exit Function
                
            Else
                If y_temp * Y1 > 0 Then
                    X1 = x_temp
                    Y1 = y_temp
                Else
                    X2 = x_temp
                    Y2 = y_temp
                End If
            End If
        Loop Until i >= 100
        
        solve_equation_bisection = False
        .x_solution = x_temp
        .y_solution = y_temp
        .iterations = i
        .found_solution = False
        .msg = "solve_equation_bisection: too many iterations " + CStr(i)
    End With
    Exit Function
err1:
    On Error GoTo 0
    With prm
        .iterations = i
        .found_solution = False
        .msg = "solve_equation_bisection error " & Err.Description
    End With
    solve_equation_bisection = False
End Function
' функция решения ОДУ методом Кэш Карпа (Cash-Karp adaptive ODE solver)
' Решается ОДУ вида  Y'=f(Y,x)  с начальными устьвиями Y(xs)=Ys
' Y или одна переменная или вектор размерности N.
Public Function solve_ode(ByVal func_name As String, _
                          y0() As Double, _
                          XA() As Double, _
                          CoeffA As Variant, _
                 Optional eps As Double = 0.000001, _
                 Optional step As Double = 10, _
                 Optional MaxIts As Long = 1000)
' func_name         - имя функции  f(x)
' Y0                - начальное значение для расчета
' XA                - значения аргумента для которых ищем решение
' CoeffA            - дополнительные параметры функции градиента
' Eps
' Step
' MaxIts
    Dim M As Long, n As Long, State As ODESolverState, _
    YA() As Double, i As Long, _
    Rtn As Boolean, Rep As ODESolverReport
    Dim R() As Double
  
    n = UBound(y0) + 1
    M = UBound(XA) + 1
    'Set up any required output arrays
    ReDim YA(0 To M - 1, 0 To n - 1)
    
    'Call the appropriate AlgLib routine to initialise the State object
    Call ODESolverRKCK(y0(), n, XA, M, eps, step, State)
    
    ' Loop through the AlgLib solver routine and the external ODE
    ' evaluation routine until the solver routine returns "False",
    ' which indicates that it has finished.
    ' The VBA function named in "func_name" is called using
    ' the Application.Run method.
    Rtn = True
    i = 0
    Do While Rtn = True And i < MaxIts
        Rtn = ODESolverIteration(State)
        R = Application.Run(func_name, State.X, State.y, CoeffA(0))
        State.DY(0) = R(0)
        i = i + 1
    Loop
    
     ' Extract the desired results from the State
     ' object using the appropriate AlgLib routine
     Call ODESolverResults(State, M, XA, YA, Rep)
    
    ' If necessary convert the AlgLib output array(s) to
    ' a form suitable for Excel.  In this case YA2 is
    ' a 2D base 0 array, which may be assigned to the
    ' function return value without further processing.
    
    ' Assign the output array to the function return value
     solve_ode = YA
End Function

