'=======================================================================================
'Unifloc 7.11  Apodemus agrarius                                           khabibullin.ra@gubkin.ru
'Petroleum engineering calculations modules (macroses)
'2000 - 2019
'
'=======================================================================================
' вспомогательные функции для проведения расчетов из рабочих книг Excel
Option Explicit
Public Function UFversion() As String
' возвращает актуальный номер версии унифлок в рабочие книги которые это поддерживают
    UFversion = "Unifloc 7.11  Apodemus agrarius"
End Function
'description_to_manual      - для автогенерации описания - помещает заголовок функции и окружающие комментарии в мануал (со след строки)
' Функция кодирования параметров PVT в строку,
' для передачи PVT свойств в прикладных пользовательских функциях.
Public Function PVT_encode_string( _
                    Optional ByVal gamma_gas As Double = const_gg_, _
                    Optional ByVal gamma_oil As Double = const_go_, _
                    Optional ByVal gamma_wat As Double = const_gw_, _
                    Optional ByVal rsb_m3m3 = const_rsb_default, _
                    Optional ByVal rp_m3m3 = -1, _
                    Optional ByVal pb_atma = -1, _
                    Optional ByVal tres_C = const_tres_default, _
                    Optional ByVal bob_m3m3 = -1, _
                    Optional ByVal muob_cP = -1, _
                    Optional ByVal PVTcorr = Standing_based, _
                    Optional ByVal ksep_fr = 0, _
                    Optional ByVal p_ksep_atma = -1, _
                    Optional ByVal t_ksep_C = -1, _
                    Optional ByVal gas_only As Boolean = False _
                    )
' gamma_gas - удельная плотность газа, по воздуху.
'             По умолчанию const_gg_ = 0.6
' gamma_oil - удельная плотность нефти, по воде.
'             По умолчанию const_go_ = 0.86
' gamma_wat - удельная плотность воды, по воде.
'             По умолчанию const_gw_ = 1
' rsb_m3m3  - газосодержание при давлении насыщения, м3/м3.
'             По умолчанию const_rsb_default = 100
' rp_m3m3 - замерной газовый фактор, м3/м3.
'           Имеет приоритет перед rsb если rp < rsb
' pb_atma - давление насыщения при  температуре tres_C, атма.
'           Опциональный калибровочный параметр,
'           если не задан или = 0, то рассчитается по корреляции.
' tres_C  - пластовая температура, С.
'           Учитывается при расчете давления насыщения.
'           По умолчанию  const_tres_default = 90
' bob_m3m3 - объемный коэффициент нефти при давлении насыщения
'            и пластовой температуре, м3/м3.
'            По умолчанию рассчитывается по корреляции.
' muob_cP  - вязкость нефти при давлении насыщения.
'            и пластовой температуре, сП.
'            По умолчанию рассчитывается по корреляции.
' PVTcorr - номер набора PVT корреляций для расчета:
'           0 - на основе корреляции Стендинга;
'           1 - на основе кор-ии Маккейна;
'           2 - на основе упрощенных зависимостей.
' ksep_fr - коэффициент сепарации - определяет изменение свойств
'           нефти после сепарации части свободного газа.
'           Зависит от давления и температуры
'           сепарации газа, которые должны быть явно заданы.
' p_ksep_atma - давление при которой была сепарация
' t_ksep_C    - температура при которой была сепарация
' gas_only   - флаг - в потоке только газ
'              по умолчанию False (нефть вода и газ)
' результат - закодированная строка
'description_end
    
    Dim str As String
    Dim frmt As String
    Dim frmt_int As String
    frmt = "#0.##0"
    frmt_int = "0"
    str = ""
    ' безхитростно кодируем все параметры один за другим
    str = str & "gamma_gas:" & Format(gamma_gas, frmt) & ";"
    str = str & "gamma_oil:" & Format(gamma_oil, frmt) & ";"
    str = str & "gamma_wat:" & Format(gamma_wat, frmt) & ";"
    str = str & "rsb_m3m3:" & Format(rsb_m3m3, frmt) & ";"
    str = str & "rp_m3m3:" & Format(rp_m3m3, frmt) & ";"
    str = str & "pb_atma:" & Format(pb_atma, frmt) & ";"
    str = str & "tres_C:" & Format(tres_C, frmt) & ";"
    str = str & "bob_m3m3:" & Format(bob_m3m3, frmt) & ";"
    str = str & "muob_cP:" & Format(muob_cP, frmt) & ";"
    str = str & "PVTcorr:" & Format(PVTcorr, frmt_int) & ";"
    str = str & "ksep_fr:" & Format(ksep_fr, frmt) & ";"
    str = str & "p_ksep_atma:" & Format(p_ksep_atma, frmt) & ";"
    str = str & "t_ksep_C:" & Format(t_ksep_C, frmt) & ";"
    str = str & "gas_only:" & Format(gas_only) & ";"
    PVT_encode_string = str
End Function
'description_to_manual      - для автогенерации описания - помещает заголовок функции и окружающие комментарии в мануал (со след строки)
' функция расшифровки параметров PVT закодированных в строке
Public Function PVT_decode_string( _
                    Optional ByVal str_PVT As String = PVT_DEFAULT, _
                    Optional ByVal getStr As Boolean = False)
' str_PVT  - строка с параметрами PVT
' getStr  - флаг проверки работы функции
'    по умолчанию False (0) - функция выдает объект CPVT
'    если задать True - функция раскодирует строку и снова закодирует
'                и выдаст строку (можно использовать из рабочей книги)
' результат - объект CPVT
'description_end
    Dim A
    Dim i As Integer
    Dim B
    Dim p_atma As Double
    Dim t_C
    Dim gamma_gas As Double
    Dim gamma_oil As Double
    Dim gamma_wat As Double
    Dim rsb_m3m3 As Double
    Dim rp_m3m3 As Double
    Dim pb_atma As Double
    Dim tres_C As Double
    Dim bob_m3m3 As Double
    Dim muob_cP As Double
    Dim PVTcorr As Integer
    Dim ksep_fr As Double
    Dim p_ksep_atma As Double
    Dim t_ksep_C As Double
    Dim gas_only As Boolean
    Dim key As String
    Dim item As String
    Dim PVT As New CPVT
    Dim dict As New Dictionary
' при разбиении строки на части ошибки недопустимы
On Error GoTo er1:
    ' пытаемся разбить строку разделителями
    A = Split(str_PVT, ";")
    ' перебираем и сохраняем все параметры
    For i = LBound(A) To UBound(A)
        ' только для непустых разбиений
        If A(i) <> "" Then
           B = Split(A(i), ":")
           'только там где есть значение
           If UBound(B) = 1 Then
               dict.item(B(0)) = B(1)
           End If
        End If
    Next i
' при считывании параметров со строки пытаемся выполнить чтение всех параметров
' с использование словаря - включаем режим после ошибки двигаться далее
On Error GoTo er2:
    ' при чтении параметров используем промежуточную переменную key
    ' чтобы иметь возможность более информативно отреагировать на ошибку
    key = "gamma_oil": gamma_oil = Cdbl_(dict.item(key))
    key = "gamma_wat": gamma_wat = Cdbl_(dict.item(key))
    key = "gamma_gas": gamma_gas = Cdbl_(dict.item(key))
    key = "rsb_m3m3": rsb_m3m3 = Cdbl_(dict.item(key))
    key = "rp_m3m3": rp_m3m3 = Cdbl_(dict.item(key))
    ' для опциональных параметров делаем доп проверку
    key = "pb_atma": item = dict.item(key): If item = "" Then item = "-1":
    pb_atma = Cdbl_(item)
    key = "bob_m3m3": item = dict.item(key): If item = "" Then item = "-1":
    bob_m3m3 = Cdbl_(item)
    key = "muob_cP": item = dict.item(key): If item = "" Then item = "-1":
    muob_cP = Cdbl_(item)
    
    key = "tres_C": item = dict.item(key): If item = "" Then item = "-1":
    tres_C = Cdbl_(item)
    
    key = "PVTcorr": item = dict.item(key): If item = "" Then item = "0":
    PVTcorr = Cdbl_(item)
    key = "ksep_fr": item = dict.item(key): If item = "" Then item = "-1":
    ksep_fr = Cdbl_(item)
    key = "p_ksep_atma": item = dict.item(key): If item = "" Then item = "-1":
    p_ksep_atma = Cdbl_(item)
    key = "t_ksep_C": item = dict.item(key): If item = "" Then item = "-1":
    t_ksep_C = Cdbl_(item)
    key = "gas_only": item = dict.item(key): If item = "" Then item = "-1":
    gas_only = CBool(item)
' ловим все ошибки, все должно пройти идеально при дешифровке
On Error GoTo er1:
    ' калибровочный параметр проверяем специально и не даем сохраниться значению по умолчанию
    ' если он неправильно указан (дублируется инициализацией в конструкторе, но все же)
    PVT.Init gamma_gas, gamma_oil, gamma_wat, rsb_m3m3, pb_atma, bob_m3m3, PVTcorr, tres_C, rp_m3m3, muob_cP
    PVT.gas_only = gas_only
    If ksep_fr > 0 And ksep_fr <= 1 And p_ksep_atma > 0 And t_ksep_C > 0 Then
        Call PVT.mod_after_separation(p_ksep_atma, t_ksep_C, ksep_fr, GasGoesIntoSolution)
    End If
    If getStr Then
        PVT_decode_string = PVT_encode_string(gamma_gas, gamma_oil, _
              gamma_wat, rsb_m3m3, rp_m3m3, _
              pb_atma, tres_C, bob_m3m3, muob_cP, PVTcorr, ksep_fr, p_ksep_atma, _
              t_ksep_C)
    Else
        Set PVT_decode_string = PVT
    End If
    Exit Function
er1:
    Dim errmsg As String
    errmsg = "PVT_decode_string. error:" & Err.Description
    addLogMsg_debug errmsg
    Err.Raise kErrPVTinput, Err.Source, errmsg
    Exit Function
er2:
 '   On Error Resume Next
    addLogMsg "PVT_decode_string: error reading PVT key: " & key & " item: " & item & ":" & Err.Description
    Resume Next
    
End Function
'description_to_manual      - для автогенерации описания - помещает заголовок функции и окружающие комментарии в мануал (со след строки)
' функция кодирования параметров конструкции скважины
' в строку, которую можно потом использовать
Public Function well_encode_string( _
                Optional ByVal h_perf_m As Double = 2000, _
                Optional ByVal h_pump_m As Double = 1800, _
                Optional ByVal udl_m As Double = 0, _
                Optional ByVal d_cas_mm As Double = 150, _
                Optional ByVal dtub_mm As Double = 72, _
                Optional ByVal dchoke_mm As Double = 15, _
                Optional ByVal roughness_m As Double = 0.0001, _
                Optional ByVal t_bh_C As Double = 85, _
                Optional ByVal t_wh_C As Double = 25)
' h_perf_m       - измеренная глубина верхних дыр перфорации
'                 глубина пласта на которой рассчитывается
'                 забойное давление
' h_pump_m       - измеренная глубина спуска насоса
' udl_m         - удлинение
'                 разница между измеренной и вертикальной
'                 глубиной пласта
' d_cas_mm       - внутренний диаметр эксплуатационной колонны
' dtub_mm       - внешний диаметр НКТ
' dchoke_mm     - диаметр штуцера
' roughness_m   - шероховатость стенок НКТ и ЭК
' t_bh_C         - температура флюида на забое скважины
' t_wh_C         - температура флюида на устье скважины
'                 по умолчанию температурный расчет идет
'                 такие образом, что температура флюида меняется
'                 линейно относительно вертикальной глубины
' результат     - строка с закодированными параметрами
'description_end
    Dim str As String
    Dim frmt As String
    Dim frmt_int As String
    frmt = "#0.####0"
    frmt_int = "0"
    str = ""
    str = str & "h_perf_m:" & Format(h_perf_m, frmt) & ";"
    str = str & "h_pump_m:" & Format(h_pump_m, frmt) & ";"
    str = str & "udl_m:" & Format(udl_m, frmt) & ";"
    str = str & "d_cas_mm:" & Format(d_cas_mm, frmt) & ";"
    str = str & "dtub_mm:" & Format(dtub_mm, frmt) & ";"
    str = str & "dchoke_mm:" & Format(dchoke_mm, frmt) & ";"
    str = str & "roughness_m:" & Format(roughness_m, frmt) & ";"
    str = str & "t_bh_C:" & Format(t_bh_C, frmt) & ";"
    str = str & "t_wh_C:" & Format(t_wh_C, frmt) & ";"
    well_encode_string = str
    
End Function
'description_to_manual      - для автогенерации описания - помещает заголовок функции и окружающие комментарии в мануал (со след строки)
' функция расшифровки параметров конструкции скважины
' закодированных в строке
Public Function well_decode_string(ByVal str_well As String, _
                          Optional ByVal getStr As Boolean = False)
' str_well  - строка с параметрами конструкции скважины
' getStr  - флаг проверки работы функции
'    по умолчанию False (0) - функция выдает объект CWellESP
'    если задать True - функция раскодирует строку и снова закодирует
'                       и выдаст строку (можно использовать из листа)
' результат - объект CWellESP
'description_end
    Dim A
    Dim S As String
    Dim i As Integer
    Dim B
    Dim p_atma As Double
    Dim h_perf_m As Double
    Dim h_pump_m As Double
    Dim udl_m As Double
    Dim d_cas_mm As Double
    Dim dtub_mm As Double
    Dim dchoke_mm As Double
    Dim roughness_m As Double
    Dim t_bh_C As Double
    Dim t_wh_C As Double
    Dim well As CWellESP
    
    Dim key As String
    Dim dict As New Dictionary
    
    
' при разбиении строки на части ошибки недопустимы
On Error GoTo er1:
    ' пытаемся разбить строку разделителями
    A = Split(str_well, ";")
    ' перебираем и сохраняем все параметры
    For i = LBound(A) To UBound(A)
        ' только для непустых разбиений
        If A(i) <> "" Then
           B = Split(A(i), ":")
           'только там где есть значение
           If UBound(B) = 1 Then
               dict.item(B(0)) = B(1)
           End If
        End If
    Next i
' при считывании параметров со строки пытаемся выполнить чтение всех параметров
' с использование словаря - включаем режим после ошибки двигаться далее
On Error GoTo er2:
    ' при чтении параметров используем промежуточную переменную key
    ' чтобы иметь возможность более информативно отреагировать на ошибку
    key = "h_perf_m": h_perf_m = Cdbl_(dict.item(key))
    key = "h_pump_m": h_pump_m = Cdbl_(dict.item(key))
    key = "udl_m": udl_m = Cdbl_(dict.item(key))
    key = "d_cas_mm": d_cas_mm = Cdbl_(dict.item(key))
    key = "dtub_mm": dtub_mm = Cdbl_(dict.item(key))
    key = "dchoke_mm": dchoke_mm = Cdbl_(dict.item(key))
    key = "roughness_m": roughness_m = Cdbl_(dict.item(key))
    key = "t_bh_C": t_bh_C = Cdbl_(dict.item(key))
    key = "t_wh_C": t_wh_C = Cdbl_(dict.item(key))
    
On Error GoTo er1:
' ловим все ошибки, все должно пройти идеально
        
    If getStr Then
         well_decode_string = well_encode_string(h_perf_m, h_pump_m, udl_m, _
                                                    d_cas_mm, dtub_mm, dchoke_mm, roughness_m, _
                                                    t_bh_C, t_wh_C)
    Else
        ' if ready to init well then do it
        Set well = New CWellESP
        well.init_well_construction h_perf_m, h_pump_m, d_cas_mm, dtub_mm, udl_m
        well.init_well_temperature t_bh_C, t_wh_C
        ' initwell with use linear temp distribution mode by default
        ' so no  need to adjust temperature here anymore
        well.set_choke dchoke_mm, dtub_mm
        Set well_decode_string = well
    End If
    Exit Function
er1:
    Dim errmsg As String
    errmsg = "well_decode_string. error:" & Err.Description
    addLogMsg_debug errmsg
    Err.Raise kErrPVTinput, Err.Source, errmsg
    Exit Function
er2:
 '   On Error Resume Next
    addLogMsg "well_decode_string: error reading PVT key: " & key & ":" & Err.Description
    Resume Next
End Function
'description_to_manual      - для автогенерации описания - помещает заголовок функции и окружающие комментарии в мануал (со след строки)
' функция кодирования параметров работы УЭЦН в строку,
' которую можно потом использовать для задания ЭЦН в прикладных функциях
Public Function ESP_encode_string( _
                    Optional ByVal esp_ID As Double = 1005, _
                    Optional ByVal HeadNom_m As Double = 2000, _
                    Optional ByVal ESPfreq_Hz As Double = 50, _
                    Optional ByVal ESP_U_V As Double = 1000, _
                    Optional ByVal MotorPowerNom_kW As Double = 30, _
                    Optional ByVal t_intake_C As Double = 85, _
                    Optional ByVal t_dis_C As Double = 85, _
                    Optional ByVal KsepGS_fr As Double = 0, _
                    Optional ByVal ESP_energy_fact_Whday As Double = 0, _
                    Optional ByVal ESP_cable_type As Double = 0, _
                    Optional ByVal ESP_h_mes_m As Double = 0, _
                    Optional ByVal ESP_gas_degradation_type As Integer = 0, _
                    Optional ByVal c_calibr_head As Double = 0, _
                    Optional ByVal c_calibr_rate As Double = 0, _
                    Optional ByVal c_calibr_power As Double = 0, _
                    Optional ByVal PKV_work_min = -1, _
                    Optional ByVal PKV_stop_min = -1 _
                    )
' esp_ID            - идентификатор насоса
' HeadNom_m         - номинальный напор системы УЭЦН
'                   - соответствует напора в записи ЭЦН 50-2000
' ESPfreq_Hz           - частота, Гц
' ESP_U_V           - напряжение на ПЭД
' MotorPowerNom_kW  - номинальная мощность двигателя
' t_intake_C             - температура на приеме насоа
' t_dis_C            - температура на выкиде насоса.
'                     если = 0 и calc_along_flow = 1 то рассчитывается
' KsepGS_fr         - коэффициент сепарации газосепаратора УЭЦН
' ESP_energy_fact_Whday  - фактическое потребление мощности ЭЦН
' ESP_cable_type    - тип кабельной линии
'                   тип 1: cable_R_Omkm = 1.18
'                          cable_name = КПпАпБП-120 3x16
'                          cable_Tmax_C = 120
' ESP_h_mes_m        - длина кабельной линии
' ESP_gas_degradation_type       - тип насоса по работе с газом
'      ESP_gas_degradation_type = 0 нет коррекции
'      ESP_gas_degradation_type = 1 стандартный ЭЦН (предел 25%)
'      ESP_gas_degradation_type = 2 ЭЦН с газостабилизирующим модулем (предел 50%)
'      ESP_gas_degradation_type = 3 ЭЦН с осевым модулем (предел 75%)
'      ESP_gas_degradation_type = 4 ЭЦН с модифицированным ступенями (предел 40%)
'                 предел по доле газа на входе в насос после сепарации
'                 на основе статьи SPE 117414 (с корректировкой)
'                 поправка дополнительная к деградации (суммируется)
' c_calibr_head        - коэффициент поправки на напор (множитель)
' c_calibr_rate        - коэффициент поправки на подачу (множитель)
' c_calibr_power       - коэффициент поправки на мощность (множитель)
' PKV_work_min      - время работы скважины для режима ПКВ в минутах
' PKV_stop_min      - время ожидания запуска скважины для ПКВ , мин
'                     ПКВ - периодическое кратковременное включение
'                     если не заданы, то скважина в ПДФ
'                     ПДФ - постоянно действующий фонд
' результат         - строка с параметрами УЭЦН
'description_end
    Dim str As String
    Dim frmt As String
    Dim frmt_int As String
    frmt = "#0.####0"
    frmt_int = "0"
    str = ""
    str = str & "ESP_ID:" & Format(esp_ID, frmt) & ";"
    str = str & "HeadNom_m:" & Format(HeadNom_m, frmt) & ";"
    str = str & "ESPfreq_Hz:" & Format(ESPfreq_Hz, frmt) & ";"
    str = str & "ESP_U_V:" & Format(ESP_U_V, frmt) & ";"
    str = str & "MotorPowerNom_kW:" & Format(MotorPowerNom_kW, frmt) & ";"
    str = str & "t_intake_C:" & Format(t_intake_C, frmt) & ";"
    str = str & "t_dis_C:" & Format(t_dis_C, frmt) & ";"
    str = str & "KsepGS_fr:" & Format(KsepGS_fr, frmt) & ";"
    str = str & "ESP_energy_fact_Whday:" & Format(ESP_energy_fact_Whday, frmt) & ";"
    str = str & "ESP_cable_type:" & Format(ESP_cable_type, frmt_int) & ";"
    str = str & "ESP_h_mes_m:" & Format(ESP_h_mes_m, frmt) & ";"
    str = str & "ESP_gas_degradation_type:" & Format(ESP_gas_degradation_type, frmt_int) & ";"
    str = str & "c_calibr_head:" & Format(c_calibr_head, frmt) & ";"
    str = str & "c_calibr_rate:" & Format(c_calibr_rate, frmt) & ";"
    str = str & "c_calibr_power:" & Format(c_calibr_power, frmt) & ";"
    str = str & "PKV_work_min:" & Format(PKV_work_min, frmt) & ";"
    str = str & "PKV_stop_min:" & Format(PKV_stop_min, frmt) & ";"
    ESP_encode_string = str
    
End Function
'description_to_manual      - для автогенерации описания - помещает заголовок функции и окружающие комментарии в мануал (со след строки)
' функция расшифровки параметров работы ЭЦН закодированных в строке
Public Function ESP_decode_string(ByVal str_ESP As String, _
                         Optional ByVal getStr As Boolean = False)
' str_ESP  - строка с параметрами ЭЦН
' getStr  - флаг проверки работы функции
'    по умолчанию False (0) - функция выдает объект CESPsystemSimple
'    если задать True - функция раскодирует строку и снова закодирует
'                       и выдаст строку (можно использовать из листа)
' результат - объект CESPsystemSimple
'description_end
    Dim A
   ' Dim s As String
    Dim i As Integer
    Dim B
    Dim p_atma As Double
    Dim esp_ID As Double
    Dim HeadNom_m As Double
    Dim ESPfreq_Hz As Double
    Dim ESP_U_V As Double
    Dim MotorPowerNom_kW As Double
    Dim t_int_C As Double
    Dim t_dis_C As Double
    Dim KsepGS_fr As Double
    Dim ESPsys As CESPsystemSimple
    Dim pmp As CESPpump
    Dim dict As New Dictionary
    
    Dim ESP_energy_fact_Whday As Double
    Dim ESP_cable_type As Double
    Dim ESP_h_mes_m As Double
    Dim ESP_gas_degradation_type As Integer
    Dim c_calibr_head As Double
    Dim c_calibr_rate As Double
    Dim c_calibr_power As Double
    
    Dim PKV_work_min As Double
    Dim PKV_stop_min As Double
    Dim key As String
    
    
' при разбиении строки на части ошибки недопустимы
On Error GoTo er1:
    ' пытаемся разбить строку разделителями
    A = Split(str_ESP, ";")
    ' перебираем и сохраняем все параметры
    For i = LBound(A) To UBound(A)
        ' только для непустых разбиений
        If A(i) <> "" Then
           B = Split(A(i), ":")
           'только там где есть значение
           If UBound(B) = 1 Then
               dict.item(B(0)) = B(1)
           End If
        End If
    Next i
' при считывании параметров со строки пытаемся выполнить чтение всех параметров
' с использование словаря - включаем режим после ошибки двигаться далее
On Error GoTo er2:
    ' при чтении параметров используем промежуточную переменную key
    ' чтобы иметь возможность более информативно отреагировать на ошибку
    key = "ESP_ID": esp_ID = Cdbl_(dict.item(key))
    key = "HeadNom_m": HeadNom_m = Cdbl_(dict.item(key))
    key = "ESPfreq_Hz": ESPfreq_Hz = Cdbl_(dict.item(key))
    key = "ESP_U_V": ESP_U_V = Cdbl_(dict.item(key))
    key = "MotorPowerNom_kW": MotorPowerNom_kW = Cdbl_(dict.item(key))
    key = "t_int_C": t_int_C = Cdbl_(dict.item(key))
    key = "t_dis_C": t_dis_C = Cdbl_(dict.item(key))
    key = "KsepGS_fr": KsepGS_fr = Cdbl_(dict.item(key))
    key = "ESP_energy_fact_Whday": ESP_energy_fact_Whday = Cdbl_(dict.item(key))
    key = "ESP_cable_type": ESP_cable_type = Cdbl_(dict.item(key))
    key = "ESP_h_mes_m": ESP_h_mes_m = Cdbl_(dict.item(key))
    key = "ESP_gas_degradation_type": ESP_gas_degradation_type = Cdbl_(dict.item(key))
    key = "c_calibr_head": c_calibr_head = Cdbl_(dict.item(key))
    key = "c_calibr_rate": c_calibr_rate = Cdbl_(dict.item(key))
    key = "c_calibr_power": c_calibr_power = Cdbl_(dict.item(key))
    key = "PKV_work_min": PKV_work_min = Cdbl_(dict.item(key))
    key = "PKV_stop_min": PKV_stop_min = Cdbl_(dict.item(key))
' при создании объекта все должно пройти идеально
' переключаем режим реакции на ошибку
On Error GoTo er1:
    If getStr Then
         ESP_decode_string = ESP_encode_string(esp_ID, HeadNom_m, ESPfreq_Hz, _
                                               ESP_U_V, MotorPowerNom_kW, t_int_C, t_dis_C, _
                                               KsepGS_fr, ESP_energy_fact_Whday, ESP_cable_type, _
                                               ESP_h_mes_m, ESP_gas_degradation_type, c_calibr_head, c_calibr_rate, c_calibr_power, _
                                               PKV_work_min, PKV_stop_min)
    Else
        If esp_ID > 0 Then
            If checkID_ESP(esp_ID) Then
                Set pmp = getESP(esp_ID)
                pmp.stage_num = pmp.calc_ESP_num_stages(pmp.nom_rate_m3day, HeadNom_m) ' ESP_numStages
                pmp.freq_Hz = ESPfreq_Hz
                Set ESPsys = New CESPsystemSimple
                Set ESPsys.ESP_pump = pmp
                ESPsys.U_V = ESP_U_V
                ESPsys.power_motor_nom_W = MotorPowerNom_kW * 1000
                ESPsys.ksep_gassep_fr = KsepGS_fr
                ESPsys.t_int_C = t_int_C
                ESPsys.t_dis_C = t_dis_C
                
                ESPsys.energy_fact_Whday = ESP_energy_fact_Whday
                ESPsys.setCable ESP_cable_type
                ESPsys.h_mes_top_m = ESP_h_mes_m
                ESPsys.ESP_pump.c_calibr_head = c_calibr_head
                ESPsys.ESP_pump.c_calibr_rate = c_calibr_rate
                ESPsys.ESP_pump.c_calibr_power = c_calibr_power
                ESPsys.ESP_pump.gas_degr_type = ESP_gas_degradation_type
                Call ESPsys.PKV_set(PKV_work_min, PKV_stop_min)
                
            End If
        End If
        Set ESP_decode_string = ESPsys
    End If
    Exit Function
er1:
    Dim errmsg As String
    errmsg = "ESP_decode_string. error:" & Err.Description
    addLogMsg_debug errmsg
    Err.Raise kErrPVTinput, Err.Source, errmsg
    Exit Function
er2:
 '   On Error Resume Next
    addLogMsg "ESP_decode_string: error reading PVT key: " & key & ":" & Err.Description
    Resume Next
    
End Function
'description_to_manual      - для автогенерации описания - помещает заголовок функции и окружающие комментарии в мануал (со след строки)
' функция расшифровки параметров работы
' газлифтной скважины закодированных в строке
Public Function wellGL_decode_string(well_GL_str As String, Optional ByVal getStr As Boolean = False)
' well_GL_str  - строка с параметрами газлифтной скважины
' getStr  - флаг проверки работы функции
'    по умолчанию False (0) - функция выдает объект CESPsystemSimple
'    если задать True - функция раскодирует строку и снова закодирует
'                       и выдаст строку (можно использовать из листа)
' результат - объект CESPsystemSimple
'description_end
    Dim h_perf_m As Double
    Dim S As String
    Dim A, B
    Dim i As Long
    
    Dim htub_m As Double
    Dim udl_m As Double
    Dim d_cas_mm As Double
    Dim dtub_mm As Double
    Dim dchoke_mm As Double
    Dim roughness_m As Double
    Dim t_bh_C As Double
    Dim t_wh_C As Double
    Dim glv As Integer
    
    Dim dict As New Dictionary
    Dim key As String
' при разбиении строки на части ошибки недопустимы
On Error GoTo er1:
    ' пытаемся разбить строку разделителями
    A = Split(well_GL_str, ";")
    ' перебираем и сохраняем все параметры
    For i = LBound(A) To UBound(A)
        ' только для непустых разбиений
        If A(i) <> "" Then
           B = Split(A(i), ":")
           'только там где есть значение
           If UBound(B) = 1 Then
               dict.item(B(0)) = B(1)
           End If
        End If
    Next i
' при считывании параметров со строки пытаемся выполнить чтение всех параметров
' с использование словаря - включаем режим после ошибки двигаться далее
On Error GoTo er2:
    ' при чтении параметров используем промежуточную переменную key
    ' чтобы иметь возможность более информативно отреагировать на ошибку
    key = "h_perf_m": h_perf_m = Cdbl_(dict.item(key))
    key = "htub_m": htub_m = Cdbl_(dict.item(key))
    key = "udl_m": udl_m = Cdbl_(dict.item(key))
    key = "d_cas_mm": d_cas_mm = Cdbl_(dict.item(key))
    key = "dtub_mm": dtub_mm = Cdbl_(dict.item(key))
    key = "dchoke_mm": dchoke_mm = Cdbl_(dict.item(key))
    key = "roughness_m": roughness_m = Cdbl_(dict.item(key))
    key = "t_bh_C": t_bh_C = Cdbl_(dict.item(key))
    key = "t_wh_C": t_wh_C = Cdbl_(dict.item(key))
    key = "GLV": glv = Cdbl_(dict.item(key)) ' количество клапанов
    
    Dim H_glv_m() As Double
    Dim d_glv_mm() As Double
    Dim p_glv_atma() As Double
    ReDim H_glv_m(1 To glv)
    ReDim d_glv_mm(1 To glv)
    ReDim p_glv_atma(1 To glv)
    
    For i = 1 To glv
            key = "H_glv_m" & FormatInteger(i, 0): H_glv_m(i) = Cdbl_(dict.item(key))
            key = "d_glv_mm" & FormatInteger(i, 0): d_glv_mm(i) = Cdbl_(dict.item(key))
            key = "p_glv_atma" & FormatInteger(i, 0): p_glv_atma(i) = Cdbl_(dict.item(key))
    Next i
    
On Error GoTo er1:
' ловим все ошибки, все должно пройти идеально при дешифровке
    
    
    If getStr Then
        wellGL_decode_string = wellGL_encode_string( _
                    h_perf_m, _
                    htub_m, _
                    udl_m, _
                    d_cas_mm, _
                    dtub_mm, _
                    dchoke_mm, _
                    roughness_m, _
                    t_bh_C, _
                    t_wh_C, _
                    H_glv_m, _
                    d_glv_mm, _
                    p_glv_atma)
    Else
        Dim well As CWellGL
        Set well = NewWellGL()
        Call well.init_well_GLV(H_glv_m, d_glv_mm, p_glv_atma)
        Call well.init_well_construction(h_perf_m, htub_m, d_cas_mm, dtub_mm, udl_m)
        Call well.init_well_temperature(t_bh_C, t_wh_C)
        well.choke.d_choke_m = dchoke_mm
        well.hydraulic_correlation = BeggsBrill
        well.temp_correlation = StartEndTemp
        Set wellGL_decode_string = well
    End If
    
    Exit Function
er1:
    Dim errmsg As String
    errmsg = "wellGL_decode_string. error:" & Err.Description
    addLogMsg_debug errmsg
    Err.Raise kErrPVTinput, Err.Source, errmsg
    Exit Function
er2:
 '   On Error Resume Next
    addLogMsg "wellGL_decode_string: error reading PVT key: " & key & ":" & Err.Description
    Resume Next
End Function
'description_to_manual      - для автогенерации описания - помещает заголовок функции и окружающие комментарии в мануал (со след строки)
' функция кодирования параметров работы скважины с газлифтом
Public Function wellGL_encode_string( _
                    Optional ByVal h_perf_m As Double = 2000, _
                    Optional ByVal htub_m As Double = 1800, _
                    Optional ByVal udl_m As Double = 0, _
                    Optional ByVal d_cas_mm As Double = 150, _
                    Optional ByVal dtub_mm As Double = 72, _
                    Optional ByVal dchoke_mm As Double = 15, _
                    Optional ByVal roughness_m As Double = 0.0001, _
                    Optional ByVal t_bh_C As Double = 85, _
                    Optional ByVal t_wh_C As Double = 25, _
                    Optional HmesGLV_m = 0, _
                    Optional dGLV_mm = 0, _
                    Optional PsurfGLV_atma = 0)
' h_perf_m       - измеренная глубина верхних дыр перфорации
'                 глубина пласта на которой рассчитывается
'                 забойное давление
' htub_m        - измеренная глубина спуска НКТ
' udl_m         - удлинение
'                 разница между измеренной и вертикальной
'                 глубиной пласта
' d_cas_mm       - внутренний диаметр эксплуатационной колонны
' dtub_mm       - внешний диаметр НКТ
' dchoke_mm     - диаметр штуцера
' roughness_m   - шероховатость стенок НКТ и ЭК
' t_bh_C         - температура флюида на забое скважины
' t_wh_C         - температура флюида на устье скважины
'                 по умолчанию температурный расчет идет
'                 такие образом, что температура флюида меняется
'                 линейно относительно вертикальной глубины
' HmesGLV_m     -
' dGLV_mm       -
' PsurfGLV_atma -
' результат     - строка с закодированными параметрами
'description_end
    Dim str As String
    Dim frmt As String
    Dim frmt_int As String
    
    Dim H_glv_m() As Variant
    Dim d_glv_mm() As Variant
    Dim p_glv_atma() As Variant
    
    frmt = "#0.####0"
    frmt_int = "0"
    str = ""
    str = str & "h_perf_m:" & Format(h_perf_m, frmt) & ";"
    str = str & "htub_m:" & Format(htub_m, frmt) & ";"
    str = str & "udl_m:" & Format(udl_m, frmt) & ";"
    str = str & "d_cas_mm:" & Format(d_cas_mm, frmt) & ";"
    str = str & "dtub_mm:" & Format(dtub_mm, frmt) & ";"
    str = str & "dchoke_mm:" & Format(dchoke_mm, frmt) & ";"
    str = str & "roughness_m:" & Format(roughness_m, frmt) & ";"
    str = str & "t_bh_C:" & Format(t_bh_C, frmt) & ";"
    str = str & "t_wh_C:" & Format(t_wh_C, frmt) & ";"
    
    H_glv_m = readRange(HmesGLV_m)
    d_glv_mm = readRange(dGLV_mm)
    p_glv_atma = readRange(PsurfGLV_atma)
    
    Dim i As Long
    If (UBound(H_glv_m) = UBound(d_glv_mm)) And (UBound(H_glv_m) = UBound(p_glv_atma)) Then
        str = str & "GLV:" & FormatInteger(UBound(H_glv_m), 0) & ";"
        For i = LBound(H_glv_m) To UBound(H_glv_m)
            str = str & "H_glv_m" & FormatInteger(i, 0) & ":" & FormatFReal(Cdbl_(H_glv_m(i)), 0, 3) & ";"
            str = str & "d_glv_mm" & FormatInteger(i, 0) & ":" & FormatFReal(Cdbl_(d_glv_mm(i)), 0, 3) & ";"
            str = str & "p_glv_atma" & FormatInteger(i, 0) & ":" & FormatFReal(Cdbl_(p_glv_atma(i)), 0, 3) & ";"
        Next i
    Else
        str = str & "GVL:0;error" & ";"
    End If
    
    wellGL_encode_string = str
    
End Function
Private Function readRange(rr)
    Dim ar() As Variant
    Dim arout() As Variant
        Dim i As Integer
        Dim j As Integer
On Error GoTo err1:
    If (TypeOf rr Is Range) Or IsArray(rr) Then
        j = 0
        If (TypeOf rr Is Range) Then
            If rr.Cells.Count = 1 Then
                ReDim ar(1 To 1, 1 To 1)
                ar(1, 1) = rr.Value
            Else
                ar = rr.Value
            End If
            For i = LBound(ar) To UBound(ar)
                If Not IsEmpty(ar(i, 1)) Then
                    j = j + 1
                    ReDim Preserve arout(1 To j)
                    arout(j) = ar(i, 1)
                End If
            Next i
        Else
            ReDim arout(LBound(rr) To UBound(rr))
            For i = LBound(rr) To UBound(rr)
                arout(i) = rr(i)
                j = j + 1
            Next i
        End If
        If j = 0 Then
        ' не газлифтная скважина
            ReDim arout(1 To 1)
            arout(1) = 0
        End If
    Else
        ReDim arout(1 To 1)
        arout(1) = rr
    End If
    readRange = arout
    Exit Function
err1:
    Dim errmsg As String
    errmsg = "Error:readRange:" & Err.Description
    addLogMsg (errmsg)
    Err.Raise kreadRangeError, "readRange", errmsg
End Function
