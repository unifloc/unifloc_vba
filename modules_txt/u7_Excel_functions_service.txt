'=======================================================================================
'Unifloc 7.50 year 2024                                  khabibullinra@gmail.com
'Petroleum engineering calculations modules (macroses)
'2000 - 2023
'
'=======================================================================================
' вспомогательные функции для проведения расчетов из рабочих книг Excel
Option Explicit
'description_to_manual      - для автогенерации
' функция возвращает номер версии Унифлок VBA
Public Function unf_version() As String
'description_end
' возвращает актуальный номер версии унифлок в рабочие книги которые это поддерживают
    unf_version = const_unifloc_version
End Function
'description_to_manual      - для автогенерации
' Функция декодирования json строки,
' позволяет вывести содержимое json строки в таблицу
Public Function decode_json(json, _
                          Optional transpose As Boolean = False, _
                          Optional keys_filter = "", _
                          Optional only_values As Boolean = False, _
                          Optional safe_out As Boolean = False, _
                          Optional null_val As String = "")
' json   - строка содержащая результаты расчета
' transpose - выбор вывода в строки или в столбцы
' keys_filter - строка с ключами, которые надо вывести
' only_values - если = 1 подписи выводиться не будут
' safe_out - флаг заставляет выводить массив сторок,
'            что может работать лучше в офисе 2016 и ранее
' null_val - символ для нулевого значения
' результат - закодированная строка
'description_end
    Dim d As Dictionary
    Dim c As Collection
    Dim p
    Dim i As Integer, j As Integer
    Dim outarr() ' As String
    Dim outarr_safe()  As String
    Dim V
    Dim k
    
    Dim keylist As Dictionary
    Dim arrkeys As Variant
    Dim keystr As String
    Dim safe_out2 As Boolean
    
    safe_out2 = False
    
    On Error GoTo err1:
    
    
    JsonConverter.JsonOptions.UseDoubleForLargeNumbers = True
    If TypeName(json) = "Variant()" Then
        On Error GoTo er1:
        json = json(1, 1)
        GoTo go:
er1:
        On Error GoTo err1:
        json = json(1)
go:
        On Error GoTo err1:
    End If
    If VarType(json) = vbDouble Then
        ' если прилетело одно число то вернем его не раскодируя
        decode_json = json
        Exit Function
    End If
    ' далее пытаемся раскодировать
    Set p = ParseJson(json)
    If TypeName(p) = "Dictionary" Then
        Set d = p
        If keys_filter <> "" Then
            arrkeys = Split(keys_filter, ",")
            Set keylist = New Dictionary
            For i = LBound(arrkeys) To UBound(arrkeys)
                keystr = Trim(arrkeys(i))
                If d.Exists(keystr) Then
                    keylist(keystr) = d(keystr)
                Else
                    decode_json = "No key " & keystr & " found"
                    Exit Function
                End If
            Next i
            If keylist.Count > 0 Then
                Set d = keylist
            Else
                decode_json = "No keys found"
                Exit Function
            End If
        End If
    
        If transpose Then
            If only_values Then
                ReDim outarr(1 To 1, 1 To d.Count)
            Else
                ReDim outarr(1 To 2, 1 To d.Count)
            End If
            For i = 1 To d.Count
                k = d.keys(i - 1)
                outarr(1, i) = k
                If IsObject(d.Items(i - 1)) Then
                    Set V = d.Items(i - 1)
                Else
                    V = d.Items(i - 1)
                End If
                Select Case TypeName(V)
                    Case "Collection", "Dictionary"
                        If only_values Then
                            outarr(1, i) = ConvertToJson(V)
                            If Len(outarr(1, i)) > 255 Then safe_out2 = True   ' prevent excel 2016- output error
                        Else
                            outarr(2, i) = ConvertToJson(V)
                            If Len(outarr(2, i)) > 255 Then safe_out2 = True   ' prevent excel 2016- output error
                        End If
                    Case "Null"
                        If only_values Then
                            outarr(1, i) = null_val
                        Else
                            outarr(2, i) = null_val
                        End If
                    Case Else
                        If only_values Then
                            outarr(1, i) = V
                        Else
                            outarr(2, i) = V
                        End If
                End Select
            Next
        Else
            If only_values Then
                ReDim outarr(1 To d.Count, 1 To 1)
            Else
                ReDim outarr(1 To d.Count, 1 To 2)
            End If
            For i = 1 To d.Count
                k = d.keys(i - 1)
                outarr(i, 1) = d.keys(i - 1)
                If IsObject(d.Items(i - 1)) Then
                    Set V = d.Items(i - 1)
                Else
                    V = d.Items(i - 1)
                End If
                Select Case TypeName(V)
                    Case "Collection", "Dictionary"
                        If only_values Then
                            outarr(i, 1) = ConvertToJson(V)
                            If Len(outarr(i, 1)) > 255 Then safe_out2 = True   ' prevent excel 2016- output error
                        Else
                            outarr(i, 2) = ConvertToJson(V)
                            If Len(outarr(i, 2)) > 255 Then safe_out2 = True   ' prevent excel 2016- output error
                        End If
                    Case "Null"
                        If only_values Then
                            outarr(i, 1) = null_val
                        Else
                            outarr(i, 2) = null_val
                        End If
                    Case Else
                        If only_values Then
                            outarr(i, 1) = V
                        Else
                            outarr(i, 2) = V
                        End If
                End Select
            Next i
        End If
    Else  ' expect collection here
        If Not (keys_filter = "") Then
            decode_json = "No keys in collection"
            Exit Function
        End If
        
        Set c = p
        If c.Count = 1 Then
            If TypeName(c.Item(1)) = "Collection" Then
                outarr = collection_to_array_2d(c.Item(1), Not transpose)
            ElseIf TypeName(c.Item(1)) = "Dictionary" Then
                ReDim outarr(1 To 1, 1 To c.Count)
                outarr(1, 1) = ConvertToJson(c.Item(1))
            Else
                ReDim outarr(1 To 1, 1 To c.Count)
                outarr(1, 1) = c.Item(1)
            End If
        Else
            i = 1
            If transpose Then
                ReDim outarr(1 To 1, 1 To c.Count)
                For Each V In c
                    
                    Select Case TypeName(V)
                        Case "Collection", "Dictionary"
                            outarr(1, i) = ConvertToJson(V)
                            If Len(outarr(1, i)) > 255 Then safe_out2 = True   ' prevent excel 2016- output error
                        Case "Null"
                            outarr(1, i) = null_val
                        Case Else
                            outarr(1, i) = V
                    End Select
                    i = i + 1
                Next
            Else
                ReDim outarr(1 To c.Count, 1 To 1)
                For Each V In c
                    Select Case TypeName(V)
                        Case "Collection", "Dictionary"
                            outarr(i, 1) = ConvertToJson(V)
                            If Len(outarr(i, 1)) > 255 Then safe_out2 = True   ' prevent excel 2016- output error
                        Case "Null"
                            outarr(i, 1) = null_val
                        Case Else
                            outarr(i, 1) = V
                    End Select
                    i = i + 1
                Next
            End If
        End If
    End If
    If safe_out Or safe_out2 Then
        ReDim outarr_safe(LBound(outarr, 1) To UBound(outarr, 1), LBound(outarr, 2) To UBound(outarr, 2))
        For i = LBound(outarr, 1) To UBound(outarr, 1)
            For j = LBound(outarr, 2) To UBound(outarr, 2)
                If Not IsNull(outarr(i, j)) Then
                    If Len(CStr(outarr(i, j))) < 100000000 Then   ' for debug
                        outarr_safe(i, j) = CStr(outarr(i, j))
                    Else
                        outarr_safe(i, j) = "---"
                    End If
                Else
                    outarr_safe(i, j) = null_val
                End If
            Next j
        Next i
        'outarr_safe = outarr
        decode_json = outarr_safe
    Else
        decode_json = outarr
    End If
    Exit Function
err1:
    decode_json = "error"
End Function
'description_to_manual      - для автогенерации
' Функция извлекает список давлений из json строки
' нужна для удобства векторных расчетов
Public Function decode_json_p_atma(json)
' json   - строка содержащая результаты расчета
' результат - закодированная строка
'description_end
    decode_json_p_atma = decode_json(json, _
                                    keys_filter:="p_atma", _
                                    only_values:=True)
End Function
'description_to_manual      - для автогенерации
' Функция извлекает список температур из json строки
' нужна для удобства векторных расчетов
Public Function decode_json_t_C(json)
' json   - строка содержащая результаты расчета
' результат - закодированная строка
'description_end
    decode_json_t_C = decode_json(json, _
                                    keys_filter:="t_C", _
                                    only_values:=True)
End Function
'description_to_manual      - для автогенерации
' Функция извлекает списки давлений и температур из json строки
' нужна для удобства векторных расчетов
Public Function decode_json_pt(json)
' json   - строка содержащая результаты расчета
' результат - закодированная строка
'description_end
    decode_json_pt = decode_json(json, _
                                 transpose:=True, _
                                 keys_filter:="p_atma,t_C", _
                                 only_values:=True)
End Function
'description_to_manual      - для автогенерации
' Функция извлекает список дебитов из json строки
' нужна для удобства векторных расчетов
Public Function decode_json_q_liq_sm3day(json)
' json   - строка содержащая результаты расчета
' результат - закодированная строка
'description_end
    Dim d As Dictionary
    On Error GoTo er1:
    Set d = ParseJson(json)
    If d.Exists("q_liq_sm3day") Then
        decode_json_q_liq_sm3day = decode_json(json, _
                                    keys_filter:="q_liq_sm3day", _
                                    only_values:=True)
    ElseIf d.Exists("feed") Then
        Dim f
        Set f = d("feed")
        If TypeName(f) = "Collection" Then
            Dim c
            Dim c_out As New Collection
            For Each c In f
                Dim a As Double
                a = c("q_liq_sm3day")
                c_out.Add a
            Next
            decode_json_q_liq_sm3day = ConvertToJson(c_out)
        Else
            decode_json_q_liq_sm3day = f("q_liq_sm3day")
        End If
    End If
    Exit Function
er1:
    decode_json_q_liq_sm3day = "error:decode_json_q_liq_sm3day: " & Err.Description
End Function
'description_to_manual      - для автогенерации
' Функция извлекает список значений коэффициентов сепарации
' из json строки
' нужна для удобства векторных расчетов
Public Function decode_json_k_sep(json)
' json   - строка содержащая результаты расчета
' результат - закодированная строка
'description_end
    decode_json_k_sep = decode_json(json, _
                                    keys_filter:="k_sep", _
                                    only_values:=True)
End Function
' проверка если в словаре есть кривая, если есть вернуть ключи
' кривая - два массива одной длины
Public Function check_crv_in_dict(dict As Dictionary, ByRef outk As Collection) As Boolean
    Dim k
    Dim i As Integer
    Dim c As Collection
'    Dim outk As New Collection
    Dim l As Integer
    
    l = 0
    k = dict.keys
    
    check_crv_in_dict = True
    
    For i = LBound(k) To UBound(k)
        If TypeName(dict(k(i))) = "Collection" Then
            Set c = dict(k(i))
            If l = 0 Then l = c.Count
            If l > 0 And l = c.Count Then
                ' нашли претендента на массив, надо сохранить ключ
                outk.Add k(i)
            Else
                check_crv_in_dict = False
            End If
        End If
    Next i
End Function
'description_to_manual      - для автогенерации
' Функция декодирования json строки с табличной кривой,
' позволяет вывести содержимое json строки в таблицу (на лист)
Public Function decode_json_crv(json, _
                       Optional transpose As Boolean = False, _
                       Optional key_x As String = "", _
                       Optional key_y As String = "")
' json   - строка содержащая результаты расчета
' transpose - выбор вывода в строки или в столбцы
' результат - закодированная строка
'description_end
    Dim d As Dictionary
    Dim cx As Collection
    Dim cy As Collection
    
    Dim ckeys As New Collection
    
    Dim out_arr() ' As String
    Dim i As Integer
    Dim keyx As String, keyy As String
    
    
    On Error GoTo err1:
        If IsArray(json) Then
            json = json(1)
        End If
        
        Set d = ParseJson(json)
        
        ' проверим, есть ли в словаре, что то похожее на массивы с данными кривой
        Call check_crv_in_dict(d, ckeys)
        
        ' далее пытаемся определить ключи в которых лежат массивы с данными кривой
        ' если заданы явно пытаемся использовать их
        ' если есть ключи "curve_x", "curve_y" то берем ключи из них
        ' иначе если есть берем первые два массива одинаковой длины
        If Len(key_x) >= 1 Then
            keyx = key_x
        Else
            keyx = "curve_x"
            If d.Exists(keyx) Then
                keyx = d(keyx)
            Else
                If ckeys.Count >= 2 Then keyx = ckeys.Item(1)
            End If
        End If
        If Len(key_y) >= 1 Then
            keyy = key_y
        Else
            keyy = "curve_y"
            If d.Exists(keyy) Then
                keyy = d(keyy)
            Else
                If ckeys.Count >= 2 Then keyy = ckeys.Item(2)
            End If
        End If
        
        If d.Exists(keyx) And d.Exists(keyy) Then
            
            Set cx = d(keyx)
            Set cy = d(keyy)
            
            If transpose Then
                ReDim out_arr(1 To 2, 1 To cx.Count + 1)
                out_arr(1, 1) = keyx
                out_arr(2, 1) = keyy
                For i = 1 To cx.Count
                    out_arr(1, i + 1) = cx.Item(i)
                    out_arr(2, i + 1) = cy.Item(i)
                Next i
            Else
                ReDim out_arr(1 To cx.Count + 1, 1 To 2)
                out_arr(1, 1) = keyx
                out_arr(1, 2) = keyy
                For i = 1 To cx.Count
                    out_arr(i + 1, 1) = cx.Item(i)
                    out_arr(i + 1, 2) = cy.Item(i)
                Next i
            
            End If
        Else
            decode_json_crv = "error:decode_json_crv:no curve found in json"
            Exit Function
        End If
        
    decode_json_crv = out_arr
    Exit Function
err1:
    decode_json_crv = "error:decode_json_crv: " & Err.Description
End Function
'description_to_manual      - для автогенерации
'Функция кодирования параметров потока флюидов в строку,
Public Function encode_feed_list( _
          Optional ByVal q_liq_sm3day As Variant = 10, _
          Optional ByVal fw_perc As Double = -1, _
          Optional ByVal rp_m3m3 As Double = -1, _
          Optional ByVal q_gas_free_sm3day As Double = -1, _
          Optional ByVal fluid As String = PVT_DEFAULT)
' q_liq_sm3day  - дебит жидкости в ст.условиях.
' fw_perc       - ободненность, %
' rp_m3m3       - газовый фактор, м3/м3:
' q_gas_free_sm3day - расход свободного газа, ст. м3/сут
'
' результат - закодированная строка
'description_end
    Dim str As String
    Dim frmt As String
    Dim frmt_int As String
    Dim dict As Dictionary
    Dim col As Collection
    Dim col_feed As New Collection
    Dim q
    Set col = ParseJson(q_liq_sm3day)
    For Each q In col
        'Set dict = New Dictionary
        Set dict = ParseJson(fluid)
        dict("q_liq_sm3day") = Round(q, const_num_decimal_out)
        If fw_perc >= 0 Then dict("fw_perc") = Round(fw_perc, const_num_decimal_out)
        If rp_m3m3 > 0 Then dict("rp_m3m3") = Round(rp_m3m3, const_num_decimal_out)
        If q_gas_free_sm3day > 0 Then dict("q_gas_free_sm3day") = Round(q_gas_free_sm3day, const_num_decimal_out)
        col_feed.Add dict
    Next
    encode_feed_list = ConvertToJson(col_feed)
End Function
'description_to_manual      - для автогенерации
' функция кодирования параметров работы УЭЦН в строку
Public Function encode_ESP_pump( _
            Optional ByVal q_nom_sm3day As Double = 50, _
            Optional ByVal head_nom_m As Double = 2000, _
            Optional ByVal freq_nom_Hz As Double = 50, _
            Optional ByVal ESP_ID As Long = -1, _
            Optional ByVal num_stages As Integer = -1, _
            Optional ByVal calibr_head As Double = 1, _
            Optional ByVal calibr_rate As Double = 1, _
            Optional ByVal calibr_power As Double = 1, _
            Optional ByVal gas_correct_model As Integer = 0, _
            Optional ByVal gas_correct_stage_by_stage As Integer = 0, _
            Optional ByVal dnum_stages_integrate = 1)
' q_nom_sm3day   - номинальная подача ЭЦН
'                - соответствует подаче в записи ЭЦН 50-2000
' head_nom_m     - номинальный напор системы УЭЦН
'                - соответствует напору в записи ЭЦН 50-2000
' freq_nom_Hz    - номинальная частота, Гц, для которой задан номинальный напор
' esp_ID         - идентификатор насоса
'                  если задан - перекрывает подачу
' num_stages     - количество ступеней, если задано
'                  перекрывает значение напора
' calibr_head    - калибровка по напору
' calibr_rate    - калибровка по подаче
' calibr_power   - калибровка по мощности
' gas_correct_model - модель калибровки по газу
' gas_correct_stage_by_stage - флаг метода применения калибровки по газу
' dnum_stages_integrate - шаг интегрирования для расчета
' результат         - строка с параметрами УЭЦН
'description_end
    Dim dict As New Dictionary
    Dim esp As New CESPpump
    
    If ESP_ID <= 0 Then
        ESP_ID = ESP_id_by_rate(q_nom_sm3day, freq_nom_Hz)
    End If
    If num_stages <= 0 Then
        num_stages = ESP_calc_stages_num(ESP_ID, head_nom_m, freq_nom_Hz, q_nom_sm3day)
    End If
    
    Call esp.set_ID(ESP_ID, freq_nom_Hz)
    
    dict.Add "q_nom_sm3day", esp.q_nom_sm3day
    dict.Add "head_nom_m", esp.head_nom_m * num_stages
    dict.Add "freq_nom_Hz", esp.freq_nom_Hz
    dict.Add "name", "ESP-" & Round(esp.q_nom_sm3day) & "-" & Round(esp.head_nom_m * num_stages)
    dict.Add "ESP_ID", ESP_ID
    dict.Add "num_stages", num_stages
    
    dict.Add "gas_correct_model", gas_correct_model
    dict.Add "gas_correct_stage_by_stage", gas_correct_stage_by_stage
    dict.Add "calibr_head", calibr_head
    dict.Add "calibr_power", calibr_power
    dict.Add "calibr_rate", calibr_rate
    dict.Add "dnum_stages_integrate", dnum_stages_integrate
  
    
    encode_ESP_pump = ConvertToJson(dict)
    
End Function
'description_to_manual      - для автогенерации
' функция кодирования параметров ПЭД в строку
Public Function encode_ESP_motor( _
            Optional ByVal motor_ID As Long = 0, _
            Optional ByVal P_nom_kW As Double = 30, _
            Optional ByVal U_nom_lin_V As Double = 1000, _
            Optional ByVal f_nom_Hz As Double = 50, _
            Optional ByVal eff_nom_fr As Double = 0.82, _
            Optional ByVal cosphi_nom_fr As Double = 0.88, _
            Optional ByVal slip_nom_fr As Double = 0.053, _
            Optional ByVal f_surf_Hz As Double = 50, _
            Optional ByVal power_fact_kW As Double = 30, _
            Optional ByVal d_od_mm As Double = 0, _
            Optional ByVal lambda_ As Double = 0, _
            Optional ByVal alpha0 As Double = 0, _
            Optional ByVal xi0 As Double = 0, _
            Optional ByVal Ixcf As Double = 0)
'motor_ID - тип 0 - постоянные значения,
'               1 - задается по каталожным кривым, ассинхронный
'               2 - задается по схеме замещения, ассинхронный
'P_nom_kW       - номинальная мощность двигателя кВт
'U_nom_lin_V    - номинальное напряжение двигателя, линейное, В
'f_nom_Hz       - номинальная частота тока, Гц
'eff_nom_fr     - КПД при номинальном режиме работы
'cosphi_nom_fr  - коэффициент мощности при номинальный
'slip_nom_fr    - скольжение при номинальном режиме работы
'f_surf_Hz - частота тока на поверхности
'power_fact_kW - фактическая потребляемая мощность
'd_od_mm            - внешний диаметр - габарит ПЭД
'lambda_ - для motorID = 2 перегрузочный коэффициент
'         отношение макс момента к номинальному
'alpha0 - параметр. влияет на положение макс КПД.для motorID = 2
'xi0    - параметр. определяет потери момента при холостом ходе.
'         для motorID = 2
'Ixcf   - поправка на поправку тока холостого хода
'         при изменении напряжения и частоты от минимальной.
'description_end
    
    
    Dim dict As New Dictionary
    
    dict.Add "motor_ID", motor_ID
'   If U_surf_high_lin_V > 0 Then dict.Add "U_surf_high_lin_V", U_surf_high_lin_V
   If f_surf_Hz > 0 Then dict.Add "f_surf_Hz", f_surf_Hz
   If power_fact_kW > 0 Then dict.Add "power_fact_kW", power_fact_kW
   If U_nom_lin_V > 0 Then dict.Add "U_nom_lin_V", U_nom_lin_V
   If P_nom_kW > 0 Then dict.Add "P_nom_kW", P_nom_kW
   If f_nom_Hz > 0 Then dict.Add "F_nom_Hz", f_nom_Hz
   If eff_nom_fr > 0 Then dict.Add "eff_nom_fr", eff_nom_fr
   If cosphi_nom_fr > 0 Then dict.Add "cosphi_nom_fr", cosphi_nom_fr
   If slip_nom_fr > 0 Then dict.Add "slip_nom_fr", slip_nom_fr
   If d_od_mm > 0 Then dict.Add "d_od_mm", d_od_mm
    
   If lambda_ > 0 Then dict.Add "lambda", lambda_
   If alpha0 > 0 Then dict.Add "alpha0", alpha0
   If xi0 > 0 Then dict.Add "xi0", xi0
   If Ixcf > 0 Then dict.Add "Ixcf", Ixcf
   encode_ESP_motor = ConvertToJson(dict)
    
End Function
'description_to_manual      - для автогенерации
' функция кодирования параметров
' кабельной линии ПЭД в строку
Public Function encode_ESP_cable( _
            Optional ByVal length_m As Double = 1000, _
            Optional ByVal cable_R_Omkm As Double = 1.18, _
            Optional ByVal cable_X_Omkm As Double = 0.01, _
            Optional ByVal cable_t_max_C As Double = 120, _
            Optional ByVal manufacturer As String = "default", _
            Optional ByVal name As String = "default_name", _
            Optional ByVal d_mm As Double = 16)
' length_m - длина кабельной линии, м
' cable_R_Omkm - удельное активное сопротивление
' cable_X_Omkm - удельное реактивное сопротивление
' cable_t_max_C - максимально допустимая температура
' manufacturer - производитель, для справки
' name  - название кабеля, для справки
' d_mm - диаметр жилы
'description_end
    Dim dict As New Dictionary
    
    If cable_R_Omkm > 0 Then dict.Add "cable_R_Omkm", cable_R_Omkm
    If cable_X_Omkm > 0 Then dict.Add "cable_X_Omkm", cable_X_Omkm
    If cable_t_max_C > 0 Then dict.Add "cable_t_max_C", cable_t_max_C
    If manufacturer <> "no" Then dict.Add "manufacturer", manufacturer
    If name <> "no" Then dict.Add "name", name
    If d_mm > 0 Then dict.Add "d_mm", d_mm
    If length_m > 0 Then dict.Add "length_m", length_m
    
    encode_ESP_cable = ConvertToJson(dict)
    
End Function
Public Function encode_ESP_gassep( _
            Optional ByVal gassep_type As Long = 0)
            
' gassep_type - тип - номер из базы
    Dim dict As New Dictionary
    
    If gassep_type >= 0 Then dict.Add "gassep_type", gassep_type
    
    encode_ESP_gassep = ConvertToJson(dict)
End Function
'description_to_manual      - для автогенерации
' функция кодирования газосепаратора
Public Function encode_ESP_separation( _
            Optional ByVal separation_mode As String = 0, _
            Optional ByVal gassep_type As Long = 1, _
            Optional ByVal natsep_type As Long = 0, _
            Optional ByVal psep_man_atma As Double = 0, _
            Optional ByVal tsep_man_C As Double = 0, _
            Optional ByVal ksep_gassep_man_d As Double = 0, _
            Optional ByVal ksep_nat_man_d As Double = 0, _
            Optional ByVal ksep_liquid_man_d As Double = 0, _
            Optional ByVal M_Nm As Double = 0, _
            Optional ByVal manufacturer As String = "no", _
            Optional ByVal name As String = "no", _
            Optional ByVal length_m As Double = 0)
' separation_mode - режим расчета сепарации
' gassep_type - тип - номер из базы
' natsep_type - модель расчета естественной сепарации
' psep_man_atma  - давление для расчета
'                     коэффициента сепарации заданного вручную
' tsep_man_C  - температура для расчета
'                     коэффициента сепарации заданного вручную
' ksep_gassep_man_d  - коэффициент сепарации ГС заданный вручную
' ksep_nat_man_d  - коэффициент сепарации натуральной
'                   заданный вручную
' ksep_liquid_man_d - коэффициент сепарации жидкости для режима
'                     потока через затруб
' M_Nm  - момент на валу
' manufacturer - производитель, для справки
' name  - название кабеля, для справки
' length_m - длина кабельной линии, м
'description_end
    Dim dict As New Dictionary
    
    If separation_mode >= 0 Then
        Select Case separation_mode
            Case "0", "byCorrealation"
                dict.Add "separation_mode", "byCorrealation"
            Case "1", "pressureManual"
                dict.Add "separation_mode", "pressureManual"
            Case "2", "valueManual"
                dict.Add "separation_mode", "valueManual"
            Case "3", "fullyManual"
                dict.Add "separation_mode", "fullyManual"
        End Select
    End If
    If gassep_type >= 0 Then dict.Add "gassep_type", gassep_type
    If natsep_type >= 0 Then dict.Add "natsep_type", natsep_type
    If psep_man_atma > 0 Then dict.Add "psep_man_atma", psep_man_atma
    If tsep_man_C > 0 Then dict.Add "tsep_man_C", tsep_man_C
    If ksep_gassep_man_d > 0 Then dict.Add "ksep_gassep_man_d", ksep_gassep_man_d
    If ksep_nat_man_d > 0 Then dict.Add "ksep_nat_man_d", ksep_nat_man_d
    If ksep_liquid_man_d > 0 Then dict.Add "ksep_liquid_man_d", ksep_liquid_man_d
    If M_Nm > 0 Then dict.Add "M_Nm", M_Nm
    If manufacturer <> "no" Then dict.Add "manufacturer", manufacturer
    If name <> "no" Then dict.Add "name", name
    If length_m > 0 Then dict.Add "length_m", length_m
    
    encode_ESP_separation = ConvertToJson(dict)
    
End Function
'description_to_manual      - для автогенерации
' функция кодирования температурных парамметров окружающей среды
Public Function encode_ambient_formation_string( _
    Optional ByVal therm_cond_form_WmC As Double = 2.4252, _
    Optional ByVal sp_heat_capacity_form_JkgC As Double = 200, _
    Optional ByVal therm_cond_cement_WmC As Double = 6.965, _
    Optional ByVal therm_cond_tubing_WmC As Double = 32, _
    Optional ByVal therm_cond_casing_WmC As Double = 32, _
    Optional ByVal heat_transfer_casing_liquid_Wm2C As Double = 200, _
    Optional ByVal heat_transfer_casing_gas_Wm2C As Double = 10, _
    Optional ByVal heat_transfer_fluid_convection_Wm2C As Double = 200, _
    Optional ByVal t_calc_hr As Double = 240)
' therm_cond_form_WmC - теплопроводность породы окружающей среды
' sp_heat_capacity_form_JkgC - удельная теплоемкость породы окружающей среды
' therm_cond_cement_WmC - теплопроводность цементного камня вокруг скважины
' therm_cond_tubing_WmC - теплопроводность стенок НКТ
' heat_transfer_casing_liquid_Wm2C - теплопередача через затруб с жидкостью
' heat_transfer_casing_gas_Wm2C - теплопередача через затруб с газом
' heat_transfer_fluid_convection_Wm2C - теплопередача в потоке
'                               с жидкостью за счет конвекции
' t_calc_hr - время на которое расчитывается распределение температуры
'
'description_end
    Dim dict As New Dictionary
    
    dict.Add "therm_cond_form_WmC", therm_cond_form_WmC
    dict.Add "sp_heat_capacity_form_JkgC", sp_heat_capacity_form_JkgC
    dict.Add "therm_cond_cement_WmC", therm_cond_cement_WmC
    dict.Add "therm_cond_tubing_WmC", therm_cond_tubing_WmC
    dict.Add "therm_cond_casing_WmC", therm_cond_casing_WmC
    dict.Add "heat_transfer_casing_liquid_Wm2C", heat_transfer_casing_liquid_Wm2C
    dict.Add "heat_transfer_casing_gas_Wm2C", heat_transfer_casing_gas_Wm2C
    dict.Add "heat_transfer_fluid_convection_Wm2C", heat_transfer_fluid_convection_Wm2C
    dict.Add "t_calc_hr", t_calc_hr
    encode_ambient_formation_string = ConvertToJson(dict)
End Function
''=============================
' - для автогенерации описания - помещает заголовок функции и окружающие комментарии в мануал (со след строки)
'' функция расшифровки параметров газлифтной компоновки скважины
'Public Function GL_decode_string(well_GL_str As String, _
'                  Optional ByVal getStr As Boolean = False)
'' well_GL_str  - строка с параметрами газлифтной скважины
'' getStr  - флаг проверки работы функции
''    по умолчанию False (0) - функция выдает объект CESPsystem
''    если задать True - функция раскодирует строку и снова закодирует
''                       и выдаст строку (можно использовать из листа)
'' результат - объект CESPsystem
'
'
'    Dim S As String
'    Dim a, b
'    Dim i As Long
'    Dim GLV As Integer
'    Dim dict As New Dictionary
'    Dim key As String
'' при разбиении строки на части ошибки недопустимы
'On Error GoTo er1:
'    ' пытаемся разбить строку разделителями
'    a = Split(well_GL_str, ";")
'    ' перебираем и сохраняем все параметры
'    For i = LBound(a) To UBound(a)
'        ' только для непустых разбиений
'        If a(i) <> "" Then
'           b = Split(a(i), ":")
'           'только там где есть значение
'           If UBound(b) = 1 Then
'               dict.Item(b(0)) = b(1)
'           End If
'        End If
'    Next i
'' при считывании параметров со строки пытаемся выполнить чтение всех параметров
'' с использование словаря - включаем режим после ошибки двигаться далее
'On Error GoTo er2:
'    ' при чтении параметров используем промежуточную переменную key
'    ' чтобы иметь возможность более информативно отреагировать на ошибку
'    key = "GLV": GLV = Cdbl_(dict.Item(key)) ' количество клапанов
'
'    Dim q_gas_inj_sm3day As Double
'    Dim p_gas_inj_atma As Double
'    Dim d_gas_inj_mm As Double
'
'    Dim h_glv_m() As Double
'    Dim d_glv_mm() As Double
'    Dim p_glv_atma() As Double
'
'    ReDim h_glv_m(1 To GLV)
'    ReDim d_glv_mm(1 To GLV)
'    ReDim p_glv_atma(1 To GLV)
'
'    key = "q_gas_inj_sm3day": q_gas_inj_sm3day = Cdbl_(dict.Item(key))
'    key = "p_gas_inj_atma": p_gas_inj_atma = Cdbl_(dict.Item(key))
'    key = "d_gas_inj_mm": d_gas_inj_mm = Cdbl_(dict.Item(key))
'
'
'    For i = 1 To GLV
'            key = "H_glv_m" & FormatInteger(i, 0): h_glv_m(i) = Cdbl_(dict.Item(key))
'            key = "d_glv_mm" & FormatInteger(i, 0): d_glv_mm(i) = Cdbl_(dict.Item(key))
'            key = "p_glv_atma" & FormatInteger(i, 0): p_glv_atma(i) = Cdbl_(dict.Item(key))
'    Next i
'On Error GoTo er1:
'' ловим все ошибки, все должно пройти идеально при дешифровке
'    If getStr Then
'        GL_decode_string = GL_encode_string(q_gas_inj_sm3day, p_gas_inj_atma, d_gas_inj_mm, h_glv_m, d_glv_mm, p_glv_atma)
'    Else
'        Dim glv_set As New CGLValveSet
'        Call glv_set.loadFromArray(h_glv_m, d_glv_mm, p_glv_atma)
'        glv_set.q_gas_inj_sm3day = q_gas_inj_sm3day
'        glv_set.p_gas_inj_atma = p_gas_inj_atma
'        glv_set.d_gas_inj_mm = d_gas_inj_mm
'
'        Set GL_decode_string = glv_set
'    End If
'    Exit Function
'er1:
'    Dim errmsg As String
'    errmsg = "GL_decode_string. error:" & Err.Description
'    add_log_msg errmsg
'    Err.Raise kErrPVTinput, Err.source, errmsg
'    Exit Function
'er2:
' '   On Error Resume Next
'    add_log_msg "GL_decode_string: error reading PVT key: " & key & ":" & Err.Description
'    Resume Next
'
'End Function
'
'- для автогенерации описания - помещает заголовок функции и окружающие комментарии в мануал (со след строки)
'' функция кодирования параметров работы скважины с газлифтом
'Public Function GL_encode_string( _
'                    Optional q_gas_inj_sm3day As Double = 0, _
'                    Optional p_gas_inj_atma As Double = 0, _
'                    Optional d_gas_inj_mm As Double = 0, _
'                    Optional HmesGLV_m = 0, _
'                    Optional dGLV_mm = 0, _
'                    Optional PsurfGLV_atma = 0)
'' q_gas_inj_sm3day - расход газа закачки
'' p_gas_inj_atma - давление газа закачки на поверхности
'' d_gas_inj_mm - диаметр штуцера регулировки закачки газа на поверхности
'' HmesGLV_m     - измеренные глубины установки газлифтных клапанов
'' dGLV_mm       - диаметры порта установленных газлифтных клапанов
'' PsurfGLV_atma - давления зарядки газлифтных клапанов
'' результат     - строка с закодированными параметрами
'
'
'    Dim str As String
'    Dim frmt As String
'    Dim frmt_int As String
'
'    Dim h_glv_m() As Variant
'    Dim d_glv_mm() As Variant
'    Dim p_glv_atma() As Variant
'
'    Dim i As Long
'
'    frmt = "#0.####0"
'    frmt_int = "0"
'    str = "GLV:1;"
'    str = str & "q_gas_inj_sm3day:" & Format(q_gas_inj_sm3day, frmt) & ";"
'    str = str & "p_gas_inj_atma:" & Format(p_gas_inj_atma, frmt) & ";"
'    str = str & "d_gas_inj_mm:" & Format(d_gas_inj_mm, frmt) & ";"
'
'    h_glv_m = readRange(HmesGLV_m)
'    d_glv_mm = readRange(dGLV_mm)
'    p_glv_atma = readRange(PsurfGLV_atma)
'
'    If (UBound(h_glv_m) = UBound(d_glv_mm)) And (UBound(h_glv_m) = UBound(p_glv_atma)) Then
'        str = str & "GLV:" & FormatInteger(UBound(h_glv_m), 0) & ";"
'        For i = LBound(h_glv_m) To UBound(h_glv_m)
'            str = str & "H_glv_m" & FormatInteger(i, 0) & ":" & FormatFReal(Cdbl_(h_glv_m(i)), 0, 3) & ";"
'            str = str & "d_glv_mm" & FormatInteger(i, 0) & ":" & FormatFReal(Cdbl_(d_glv_mm(i)), 0, 3) & ";"
'            str = str & "p_glv_atma" & FormatInteger(i, 0) & ":" & FormatFReal(Cdbl_(p_glv_atma(i)), 0, 3) & ";"
'        Next i
'    Else
'        str = str & "GVL:0;error" & ";"
'    End If
'
'    GL_encode_string = str
'
'End Function
'=============================
'description_to_manual      - для автогенерации
' функция кодирования параметров работы скважины с газлифтом
Public Function encode_well_construction_string( _
             ByVal h_perf_m As Double, _
             ByVal h_tub_m As Double, _
             ByVal h_list_m As Variant, _
             ByVal d_tub_list_mm As Variant, _
             ByVal d_cas_list_mm As Variant, _
    Optional ByVal d_choke_mm As Double, _
    Optional ByVal t_val_C As Variant, _
    Optional ByVal rough_m As Double = 0.0001)
'h_perf_m - глубина перфорации по длине скважины
'           точка узлового анализа для забоя
'h_tub_m - глубина спуска НКТ, или глубина
'          спуска ЭЦН
'h_list_m  - траектория скважины, если число то измеренная
'           длина, range или таблица [0..N,0..1] то траектория
'd_tub_list_mm - диаметр НКТ. range или таблица [0..N,0..1]
'd_cas_list_mm - диаметр эксп колонны.
'              range или таблица [0..N,0..1]
'd_choke_mm - диаметр штуцера
't_val_C   - температура вдоль скважины
'           если число то температура на устье скважины
'           если range или таблица [0..N,0..1] то температура
'           окружающей среды по вертикальной глубине, С
'rough_m    - шероховатость трубы
' результат     - строка с закодированными параметрами
'description_end
    Dim dict As New Dictionary
    
    dict.Add "h_perf_m", h_perf_m
    dict.Add "h_tub_m", h_tub_m
    dict.Add "rough_m", rough_m
    dict.Add "d_choke_mm", d_choke_mm
    dict.Add "t_val_C", array_num_from_range(t_val_C, True)
    dict.Add "h_list_m", array_num_from_range(h_list_m, True)
    dict.Add "d_tub_list_mm", array_num_from_range(d_tub_list_mm, True)
    dict.Add "d_cas_list_mm", array_num_from_range(d_cas_list_mm, True)
    encode_well_construction_string = ConvertToJson(dict)
    
End Function
'description_to_manual      - для автогенерации
' функция кодирования диапазона ячеек в json строку
Public Function encode_json(rng, _
        Optional always_collection As Boolean = False)
' rng       - диапазон ячеек для кодирования
'           один столбец кодируется в коллекцию
'           два столбца кодируются в словарь
' always_collection - флаг принудительного кодирования
'           в коллекцию
' результат - закодированная строка
'description_end
    Dim d As New Dictionary
    Dim c As New Collection
    
    Dim t As Variant
    Dim i As Integer
    
    t = array_from_range(rng)
    
    If UBound(t, 2) = 1 Or always_collection Then
        If UBound(t, 2) = 1 Then
            For i = 1 To UBound(t)
                If Not IsEmpty(t(i, 1)) Then
                    c.Add t(i, 1)
                End If
            Next i
            encode_json = ConvertToJson(c)
        Else
            ' далее range преобразуется в массив, который сразу кодируется в json
            encode_json = ConvertToJson(array_from_range(rng, True))
        End If
    Else
        On Error GoTo er1:
        For i = 1 To UBound(t)
                d(t(i, 1)) = ParseJson(t(i, 2))
                GoTo cont1:
er1:
                d(t(i, 1)) = t(i, 2)
                Resume Next
cont1:
        Next i
        On Error GoTo 0
        encode_json = ConvertToJson(d)
    End If
    
End Function
'description_to_manual      - для автогенерации
' кодирование табличных результатов в json формат
Public Function encode_table_json(key As range, _
                                  val_name As range, _
                                  val As range)
' key      - столбец со значениями ключей (ID)
'            должны быть уникальные значения
' val_name - строка с названиями полей значений
'            должны быть уникальные значения
' val      - таблица со значениями, которые надо
'            закодировать
'description_end
    Dim dict As New Dictionary
    Dim d As Dictionary
    Dim i As Integer
    Dim j As Integer
    
    If key.Rows.Count <> val.Rows.Count Or val_name.Columns.Count <> val.Columns.Count Then
        encode_table_json = "error in data"
        Exit Function
    End If
    For i = 1 To key.Rows.Count
        Set d = New Dictionary
        For j = 1 To val_name.Columns.Count
            d.Add val_name.Cells(1, j), val.Cells(i, j)
        Next j
        dict.Add key.Cells(i, 1), d
    Next i
    encode_table_json = ConvertToJson(dict)
End Function
 Public Function combine_json(str1, str2)
    
   combine_json = Left(str1, Len(str1) - 1) & "," & Right(str2, Len(str2) - 1)
 End Function
'description_to_manual      - для автогенерации
' задание объекта трубы для расчета
Public Function encode_pipe( _
        Optional ByVal construction As String = "", _
        Optional ByVal t_model As String = "", _
        Optional ByVal flow_correlation As Integer = 0, _
        Optional ByVal flow_along_coord As Boolean = True, _
        Optional ByVal calibr_grav As Double = 1, _
        Optional ByVal calibr_fric As Double = 1, _
        Optional ByVal h_start_m As Double = -10000000000.1, _
        Optional ByVal h_end_m As Double = 10000000000.1, _
        Optional ByVal znlf As Boolean = False)
' construction - json кодирующий конструкцию скважины,
' используйте encode_pipe_construction
' t_model - температурная модель,
' используйте encode_t_model
' flow_correlation - корреляция многофазного потока
' flow_along_coord - флаг, определяющий направление потока
' calibr_grav - калибровка по гравитации (множитель)
' calibr_fric - калибровка по трению (множитель)
' h_start_m - измеренная глубина начала трубы, м
' h_end_m - измеренная глубина конца трубы, м
' znlf - флаг для включения барботажа
'description_end
    Dim dict As New Dictionary
    If construction = "" Then construction = encode_pipe_construction()
    dict.Add "construction", ParseJson(construction)
    If t_model = "" Then t_model = encode_t_model()
    dict.Add "t_model", ParseJson(t_model)
    dict.Add "flow_correlation", flow_correlation
    dict.Add "flow_along_coord", flow_along_coord
    dict.Add "calibr_grav", calibr_grav
    dict.Add "calibr_fric", calibr_fric
    If h_start_m > -1000000000 Then dict.Add "h_start_m", h_start_m
    If h_end_m < 1000000000 Then dict.Add "h_end_m", h_end_m
    dict.Add "znlf", znlf
    
    encode_pipe = ConvertToJson(dict)
End Function
'description_to_manual      - для автогенерации
'кодирование параметров штуцера
Public Function encode_choke( _
            Optional ByVal d_choke_mm As Double = 10, _
            Optional ByVal d_pipe_mm As Double = 70, _
            Optional ByVal calibr As Double = 1, _
            Optional ByVal CDischarge As Double = 0.826)
' d_choke_mm - диаметр штуцера, мм
' d_pipe_mm - диаметр трубы прилегающей к штуцеру, мм
' calibr - калибровочный параметр штуцера
' CDischarge - настроечный параметр штуцера
'description_end
    Dim dict As New Dictionary
    dict.Add "d_choke_mm", d_choke_mm
    dict.Add "d_pipe_mm", d_pipe_mm
    dict.Add "calibr", calibr
    dict.Add "CDischarge", CDischarge
    
    encode_choke = ConvertToJson(dict)
End Function
'description_to_manual      - для автогенерации
' задание параметров траектории трубы в json строке
Public Function encode_pipe_construction(Optional h_list_m As Variant = 1000, _
                                         Optional diam_list_mm As Variant = 62, _
                                         Optional roughness_m As Double = 0, _
                                         Optional h_vert_m As Variant = -1)
'h_list_m - число - длина вертикальной трубы или массив или range
'         содержащий зависимость вертикальной глубины от измеренной
'diam_list_mm - число-внутренний диаметр трубы или массив или range
'         содержащий зависимость внутреннего от измеренной глубины
'roughness_m - число - шероховатость, одна для всей трубы
'h_vert_m - число или массив вертикальных глубин
'           если задано то инклинометрия задается двумя векторами
'результат - json строка с описанием трубы
'description_end
    
    Dim dict As New Dictionary
    Dim h_curve As New CInterpolation
    Dim h_raw() As Double
    Dim h_vert() As Double
    Dim d_curve As New CInterpolation
    Dim d_raw() As Double
    
    Dim i As Integer
On Error GoTo er1:
    h_raw = array_num_from_range(h_list_m, remove_zeros:=True, key_crv:="h_list_m", key_x:="hmes_m", key_y:="hvert_m")
    h_vert = array_num_from_range(h_vert_m, remove_zeros:=True)
    
    If UBound(h_vert, 1) = UBound(h_raw, 1) And h_vert(UBound(h_vert, 1), 1) > 0 Then
    
        For i = LBound(h_raw, 1) To UBound(h_raw, 1)
            h_curve.AddPoint h_raw(i, 1), h_vert(i, 1)
        Next i
        
    Else
        For i = LBound(h_raw, 1) To UBound(h_raw, 1)
            If UBound(h_raw, 2) = 1 Then
                h_curve.AddPoint h_raw(i, 1), h_raw(i, 1)
            Else
                h_curve.AddPoint h_raw(i, 1), h_raw(i, 2)
            End If
        Next i
    
    End If
    If h_curve.num_points = 1 Then
        h_curve.AddPoint 0, 0
        If h_curve.num_points = 1 Then GoTo er2
    End If
    h_curve.xName = const_name_hmes_m
    h_curve.yName = const_name_hvert_m
    dict.Add const_name_h_list_m, h_curve.getDictShort
    
    d_raw = array_num_from_range(diam_list_mm, remove_zeros:=True, key_crv:="diam_list_mm", key_x:="hmes_m", key_y:="diam_int_mm")
    
    If UBound(d_raw, 2) = 1 Then
        d_curve.AddPoint 0, d_raw(1, 1)
        d_curve.AddPoint h_raw(UBound(h_raw, 1), 1), d_raw(1, 1)
    ElseIf UBound(d_raw, 2) > 1 Then
        For i = LBound(d_raw, 1) To UBound(d_raw, 1)
            If d_raw(i, 1) < h_raw(UBound(h_raw, 1), 1) Then
                d_curve.AddPoint d_raw(i, 1), d_raw(i, 2)
            End If
        Next
        d_curve.AddPoint h_raw(UBound(h_raw, 1), 1), d_raw(i - 1, 2)
    End If
    d_curve.xName = const_name_hmes_m
    d_curve.yName = const_name_diam_int_mm
    dict.Add const_name_diam_list_mm, d_curve.getDictShort
    
    If roughness_m > 0 Then
        dict.Add "roughness_m", roughness_m
    End If
    
    encode_pipe_construction = ConvertToJson(dict)
    
    Exit Function
    
er1:
    encode_pipe_construction = "error encode_pipe_construction " & Err.Description
    Exit Function
er2:
    encode_pipe_construction = "error encode_pipe_construction. zero length"
    Exit Function
End Function
Public Function encode_crv(crv_tab, _
                    Optional xlabel As String = "x", _
                    Optional ylabel As String = "y", _
                    Optional name As String = "crv")
    Dim val
    Dim crv As New CInterpolation
    Dim i As Integer
    Dim dict As New Dictionary
    Dim rng As range
    
On Error GoTo er2:
    Set dict = New Dictionary
    If (TypeOf crv_tab Is range) Then
        Set rng = crv_tab
        If Not IsNumeric(rng.Cells(1, 1)) Then
            If Not IsNumeric(rng.Cells(2, 1)) Then
                name = rng.Cells(1, 1)
                xlabel = rng.Cells(2, 1)
                ylabel = rng.Cells(2, 2)
            Else
                xlabel = rng.Cells(1, 1)
                ylabel = rng.Cells(1, 2)
            End If
        End If
    End If
    GoTo resume_after_error
er2:
    Resume resume_after_error
resume_after_error:
On Error GoTo er1:
    val = array_num_from_range(crv_tab, remove_zeros:=True)
    
    If UBound(val, 2) = 1 Then
        For i = LBound(val, 1) To UBound(val, 1)
            crv.AddPoint val(i, 1), val(i, 1)
        Next i
    ElseIf UBound(val, 2) >= 2 Then
        For i = LBound(val, 1) To UBound(val, 1)
            crv.AddPoint val(i, 1), val(i, 2)
        Next i
    End If
    
    crv.xName = xlabel
    crv.yName = ylabel
    dict.Add name, crv.getDictShort
    encode_crv = ConvertToJson(dict)
    
    Exit Function
    
er1:
    encode_crv = "error encode_crv " & Err.Description
    
End Function
'description_to_manual      - для автогенерации
' кодирование параметров температурной модели трубы/скважины
Public Function encode_t_model( _
            Optional t_model As TEMP_CALC_METHOD = StartEndTemp, _
            Optional t_list_C As Variant = 50, _
            Optional t_start_C As Double = -100, _
            Optional t_end_C As Double = -100, _
            Optional param As String = "")
' t_model   - номер температурной модели
' t_list_C  - массив n*2 распределения температуры
' t_start_C - температура в начале трубы
' t_end_C   - температура в конце трубы
' param     - параметры температурной модели
'             список параметров в мануале
'description_end
' encodes temperature model for pipe and wells
' describes ambient space params needed for temperature estimation
    Dim dict As New Dictionary
    Dim t_raw() As Double
    Dim t_curve As New CInterpolation
    Dim i As Integer
    
    Dim therm_cond_form_WmC As Double                 ' therm_cond_form_WmC - теплопроводность породы окружающей среды
    Dim sp_heat_capacity_form_JkgC As Double          ' sp_heat_capacity_form_JkgC - удельная теплоемкость породы окружающей среды
    Dim therm_cond_cement_WmC As Double               ' therm_cond_cement_WmC - теплопроводность цементного камня вокруг скважины
    Dim therm_cond_tubing_WmC As Double               ' therm_cond_tubing_WmC - теплопроводность стенок НКТ
    Dim therm_cond_casing_WmC As Double
    Dim heat_transfer_casing_liquid_Wm2C As Double    ' heat_transfer_casing_liquid_Wm2C - теплопередача через затруб с жидкостью
    Dim heat_transfer_casing_gas_Wm2C As Double       ' heat_transfer_casing_gas_Wm2C - теплопередача через затруб с газом
    Dim heat_transfer_fluid_convection_Wm2C As Double ' heat_transfer_fluid_convection_Wm2C - теплопередача в потоке с жидкостью за счет конвекции
    Dim t_calc_hr As Double                           ' t_calc_hr - время на которое расчитывается распределение температуры
      
On Error GoTo er1:
    dict.Add prm_t_model, t_model
    t_raw = array_num_from_range(t_list_C, remove_zeros:=True)
    
    For i = LBound(t_raw, 1) To UBound(t_raw, 1)
        If UBound(t_raw, 2) = 1 Then
            If UBound(t_raw, 1) = 1 Then
                t_curve.AddPoint 1000, t_raw(i, 1)
            Else
                t_curve.AddPoint 1000 * (i - 1), t_raw(i, 1)
            End If
        Else
            t_curve.AddPoint t_raw(i, 1), t_raw(i, 2)
        End If
    Next i
    If t_curve.num_points = 1 Then
        t_curve.AddPoint 0, 20
         If t_curve.num_points = 1 Then GoTo er2
    End If
    
    If t_start_C < 0 Then t_start_C = 20
    If t_end_C < 0 Then t_end_C = 40
    
    therm_cond_form_WmC = 2.4252
    sp_heat_capacity_form_JkgC = 200
    therm_cond_cement_WmC = 6.965
    therm_cond_tubing_WmC = 32
    therm_cond_casing_WmC = 32
    heat_transfer_casing_liquid_Wm2C = 200
    heat_transfer_casing_gas_Wm2C = 10
    heat_transfer_fluid_convection_Wm2C = 200
    t_calc_hr = 240
    
    If Len(param) > 0 Then
        Dim pdict As Dictionary
        Set pdict = ParseJson(param)
        
        If pdict.Exists(prm_t_start_C) Then t_start_C = pdict(prm_t_start_C)
        If pdict.Exists(prm_t_end_C) Then t_end_C = pdict(prm_t_end_C)
        
        If t_model = AmbientTemp Then
            If pdict.Exists(prm_thermal_conductivity_formation_WmC) Then therm_cond_form_WmC = pdict(prm_thermal_conductivity_formation_WmC)
            If pdict.Exists(prm_specific_heat_capacity_formation_JkgC) Then sp_heat_capacity_form_JkgC = pdict(prm_specific_heat_capacity_formation_JkgC)
            If pdict.Exists(prm_thermal_conductivity_cement_WmC) Then therm_cond_cement_WmC = pdict(prm_thermal_conductivity_cement_WmC)
            If pdict.Exists(prm_thermal_conductivity_tubing_WmC) Then therm_cond_tubing_WmC = pdict(prm_thermal_conductivity_tubing_WmC)
            If pdict.Exists(prm_thermal_conductivity_casing_WmC) Then therm_cond_casing_WmC = pdict(prm_thermal_conductivity_casing_WmC)
            If pdict.Exists(prm_heat_transfer_casing_liquid_Wm2C) Then heat_transfer_casing_liquid_Wm2C = pdict(prm_heat_transfer_casing_liquid_Wm2C)
            If pdict.Exists(prm_heat_transfer_casing_gas_Wm2C) Then heat_transfer_casing_gas_Wm2C = pdict(prm_heat_transfer_casing_gas_Wm2C)
            If pdict.Exists(prm_heat_transfer_fluid_convection_Wm2C) Then heat_transfer_fluid_convection_Wm2C = pdict(prm_heat_transfer_fluid_convection_Wm2C)
            If pdict.Exists(prm_time_calc_hr) Then t_calc_hr = pdict(prm_time_calc_hr)
        End If
        
    End If
    
    Select Case t_model
        Case AmbientTemp
            dict.Add prm_thermal_conductivity_formation_WmC, therm_cond_form_WmC
            dict.Add prm_specific_heat_capacity_formation_JkgC, sp_heat_capacity_form_JkgC
            dict.Add prm_thermal_conductivity_cement_WmC, therm_cond_cement_WmC
            dict.Add prm_thermal_conductivity_tubing_WmC, therm_cond_tubing_WmC
            dict.Add prm_thermal_conductivity_casing_WmC, therm_cond_casing_WmC
            dict.Add prm_heat_transfer_casing_liquid_Wm2C, heat_transfer_casing_liquid_Wm2C
            dict.Add prm_heat_transfer_casing_gas_Wm2C, heat_transfer_casing_gas_Wm2C
            dict.Add prm_heat_transfer_fluid_convection_Wm2C, heat_transfer_fluid_convection_Wm2C
            dict.Add prm_time_calc_hr, t_calc_hr
            t_curve.xName = const_name_hvert_m
            t_curve.yName = const_name_t_C
            dict.Add const_name_t_list_C, t_curve.getDictShort
        Case StartEndTemp
            Call dict.Add(prm_t_start_C, t_start_C)
            Call dict.Add(prm_t_end_C, t_end_C)
        Case GeoGradTemp
            t_curve.xName = const_name_hvert_m
            t_curve.yName = const_name_t_C
            dict.Add const_name_t_list_C, t_curve.getDictShort
        Case LengthTemp
            t_curve.xName = const_name_hmes_m   ' here we change vector name
            t_curve.yName = const_name_t_C
            dict.Add const_name_t_list_C, t_curve.getDictShort
    End Select
    encode_t_model = ConvertToJson(dict)
    
    Exit Function
    
er1:
    encode_t_model = "error encode_t_model " & Err.Description
    Exit Function
er2:
    encode_t_model = "error encode_t_model. zero length"
    Exit Function
End Function
'description_to_manual      - для автогенерации
' кодирование списка значений для векторных расчетов
' c заданным шагом, значения распределены равномерно
Public Function encode_arange(ByVal val_from As Double, _
                              ByVal val_to As Double, _
                              ByVal step As Double)
' val_from   - первое значение списка
' val_to     - последнее значение списка
' step       - шаг значений списка
'description_end
    Dim col As New Collection
    Dim i As Integer
    i = 0
    If val_to < val_from Or step <= 0 Then
        col.Add val_from
        encode_arange = ConvertToJson(col)
        Exit Function
    End If
    Do
        col.Add val_from + step * i
        i = i + 1
        ' на выходе позволим небольшую ошибку для double значений, чтобы проще искать границы
    Loop Until (val_to - val_from - step * i) < -0.0000000001
    
    encode_arange = ConvertToJson(col)
End Function
'description_to_manual      - для автогенерации
' кодирование списка значений для векторных расчетов
' с заданным кол-вом значений, значения распределены равномерно
Public Function encode_linspace(ByVal val_from As Double, _
                                ByVal val_to As Double, _
                                ByVal num As Double)
' val_from   - первое значение списка
' val_to     - последнее значение списка
' num        - количество значений
'description_end
    Dim col As New Collection
    Dim i As Integer
    i = 0
    If val_to < val_from Or num <= 0 Then
        col.Add val_from
        encode_linspace = ConvertToJson(col)
        Exit Function
    End If
    Dim step As Double
    step = (val_to - val_from) / num
    Do
        col.Add Round(val_from + step * i, 3)
        i = i + 1
        ' на выходе позволим небольшую ошибку для double значений, чтобы проще искать границы
    Loop Until i > num
    
    encode_linspace = ConvertToJson(col)
End Function
'description_to_manual      - для автогенерации
' кодирование списка значений для векторных расчетов
' с заданным кол-вом значений, значения распределены логарифмически
Public Function encode_logspace(ByVal val_from As Double, _
                                ByVal val_to As Double, _
                                ByVal num As Double)
' val_from   - первое значение списка
' val_to     - последнее значение списка
' num        - количество значений
'description_end
    Dim col As New Collection
    Dim i As Integer
    i = 0
    If val_to < val_from Or num <= 0 Then
        col.Add val_from
        encode_logspace = ConvertToJson(col)
        Exit Function
    End If
    Dim step As Double
    Dim eps As Double
    eps = 0.00001
    
    step = (Log(val_to - val_from) - Log(eps)) / num
    Do
        col.Add Exp(Log(eps) + step * i) + val_from
        i = i + 1
        ' на выходе позволим небольшую ошибку для double значений, чтобы проще искать границы
    Loop Until i > num
    
    encode_logspace = ConvertToJson(col)
End Function
Public Function list_add(ParamArray var() As Variant)
    list_add = "to be done"
End Function
Public Function list_mult(ParamArray var() As Variant)
    list_add = "to be done"
End Function
'description_to_manual      - для автогенерации
' слияние списков чисел в json формате
' если значения на границе совпадают - они сливаются в одно
Public Function list_merge(ParamArray var() As Variant)
'description_end
    Dim i As Integer, j As Integer
    Dim tmp
    Dim dimen As Integer
    Dim shift As Integer
On Error GoTo er1:
    dimen = 0
    Dim res As New Collection
    For i = LBound(var) To UBound(var)
        If Not IsEmpty(var(i)) Then
            tmp = parse_list(var(i))
            dimen = dimen + UBound(tmp) - LBound(tmp) + 1
            For j = LBound(tmp) To UBound(tmp)
                If res.Count > 0 Then
                    If Abs(tmp(j) - res.Item(res.Count)) > 0.0001 Then
                        res.Add tmp(j)
                    End If
                Else
                    res.Add tmp(j)
                End If
            Next
            shift = dimen
        End If
    Next
    list_merge = ConvertToJson(res)
    Exit Function
er1:
    list_merge = "error: list_merge " & Err.Description
End Function
'description_to_manual      - для автогенерации
' слияние списков чисел в json формате
' если значения на границе совпадают - они дублируются
Public Function list_concatenate(ParamArray var() As Variant)
'description_end
    Dim i As Integer, j As Integer
    Dim tmp
    Dim dimen As Integer
    Dim shift As Integer
On Error GoTo er1:
    dimen = 0
    Dim res As New Collection
    For i = LBound(var) To UBound(var)
        tmp = parse_list(var(i))
        dimen = dimen + UBound(tmp) - LBound(tmp) + 1
        For j = LBound(tmp) To UBound(tmp)
            res.Add tmp(j)
        Next
        shift = dimen
    Next
    list_concatenate = ConvertToJson(res)
    Exit Function
er1:
    list_concatenate = "error: list_merge " & Err.Description
End Function

