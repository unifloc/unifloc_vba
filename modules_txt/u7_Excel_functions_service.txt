'=======================================================================================
'Unifloc 7.38 aspo                                    khabibullinra@gmail.com
'Petroleum engineering calculations modules (macroses)
'2000 - 2022
'
'=======================================================================================
' вспомогательные функции для проведения расчетов из рабочих книг Excel
Option Explicit
'description_to_manual      - для автогенерации
' функция возвращает номер версии Унифлок VBA
Public Function unf_version() As String
'description_end
' возвращает актуальный номер версии унифлок в рабочие книги которые это поддерживают
    unf_version = const_unifloc_version
End Function
'description_to_manual      - для автогенерации
' Функция декодирования json строки,
' позволяет вывести содержимое json строки в таблицу
Public Function decode_json(json, _
                          Optional transpose As Boolean = False, _
                          Optional keys_filter = "", _
                          Optional only_values As Boolean = False, _
                          Optional safe_out As Boolean = False, _
                          Optional null_val As String = "")
' json   - строка содержащая результаты расчета
' transpose - выбор вывода в строки или в столбцы
' keys_filter - строка с ключами, которые надо вывести
' only_values - если = 1 подписи выводиться не будут
' safe_out - флаг заставляет выводить массив сторок,
'            что может работать лучше в офисе 2016 и ранее
' результат - закодированная строка
'description_end
    Dim d As Dictionary
    Dim C As Collection
    Dim p
    Dim i As Integer, j As Integer
    Dim outarr() ' As String
    Dim outarr_safe()  As String
    Dim V
    Dim K
    
    Dim keylist As Dictionary
    Dim arrkeys As Variant
    Dim keystr As String
    Dim safe_out2 As Boolean
    
    safe_out2 = False
    
    On Error GoTo err1:
    
    
    JsonConverter.JsonOptions.UseDoubleForLargeNumbers = True
    If TypeName(json) = "Variant()" Then
        json = json(1, 1)
    End If
    If VarType(json) = vbDouble Then
        ' если прилетело одно число то вернем его не раскодируя
        decode_json = json
        Exit Function
    End If
    ' далее пытаемся раскодировать
    Set p = ParseJson(json)
    If TypeName(p) = "Dictionary" Then
        Set d = p
        If keys_filter <> "" Then
            arrkeys = Split(keys_filter, ",")
            Set keylist = New Dictionary
            For i = LBound(arrkeys) To UBound(arrkeys)
                keystr = Trim(arrkeys(i))
                If d.Exists(keystr) Then
                    keylist(keystr) = d(keystr)
                Else
                    decode_json = "No key " & keystr & " found"
                    Exit Function
                End If
            Next i
            If keylist.Count > 0 Then
                Set d = keylist
            Else
                decode_json = "No keys found"
                Exit Function
            End If
        End If
    
        If transpose Then
            If only_values Then
                ReDim outarr(1 To 1, 1 To d.Count)
            Else
                ReDim outarr(1 To 2, 1 To d.Count)
            End If
            For i = 1 To d.Count
                K = d.keys(i - 1)
                outarr(1, i) = K
                If IsObject(d.Items(i - 1)) Then
                    Set V = d.Items(i - 1)
                Else
                    V = d.Items(i - 1)
                End If
                Select Case TypeName(V)
                    Case "Collection", "Dictionary"
                        If only_values Then
                            outarr(1, i) = ConvertToJson(V)
                            If Len(outarr(1, i)) > 255 Then safe_out2 = True   ' prevent excel 2016- output error
                        Else
                            outarr(2, i) = ConvertToJson(V)
                            If Len(outarr(2, i)) > 255 Then safe_out2 = True   ' prevent excel 2016- output error
                        End If
                    Case "Null"
                        If only_values Then
                            outarr(1, i) = null_val
                        Else
                            outarr(2, i) = null_val
                        End If
                    Case Else
                        If only_values Then
                            outarr(1, i) = V
                        Else
                            outarr(2, i) = V
                        End If
                End Select
            Next
        Else
            If only_values Then
                ReDim outarr(1 To d.Count, 1 To 1)
            Else
                ReDim outarr(1 To d.Count, 1 To 2)
            End If
            For i = 1 To d.Count
                K = d.keys(i - 1)
                outarr(i, 1) = d.keys(i - 1)
                If IsObject(d.Items(i - 1)) Then
                    Set V = d.Items(i - 1)
                Else
                    V = d.Items(i - 1)
                End If
                Select Case TypeName(V)
                    Case "Collection", "Dictionary"
                        If only_values Then
                            outarr(i, 1) = ConvertToJson(V)
                            If Len(outarr(i, 1)) > 255 Then safe_out2 = True   ' prevent excel 2016- output error
                        Else
                            outarr(i, 2) = ConvertToJson(V)
                            If Len(outarr(i, 2)) > 255 Then safe_out2 = True   ' prevent excel 2016- output error
                        End If
                    Case "Null"
                        If only_values Then
                            outarr(i, 1) = null_val
                        Else
                            outarr(i, 2) = null_val
                        End If
                    Case Else
                        If only_values Then
                            outarr(i, 1) = V
                        Else
                            outarr(i, 2) = V
                        End If
                End Select
            Next i
        End If
    Else  ' expect collection here
        If Not (keys_filter = "") Then
            decode_json = "No keys in collection"
            Exit Function
        End If
        
        Set C = p
        If C.Count = 1 Then
            If TypeName(C.Item(1)) = "Collection" Then
                outarr = collection_to_array_2d(C.Item(1), Not transpose)
            Else
                ReDim outarr(1 To 1, 1 To C.Count)
                outarr(1, 1) = C.Item(1)
            End If
        Else
            i = 1
            If transpose Then
                ReDim outarr(1 To 1, 1 To C.Count)
                For Each V In C
                    
                    Select Case TypeName(V)
                        Case "Collection", "Dictionary"
                            outarr(1, i) = ConvertToJson(V)
                            If Len(outarr(1, i)) > 255 Then safe_out2 = True   ' prevent excel 2016- output error
                        Case "Null"
                            outarr(1, i) = null_val
                        Case Else
                            outarr(1, i) = V
                    End Select
                    i = i + 1
                Next
            Else
                ReDim outarr(1 To C.Count, 1 To 1)
                For Each V In C
                    Select Case TypeName(V)
                        Case "Collection", "Dictionary"
                            outarr(i, 1) = ConvertToJson(V)
                            If Len(outarr(i, 1)) > 255 Then safe_out2 = True   ' prevent excel 2016- output error
                        Case "Null"
                            outarr(i, 1) = null_val
                        Case Else
                            outarr(i, 1) = V
                    End Select
                    i = i + 1
                Next
            End If
        End If
    End If
    If safe_out Or safe_out2 Then
        ReDim outarr_safe(LBound(outarr, 1) To UBound(outarr, 1), LBound(outarr, 2) To UBound(outarr, 2))
        For i = LBound(outarr, 1) To UBound(outarr, 1)
            For j = LBound(outarr, 2) To UBound(outarr, 2)
                If Not IsNull(outarr(i, j)) Then
                    If Len(CStr(outarr(i, j))) < 100000000 Then   ' for debug
                        outarr_safe(i, j) = CStr(outarr(i, j))
                    Else
                        outarr_safe(i, j) = "---"
                    End If
                Else
                    outarr_safe(i, j) = null_val
                End If
            Next j
        Next i
        'outarr_safe = outarr
        decode_json = outarr_safe
    Else
        decode_json = outarr
    End If
    Exit Function
err1:
    decode_json = "error"
End Function
'description_to_manual      - для автогенерации
' Функция извлекает список давлений из json строки
' нужна для удобства векторных расчетов
Public Function decode_json_p_atma(json)
' json   - строка содержащая результаты расчета
' результат - закодированная строка
'description_end
    decode_json_p_atma = decode_json(json, _
                                    keys_filter:="p_atma", _
                                    only_values:=True)
End Function
'description_to_manual      - для автогенерации
' Функция извлекает список температур из json строки
' нужна для удобства векторных расчетов
Public Function decode_json_t_C(json)
' json   - строка содержащая результаты расчета
' результат - закодированная строка
'description_end
    decode_json_t_C = decode_json(json, _
                                    keys_filter:="t_C", _
                                    only_values:=True)
End Function
'description_to_manual      - для автогенерации
' Функция извлекает списки давлений и температур из json строки
' нужна для удобства векторных расчетов
Public Function decode_json_pt(json)
' json   - строка содержащая результаты расчета
' результат - закодированная строка
'description_end
    decode_json_pt = decode_json(json, _
                                 transpose:=True, _
                                 keys_filter:="p_atma,t_C", _
                                 only_values:=True)
End Function
'description_to_manual      - для автогенерации
' Функция извлекает список дебитов из json строки
' нужна для удобства векторных расчетов
Public Function decode_json_q_liq_sm3day(json)
' json   - строка содержащая результаты расчета
' результат - закодированная строка
'description_end
    Dim d As Dictionary
    On Error GoTo er1:
    Set d = ParseJson(json)
    If d.Exists("q_liq_sm3day") Then
        decode_json_q_liq_sm3day = decode_json(json, _
                                    keys_filter:="q_liq_sm3day", _
                                    only_values:=True)
    ElseIf d.Exists("feed") Then
        Dim f
        Set f = d("feed")
        If TypeName(f) = "Collection" Then
            Dim C
            Dim c_out As New Collection
            For Each C In f
                Dim a As Double
                a = C("q_liq_sm3day")
                c_out.Add a
            Next
            decode_json_q_liq_sm3day = ConvertToJson(c_out)
        Else
            decode_json_q_liq_sm3day = f("q_liq_sm3day")
        End If
    End If
    Exit Function
er1:
    decode_json_q_liq_sm3day = "error:decode_json_q_liq_sm3day: " & Err.Description
End Function
'description_to_manual      - для автогенерации
' Функция извлекает список значений коэффициентов сепарации
' из json строки
' нужна для удобства векторных расчетов
Public Function decode_json_k_sep(json)
' json   - строка содержащая результаты расчета
' результат - закодированная строка
'description_end
    decode_json_k_sep = decode_json(json, _
                                    keys_filter:="k_sep", _
                                    only_values:=True)
End Function
'description_to_manual      - для автогенерации
' Функция декодирования json строки с табличной кривой,
' позволяет вывести содержимое json строки в таблицу (на лист)
Public Function decode_json_crv(json, _
                       Optional transpose As Boolean = False)
' json   - строка содержащая результаты расчета
' transpose - выбор вывода в строки или в столбцы
' результат - закодированная строка
'description_end
    Dim d As Dictionary
    Dim cx As Collection
    Dim cy As Collection
    
    Dim out_arr() ' As String
    Dim i As Integer
    
    On Error GoTo err1:
        Set d = ParseJson(json)
        If d.Exists("curve_x") And d.Exists("curve_y") Then
            Set cx = d(d("curve_x"))
            Set cy = d(d("curve_y"))
            If transpose Then
                ReDim out_arr(1 To 2, 1 To cx.Count + 1)
                out_arr(1, 1) = d("curve_x")
                out_arr(2, 1) = d("curve_y")
                For i = 1 To cx.Count
                    out_arr(1, i + 1) = cx.Item(i)
                    out_arr(2, i + 1) = cy.Item(i)
                Next i
            Else
                ReDim out_arr(1 To cx.Count + 1, 1 To 2)
                out_arr(1, 1) = d("curve_x")
                out_arr(1, 2) = d("curve_y")
                For i = 1 To cx.Count
                    out_arr(i + 1, 1) = cx.Item(i)
                    out_arr(i + 1, 2) = cy.Item(i)
                Next i
            
            End If
        Else
            decode_json_crv = "error:decode_json_crv:no curve found in json. ""curve_x"" and ""curve_y"" keys musb be in json"
            Exit Function
        End If
        
    decode_json_crv = out_arr
    Exit Function
err1:
    decode_json_crv = "error:decode_json_crv: " & Err.Description
End Function
'description_to_manual      - для автогенерации
' Функция кодирования параметров PVT в строку,
' для передачи PVT свойств в прикладные функции Унифлок.
Public Function encode_PVT( _
                    Optional ByVal gamma_gas As Double = const_gg_, _
                    Optional ByVal gamma_oil As Double = const_go_, _
                    Optional ByVal gamma_wat As Double = const_gw_, _
                    Optional ByVal rsb_m3m3 = const_rsb_default, _
                    Optional ByVal pb_atma = 0, _
                    Optional ByVal t_res_C = 80, _
                    Optional ByVal bob_m3m3 = 0, _
                    Optional ByVal muob_cP = 0, _
                    Optional ByVal PVT_corr_set = 0 _
                    )
' gamma_gas - удельная плотность газа, по воздуху.
'             По умолчанию const_gg_ = 0.6
' gamma_oil - удельная плотность нефти, по воде.
'             По умолчанию const_go_ = 0.86
' gamma_wat - удельная плотность воды, по воде.
'             По умолчанию const_gw_ = 1
' rsb_m3m3  - газосодержание при давлении насыщения, м3/м3.
'             По умолчанию const_rsb_default = 100
' pb_atma - давление насыщения при заданной температуре, атма.
'           Опциональный калибровочный параметр,
'           если не задан или = 0, то рассчитается по корреляции.
' t_res_C  - пластовая температура, С.
'           Учитывается при расчете давления насыщения.
'           По умолчанию  const_tres_default = 90
' bob_m3m3 - объемный коэффициент нефти при давлении насыщения
'            и пластовой температуре, м3/м3.
'            По умолчанию рассчитывается по корреляции.
' muob_cP  - вязкость нефти при давлении насыщения.
'            и пластовой температуре, сП.
'            По умолчанию рассчитывается по корреляции.
' PVT_corr_set - номер набора PVT корреляций для расчета:
'           0 - на основе корреляции Стендинга;
'           1 - на основе кор-ии Маккейна;
'           2 - на основе упрощенных зависимостей.
' результат - закодированная строка
'description_end
    
    Dim str As String
    Dim frmt As String
    Dim frmt_int As String
    
    Dim pvt_dict As New Dictionary
    
    pvt_dict.Add "gamma_gas", Round(gamma_gas, const_num_decimal_out)
    pvt_dict.Add "gamma_oil", Round(gamma_oil, const_num_decimal_out)
    pvt_dict.Add "gamma_wat", Round(gamma_wat, const_num_decimal_out)
    pvt_dict.Add "rsb_m3m3", Round(rsb_m3m3, const_num_decimal_out)
    
    If pb_atma > 0 Then
        pvt_dict.Add "pb_atma", Round(pb_atma, const_num_decimal_out)
        pvt_dict.Add "t_res_C", Round(t_res_C, const_num_decimal_out)
    End If
    If bob_m3m3 > 0 Then pvt_dict.Add "bob_m3m3", Round(bob_m3m3, const_num_decimal_out)
    If muob_cP > 0 Then pvt_dict.Add "muob_cP", Round(muob_cP, const_num_decimal_out)
    If PVT_corr_set >= 0 And PVT_corr_set <= 2 Then
        pvt_dict.Add "PVT_corr_set", PVT_corr_set
    End If
    encode_PVT = ConvertToJson(pvt_dict)
End Function
'description_to_manual      - для автогенерации
'Функция кодирования параметров потока флюидов в строку,
Public Function encode_feed( _
          Optional ByVal q_liq_sm3day As Double = 10, _
          Optional ByVal fw_perc As Double = -1, _
          Optional ByVal rp_m3m3 As Double = -1, _
          Optional ByVal q_gas_free_sm3day As Double = -1, _
          Optional ByVal fluid As String = PVT_DEFAULT)
' q_liq_sm3day  - дебит жидкости в ст.условиях.
' fw_perc       - ободненность, %
' rp_m3m3       - газовый фактор, м3/м3:
' q_gas_free_sm3day - расход свободного газа, ст. м3/сут
' fluid         -  закодированная PVT строка
'                  с параметрами флюида
' результат - закодированная строка
'description_end
    
    Dim str As String
    Dim frmt As String
    Dim frmt_int As String
    
    Dim dict As Dictionary
    Set dict = ParseJson(fluid)
    
    dict("q_liq_sm3day") = Round(q_liq_sm3day, const_num_decimal_out)
    If fw_perc >= 0 Then dict("fw_perc") = Round(fw_perc, const_num_decimal_out)
    If rp_m3m3 > 0 Then dict("rp_m3m3") = Round(rp_m3m3, const_num_decimal_out)
    If q_gas_free_sm3day > 0 Then dict("q_gas_free_sm3day") = Round(q_gas_free_sm3day, const_num_decimal_out)
    
    encode_feed = ConvertToJson(dict)
End Function
'description_to_manual      - для автогенерации
'Функция кодирования параметров потока флюидов в строку,
Public Function encode_feed_list( _
          Optional ByVal q_liq_sm3day As Variant = 10, _
          Optional ByVal fw_perc As Double = -1, _
          Optional ByVal rp_m3m3 As Double = -1, _
          Optional ByVal q_gas_free_sm3day As Double = -1, _
          Optional ByVal fluid As String = PVT_DEFAULT)
' q_liq_sm3day  - дебит жидкости в ст.условиях.
' fw_perc       - ободненность, %
' rp_m3m3       - газовый фактор, м3/м3:
' q_gas_free_sm3day - расход свободного газа, ст. м3/сут
'
' результат - закодированная строка
'description_end
    
    Dim str As String
    Dim frmt As String
    Dim frmt_int As String
    
    Dim dict As Dictionary
    
    Dim col As Collection
    Dim col_feed As New Collection
    Dim q
    
    Set col = ParseJson(q_liq_sm3day)
    For Each q In col
        'Set dict = New Dictionary
        Set dict = ParseJson(fluid)
        dict("q_liq_sm3day") = Round(q, const_num_decimal_out)
        If fw_perc >= 0 Then dict("fw_perc") = Round(fw_perc, const_num_decimal_out)
        If rp_m3m3 > 0 Then dict("rp_m3m3") = Round(rp_m3m3, const_num_decimal_out)
        If q_gas_free_sm3day > 0 Then dict("q_gas_free_sm3day") = Round(q_gas_free_sm3day, const_num_decimal_out)
        col_feed.Add dict
    Next
    encode_feed_list = ConvertToJson(col_feed)
End Function
'description_to_manual      - для автогенерации
' функция кодирования параметров работы УЭЦН в строку
Public Function encode_ESP_pump( _
            Optional ByVal ESP_ID As Long = "1005", _
            Optional ByVal head_nom_m As Double = 2000, _
            Optional ByVal num_stages As Integer = 0, _
            Optional ByVal freq_Hz As Double = 50, _
            Optional ByVal calibr_head As Double = 1, _
            Optional ByVal calibr_rate As Double = 1, _
            Optional ByVal calibr_power As Double = 1, _
            Optional ByVal gas_correct_model As Integer = 0, _
            Optional ByVal gas_correct_stage_by_stage As Integer = 0, _
            Optional ByVal dnum_stages_integrate = 1)
' esp_ID         - идентификатор насоса
' head_nom_m     - номинальный напор системы УЭЦН
'                - соответствует напора в записи ЭЦН 50-2000
' num_stages     - количество ступеней, если задано
'                  перекрывает значение напора
' freq_Hz        - частота, Гц
' calibr_head    - калибровка по напору
' calibr_rate    - калибровка по подаче
' calibr_power   - калибровка по мощности
' gas_correct_model - модель калибровки по газу
' gas_correct_stage_by_stage - флаг метода применения калибровки по газу
' dnum_stages_integrate - шаг интегрирования для расчета
' результат         - строка с параметрами УЭЦН
'description_end
'    Dim calibr_head As Double
'    Dim calibr_rate As Double
'    Dim calibr_power As Double
    Dim dict As New Dictionary
    
    
    dict.Add "ESP_ID", ESP_ID
    dict.Add "head_nom_m", head_nom_m
    If num_stages > 0 Then dict.Add "num_stages", num_stages
    dict.Add "freq_Hz", freq_Hz
    dict.Add "gas_correct_model", gas_correct_model
    dict.Add "gas_correct_stage_by_stage", gas_correct_stage_by_stage
    dict.Add "calibr_head", calibr_head
    dict.Add "calibr_power", calibr_power
    dict.Add "calibr_rate", calibr_rate
    dict.Add "dnum_stages_integrate", dnum_stages_integrate
  
    
    encode_ESP_pump = ConvertToJson(dict)
    
End Function
'description_to_manual      - для автогенерации
' функция кодирования параметров ПЭД в строку
Public Function encode_ESP_motor( _
            Optional ByVal motor_ID As Long = 0, _
            Optional ByVal P_nom_kW As Double = 30, _
            Optional ByVal U_nom_lin_V As Double = 1000, _
            Optional ByVal f_nom_Hz As Double = 50, _
            Optional ByVal eff_nom_fr As Double = 0.82, _
            Optional ByVal cosphi_nom_fr As Double = 0.88, _
            Optional ByVal slip_nom_fr As Double = 0.053, _
            Optional ByVal U_surf_high_lin_V As Double = 1000, _
            Optional ByVal f_surf_Hz As Double = 50, _
            Optional ByVal power_fact_kW As Double = 30, _
            Optional ByVal d_od_mm As Double = 0, _
            Optional ByVal lambda_ As Double = 0, _
            Optional ByVal alpha0 As Double = 0, _
            Optional ByVal xi0 As Double = 0, _
            Optional ByVal Ixcf As Double = 0)
'motor_ID - тип 0 - постоянные значения,
'               1 - задается по каталожным кривым, ассинхронный
'               2 - задается по схеме замещения, ассинхронный
'P_nom_kW       - номинальная мощность двигателя кВт
'U_nom_lin_V    - номинальное напряжение двигателя, линейное, В
'f_nom_Hz       - номинальная частота тока, Гц
'eff_nom_fr     - КПД при номинальном режиме работы
'cosphi_nom_fr  - коэффициент мощности при номинальный
'slip_nom_fr    - скольжение при номинальном режиме работы
'U_surf_high_lin_V - напряжение на поверхности
'f_surf_Hz - частота тока на поверхности
'power_fact_kW - фактическая потребляемая мощность
'd_od_mm            - внешний диаметр - габарит ПЭД
'lambda_ - для motorID = 2 перегрузочный коэффициент
'         отношение макс момента к номинальному
'alpha0 - параметр. влияет на положение макс КПД.для motorID = 2
'xi0    - параметр. определяет потери момента при холостом ходе.
'         для motorID = 2
'Ixcf   - поправка на поправку тока холостого хода
'         при изменении напряжения и частоты от минимальной.
'description_end
    
    
' ранее эти данные передавались, но наверное они лишние
    
'            Optional ByVal U_surf_high_lin_V As Double, _
'            Optional ByVal f_surf_Hz As Double, _
'            Optional ByVal power_fact_kW As Double, _
''U_surf_high_lin_V  - напряжение на поверхности
'                     на высокой стороне трансформатора
'                     для motorID = 2
'f_surf_Hz          - частота питающего напряжения
'power_fact_kW      - фактическая мощность потребляемая
    
    Dim dict As New Dictionary
    
    dict.Add "motor_ID", motor_ID
   If U_surf_high_lin_V > 0 Then dict.Add "U_surf_high_lin_V", U_surf_high_lin_V
   If f_surf_Hz > 0 Then dict.Add "f_surf_Hz", f_surf_Hz
   If power_fact_kW > 0 Then dict.Add "power_fact_kW", power_fact_kW
   If U_nom_lin_V > 0 Then dict.Add "U_nom_lin_V", U_nom_lin_V
   If P_nom_kW > 0 Then dict.Add "P_nom_kW", P_nom_kW
   If f_nom_Hz > 0 Then dict.Add "F_nom_Hz", f_nom_Hz
   If eff_nom_fr > 0 Then dict.Add "eff_nom_fr", eff_nom_fr
   If cosphi_nom_fr > 0 Then dict.Add "cosphi_nom_fr", cosphi_nom_fr
   If slip_nom_fr > 0 Then dict.Add "slip_nom_fr", slip_nom_fr
   If d_od_mm > 0 Then dict.Add "d_od_mm", d_od_mm
    
   If lambda_ > 0 Then dict.Add "lambda", lambda_
   If alpha0 > 0 Then dict.Add "alpha0", alpha0
   If xi0 > 0 Then dict.Add "xi0", xi0
   If Ixcf > 0 Then dict.Add "Ixcf", Ixcf
   encode_ESP_motor = ConvertToJson(dict)
    
End Function
'description_to_manual      - для автогенерации
' функция кодирования параметров
' кабельной линии ПЭД в строку
Public Function encode_ESP_cable( _
            Optional ByVal length_m As Double = 1000, _
            Optional ByVal cable_R_Omkm As Double = 1.18, _
            Optional ByVal cable_X_Omkm As Double = 0.01, _
            Optional ByVal cable_t_max_C As Double = 120, _
            Optional ByVal manufacturer As String = "default", _
            Optional ByVal name As String = "default_name", _
            Optional ByVal d_mm As Double = 16)
' length_m - длина кабельной линии, м
' cable_R_Omkm - удельное активное сопротивление
' cable_X_Omkm - удельное реактивное сопротивление
' cable_t_max_C - максимально допустимая температура
' manufacturer - производитель, для справки
' name  - название кабеля, для справки
' d_mm - диаметр жилы
'description_end
    Dim dict As New Dictionary
    
    If cable_R_Omkm > 0 Then dict.Add "cable_R_Omkm", cable_R_Omkm
    If cable_X_Omkm > 0 Then dict.Add "cable_X_Omkm", cable_X_Omkm
    If cable_t_max_C > 0 Then dict.Add "cable_t_max_C", cable_t_max_C
    If manufacturer <> "no" Then dict.Add "manufacturer", manufacturer
    If name <> "no" Then dict.Add "name", name
    If d_mm > 0 Then dict.Add "d_mm", d_mm
    If length_m > 0 Then dict.Add "length_m", length_m
    
    encode_ESP_cable = ConvertToJson(dict)
    
End Function
'description_to_manual      - для автогенерации
' функция кодирования газосепаратора
Public Function encode_ESP_separation( _
            Optional ByVal separation_mode As String, _
            Optional ByVal gassep_type As Long, _
            Optional ByVal natsep_type As Long = 0, _
            Optional ByVal psep_man_atma As Double = 0, _
            Optional ByVal tsep_man_C As Double = 0, _
            Optional ByVal ksep_gassep_man_d As Double = 0, _
            Optional ByVal ksep_nat_man_d As Double = 0, _
            Optional ByVal ksep_liquid_man_d As Double = 0, _
            Optional ByVal M_Nm As Double = 0, _
            Optional ByVal manufacturer As String = "no", _
            Optional ByVal name As String = "no", _
            Optional ByVal length_m As Double = 0)
' separation_mode - режим расчета сепарации
' gassep_type - тип - номер из базы
' natsep_type - модель расчета естественной сепарации
' psep_man_atma  - давление для расчета
'                     коэффициента сепарации заданного вручную
' tsep_man_C  - температура для расчета
'                     коэффициента сепарации заданного вручную
' ksep_gassep_man_d  - коэффициент сепарации ГС заданный вручную
' ksep_nat_man_d  - коэффициент сепарации натуральной
'                   заданный вручную
' ksep_liquid_man_d - коэффициент сепарации жидкости для режима
'                     потока через затруб
' M_Nm  - момент на валу
' manufacturer - производитель, для справки
' name  - название кабеля, для справки
' length_m - длина кабельной линии, м
'description_end
    Dim dict As New Dictionary
    
    If separation_mode >= 0 Then
        Select Case separation_mode
            Case "0", "byCorrealation"
                dict.Add "separation_mode", "byCorrealation"
            Case "1", "pressureManual"
                dict.Add "separation_mode", "pressureManual"
            Case "2", "valueManual"
                dict.Add "separation_mode", "valueManual"
            Case "3", "fullyManual"
                dict.Add "separation_mode", "fullyManual"
        End Select
    End If
    If gassep_type >= 0 Then dict.Add "gassep_type", gassep_type
    If natsep_type >= 0 Then dict.Add "natsep_type", natsep_type
    If psep_man_atma > 0 Then dict.Add "psep_man_atma", psep_man_atma
    If tsep_man_C > 0 Then dict.Add "tsep_man_C", tsep_man_C
    If ksep_gassep_man_d > 0 Then dict.Add "ksep_gassep_man_d", ksep_gassep_man_d
    If ksep_nat_man_d > 0 Then dict.Add "ksep_nat_man_d", ksep_nat_man_d
    If ksep_liquid_man_d > 0 Then dict.Add "ksep_liquid_man_d", ksep_liquid_man_d
    If M_Nm > 0 Then dict.Add "M_Nm", M_Nm
    If manufacturer <> "no" Then dict.Add "manufacturer", manufacturer
    If name <> "no" Then dict.Add "name", name
    If length_m > 0 Then dict.Add "length_m", length_m
    
    encode_ESP_separation = ConvertToJson(dict)
    
End Function
'description_to_manual      - для автогенерации
' функция кодирования температурных парамметров окружающей среды
Public Function encode_ambient_formation_string( _
    Optional ByVal therm_cond_form_WmC As Double = 2.4252, _
    Optional ByVal sp_heat_capacity_form_JkgC As Double = 200, _
    Optional ByVal therm_cond_cement_WmC As Double = 6.965, _
    Optional ByVal therm_cond_tubing_WmC As Double = 32, _
    Optional ByVal therm_cond_casing_WmC As Double = 32, _
    Optional ByVal heat_transfer_casing_liquid_Wm2C As Double = 200, _
    Optional ByVal heat_transfer_casing_gas_Wm2C As Double = 10, _
    Optional ByVal heat_transfer_fluid_convection_Wm2C As Double = 200, _
    Optional ByVal t_calc_hr As Double = 240)
' therm_cond_form_WmC - теплопроводность породы окружающей среды
' sp_heat_capacity_form_JkgC - удельная теплоемкость породы окружающей среды
' therm_cond_cement_WmC - теплопроводность цементного камня вокруг скважины
' therm_cond_tubing_WmC - теплопроводность стенок НКТ
' heat_transfer_casing_liquid_Wm2C - теплопередача через затруб с жидкостью
' heat_transfer_casing_gas_Wm2C - теплопередача через затруб с газом
' heat_transfer_fluid_convection_Wm2C - теплопередача в потоке
'                               с жидкостью за счет конвекции
' t_calc_hr - время на которое расчитывается распределение температуры
'
'description_end
    Dim dict As New Dictionary
    
    dict.Add "therm_cond_form_WmC", therm_cond_form_WmC
    dict.Add "sp_heat_capacity_form_JkgC", sp_heat_capacity_form_JkgC
    dict.Add "therm_cond_cement_WmC", therm_cond_cement_WmC
    dict.Add "therm_cond_tubing_WmC", therm_cond_tubing_WmC
    dict.Add "therm_cond_casing_WmC", therm_cond_casing_WmC
    dict.Add "heat_transfer_casing_liquid_Wm2C", heat_transfer_casing_liquid_Wm2C
    dict.Add "heat_transfer_casing_gas_Wm2C", heat_transfer_casing_gas_Wm2C
    dict.Add "heat_transfer_fluid_convection_Wm2C", heat_transfer_fluid_convection_Wm2C
    dict.Add "t_calc_hr", t_calc_hr
    encode_ambient_formation_string = ConvertToJson(dict)
End Function
''=============================
' - для автогенерации описания - помещает заголовок функции и окружающие комментарии в мануал (со след строки)
'' функция расшифровки параметров газлифтной компоновки скважины
'Public Function GL_decode_string(well_GL_str As String, _
'                  Optional ByVal getStr As Boolean = False)
'' well_GL_str  - строка с параметрами газлифтной скважины
'' getStr  - флаг проверки работы функции
''    по умолчанию False (0) - функция выдает объект CESPsystem
''    если задать True - функция раскодирует строку и снова закодирует
''                       и выдаст строку (можно использовать из листа)
'' результат - объект CESPsystem
'
'
'    Dim S As String
'    Dim a, b
'    Dim i As Long
'    Dim GLV As Integer
'    Dim dict As New Dictionary
'    Dim key As String
'' при разбиении строки на части ошибки недопустимы
'On Error GoTo er1:
'    ' пытаемся разбить строку разделителями
'    a = Split(well_GL_str, ";")
'    ' перебираем и сохраняем все параметры
'    For i = LBound(a) To UBound(a)
'        ' только для непустых разбиений
'        If a(i) <> "" Then
'           b = Split(a(i), ":")
'           'только там где есть значение
'           If UBound(b) = 1 Then
'               dict.Item(b(0)) = b(1)
'           End If
'        End If
'    Next i
'' при считывании параметров со строки пытаемся выполнить чтение всех параметров
'' с использование словаря - включаем режим после ошибки двигаться далее
'On Error GoTo er2:
'    ' при чтении параметров используем промежуточную переменную key
'    ' чтобы иметь возможность более информативно отреагировать на ошибку
'    key = "GLV": GLV = Cdbl_(dict.Item(key)) ' количество клапанов
'
'    Dim q_gas_inj_sm3day As Double
'    Dim p_gas_inj_atma As Double
'    Dim d_gas_inj_mm As Double
'
'    Dim h_glv_m() As Double
'    Dim d_glv_mm() As Double
'    Dim p_glv_atma() As Double
'
'    ReDim h_glv_m(1 To GLV)
'    ReDim d_glv_mm(1 To GLV)
'    ReDim p_glv_atma(1 To GLV)
'
'    key = "q_gas_inj_sm3day": q_gas_inj_sm3day = Cdbl_(dict.Item(key))
'    key = "p_gas_inj_atma": p_gas_inj_atma = Cdbl_(dict.Item(key))
'    key = "d_gas_inj_mm": d_gas_inj_mm = Cdbl_(dict.Item(key))
'
'
'    For i = 1 To GLV
'            key = "H_glv_m" & FormatInteger(i, 0): h_glv_m(i) = Cdbl_(dict.Item(key))
'            key = "d_glv_mm" & FormatInteger(i, 0): d_glv_mm(i) = Cdbl_(dict.Item(key))
'            key = "p_glv_atma" & FormatInteger(i, 0): p_glv_atma(i) = Cdbl_(dict.Item(key))
'    Next i
'On Error GoTo er1:
'' ловим все ошибки, все должно пройти идеально при дешифровке
'    If getStr Then
'        GL_decode_string = GL_encode_string(q_gas_inj_sm3day, p_gas_inj_atma, d_gas_inj_mm, h_glv_m, d_glv_mm, p_glv_atma)
'    Else
'        Dim glv_set As New CGLValveSet
'        Call glv_set.loadFromArray(h_glv_m, d_glv_mm, p_glv_atma)
'        glv_set.q_gas_inj_sm3day = q_gas_inj_sm3day
'        glv_set.p_gas_inj_atma = p_gas_inj_atma
'        glv_set.d_gas_inj_mm = d_gas_inj_mm
'
'        Set GL_decode_string = glv_set
'    End If
'    Exit Function
'er1:
'    Dim errmsg As String
'    errmsg = "GL_decode_string. error:" & Err.Description
'    add_log_msg errmsg
'    Err.Raise kErrPVTinput, Err.source, errmsg
'    Exit Function
'er2:
' '   On Error Resume Next
'    add_log_msg "GL_decode_string: error reading PVT key: " & key & ":" & Err.Description
'    Resume Next
'
'End Function
'
'- для автогенерации описания - помещает заголовок функции и окружающие комментарии в мануал (со след строки)
'' функция кодирования параметров работы скважины с газлифтом
'Public Function GL_encode_string( _
'                    Optional q_gas_inj_sm3day As Double = 0, _
'                    Optional p_gas_inj_atma As Double = 0, _
'                    Optional d_gas_inj_mm As Double = 0, _
'                    Optional HmesGLV_m = 0, _
'                    Optional dGLV_mm = 0, _
'                    Optional PsurfGLV_atma = 0)
'' q_gas_inj_sm3day - расход газа закачки
'' p_gas_inj_atma - давление газа закачки на поверхности
'' d_gas_inj_mm - диаметр штуцера регулировки закачки газа на поверхности
'' HmesGLV_m     - измеренные глубины установки газлифтных клапанов
'' dGLV_mm       - диаметры порта установленных газлифтных клапанов
'' PsurfGLV_atma - давления зарядки газлифтных клапанов
'' результат     - строка с закодированными параметрами
'
'
'    Dim str As String
'    Dim frmt As String
'    Dim frmt_int As String
'
'    Dim h_glv_m() As Variant
'    Dim d_glv_mm() As Variant
'    Dim p_glv_atma() As Variant
'
'    Dim i As Long
'
'    frmt = "#0.####0"
'    frmt_int = "0"
'    str = "GLV:1;"
'    str = str & "q_gas_inj_sm3day:" & Format(q_gas_inj_sm3day, frmt) & ";"
'    str = str & "p_gas_inj_atma:" & Format(p_gas_inj_atma, frmt) & ";"
'    str = str & "d_gas_inj_mm:" & Format(d_gas_inj_mm, frmt) & ";"
'
'    h_glv_m = readRange(HmesGLV_m)
'    d_glv_mm = readRange(dGLV_mm)
'    p_glv_atma = readRange(PsurfGLV_atma)
'
'    If (UBound(h_glv_m) = UBound(d_glv_mm)) And (UBound(h_glv_m) = UBound(p_glv_atma)) Then
'        str = str & "GLV:" & FormatInteger(UBound(h_glv_m), 0) & ";"
'        For i = LBound(h_glv_m) To UBound(h_glv_m)
'            str = str & "H_glv_m" & FormatInteger(i, 0) & ":" & FormatFReal(Cdbl_(h_glv_m(i)), 0, 3) & ";"
'            str = str & "d_glv_mm" & FormatInteger(i, 0) & ":" & FormatFReal(Cdbl_(d_glv_mm(i)), 0, 3) & ";"
'            str = str & "p_glv_atma" & FormatInteger(i, 0) & ":" & FormatFReal(Cdbl_(p_glv_atma(i)), 0, 3) & ";"
'        Next i
'    Else
'        str = str & "GVL:0;error" & ";"
'    End If
'
'    GL_encode_string = str
'
'End Function
'=============================
'description_to_manual      - для автогенерации
' функция кодирования параметров работы скважины с газлифтом
Public Function encode_well_construction_string( _
             ByVal h_perf_m As Double, _
             ByVal h_tub_m As Double, _
             ByVal h_list_m As Variant, _
             ByVal d_tub_list_mm As Variant, _
             ByVal d_cas_list_mm As Variant, _
    Optional ByVal d_choke_mm As Double, _
    Optional ByVal t_val_C As Variant, _
    Optional ByVal rough_m As Double = 0.0001)
'h_perf_m - глубина перфорации по длине скважины
'           точка узлового анализа для забоя
'h_tub_m - глубина спуска НКТ, или глубина
'          спуска ЭЦН
'h_list_m  - траектория скважины, если число то измеренная
'           длина, range или таблица [0..N,0..1] то траектория
'd_tub_list_mm - диаметр НКТ. range или таблица [0..N,0..1]
'd_cas_list_mm - диаметр эксп колонны.
'              range или таблица [0..N,0..1]
'd_choke_mm - диаметр штуцера
't_val_C   - температура вдоль скважины
'           если число то температура на устье скважины
'           если range или таблица [0..N,0..1] то температура
'           окружающей среды по вертикальной глубине, С
'rough_m    - шероховатость трубы
' результат     - строка с закодированными параметрами
'description_end
    Dim dict As New Dictionary
    
    dict.Add "h_perf_m", h_perf_m
    dict.Add "h_tub_m", h_tub_m
    dict.Add "rough_m", rough_m
    dict.Add "d_choke_mm", d_choke_mm
    dict.Add "t_val_C", array_num_from_range(t_val_C, True)
    dict.Add "h_list_m", array_num_from_range(h_list_m, True)
    dict.Add "d_tub_list_mm", array_num_from_range(d_tub_list_mm, True)
    dict.Add "d_cas_list_mm", array_num_from_range(d_cas_list_mm, True)
    encode_well_construction_string = ConvertToJson(dict)
    
End Function
'description_to_manual      - для автогенерации
' функция кодирования диапазона ячеек в json строку
Public Function encode_json(rng, _
        Optional always_collection As Boolean = False)
' rng       - диапазон ячеек для кодирования
'           один столбец кодируется в коллекцию
'           два столбца кодируются в словарь
' always_collection - флаг принудительного кодирования
'           в коллекцию
' результат - закодированная строка
'description_end
    Dim d As New Dictionary
    Dim C As New Collection
    
    Dim t As Variant
    Dim i As Integer
    
    t = array_from_range(rng)
    
    If UBound(t, 2) = 1 Or always_collection Then
        If UBound(t, 2) = 1 Then
            For i = 1 To UBound(t)
                If Not IsEmpty(t(i, 1)) Then C.Add t(i, 1)
            Next i
            encode_json = ConvertToJson(C)
        Else
            ' далее range преобразуется в массив, который сразу кодируется в json
            encode_json = ConvertToJson(array_from_range(rng, True))
        End If
    Else
        For i = 1 To UBound(t)
            d(t(i, 1)) = t(i, 2)
        Next i
        encode_json = ConvertToJson(d)
    End If
    
End Function
'description_to_manual      - для автогенерации
' кодирование табличных результатов в json формат
Public Function encode_table_json(key As range, _
                                  val_name As range, _
                                  val As range)
' key      - столбец со значениями ключей (ID)
'            должны быть уникальные значения
' val_name - строка с названиями полей значений
'            должны быть уникальные значения
' val      - таблица со значениями, которые надо
'            закодировать
'description_end
    Dim dict As New Dictionary
    Dim d As Dictionary
    Dim i As Integer
    Dim j As Integer
    
    If key.Rows.Count <> val.Rows.Count Or val_name.Columns.Count <> val.Columns.Count Then
        encode_table_json = "error in data"
        Exit Function
    End If
    For i = 1 To key.Rows.Count
        Set d = New Dictionary
        For j = 1 To val_name.Columns.Count
            d.Add val_name.Cells(1, j), val.Cells(i, j)
        Next j
        dict.Add key.Cells(i, 1), d
    Next i
    encode_table_json = ConvertToJson(dict)
End Function
 Public Function combine_json(str1, str2)
    
   combine_json = Left(str1, Len(str1) - 1) & "," & Right(str2, Len(str2) - 1)
 End Function
'description_to_manual      - для автогенерации
' задание параметров траектории трубы в json строке
Public Function encode_pipe(Optional h_list_m As Variant = 1000, _
                            Optional diam_list_mm As Variant = 62, _
                            Optional roughness_m As Double = 0, _
                            Optional h_vert_m As Variant = -1)
'h_list_m - число - длина вертикальной трубы или массив или range
'         содержащий зависимость вертикальной глубины от измеренной
'diam_list_mm - число-внутренний диаметр трубы или массив или range
'         содержащий зависимость внутреннего от измеренной глубины
'roughness_m - число - шероховатость, одна для всей трубы
'h_vert_m - число или массив вертикальных глубин
'           если задано то инклинометрия задается двумя векторами
'результат - json строка с описанием трубы
'description_end
    
    Dim dict As New Dictionary
    Dim h_curve As New CInterpolation
    Dim h_raw() As Double
    Dim h_vert() As Double
    Dim d_curve As New CInterpolation
    Dim d_raw() As Double
    
    Dim i As Integer
On Error GoTo er1:
    h_raw = array_num_from_range(h_list_m, remove_zeros:=True)
    
    h_vert = array_num_from_range(h_vert_m, remove_zeros:=True)
    
    If UBound(h_vert, 1) = UBound(h_raw, 1) And h_vert(UBound(h_vert, 1), 1) > 0 Then
    
        For i = LBound(h_raw, 1) To UBound(h_raw, 1)
            h_curve.AddPoint h_raw(i, 1), h_vert(i, 1)
        Next i
        
    Else
        For i = LBound(h_raw, 1) To UBound(h_raw, 1)
            If UBound(h_raw, 2) = 1 Then
                h_curve.AddPoint h_raw(i, 1), h_raw(i, 1)
            Else
                h_curve.AddPoint h_raw(i, 1), h_raw(i, 2)
            End If
        Next i
    
    End If
    If h_curve.num_points = 1 Then
        h_curve.AddPoint 0, 0
        If h_curve.num_points = 1 Then GoTo er2
    End If
    h_curve.xName = const_name_hmes_m
    h_curve.yName = const_name_hvert_m
    dict.Add const_name_h_list_m, h_curve.getDict
    
    d_raw = array_num_from_range(diam_list_mm, remove_zeros:=True)
    
    If UBound(d_raw, 2) = 1 Then
        d_curve.AddPoint 0, d_raw(1, 1)
        d_curve.AddPoint h_raw(UBound(h_raw, 1), 1), d_raw(1, 1)
    ElseIf UBound(d_raw, 2) > 1 Then
        For i = LBound(d_raw, 1) To UBound(d_raw, 1)
            If d_raw(i, 1) < h_raw(UBound(h_raw, 1), 1) Then
                d_curve.AddPoint d_raw(i, 1), d_raw(i, 2)
            End If
        Next
        d_curve.AddPoint h_raw(UBound(h_raw, 1), 1), d_raw(i - 1, 2)
    End If
    d_curve.xName = const_name_hmes_m
    d_curve.yName = const_name_diam_int_mm
    dict.Add const_name_diam_list_mm, d_curve.getDict
    
    If roughness_m > 0 Then
        dict.Add "roughness_m", roughness_m
    End If
    
    encode_pipe = ConvertToJson(dict)
    
    Exit Function
    
er1:
    encode_pipe = "error encode_pipe " & Err.Description
    Exit Function
er2:
    encode_pipe = "error encode_pipe. zero length"
    Exit Function
End Function
'description_to_manual      - для автогенерации
' кодирование параметров температурной модели трубы/скважины
Public Function encode_t_model( _
            Optional t_model As TEMP_CALC_METHOD = StartEndTemp, _
            Optional t_list_C As Variant = 50, _
            Optional t_start_C As Double = -100, _
            Optional t_end_C As Double = -100, _
            Optional param As String = "")
' t_model   - номер температурной модели
' t_list_C  - массив n*2 распределения температуры
' t_start_C - температура в начале трубы
' t_end_C   - температура в конце трубы
' param     - параметры температурной модели
'             список параметров в мануале
'description_end
' encodes temperature model for pipe and wells
' describes ambient space params needed for temperature estimation
    Dim dict As New Dictionary
    Dim t_raw() As Double
    Dim t_curve As New CInterpolation
    Dim i As Integer
    
    Dim therm_cond_form_WmC As Double                 ' therm_cond_form_WmC - теплопроводность породы окружающей среды
    Dim sp_heat_capacity_form_JkgC As Double          ' sp_heat_capacity_form_JkgC - удельная теплоемкость породы окружающей среды
    Dim therm_cond_cement_WmC As Double               ' therm_cond_cement_WmC - теплопроводность цементного камня вокруг скважины
    Dim therm_cond_tubing_WmC As Double               ' therm_cond_tubing_WmC - теплопроводность стенок НКТ
    Dim therm_cond_casing_WmC As Double
    Dim heat_transfer_casing_liquid_Wm2C As Double    ' heat_transfer_casing_liquid_Wm2C - теплопередача через затруб с жидкостью
    Dim heat_transfer_casing_gas_Wm2C As Double       ' heat_transfer_casing_gas_Wm2C - теплопередача через затруб с газом
    Dim heat_transfer_fluid_convection_Wm2C As Double ' heat_transfer_fluid_convection_Wm2C - теплопередача в потоке с жидкостью за счет конвекции
    Dim t_calc_hr As Double                           ' t_calc_hr - время на которое расчитывается распределение температуры
      
On Error GoTo er1:
    dict.Add prm_t_model, t_model
    t_raw = array_num_from_range(t_list_C, remove_zeros:=True)
    
    For i = LBound(t_raw, 1) To UBound(t_raw, 1)
        If UBound(t_raw, 2) = 1 Then
            t_curve.AddPoint t_raw(i, 1), t_raw(i, 1)
        Else
            t_curve.AddPoint t_raw(i, 1), t_raw(i, 2)
        End If
    Next i
    If t_curve.num_points = 1 Then
        t_curve.AddPoint 0, 20
         If t_curve.num_points = 1 Then GoTo er2
    End If
    
    If t_start_C < 0 Then t_start_C = 20
    If t_end_C < 0 Then t_end_C = 40
    
    therm_cond_form_WmC = 2.4252
    sp_heat_capacity_form_JkgC = 200
    therm_cond_cement_WmC = 6.965
    therm_cond_tubing_WmC = 32
    therm_cond_casing_WmC = 32
    heat_transfer_casing_liquid_Wm2C = 200
    heat_transfer_casing_gas_Wm2C = 10
    heat_transfer_fluid_convection_Wm2C = 200
    t_calc_hr = 240
    
    If Len(param) > 0 Then
        Dim pdict As Dictionary
        Set pdict = ParseJson(param)
        
        If pdict.Exists(prm_t_start_C) Then t_start_C = pdict(prm_t_start_C)
        If pdict.Exists(prm_t_end_C) Then t_end_C = pdict(prm_t_end_C)
        
        If t_model = AmbientTemp Then
            If pdict.Exists(prm_thermal_conductivity_formation_WmC) Then therm_cond_form_WmC = pdict(prm_thermal_conductivity_formation_WmC)
            If pdict.Exists(prm_specific_heat_capacity_formation_JkgC) Then sp_heat_capacity_form_JkgC = pdict(prm_specific_heat_capacity_formation_JkgC)
            If pdict.Exists(prm_thermal_conductivity_cement_WmC) Then therm_cond_cement_WmC = pdict(prm_thermal_conductivity_cement_WmC)
            If pdict.Exists(prm_thermal_conductivity_tubing_WmC) Then therm_cond_tubing_WmC = pdict(prm_thermal_conductivity_tubing_WmC)
            If pdict.Exists(prm_thermal_conductivity_casing_WmC) Then therm_cond_casing_WmC = pdict(prm_thermal_conductivity_casing_WmC)
            If pdict.Exists(prm_heat_transfer_casing_liquid_Wm2C) Then heat_transfer_casing_liquid_Wm2C = pdict(prm_heat_transfer_casing_liquid_Wm2C)
            If pdict.Exists(prm_heat_transfer_casing_gas_Wm2C) Then heat_transfer_casing_gas_Wm2C = pdict(prm_heat_transfer_casing_gas_Wm2C)
            If pdict.Exists(prm_heat_transfer_fluid_convection_Wm2C) Then heat_transfer_fluid_convection_Wm2C = pdict(prm_heat_transfer_fluid_convection_Wm2C)
            If pdict.Exists(prm_time_calc_hr) Then t_calc_hr = pdict(prm_time_calc_hr)
        End If
        
    End If
    
    Select Case t_model
        Case AmbientTemp
            dict.Add prm_thermal_conductivity_formation_WmC, therm_cond_form_WmC
            dict.Add prm_specific_heat_capacity_formation_JkgC, sp_heat_capacity_form_JkgC
            dict.Add prm_thermal_conductivity_cement_WmC, therm_cond_cement_WmC
            dict.Add prm_thermal_conductivity_tubing_WmC, therm_cond_tubing_WmC
            dict.Add prm_thermal_conductivity_casing_WmC, therm_cond_casing_WmC
            dict.Add prm_heat_transfer_casing_liquid_Wm2C, heat_transfer_casing_liquid_Wm2C
            dict.Add prm_heat_transfer_casing_gas_Wm2C, heat_transfer_casing_gas_Wm2C
            dict.Add prm_heat_transfer_fluid_convection_Wm2C, heat_transfer_fluid_convection_Wm2C
            dict.Add prm_time_calc_hr, t_calc_hr
            t_curve.xName = const_name_hvert_m
            t_curve.yName = const_name_t_C
            dict.Add const_name_t_list_C, t_curve.getDict
        Case StartEndTemp
            Call dict.Add(prm_t_start_C, t_start_C)
            Call dict.Add(prm_t_end_C, t_end_C)
        Case GeoGradTemp
            t_curve.xName = const_name_hvert_m
            t_curve.yName = const_name_t_C
            dict.Add const_name_t_list_C, t_curve.getDict
        Case LengthTemp
            t_curve.xName = const_name_hmes_m   ' here we change vector name
            t_curve.yName = const_name_t_C
            dict.Add const_name_t_list_C, t_curve.getDict
    End Select
    encode_t_model = ConvertToJson(dict)
    
    Exit Function
    
er1:
    encode_t_model = "error encode_t_model " & Err.Description
    Exit Function
er2:
    encode_t_model = "error encode_t_model. zero length"
    Exit Function
End Function
Public Function encode_ipr(ByVal p_res_atma As Double, _
                           ByVal pi_m3dayatm As Double, _
                  Optional ByVal pb_atma As Double = 0, _
                  Optional ByVal fw_perc As Double = 0)
    
    Dim dict As New Dictionary
    dict.Add "p_res_atma", p_res_atma
    dict.Add "pi_m3dayatm", pi_m3dayatm
    dict.Add "pb_atma", pb_atma
    dict.Add "fw_perc", fw_perc
    
    encode_ipr = ConvertToJson(dict)
    
    
End Function
'description_to_manual      - для автогенерации
' кодирование списка значений для векторных расчетов
' c заданным шагом, значения распределены равномерно
Public Function encode_arange(ByVal val_from As Double, _
                              ByVal val_to As Double, _
                              ByVal step As Double)
' val_from   - первое значение списка
' val_to     - последнее значение списка
' step       - шаг значений списка
'description_end
    Dim col As New Collection
    Dim i As Integer
    i = 0
    If val_to < val_from Or step <= 0 Then
        col.Add val_from
        encode_arange = ConvertToJson(col)
        Exit Function
    End If
    Do
        col.Add val_from + step * i
        i = i + 1
        ' на выходе позволим небольшую ошибку для double значений, чтобы проще искать границы
    Loop Until (val_to - val_from - step * i) < -0.0000000001
    
    encode_arange = ConvertToJson(col)
End Function
'description_to_manual      - для автогенерации
' кодирование списка значений для векторных расчетов
' с заданным кол-вом значений, значения распределены равномерно
Public Function encode_linspace(ByVal val_from As Double, _
                                ByVal val_to As Double, _
                                ByVal num As Double)
' val_from   - первое значение списка
' val_to     - последнее значение списка
' num        - количество значений
'description_end
    Dim col As New Collection
    Dim i As Integer
    i = 0
    If val_to < val_from Or num <= 0 Then
        col.Add val_from
        encode_linspace = ConvertToJson(col)
        Exit Function
    End If
    Dim step As Double
    step = (val_to - val_from) / num
    Do
        col.Add val_from + step * i
        i = i + 1
        ' на выходе позволим небольшую ошибку для double значений, чтобы проще искать границы
    Loop Until i > num
    
    encode_linspace = ConvertToJson(col)
End Function
'description_to_manual      - для автогенерации
' кодирование списка значений для векторных расчетов
' с заданным кол-вом значений, значения распределены логарифмически
Public Function encode_logspace(ByVal val_from As Double, _
                                ByVal val_to As Double, _
                                ByVal num As Double)
' val_from   - первое значение списка
' val_to     - последнее значение списка
' num        - количество значений
'description_end
    Dim col As New Collection
    Dim i As Integer
    i = 0
    If val_to < val_from Or num <= 0 Then
        col.Add val_from
        encode_logspace = ConvertToJson(col)
        Exit Function
    End If
    Dim step As Double
    Dim eps As Double
    eps = 0.00001
    
    step = (Log(val_to - val_from) - Log(eps)) / num
    Do
        col.Add Exp(Log(eps) + step * i) + val_from
        i = i + 1
        ' на выходе позволим небольшую ошибку для double значений, чтобы проще искать границы
    Loop Until i > num
    
    encode_logspace = ConvertToJson(col)
End Function
Public Function list_add(ParamArray var() As Variant)
    list_add = "to be done"
End Function
Public Function list_mult(ParamArray var() As Variant)
    list_add = "to be done"
End Function
'description_to_manual      - для автогенерации
' слияние списков чисел в json формате
' если значения на границе совпадают - они сливаются в одно
Public Function list_merge(ParamArray var() As Variant)
'description_end
    Dim i As Integer, j As Integer
    Dim tmp
    Dim dimen As Integer
    Dim shift As Integer
On Error GoTo er1:
    dimen = 0
    Dim res As New Collection
    For i = LBound(var) To UBound(var)
        If Not IsEmpty(var(i)) Then
            tmp = parse_list(var(i))
            dimen = dimen + UBound(tmp) - LBound(tmp) + 1
            For j = LBound(tmp) To UBound(tmp)
                If res.Count > 0 Then
                    If Abs(tmp(j) - res.Item(res.Count)) > 0.0001 Then
                        res.Add tmp(j)
                    End If
                Else
                    res.Add tmp(j)
                End If
            Next
            shift = dimen
        End If
    Next
    list_merge = ConvertToJson(res)
    Exit Function
er1:
    list_merge = "error: list_merge " & Err.Description
End Function
'description_to_manual      - для автогенерации
' слияние списков чисел в json формате
' если значения на границе совпадают - они дублируются
Public Function list_concatenate(ParamArray var() As Variant)
'description_end
    Dim i As Integer, j As Integer
    Dim tmp
    Dim dimen As Integer
    Dim shift As Integer
On Error GoTo er1:
    dimen = 0
    Dim res As New Collection
    For i = LBound(var) To UBound(var)
        tmp = parse_list(var(i))
        dimen = dimen + UBound(tmp) - LBound(tmp) + 1
        For j = LBound(tmp) To UBound(tmp)
            res.Add tmp(j)
        Next
        shift = dimen
    Next
    list_concatenate = ConvertToJson(res)
    Exit Function
er1:
    list_concatenate = "error: list_merge " & Err.Description
End Function

