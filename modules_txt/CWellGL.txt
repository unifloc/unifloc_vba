''=======================================================================================
''Unifloc 7.50 year 2024                                  khabibullinra@gmail.com
''Petroleum engineering calculations modules (macroses)
''2000 - 2023
''
''=======================================================================================
'' класс для расчета свойств скважины c газлифтом - распределение давления и температуры в скважине
'
'Option Explicit
'Option Base 0
''
''Implements IWell
'Public Event ReportProgress(msg As String)
'
'Private valves_ As New CGLValveSet         ' коллекция клапанов установленных в скважине
'Public curve As New CCurves ' коллекция кривых с результатами расчетов
'Public trajectory_tub As New CPipeTrajectory         ' полная траектория скважины с инклинометрии (основной способ задания скважины)
'Public trajectory_cas As New CPipeTrajectory         ' полная траектория скважины с инклинометрии (основной способ задания скважины)
'Public h_perf_m As Double
'Public h_tub_m As Double
'Public isCalcCasing As Boolean
'
'' штуцер установленный на поверхности
'' choke always exist in well (but can have diam = 0 means - no influence on flow)
'Public choke As New Cchoke
'Public choke_inj As New CGLvalve
'
'' input fluid object
'Private fluid_ As New CPVT                  ' флюид из пласта
'Private fluid_surf_ As CPVT
'Private fluid_cas_ As New CPVT
'' abbient formation object needed for full temperature calculation
'' must be accessed through property - in order to pass it to pipes properly
'Private ambient_formation_ As New CAmbientFormation
'' calculated parameters for well
'Private PT_buf_ As PTtype
'Private PT_lin_ As PTtype
'Private PT_wf_ As PTtype
'
'' casing and gas injection pressure taken with well head temp - temp do not influence on calculations
'Private p_gas_inj_atma_ As Double    ' pressure in gas injection line (before gas injection valve)
'Private p_cas_atma_ As Double        ' casing pressure - after gas injection valve
'' it is assumed - one fluid in tubing - other in casing
'' in gasing gas - with additional amount of gas in flow
'Private q_gas_inj_scm3day_ As Double
'Private d_gas_inj_mm_ As Double    ' injection gas valve diameter
'' temperature params
'' температура задается отдельно, поэтому для удобства прямые параметры для работы с температурной моделью скважины заданы
'Private t_wh_C_ As Double
'Private t_surf_C_ As Double
'Private t_bh_C_ As Double
'Private t_valve_C_ As Double
'Private t_res_C_ As Double
'Private param_ As PARAMCALC                 ' параметры расчета по трубе
' ' поправочные коэффициенты для расчета распределения давления
'Private calibr_grav_ As Double
'Private calibr_fric_ As Double
'' ключевые элементы конструкции
'Private PipesProd As New Collection      ' коллеция труб по которым идет добыча из которых состоит скважина
'Private PipesInj As New Collection       '  коллекция труб по которым идет закачка газа
'
'
'
'' ============ constructor ====================
'Private Sub Class_Initialize()
'    With param_
'        .correlation = Ansari
''        .FlowDirection = FlowAgainstCoord
'        .flow_along_coord = False
'        .temp_method = AmbientTemp
'    End With
'    ''PT_gas_inj_.t_C = 30
'    calibr_grav_ = 1
'    calibr_fric_ = 1
'    isCalcCasing = True
'    d_gas_inj_mm_ = 0
'    choke_inj.IPO = False
'
'End Sub
'
'
''------------------------------------------------------------
'' fluid general properties
''------------------------------------------------------------
'
'Public Property Get valves() As CGLValveSet
'    Set valves = valves_
'End Property
'
'Public Property Set valves(glv_set As CGLValveSet)
'    Set valves_ = glv_set
'    With glv_set
'        d_gas_inj_mm_ = .d_gas_inj_mm
'        q_gas_inj_scm3day_ = .q_gas_inj_sm3day
'        p_gas_inj_atma_ = .p_gas_inj_atma
'        If .p_gas_inj_atma > 0 Then
'            p_gas_inj_atma_ = .p_gas_inj_atma
'        End If
'    End With
'    Call FillWellConstructionTr
'
'End Property
'
'Public Property Get fluid() As CPVT
'    Set fluid = fluid_
'End Property
'
'Public Property Get fluid_tub() As CPVT
'    Set fluid_tub = fluid_
'End Property
'
'Public Property Get fluid_surf() As CPVT
'    If Not fluid_surf_ Is Nothing Then
'        Set fluid_surf = fluid_surf_
'    Else
'        Set fluid_surf = fluid_
'    End If
'End Property
'
'Public Property Get fluid_cas() As CPVT
'    Set fluid_cas = fluid_cas_
'End Property
'
'Public Property Set fluid(val As CPVT)
'    Dim pipe As CPipe
'    Set fluid_ = val    ' set main tubing fluid here
'    Set fluid_cas_ = val.clone ' set clone fluid object in casing
'
'    For Each pipe In PipesProd
'        Set pipe.fluid = fluid_
'    Next pipe
'    For Each pipe In PipesInj
'        Set pipe.fluid = fluid_cas_
'    Next pipe
'
'    Set choke.fluid = fluid_
'    Set valves.fluid = fluid_cas_
'End Property
'
'' ---------------------------------------------------------------
'' flow correlations tuning methods
'' ---------------------------------------------------------------
'Public Property Get calibr_grav() As Double
'   calibr_grav = calibr_grav_
'End Property
'
'Public Property Get calibr_fric() As Double
'   calibr_fric = calibr_fric_
'End Property
'
'Public Property Let calibr_grav(val As Double)
'   Dim pipe As CPipe
'   If val > 0 And val < 2 Then
'   ' не стоит подстрочный коэффициент менять слишком сильно - если что тут можно поправить
'        For Each pipe In PipesProd
'            pipe.calibr_grav = val
'        Next pipe
'        For Each pipe In PipesInj
'            pipe.calibr_grav = val
'        Next pipe
'        calibr_grav_ = val
'        If val <> 1 Then
'            add_log_msg "CWellGL.calibr_grav = " & str(val) & " warning. correction to multiphase flow correlation active!"
'        End If
'   Else
'        add_log_msg "CWellGL.calibr_grav: value " & str(val) & " not set. Out of range"
'   End If
'End Property
'
'Public Property Let calibr_fric(val As Double)
'   Dim pipe As CPipe
'   If val >= 0 And val < 2 Then
'   ' не стоит подстрочный коэффициент менять слишком сильно - если что тут можно поправить
'        For Each pipe In PipesProd
'            pipe.calibr_fric = val
'        Next pipe
'        For Each pipe In PipesInj
'            pipe.calibr_fric = val
'        Next pipe
'        calibr_fric_ = val
'        If val <> 1 Then add_log_msg "CWellGL.calibr_fric = " & str(val) & " warning. correction to multiphase flow correlation friction active!"
'   Else
'        add_log_msg "CWellGL.calibr_fric: value " & str(val) & " not set. Out of range"
'   End If
'End Property
'
'Public Property Get param() As PARAMCALC
'    param = param_
'End Property
'
'Public Property Let param(val As PARAMCALC)
'    param_ = val
'    Dim pipe As CPipe
'
'    For Each pipe In PipesProd
'        pipe.param = val
'    Next pipe
'    For Each pipe In PipesInj
'        pipe.param = val
'    Next pipe
'End Property
'
'Public Sub set_param( _
'                Optional ByVal calc_along_coord As Boolean = False, _
'                Optional ByVal flow_along_coord As Boolean = False, _
'                Optional ByVal hcor As H_CORRELATION = Ansari, _
'                Optional ByVal temp_method As TEMP_CALC_METHOD = StartEndTemp, _
'                Optional ByVal length_gas_m As Double = 0)
'' calc_along_coord - calculation direction flag
'' flow_along_coord - flow direction relative to coordinate
'' hcor             - hydraulic correlation selector
'' temp_method      - temperature method selector
'' length_gas_m     - boundary of gas correlation application in flow
'
'    Dim prm As PARAMCALC
'    prm.calc_along_coord = calc_along_coord
'    prm.flow_along_coord = flow_along_coord
'    prm.correlation = hcor
'    prm.temp_method = temp_method
'    prm.length_gas_m = length_gas_m
'    param = prm
'End Sub
'
''------------------------------------------------------------
'' temperature general properties
''------------------------------------------------------------
'Public Property Get t_line_C() As Double
'    t_line_C = PT_lin_.t_C
'End Property
'
'Public Property Get t_buf_C() As Double
'    t_buf_C = PT_buf_.t_C
'End Property
'
'Public Property Get t_bh_C() As Double
'    t_bh_C = PT_wf_.t_C
'End Property
'
'Public Property Get t_wh_C() As Double
'    t_wh_C = PT_buf_.t_C
'End Property
'
'Public Property Get t_surf_C() As Double
'    On Error Resume Next
'    t_surf_C = PT_buf_.t_C
'    t_surf_C = ambient_formation.amb_temp_C(0)
'End Property
'
'Public Property Get ambient_formation() As CAmbientFormation
'    Set ambient_formation = ambient_formation_
'End Property
'
'Public Property Set ambient_formation(ByVal vNewValue As CAmbientFormation)
'    Dim pipe As CPipe
'    Set ambient_formation_ = vNewValue
'    For Each pipe In PipesProd
'        Set pipe.ambient_formation = ambient_formation_
'    Next pipe
'    For Each pipe In PipesInj
'        Set pipe.ambient_formation = ambient_formation_
'    Next pipe
'
'    Call fill_temperature_from_amb
'End Property
'
''------------------------------------------------------------
'' pressure general properties
''------------------------------------------------------------
'Public Property Get p_line_atma() As Double
'   p_line_atma = PT_lin_.p_atma
'End Property
'
'Public Property Get pbuf_atma() As Double
'' buffer pressure
'   pbuf_atma = PT_buf_.p_atma
'End Property
'
'Public Property Get p_wf_atma() As Double
'' давление на забое
'   p_wf_atma = PT_wf_.p_atma
'End Property
'
'Public Property Get p_cas_atma() As Double
'    p_cas_atma = p_cas_atma_
'End Property
'
'Public Property Let p_cas_atma(val As Double)
'    p_cas_atma_ = val
'End Property
'
'
''------------------------------------------------------------
'' well rates general properties
''------------------------------------------------------------
'Property Let q_liq_sm3day(Qval_scm3day As Double)
'   fluid.q_liq_sm3day = Qval_scm3day
'   ' далее надо сбросить все флюиды которые были в системе на единый, что возможно потребует пересчета
'   Set fluid = fluid
'End Property
'
'' дебит жидкости из скважины в поверхностных условиях
'Public Property Get q_liq_sm3day() As Double
'   q_liq_sm3day = fluid_.q_liq_sm3day
'End Property
'
'Public Property Get w_kgsec() As Double
''    массовый расход продукции рассчитаем
'    With fluid_
'       w_kgsec = .mo_kgsec + .mw_kgsec + .mg_kgsec
'    End With
'End Property
'
'Public Property Get q_oil_sm3day() As Double
'   q_oil_sm3day = fluid_.q_oil_sm3day
'End Property
'
'Public Property Get q_oil_sctday() As Double
'   q_oil_sctday = q_liq_sm3day * (1 - fluid_.fw_fr) * fluid_.gamma_o
'End Property
'
'Public Property Get q_wat_sm3day() As Double
'   q_wat_sm3day = q_liq_sm3day * fluid_.fw_fr
'End Property
'
'Public Property Get q_gas_scm3day() As Double
'   q_gas_scm3day = fluid_.q_gas_sm3day
'End Property
'
'Property Get fw_perc() As Double
'    fw_perc = fluid_.fw_perc
'End Property
'
'Property Let fw_perc(wcval As Double)
'   Dim Wc As Double
'   Wc = wcval / 100
'   fluid.fw_fr = Wc
'   ' далее надо сбросить все флюиды которые были в системе на единый, что возможно потребует пересчета
'   Set fluid = fluid_
'End Property
'
'Property Let rp_m3m3(Rpval As Double)
'   fluid.rp_m3m3 = Rpval
'   ' далее надо сбросить все флюиды которые были в системе на единый, что возможно потребует пересчета
'   Set fluid = fluid_
'End Property
'
'' ---------------------------------------------------------------
'' service function
'' ---------------------------------------------------------------
' Public Function clone() As CWellGL
'    Dim wl As New CWellGL
'    Dim i As Integer
'    wl.h_perf_m = h_perf_m
'    wl.h_tub_m = h_tub_m
'    wl.isCalcCasing = isCalcCasing
'    wl.param = param
'
'    ' todo full clone needs to be done
'    ' for now trajectories and ambient formation shared here to clone object
'    Set wl.trajectory_tub = trajectory_tub
'    Set wl.trajectory_cas = trajectory_cas
'
'    Call wl.choke.Copy(choke)
'   ' Set wl.choke_inj = choke_inj
'
'    Set wl.fluid = fluid.clone
'    Set wl.ambient_formation = ambient_formation
'
'    Call wl.FillWellConstructionTr
'    Set clone = wl
' End Function
'
'
'Public Sub fill_temperature_from_amb()
'    ' here we must have ambient_formation_ ready for initialisation
'On Error GoTo err1:
'
'    ' here we must have ambient_formation_ ready for initialisation
'
'    t_bh_C_ = ambient_formation_.amb_temp_C(trajectory_cas.h_abs_hmes_m(h_perf_m))
'    t_wh_C_ = ambient_formation_.amb_temp_C(0)
'    t_surf_C_ = t_wh_C_
'    t_res_C_ = fluid.t_res_C
'
'    ' инициализируем все элементы скважины для расчета по линейной зависимости от измеренной глубине
'    ' это метод расчета по умолчанию
'    ' все другие режимы расчета используют объект ambient_formation_ и не зависят от этой инициализации
'    Dim TempGrad As Double
'    Dim t_int_C As Double
'    If h_perf_m > 0 Then
'        TempGrad = (t_bh_C_ - t_wh_C_) / h_perf_m
'    Else
'        TempGrad = 0
'    End If
'
'
'    Dim i As Integer
'    Dim tempDown_C As Double
'    Dim tempUp_C As Double
'    Dim pipe As CPipe
'    Dim HvalveVert0_m  As Double
'
'
'    tempUp_C = t_bh_C_
'    For i = 1 To PipesProd.Count
'         Set pipe = PipesProd(i)
'         tempDown_C = tempUp_C
'         tempUp_C = tempDown_C - TempGrad * pipe.length_mes_m
'         pipe.InitTlinear tempUp_C, tempDown_C
'    Next i
'
'    HvalveVert0_m = trajectory_cas.h_abs_hmes_m(valves.Hmes_lowest_m)
'    tempUp_C = ambient_formation.amb_temp_C(HvalveVert0_m)
'    For i = 1 To PipesInj.Count
'         Set pipe = PipesInj(i)
'         tempDown_C = tempUp_C
'         tempUp_C = tempDown_C - TempGrad * pipe.length_mes_m
'         pipe.InitTlinear tempUp_C, tempDown_C
'    Next i
'
'    ' зададим значения всех температур в ключевых точках в соответствии с исходными параметрами
'    ' некоторые из этих параметров потом могут быть перевычисленны
'    PT_buf_.t_C = t_wh_C_
'    PT_lin_.t_C = t_wh_C_
'    'PT_gas_inj_.t_C = t_wh_C_
'    PT_wf_.t_C = t_bh_C_
'
'    Exit Sub
'err1:
'    Dim errmsg As String
'    errmsg = "CWellGL.init_well_temperature: error in temperature init " & sDELIM & Err.Description
'    RaiseEvent ReportProgress(errmsg)
'    Err.Raise kErrInitCalc, Err.source, errmsg
'End Sub
'
'
'
'
'' метод инициализации газлифтной скважины
'' должен уметь задавать все трубы по скважине из исходных данных по траектории
'Public Sub init_well_GLV(Optional ByVal GLV_h_mes_m = 0, _
'                       Optional ByVal GLV_dvalve_mm = 0, _
'                       Optional ByVal GLV_Pbellow_atma = 0)
'   Dim RangeX As range
'   Dim RangeY As range
'   If IsObject(GLV_h_mes_m) Then
'        Set RangeX = GLV_h_mes_m
'        Set RangeY = GLV_dvalve_mm
'        Call valves.loadFromVertRange(RangeX, RangeY)
'   ElseIf IsArray(GLV_h_mes_m) Then
'        Call valves.loadFromArray(GLV_h_mes_m, GLV_dvalve_mm, GLV_Pbellow_atma)
'   End If
'
'
'End Sub
'
'
'' ============================================================
'' основные расчетные функции
'' ============================================================
'Public Sub set_qgas_inj(Optional ByVal pcas_inj_atma As Double = 1, _
'                      Optional ByVal qgas_inj_scm3day As Double = -1)
'    q_gas_inj_scm3day_ = qgas_inj_scm3day
'    p_gas_inj_atma_ = pcas_inj_atma
'End Sub
'
'Public Function calc_plin_p_wf_atma(ByVal p_wf_atma As Double, _
'                          Optional ByVal t_C As Double, _
'                          Optional ByVal saveCurve As CALC_RESULTS = nocurves) As Double
'' calculate PWH based on BHP
'' there are following options
''       1. q_gas_inj_scm3day_ given - assumed it goes into lowenst GLV, injection pressure not acounted
''                                     GLV model not used
''                                     work fast
''       2. q_gas_inj_scm3day_ not given, p_gas_inj_atma_ is given > 0 - full gas lift calculates
''                                   - q_gas_inj_scm3day_ calculated based on GLV parameters
''                                     surface injection valve settings acounted
''                                     may require some iterations to acount surface valve settings (slow)
'Dim chk_inj_crv As CInterpolation
'Dim surf_inj_crv As New CInterpolation
'Dim sol_crv As CInterpolation
'Dim plin As Double
'Dim pcas As Double
'Dim i As Integer
'Dim n As Integer
'Dim q As Double
'Dim p As Double
'
'    If q_gas_inj_scm3day_ > 0 Then
'        calc_plin_p_wf_atma = estimate_plin_p_wf_atma(p_wf_atma, p_gas_inj_atma_, q_gas_inj_scm3day_, t_C, saveCurve)
'    Else
'        If p_gas_inj_atma_ > 0 Then
'            If d_gas_inj_mm_ <= 0 Then
'                calc_plin_p_wf_atma = estimate_plin_p_wf_atma(p_wf_atma, p_gas_inj_atma_, q_gas_inj_scm3day_, t_C, saveCurve)
'            Else
'                ' surface valve acounting complicated - make it here
'                ' 1. estime valve curve
'                choke_inj.d_port_mm = d_gas_inj_mm_
'                choke_inj.t_C = t_wh_C_
'                Set choke_inj.fluid = fluid_cas_
'                Set chk_inj_crv = choke_inj.table_pin(p_gas_inj_atma_, t_wh_C)
'                ' 2. calc well curve - qinj vs pinj curve for given well model
'                i = 0
'                n = 20
'                Do
'                    pcas = p_gas_inj_atma_ * (n - i) / n
'                    plin = estimate_plin_p_wf_atma(p_wf_atma, pcas, 0, t_C, saveCurve)
'                    surf_inj_crv.AddPoint pcas, q_gas_inj_scm3day_
'                    i = i + 1
'                Loop While i < n And plin > 0
'                ' find intersections
'                Set sol_crv = surf_inj_crv.SubtractCurve(chk_inj_crv)
'                If sol_crv.FindSolutions(0) = 1 Then
'                    p = sol_crv.SolutionPointX(1)
'                    q = surf_inj_crv.getPoint(p)
'                    calc_plin_p_wf_atma = estimate_plin_p_wf_atma(p_wf_atma, p, 0, t_C, saveCurve)
'                Else
'                    ' there are no intersections or too many of them
'                    add_log_msg "CWellGL.calc_plin_p_wf_atma: not fuond solution for surface valve injection rate"
'                    calc_plin_p_wf_atma = estimate_plin_p_wf_atma(p_wf_atma, p_gas_inj_atma_, q_gas_inj_scm3day_, t_C, saveCurve)
'                End If
'            End If
'        Else
'            calc_plin_p_wf_atma = estimate_plin_p_wf_atma(p_wf_atma, p_gas_inj_atma_, q_gas_inj_scm3day_, t_C, saveCurve)
'        End If
'    End If
'    valves_.p_gas_inj_atma = p_gas_inj_atma_
'    valves_.q_gas_inj_sm3day = q_gas_inj_scm3day_
'End Function
'
'Private Function estimate_plin_p_wf_atma(ByVal p_wf_atma As Double, _
'                               Optional ByVal pinj_atma As Double, _
'                               Optional ByVal qinj_atma As Double, _
'                               Optional ByVal tbh_C As Double, _
'                               Optional ByVal saveCurve As CALC_RESULTS = nocurves) As Double
'' calculate well head pressure based on flowing bottom hole pressure (downside - up)
'' p_wf_atma - well flowing pressure (BHP) - must be given
'' pinj_atma - gas injection pressure. if not given - value from well model taken
'' qinj_atma - gas injection rate. if 0 then will be estimated - else will be used
'' d_surf_inj_mm - surface injection line valve diam
'' tbh_C - bottom hole temperature
'' saveCurve - if 0 no curves will be saved else some will
'
'Dim i As Integer
'Dim PT_temp As PTtype               ' temporary pt in tubing storage
'Dim PTcas_temp As PTtype            ' temporary pt in casing
'Dim qgas_inj_GLV_scm3day As Double     ' temporary qinj storage
'
'Dim pipe As CPipe
'Dim Qgfree_tot_scm3day As Double
'Dim fluid_Pipe_Below As CPVT
'Dim temp_corr_inj As TEMP_CALC_METHOD
'Dim p_cas_atma As Double
'Dim choke_inj_res
'
'Dim LowestGLVdone As Boolean ' flag show if lowest GLV has been acounted
'LowestGLVdone = False
'
'qgas_inj_GLV_scm3day = 0
'
'On Error GoTo err1:
'
'    Set fluid = fluid
'    Set fluid_Pipe_Below = fluid ' first initialize temp fluid with general one
'    ' 1. prepare initial data for calculation from p_wf, Tbh
'    Qgfree_tot_scm3day = fluid.q_gas_free_sm3day
'    PT_wf_.p_atma = p_wf_atma
'    If Not IsMissing(tbh_C) Then t_bh_C_ = tbh_C
'    PT_wf_.t_C = t_bh_C_
'
'    PT_temp = PT_wf_
'    ' 1.1 prepare gas injection pressure gradient calculation
''    If Not IsMissing(pinj_atma) Then
''        'explicitly given injection pressure has priority here
''    '    p_gas_inj_atma_ = pinj_atma
''    '    valves_.p_gas_inj_atma = pinj_atma
''        ' hope that temp will be ok up to here
''    End If
'    If Not IsMissing(qinj_atma) Then
'        q_gas_inj_scm3day_ = qinj_atma
''        valves.q_gas_inj_sm3day = qinj_atma
'    End If
'    PT_temp = PT_wf_
'    p_cas_atma_ = pinj_atma
'
'    ' 2. calculate pressure distribution in annulus
'    PTcas_temp = set_PT(p_cas_atma_, t_wh_C_)
'    For i = PipesInj.Count To 1 Step -1
'        Set pipe = PipesInj(i)
'        If param_.temp_method = AmbientTemp Then
'            ' AmbientTemp correlation not work with gas injection in this version
'            ' with relatively small gas injection rates errors should not be significant
'            ' with temprature distribution taken as ambient temperature      rnt2019
'            temp_corr_inj = GeoGradTemp
'        Else
'            temp_corr_inj = param_.temp_method
'        End If
'        pipe.param = set_calc_flow_param(calc_along_coord:=True, _
'                                         flow_along_coord:=True, _
'                                         hcor:=gas, _
'                                         temp_method:=temp_corr_inj, _
'                                         length_gas_m:=param_.length_gas_m)
'        PTcas_temp = pipe.calc_dPipe(PTcas_temp.p_atma, , saveCurve)
'        If Not pipe.GLVin Is Nothing Then
'            ' if  there is a valve - save PT in casing at valve intake
'            pipe.GLVin.p_in_atma = PTcas_temp.p_atma
'            pipe.GLVin.t_C = PTcas_temp.t_C
'        End If
'    Next i
'
'    ' 3. calculate tubing pressure distribution
'    For i = 1 To PipesProd.Count
'        ' first segment - from bottom to tubing depth then goes up
'        Set pipe = PipesProd(i)
'        ' taking fluid from previos segment - if we had gas injected below it will acounted here
'        Set pipe.fluid = fluid_Pipe_Below
'        ' check if there is a valve on pipe bottom
'        ' GLV meant it is possible ijection point
'        If Not pipe.GLVin Is Nothing Then
'            ' if valve set up then estimate gas coming through valve
'            pipe.GLVin.p_out_atma = PT_temp.p_atma   ' pressure at pipe bottom from previos step
'            pipe.GLVin.t_C = PT_temp.t_C
'            ' adding additional gas coming trough valve
'On Error GoTo err2:
'            If q_gas_inj_scm3day_ > 0 Then
'                ' use manual Qgas in well
'                If Not LowestGLVdone Then
'                    qgas_inj_GLV_scm3day = q_gas_inj_scm3day_
'                    LowestGLVdone = True
'                Else
'                    qgas_inj_GLV_scm3day = 0
'                End If
'            Else
'                qgas_inj_GLV_scm3day = pipe.GLVin.calc_q_gas_sm3day(-1, -1, -1)
'            End If
'            pipe.GLVin.q_gas_inj_scm3day = qgas_inj_GLV_scm3day
'On Error GoTo err1:
'            Qgfree_tot_scm3day = Qgfree_tot_scm3day + qgas_inj_GLV_scm3day
'            If qgas_inj_GLV_scm3day > 0 Then
'                Set pipe.fluid = fluid_Pipe_Below.clone
'                pipe.fluid.q_gas_free_sm3day = Qgfree_tot_scm3day
'                Set fluid_Pipe_Below = pipe.fluid
'                Set fluid_surf_ = fluid_Pipe_Below
'            End If
'        End If
'        ' считаем снизу в сторону буферного
'        pipe.param = set_calc_flow_param(calc_along_coord:=False, _
'                                         flow_along_coord:=False, _
'                                         hcor:=param_.correlation, _
'                                         temp_method:=param_.temp_method, _
'                                         length_gas_m:=param_.length_gas_m)
'        PT_temp = pipe.calc_dPipe(PT_temp.p_atma, PT_temp.t_C, saveCurve)
'    Next i
'    q_gas_inj_scm3day_ = Qgfree_tot_scm3day - fluid.q_gas_free_sm3day
'  '  valves.q_gas_inj_sm3day = q_gas_inj_scm3day_
'    PT_buf_ = PT_temp
'    PT_lin_ = PT_buf_
'On Error GoTo err3:
'    ' 4. Расчет линейного давления по штуцеру
'    If choke.d_choke_m > 0 Then      ' пока отключено
'        Set choke.fluid = pipe.fluid   ' take fluid from last pipe
'        If PT_buf_.p_atma > 0 Then
'            PT_lin_ = choke.calc_choke_p_lin(PT_buf_)
'            If PT_lin_.p_atma < 0 Then
'                PT_lin_.p_atma = 0     ' 0 - means calculation were wrong
'            End If
'        Else
'            PT_lin_ = PT_buf_
'        End If
'    End If
'On Error GoTo err1:
'    estimate_plin_p_wf_atma = PT_temp.p_atma
'    Call save_curves(saveCurve)
'    Exit Function
'err1:
'    On Error Resume Next
'    RaiseEvent ReportProgress("CWellGL.estimate_plin_p_wf_atma: some general error")
'    Err.Raise Err.Number, Err.source, Err.Description
'    Exit Function
'
'err2:
'    On Error Resume Next
'    add_log_msg "CWellGL.estimate_plin_p_wf_atma:error while GLV Hmes = " & CStr(pipe.GLVin.h_mes_m) & " calc - Qgas_inj_GLV_scm3day = " & CStr(qgas_inj_GLV_scm3day)
'    Resume Next
'    Exit Function
'
'err3:
'    On Error Resume Next
'    add_log_msg "CWellGL.estimate_plin_p_wf_atma:error while choke calc - choke have been  ignored"
'    Resume Next
'err4:
'    On Error Resume Next
'    add_log_msg "CWellGL.estimate_plin_p_wf_atma:error while injection choke calc - choke have been  ignored"
'    ReDim choke_inj_res(2)
'    Dim a()
'    ReDim a(3)
'    a(0) = PTcas_temp.p_atma
'    a(3) = False
'    choke_inj_res(0) = a
'    Resume Next
'
'End Function
'
'Private Sub save_curves(saveCurve As CALC_RESULTS)
'Dim i As Integer
'Dim pipe As CPipe
'On Error GoTo err1:
'    If saveCurve > 0 Then
'        add_crv "c_udl_m", "c_udl_m", tub:=True, xnam:="hmes_m", ynam:="h_vert_m"
'
'        Call add_crv(str_PtubHmes_curve, "c_P", tub:=True, xnam:="hmes ptub", ynam:="ptub")
'        Call add_crv(str_TtubHmes_curve, "c_T", tub:=True, xnam:="hmes ttub", ynam:="ttub")
'        Call add_crv(str_TambHmes_curve, "c_Tamb", tub:=True, xnam:="hmes tamb", ynam:="tamb")
'        Call add_crv(str_PcasHmes_curve, "c_P", tub:=False, xnam:="hmes pcas", ynam:="pcas")
'        Call add_crv(str_TcasHmes_curve, "c_T", tub:=False, xnam:="hmes tcas", ynam:="tcas")
'
'        add_crv "c_Diam", "c_Diam", tub:=True, xnam:="hmes_m", ynam:="c_Diam"
'        add_crv "c_Roughness", "c_Roughness", tub:=True, xnam:="hmes_m", ynam:="c_Roughness"
'        add_crv "c_Theta", "c_Theta", tub:=True, xnam:="hmes_m", ynam:="c_Theta"
'
'
'        If saveCurve > 1 Then
'            add_crv str_HlHmes_curve, "c_Hl", tub:=True, xnam:="hmes_m", ynam:="Hl_tub"
'            add_crv str_HLcasHmes_curve, "c_Hl", tub:=False, xnam:="hmes_m", ynam:="Hl_cas"
'
'            add_crv "c_fpat", "c_fpat", tub:=True, xnam:="hmes_m", ynam:="c_fpat"
'            add_crv "c_Rs", "c_Rs", tub:=True, xnam:="hmes_m", ynam:="c_Rs"
'            add_crv "c_gasfrac", "c_gasfrac", tub:=True, xnam:="hmes_m", ynam:="c_gasfrac"
'
'            add_crv "c_dpdl_g", "c_dpdl_g", tub:=True, xnam:="hmes_m", ynam:="c_dpdl_g"
'            add_crv "c_dpdl_f", "c_dpdl_f", tub:=True, xnam:="hmes_m", ynam:="c_dpdl_f"
'            add_crv "c_dpdl_a", "c_dpdl_a", tub:=True, xnam:="hmes_m", ynam:="c_dpdl_a"
'            add_crv "c_vsl", "c_vsl", tub:=True, xnam:="hmes_m", ynam:="c_vsl"
'            add_crv "c_vsg", "c_vsg", tub:=True, xnam:="hmes_m", ynam:="c_vsg"
'            add_crv "c_muo", "c_muo", tub:=True, xnam:="hmes_m", ynam:="c_muo"
'            add_crv "c_muw", "c_muw", tub:=True, xnam:="hmes_m", ynam:="c_muw"
'            add_crv "c_mug", "c_mug", tub:=True, xnam:="hmes_m", ynam:="c_mug"
'            add_crv "c_mumix", "c_mumix", tub:=True, xnam:="hmes_m", ynam:="c_mumix"
'        End If
'
'    End If
'
'    Exit Sub
'err1:
'    Dim errmsg As String
'    errmsg = "CWellESP.save_curves: ошибка" & sDELIM & Err.Description
'    add_log_msg errmsg
'    RaiseEvent ReportProgress(errmsg)
'    Err.Raise kErrInitCalc, Err.source, errmsg
'
'End Sub
'
'Private Sub add_crv(crv_name As String, _
'                    crv_pipe_name As String, _
'                    tub As Boolean, _
'                    xnam As String, _
'                    ynam As String)
'    Dim i As Integer
'    Dim pipe As CPipe
'
'    If tub Then
'        For i = 1 To PipesProd.Count
'            Set pipe = PipesProd(i)
'            Call curve(crv_name).AddPointsCurve(pipe.curve(crv_pipe_name))
'        Next i
'    Else
'        For i = 1 To PipesInj.Count
'           Set pipe = PipesInj(i)
'           Call curve(crv_name).AddPointsCurve(pipe.curve(crv_pipe_name))
'        Next i
'    End If
'
'    curve(crv_name).xName = xnam
'    curve(crv_name).yName = ynam
'
'End Sub
'
'Public Function calc_pwf_plin_atma(ByVal plin_atma As Double, _
'                                   ByVal t_bh_C As Double, _
'                          Optional ByVal saveCurve As CALC_RESULTS = nocurves)
'' @brief calc_pwf_plin_atma расчет забойного давления по известному давлению в линии и конструкции скважины дихотомией
'' @param plin_atma - давление в линии
'' @param Hd - динамический уровень
'' @param t_bh_C - температура на забое скважины
'' @return Подсчитанное для заданного линейного давление
'On Error GoTo err1:
'    Dim p_wf1 As Double      ' первое приближение
'    Dim p_wfUp As Double, p_wfDown As Double
'    Dim p_linUp As Double, p_linDown As Double
'    Dim p_lin0 As Double, p_lin1 As Double
'    Dim found_solution As Boolean
'    Dim i As Integer
'    Dim qgas_inj_temp_sm3day As Double
'
'    found_solution = False
'    i = 0
'    p_wf1 = 60
'    p_wfUp = -1
'    p_wfDown = -1
'    qgas_inj_temp_sm3day = q_gas_inj_scm3day_
'    Do
'        q_gas_inj_scm3day_ = qgas_inj_temp_sm3day
'        ' ищем  приближения
'        p_lin1 = calc_plin_p_wf_atma(p_wf1, t_bh_C, saveCurve:=nocurves)
'        If (Abs(p_lin1 - plin_atma) < const_well_P_tolerance) Then
'             found_solution = True
'             PT_wf_.p_atma = p_wf1
'             PT_wf_.t_C = t_bh_C
'        End If
'        If Not found_solution Then
'          If p_lin1 > plin_atma Then
'              p_wfUp = p_wf1
'              p_linUp = p_lin1
'              If p_wfDown < 0 Then
'                  p_wf1 = p_wfUp / 2
'              Else
'                  p_wf1 = p_wfDown + (p_wfUp - p_wfDown) * (plin_atma - p_linDown) / (p_linUp - p_linDown)
'              End If
'          Else
'              p_wfDown = p_wf1
'              p_linDown = p_lin1
'              If p_wfUp < 0 Then
'                  p_wf1 = p_wf1 * 2
'              Else
'                  p_wf1 = (p_wfUp + p_wfDown) / 2
'              End If
'          End If
'        End If
'        i = i + 1
'    Loop While Not found_solution And i < 20
'
'    If i = 20 Then
'       add_log_msg "CWellGL.calc_pwf_plin_atma: max iteration num reached. i = " & CStr(i) & " tolerance reached = " & CStr(Abs(p_lin1 - plin_atma))
'    End If
'
'   ' Call set_qgas_inj(Pcas_inj_atma, Qgas_inj_scm3day)
'    PT_lin_ = set_PT(calc_plin_p_wf_atma(PT_wf_.p_atma, t_bh_C, saveCurve:=saveCurve), t_buf_C)
'
'    If Abs(p_line_atma - plin_atma) > const_well_P_tolerance Then
'       add_log_msg "CWellGL.calc_pwf_plin_atma: BHP estimation error exceeds tolerance " & const_well_P_tolerance & ". Equal = " & Abs(Me.p_line_atma - plin_atma)
'    End If
'    calc_pwf_plin_atma = PT_wf_.p_atma
'
'    Exit Function
'err1:
'    ' тут надо среагировать на ошибку
'        On Error Resume Next
'    RaiseEvent ReportProgress("CWellGL.calc_plin_p_wf_atma: some general error")
'    Err.Raise Err.Number, Err.source, Err.Description
'    Exit Function
'
' End Function
'
'
'
'' =============================================================================
'' specific properties and functions
'' =============================================================================
'Public Sub FillWellConstructionTr()
'    Dim i As Integer, j As Integer
'    Dim segmUp_m As Double
'    Dim segmDown_m As Double
'    Dim pipe As CPipe
'    ' need to fill up individual pipe segments in well (production line)
'    ' 1 segment from bottom hole to Htub  (lowest)
'    ' next - from Htub to valve(0) depth - and so on
'    ' at this point valve depth values must be ok (sorted and non zero)
'
'    ' set up pipe segments for injection line
'    ' 1 segment from lowest valve to upper
'    ' not interested for now what happens bellow lowest valve
'
'    ' set up csing flow below tubing depth
'    segmDown_m = h_perf_m
'    segmUp_m = h_tub_m
'    Set PipesProd = Nothing
'    Set PipesInj = Nothing
'    If segmDown_m > segmUp_m Then
'        ' first segment from bottom to tubing depth exist
'        ' hae to be created here
'        Set pipe = New CPipe  ' creating new object
'        Set pipe.fluid = fluid
'        Call pipe.init_pipe_constr_by_trajectory(trajectory_cas, segmUp_m, segmDown_m)
'        PipesProd.Add pipe    ' save it to collection
'    End If
'    segmDown_m = segmUp_m
'    i = valves.Count
'    If i > 0 Then
'        segmUp_m = valves.h_mes_m(i)
'    Else
'        segmUp_m = 0
'    End If
'    For j = i To 0 Step -1
'        If segmUp_m < segmDown_m Then
'            Set pipe = New CPipe  ' creating new object
'            Set pipe.fluid = fluid
'            Call pipe.init_pipe_constr_by_trajectory(trajectory_tub, segmUp_m, segmDown_m)
'            If j < i Then
'                Set pipe.GLVin = valves.valves(j + 1)
'            End If
'            PipesProd.Add pipe    ' save it to collection
'            segmDown_m = segmUp_m
'        End If
'        If j > 1 Then
'            segmUp_m = valves.h_mes_m(j - 1)
'        Else
'            segmUp_m = 0
'        End If
'        If segmUp_m < segmDown_m Then
'            ' if exist segment
'            Set pipe = New CPipe  ' creating new object
'            Set pipe.fluid = fluid
'            Call pipe.init_pipe_constr_by_trajectory(trajectory_tub, segmUp_m, segmDown_m, trajectory_cas)
'            Set pipe.GLVin = valves.valves(j)
'            PipesInj.Add pipe
'        End If
'    Next j
'
'    choke.d_up_m = 0.06
'    choke.d_down_m = 0.06
'    Set ambient_formation = ambient_formation
'    ' repopulate calibration values to new pipes
'    calibr_fric = calibr_fric
'    calibr_grav = calibr_grav
'
'End Sub
'
'
'
'
'
'
'
'
'Public Property Get p_gas_inj_atma() As Double
'    p_gas_inj_atma = p_gas_inj_atma_
'End Property
'
'Public Property Let p_gas_inj_atma(val As Double)
'    p_gas_inj_atma_ = val
'End Property
'
'
''Private Property Set IWell_AmbFormation(RHS As CAmbientFormation)
''    Set ambient_formation_ = RHS
''End Property
''
''Private Property Get IWell_AmbFormation() As CAmbientFormation
''    Set IWell_AmbFormation = ambient_formation_
''End Property
''
''' ======================================================================
''' Iwell implementation
''' ======================================================================
''
''
''Private Function IWell_CalcDown(p_line_atma As Double, _
''                                twf_C As Double, _
''                       Optional saveCurve As CALC_RESULTS = 0&) As Double
''    IWell_CalcDown = calc_pwf_plin_atma(p_line_atma, twf_C, saveCurve:=saveCurve)
''End Function
''
''Private Function IWell_CalcUp(p_wf_atma As Double, _
''                              twf_C As Double, _
''                              Optional saveCurve As CALC_RESULTS = 0&) As Double
''    IWell_CalcUp = calc_plin_p_wf_atma(p_wf_atma, twf_C, saveCurve:=saveCurve)
''End Function
''
''Private Function IWell_CalcWell(p_wf_atma As Double, Optional saveCurve As CALC_RESULTS = 0&) As Double
''
''End Function
''
''Private Property Get IWell_cfBettaFric() As Double
''    IWell_cfBettaFric = calibr_fric
''End Property
''
''Private Property Let IWell_cfBettaFric(val As Double)
''    calibr_fric = val
''End Property
''
''Private Property Get IWell_cfBettaGrav() As Double
''    IWell_cfBettaGrav = calibr_grav
''End Property
''
''Private Property Let IWell_cfBettaGrav(val As Double)
''    calibr_grav = val
''End Property
''
''
''
''Private Property Get IWell_cfESP() As Double
'''    IWell_cfESP = ESP.calibr_head
''    ' пока учитывается только по напору
''    ' наверное потом надо будет добавить по дебиту и по мощности как то
''End Property
''
''Private Property Get IWell_cfFw() As Double
''    IWell_cfFw = 0
''End Property
''
''Private Property Get IWell_cfGLinj() As Double
''    IWell_cfGLinj = 0
''End Property
''
''Private Property Get IWell_cfRp() As Double
''    IWell_cfRp = 0
''End Property
''
''Private Property Get IWell_Choke() As Cchoke
''    Set IWell_Choke = choke
''End Property
''
''Private Property Get IWell_curve() As CCurves
''    Set IWell_curve = curve
''End Property
''
''Private Property Get IWell_ESP() As CESPsystem
''    Set IWell_ESP = Nothing
''End Property
''
''Private Property Get IWell_fluid() As CPVT
''    Set IWell_fluid = fluid
''End Property
''
''Private Property Get IWell_fw() As Double
''    IWell_fw = fluid.fw_perc
''End Property
''
''Private Property Get IWell_GLVset() As CGLValveSet
''    Set IWell_GLVset = valves_
''End Property
''
''Private Property Get IWell_HdynPcas() As PCAS_HDYN_type
''    IWell_HdynPcas.correct = False
''    IWell_HdynPcas.hdyn_m = 0
''    IWell_HdynPcas.p_cas_atma = 0
''    IWell_HdynPcas.pump_off_condition = False
''    IWell_HdynPcas.self_flow_condition = False
''End Property
''
''Private Property Get IWell_isESP() As Boolean
''    IWell_isESP = False
''End Property
''
''Private Property Get IWell_isGL() As Boolean
''    IWell_isGL = valves_.Count > 0
''End Property
''
''Private Property Get IWell_PTbuf() As PTtype
''    IWell_PTbuf = PT_buf_
''End Property
''
''Private Property Get IWell_PTcas() As PTtype
''    IWell_PTcas = set_PT(p_cas_atma_, t_wh_C_)
''End Property
''
''Private Property Get IWell_PTdis() As PTtype
''    IWell_PTdis = set_PT(0, 0)  'PT_int_
''End Property
''
''Private Property Get IWell_PTintake() As PTtype
''    IWell_PTintake = set_PT(0, 0) 'PT_int_
''End Property
''
''Private Property Get IWell_PTline() As PTtype
''    IWell_PTline = PT_lin_
''End Property
''
''Private Property Get IWell_PTwf() As PTtype
''    IWell_PTwf = PT_wf_
''End Property
''
''Private Property Get IWell_Qgas() As Double
''    IWell_Qgas = fluid_surf.q_gas_sm3day
''End Property
''
''Private Property Get IWell_Qgascas() As Double
''    IWell_Qgascas = 0
''End Property
''
''Private Property Get IWell_Qgasinj() As Double
''    IWell_Qgasinj = 0
''End Property
''
''Private Property Let IWell_Qliq(RHS As Double)
''    fluid.q_liq_sm3day = RHS
''End Property
''
''Private Property Get IWell_Qliq() As Double
''    IWell_Qliq = fluid.q_liq_sm3day
''End Property
''
''
'
'
'
'
'
'
'
'
'
'
'
'
'' =======================================
'' методы инициализации скважины
'' =======================================
''Public Sub init_well_construction(ByVal h_perf_m As Double, _
''                                  ByVal h_tub_m As Double, _
''                         Optional ByVal d_cas_mm As Double = 125, _
''                         Optional ByVal d_tub_mm As Double = 72, _
''                         Optional ByVal udl_m As Double = 0, _
''                         Optional ByVal hmes_incl_range_m_ = -1, _
''                         Optional ByVal hvert_incl_range_m_ = -1, _
''                         Optional ByVal hmes_dcas_range_m_ = -1, _
''                         Optional ByVal dcas_range_mm_ = -1, _
''                         Optional ByVal hmes_dtub_range_m_ = -1, _
''                         Optional ByVal dtub_range_mm_ = -1)
''    ' универсальный метод инициализации скважины - должен использоваться для инициализации скважины
''    ' поддерживает три варианта инициалиции
''    '       - с упрощенным набором данных с удлинением (загрузка из тех режима)
''    '       - с заданием инклинометрии через range и упрощенным набором труб (диаметры)
''    '       - с заданием инклинометрии и диаметров с использованием range
''    '
''    ' параметры обязательные для всех вариантов задания
''    ' h_perf_m               - глубина перфорации измеренная, м. Используется для расчета забойного давления
''    ' h_tub_m                - глубина спуска НКТ измеренная, м. Соответствует глубине спуска насоса
''    '
''    ' параметры упрощенного режима задания
''    ' d_cas_mm               - внутренний диамет эксплуатационной колонны, мм
''    ' d_tub_mm               - внешний диамет НКТ, мм (толщина стенки 10 мм)
''    ' udl_m                 - удлинение на глубину перфорации, м (разница между измеренной и вертикальной глубиной)
''    '
''    ' параметры детального задания скважины  (все - вертикальные range)
''    ' hmes_incl_range_m_    - измеренная глубина скважины для задания инклинометрии
''    ' hvert_incl_range_m_   - вертикальная глубина скважины для задания инклинометрии
''    '                       - если инклинометрии как range задана, то удлинение игнорируется
''    '
''    ' hmes_dcas_range_m_    - измеренная глубина для задания диаметра эксплуатационной колонны (начинается с 0)
''    ' dcas_range_mm_        - диаметр эксплуатационной колонны на соответствующей глубине (действует от глубины и вниз до след изменения)
''    ' hmes_dtub_range_m_    - измеренная глубина для задания диаметра НКТ
''    ' dtub_range_mm_        - диаметр НКТ внешний на соответствующей глубине (действует от глубины и вниз до след изменения)
''    '                       - для полного задания скважины все range должны быть заданы
''
''
''
''    Dim simpleNumbers As Boolean
''    Dim fullRange As Boolean
''    Dim inclRange As Boolean
''    Dim fullArray As Boolean
''
''    simpleNumbers = IsNumeric(hmes_incl_range_m_)
''    inclRange = IsObject(hmes_incl_range_m_) And IsObject(hvert_incl_range_m_)
''    fullRange = inclRange And IsObject(hmes_dcas_range_m_) And IsObject(dcas_range_mm_) And _
''                              IsObject(hmes_dtub_range_m_) And IsObject(dtub_range_mm_)
''
''    If simpleNumbers Then
''    ' use simple numbers here
''        Call FillWellConstructionSimple(h_perf_m, h_tub_m, udl_m, d_cas_mm, d_tub_mm)
''    ElseIf fullRange Then
''        Call FillWellConstructionRangeAll(hmes_incl_range_m_, hvert_incl_range_m_, hmes_dcas_range_m_, _
''                              dcas_range_mm_, hmes_dtub_range_m_, dtub_range_mm_, _
''                              h_perf_m, h_tub_m)
'''    ElseIf inclRange Then
'''        Call FillWellConstructionRange(hmes_incl_range_m_, hvert_incl_range_m_, h_perf_m, h_tub_m, d_cas_mm, d_tub_mm)
''    End If
''
''
''End Sub
'
'
'
'' Public Sub InitTempTr(geoGrad As CInterpolation)
''' процедура для инициализации температуры в скважине, для линейнго расчета
''' при линейном расчете предполагается,
''' что температура меняется линейно относительно глубины скважины
'''
''   Dim TempGradVert As Double
''   Dim pipe As CPipe
''
''   PT_wf_.T_C = geoGrad.getPoint(geoGrad.maxx)
''   PT_buf_.T_C = geoGrad.getPoint(geoGrad.minx)
''
''   TempGradVert = (PT_wf_.T_C - PT_buf_.T_C) / Trajectory.h_perf_m
''
''   For Each pipe In PipesProd
''       pipe.dTdLinit = TempGradVert
''   Next pipe
''   For Each pipe In PipesInj
''       pipe.dTdLinit = TempGradVert
''   Next pipe
''
''   temp_correlation = GeoGradTemp
''
''End Sub
'
''Private Sub FillWellConstructionSimple(ByVal h_perf_m As Double, _
''                    ByVal h_tub_m As Double, _
''                    ByVal udl_m As Double, _
''                    ByVal d_cas_mm As Double, _
''                    ByVal d_tub_mm As Double)
''' метод для инициализации скважины простыми числами
''On Error GoTo err1:
''   Dim errmsg As String
''
''   ' задаем траекторию свола скважины, на основе которого потом будет задано все остальное
''   Dim habs_curve_m As New CInterpolation  ' инклинометрия - две точки
''
''   habs_curve_m.AddPoint 0, 0
''   habs_curve_m.AddPoint h_perf_m, h_perf_m - udl_m
''
''   Dim dcas_curve_mm As New CInterpolation  ' casing diameter
''   dcas_curve_mm.AddPoint 0, d_cas_mm
''   dcas_curve_mm.AddPoint h_perf_m, d_cas_mm  ' casing goes from top to bottom here
''
''   Dim dtub_curve_mm As New CInterpolation  ' tubing diameter
''   dtub_curve_mm.AddPoint 0, d_tub_mm
''   dtub_curve_mm.AddPoint h_tub_m, d_tub_mm  ' goes to tubing setting depth
''
''   ' initialise trajectory (same as ESP well class)
''   Me.h_perf_m = h_perf_m
''   Me.h_tub_m = h_tub_m
''   Call trajectory_tub.init_from_curves(habs_curve_m, dtub_curve_mm)
''   Call trajectory_cas.init_from_curves(habs_curve_m, dcas_curve_mm)
''
''   Call FillWellConstructionTr
''
''   Exit Sub
''
''err1:
''   errmsg = "CWellGL.FillWellConstructionSimple: Ошибка простой инициализации скважины " & sDELIM & Err.Description
''   RaiseEvent ReportProgress(errmsg)
''   Err.Raise kErrInitCalc, Err.Source, errmsg
''End Sub
''
''Private Sub FillWellConstructionRangeAll(ByVal incl_h_mes_m_ As range, _
''                           ByVal incl_h_vert_m_ As range, _
''                           ByVal hmes_d_cas_m_ As range, _
''                           ByVal dcas_arr_mm_ As range, _
''                           ByVal hmes_d_tub_m_ As range, _
''                           ByVal dtub_arr_mm_ As range, _
''                           ByVal h_perf_m As Double, _
''                           ByVal h_tub_m As Double)
''' метод для инициализации скважины из диапазонов измнения ключевых параметров
''On Error GoTo err1:
''   Dim habs_curve_m As New CInterpolation
''   Dim dcas_curve_mm As New CInterpolation
''   Dim dtub_curve_mm As New CInterpolation
''   Dim geoGrad As New CInterpolation
''   Dim ambTemp As New CAmbientFormation
''   Dim errmsg As String
''
''   Call habs_curve_m.loadFromVertRange(incl_h_mes_m_, incl_h_vert_m_)
''   Call dcas_curve_mm.loadFromVertRange(hmes_d_cas_m_, dcas_arr_mm_)
''   Call dtub_curve_mm.loadFromVertRange(hmes_d_tub_m_, dtub_arr_mm_)
''
''   h_perf_m = dcas_curve_mm.maxx
''   h_tub_m = dtub_curve_mm.maxx
''
''   Me.h_perf_m = h_perf_m
''   Me.h_tub_m = h_tub_m
''   Call trajectory_cas.init_from_curves(habs_curve_m, dcas_curve_mm)
''   Call trajectory_tub.init_from_curves(habs_curve_m, dtub_curve_mm)
''   Call FillWellConstructionTr
''
''   Exit Sub
''err1:
''   errmsg = "CWellESP.InitWellRangeAll: Ошибка простой инициализации скважины " & sDELIM & Err.Description
''   RaiseEvent ReportProgress(errmsg)
''   Err.Raise kErrInitCalc, Err.Source, errmsg
''End Sub
''
'
'

