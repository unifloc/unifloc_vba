'=======================================================================================
'Unifloc 7.6  Vulpes zerda                                           khabibullin.ra@gubkin.ru
'Petroleum engineering calculations modules (macroses)
'2000 - 2019
'
'=======================================================================================
'
Option Explicit
'  класс для описания работы газлифтной скважины
'
'  предполагается, что есть пакер отделяющий затруб и газлифтные клапана
'Public NumValves As Integer
' количество газлифтных клапанов. От этого зависит количество сегментов труб
' should be read only - base on valves collection
' штуцер установленный на поверхности
Public Choke As New Cchoke
Private PipesProd As New Collection      ' коллеция труб по которым идет добыча из которых состоит скважина
Private PipesInj As New Collection       '  коллекция труб по которым идет закачка газа
Private valves As New CGLValveSet         ' коллекция клапанов установленных в скважине
'Private p_Hvalve_m() As Double              ' массив с глубинами расположения клапанов
Public Fluid As New CPVT                 ' флюиды из пласта
Public FluidInj As New CPVT              ' gas injected in annulus
Public Trajectory As New CTrajectory     ' полная траектория скважины с инклинометрии (основной способ задания скважины)
Private p_AmbientForm As New CAmbientFormation  ' порода за пределями скважины   (new тут лишнее)
'Public Hpacker_m As Double               ' глубина установки пакера, ограничивает глубину закачки газа
Public Hvd_m As Double                   ' глубина верхних дыр перфорации
Private p_PTbuf As PTtype
Private p_PTlin As PTtype
Private p_PTcas As PTtype
Private p_PTwf As PTtype
' параметры расчета по трубе
Private p_Param As PARAMCALC
'Public TempCorrelation As TEMP_CALC_METHOD
Private c_Curves As New Collection         ' коллекция кривых с результатами расчетов
' блок оценки качества данных
 'Private p_LogMsg As New CLogger                ' логгер
 
Public Event ReportProgress(msg As String)
Public Property Get Pwf_atma() As Double
    Pwf_atma = p_PTwf.P_atma
End Property
Public Property Get Tbh_C() As Double
    Tbh_C = p_PTwf.T_C
End Property
Public Property Get Pbuf_atma() As Double
    Pbuf_atma = p_PTbuf.P_atma
End Property
Public Property Get Pline_atma() As Double
    Pline_atma = p_PTlin.P_atma
End Property
Public Property Get Tline_C() As Double
    Tline_C = p_PTlin.T_C
End Property
Public Property Get Tbuf_C() As Double
    Tbuf_C = p_PTbuf.T_C
End Property
Public Property Let HFlowCorrelation(val As H_CORRELATION)
    Dim prm As PARAMCALC
    prm = Param
    prm.correlation = val
    Param = prm
End Property
 
Public Property Get HFlowCorrelation() As H_CORRELATION
    HFlowCorrelation = Param.correlation
End Property
 
Public Property Let TempCorrelation(val As TEMP_CALC_METHOD)
    Dim prm As PARAMCALC
    prm = Param
    prm.tempMethod = val
    Param = prm
End Property
 
Public Property Get TempCorrelation() As TEMP_CALC_METHOD
    TempCorrelation = Param.tempMethod
End Property
Public Property Let Param(val As PARAMCALC)
    p_Param = val
    Dim pipe As CPipe
    
    For Each pipe In PipesProd
        pipe.Param = val
    Next pipe
    For Each pipe In PipesInj
        pipe.Param = val
    Next pipe
End Property
 
Public Property Get Param() As PARAMCALC
    Param = p_Param
End Property
Public Property Get Curve(Key As String) As TInterpolation
On Error Resume Next
    Dim exists As Boolean
    exists = Not IsEmpty(c_Curves.Item(Key))
    If exists Then
       Set Curve = c_Curves.Item(Key)
    Else
       Set Curve = New TInterpolation
       c_Curves.Add Curve, Key
    End If
End Property
Public Property Set Curve(Key As String, valNew As TInterpolation)
 On Error Resume Next
    Dim exists As Boolean
    exists = Not IsEmpty(c_Curves.Item(Key))
    If exists Then
       c_Curves(Key) = valNew
    Else
       c_Curves.Add valNew, Key
    End If
End Property
Public Property Get AmbientForm() As CAmbientFormation
    Set AmbientForm = p_AmbientForm
End Property
Public Property Set AmbientForm(ByVal vNewValue As CAmbientFormation)
    Dim pipe As CPipe
    Set p_AmbientForm = vNewValue
    For Each pipe In PipesProd
        Set pipe.AmbientForm = p_AmbientForm
    Next pipe
    For Each pipe In PipesInj
        Set pipe.AmbientForm = p_AmbientForm
    Next pipe
End Property
'===================================================================
'
'===================================================================
Private Sub Class_Initialize()
    With p_Param
        .correlation = AnsariCor
        .FlowDirection = FlowAgainstCoord
        .tempMethod = AmbientTemp
    End With
    p_PTcas.T_C = 30
'    Param = p_Param    ' здесь распространим все настройки на трубы
End Sub
' метод инициализации газлифтной скважины
' должен уметь задавать все трубы по скважине из исходных данных по траектории
'
'
Public Sub InitWell(ByVal Hperf_m As Double, ByVal Htub_m As Double, ByVal Udl_m As Double, _
                    ByVal dCas_mm As Double, ByVal dTub_mm As Double, ByVal Tbh_C As Double, _
                    ByVal Twh_C As Double)
' метод для инициализации скважины простыми числами
On Error GoTo err1:
   Dim errMsg As String
   
   ' задаем траекторию свола скважины, на основе которого потом будет задано все остальное
   Dim tr As New CTrajectory
   Dim HabsCurve_m As New TInterpolation  ' инклинометрия - две точки
   HabsCurve_m.AddPoint 0, 0
   HabsCurve_m.AddPoint Hperf_m, Hperf_m - Udl_m
   
   Dim DcasCurve_mm As New TInterpolation  ' casing diameter
   DcasCurve_mm.AddPoint 0, dCas_mm
   DcasCurve_mm.AddPoint Hperf_m, dCas_mm  ' casing goes from top to bottom here
   
   Dim DtubCurve_mm As New TInterpolation  ' tubing diameter
   DtubCurve_mm.AddPoint 0, dTub_mm
   DtubCurve_mm.AddPoint Htub_m, dTub_mm  ' goes to tubing setting depth
   
   ' initialise trajectory (same as ESP well class)
   Call tr.InitTrajectoryHabs(HabsCurve_m, DcasCurve_mm, DtubCurve_mm, Hperf_m, Htub_m)
   Set Trajectory = tr
   Call InitWellFromTr
   
   ' save given temperature distribution
   Dim geoGrad As New TInterpolation
   geoGrad.AddPoint 0, Twh_C
   geoGrad.AddPoint Hperf_m, Tbh_C
   
   Dim ambTemp As New CAmbientFormation
   Set ambTemp.AmbTempCurve = geoGrad
   Set AmbientForm = ambTemp
   
   InitTempTr geoGrad
   Exit Sub
   
err1:
   errMsg = "CWell.InitWell: Ошибка простой инициализации скважины " & sDELIM & Err.Description
   RaiseEvent ReportProgress(errMsg)
   Err.Raise kErrInitCalc, Err.Source, errMsg
End Sub
Public Sub InitWellRangeAll(ByVal Incl_Hmes_m_ As Range, _
                           ByVal Incl_Hvert_m_ As Range, _
                           ByVal hmes_dcas_m_ As Range, _
                           ByVal dcas_arr_mm_ As Range, _
                           ByVal hmes_dtub_m_ As Range, _
                           ByVal dtub_arr_mm_ As Range, _
                           ByVal hmes_tamb_m_ As Range, _
                           ByVal tamb_C_ As Range, _
                           Optional ByVal GLV_Hmes_m_ As Range = Nothing, _
                           Optional ByVal GLV_dvalve_mm_ As Range = Nothing)
' метод для инициализации скважины из диапазонов измнения ключевых параметров
On Error GoTo err1:
   Dim HabsCurve_m As New TInterpolation
   Dim DcasCurve_mm As New TInterpolation
   Dim DtubCurve_mm As New TInterpolation
   Dim geoGrad As New TInterpolation
   Dim ambTemp As New CAmbientFormation
   Dim Hperf_m As Double, Htub_m As Double
   Dim errMsg As String
   
   Call HabsCurve_m.LoadFromVertRange(Incl_Hmes_m_, Incl_Hvert_m_)
   Call DcasCurve_mm.LoadFromVertRange(hmes_dcas_m_, dcas_arr_mm_)
   Call DtubCurve_mm.LoadFromVertRange(hmes_dtub_m_, dtub_arr_mm_)
   Call valves.LoadFromVertRange(GLV_Hmes_m_, GLV_dvalve_mm_)
   Set valves.Fluid = Fluid
  
   Hperf_m = DcasCurve_mm.maxx
   Htub_m = DtubCurve_mm.maxx
   
   Call Trajectory.InitTrajectoryHabs(HabsCurve_m, DcasCurve_mm, DtubCurve_mm, Hperf_m, Htub_m, valves)
   Call InitWellFromTr
   
   Call geoGrad.LoadFromVertRange(hmes_tamb_m_, tamb_C_)
   Set ambTemp.AmbTempCurve = geoGrad
   
   Set AmbientForm = ambTemp
   
   InitTempTr geoGrad
   Exit Sub
err1:
   errMsg = "CWell.InitWellRangeAll: Ошибка простой инициализации скважины " & sDELIM & Err.Description
   RaiseEvent ReportProgress(errMsg)
   Err.Raise kErrInitCalc, Err.Source, errMsg
End Sub
Private Sub InitWellFromTr()
    Dim i As Integer, j As Integer
    Dim segmUp_m As Double
    Dim segmDown_m As Double
    Dim pipe As CPipe
    ' need to fill up individual pipe segments in well (production line)
    ' 1 segment from bottom hole to Htub  (lowest)
    ' next - from Htub to valve(0) depth - and so on
    ' at this point valve depth values must be ok (sorted and non zero)
        
    ' set up pipe segments for injection line
    ' 1 segment from lowest valve to upper
    ' not interested for now what happens bellow lowest valve
    
    ' set up csing flow below tubing depth
    segmDown_m = Trajectory.Hperf_m
    segmUp_m = Trajectory.Htubing_m
    If segmDown_m > segmUp_m Then
        ' first segment from bottom to tubing depth exist
        ' hae to be created here
        Set pipe = New CPipe  ' creating new object
        Set pipe.Fluid = Fluid
        Call pipe.InitPipeConstrTr(Trajectory, segmUp_m, segmDown_m, pipeCasing)
        PipesProd.Add pipe    ' save it to collection
        segmDown_m = segmUp_m
        i = valves.Count
        segmUp_m = valves.Hmes_m(i) ' will work if there is no valves set
        If i = 0 Then i = 1 ' if no valve - set to 1 to ensure next loop one iteration
    End If
    
    For j = i To 0 Step -1
        ' should be ok for numvalves = 0
        Set pipe = New CPipe  ' creating new object
        Set pipe.Fluid = Fluid
        Call pipe.InitPipeConstrTr(Trajectory, segmUp_m, segmDown_m, pipeTubing)
        If j < i Then
            Set pipe.GLVin = valves.valves(j + 1)
        End If
        PipesProd.Add pipe    ' save it to collection
        
        segmDown_m = segmUp_m
        segmUp_m = valves.Hmes_m(j - 1)
        If segmUp_m < segmDown_m Then
            ' if exist segment
            Set pipe = New CPipe  ' creating new object
            Set pipe.Fluid = Fluid
            Call pipe.InitPipeConstrTr(Trajectory, segmUp_m, segmDown_m, pipeAnnulus)
            Set pipe.GLVin = valves.valves(j)
            PipesInj.Add pipe
        End If
        
        
    Next j
'   Hvd_m = Trajectory.Htubing_m ' определим глубину спуска установки
'   p_Hspvert_m = Trajectory.HabsZ_m(p_Hsp_m)    ' в том числе по вертикали
'   Call p_Pipe_HspHvd.InitPipeConstrTr(Trajectory, Trajectory.Htubing_m, Trajectory.Hperf_m, 1)
    Choke.Dup_m = 0.06
    Choke.Ddown_m = 0.06
    For Each pipe In PipesProd
        Set pipe.AmbientForm = AmbientForm
    Next pipe
    For Each pipe In PipesInj
        Set pipe.AmbientForm = AmbientForm
    Next pipe
    
    Hvd_m = Trajectory.Hperf_m
  ' переводим в состояние "целостность нарушена"
'   p_Calculated = False
End Sub
 Public Sub InitTempTr(geoGrad As TInterpolation)
' процедура для инициализации температуры в скважине, для линейнго расчета
' при линейном расчете предполагается,
' что температура меняется линейно относительно глубины скважины
'
   Dim TempGradVert As Double
   Dim pipe As CPipe
   p_PTwf.T_C = geoGrad.GetPoint(geoGrad.maxx)
   p_PTbuf.T_C = geoGrad.GetPoint(geoGrad.minx)
   
   TempGradVert = (p_PTwf.T_C - p_PTbuf.T_C) / Hvd_m
      
   For Each pipe In PipesProd
       pipe.dTdLinit = TempGradVert
   Next pipe
   For Each pipe In PipesInj
       pipe.dTdLinit = TempGradVert
   Next pipe
   
   TempCorrelation = GeoGradTemp
End Sub
 
Public Sub InitTempLinear(ByVal Tbhinit_C As Double, ByVal Twhinit_C As Double)
' процедура для инициализации температуры в скважине, для линейнго расчета
   Dim TempGrad As Double
   Dim i As Integer
   Dim tempDown_C As Double
   Dim tempUp_C As Double
   Dim pipe As CPipe
   Dim HvalveVert0_m  As Double
   
   TempGrad = (Tbhinit_C - Twhinit_C) / Hvd_m
   p_PTwf.T_C = Tbhinit_C
   p_PTbuf.T_C = Twhinit_C
   
   tempUp_C = Tbhinit_C
   For i = 1 To PipesProd.Count
        Set pipe = PipesProd(i)
        tempDown_C = tempUp_C
        tempUp_C = tempDown_C - TempGrad * pipe.LengthMes_m
        pipe.InitTlinear tempUp_C, tempDown_C
   Next i
   
   HvalveVert0_m = Trajectory.HabsZ_m(valves.Hmes_lowest_m)
   tempUp_C = AmbientForm.AmbTemp_С(HvalveVert0_m)
   For i = 1 To PipesInj.Count
        Set pipe = PipesInj(i)
        tempDown_C = tempUp_C
        tempUp_C = tempDown_C - TempGrad * pipe.LengthMes_m
        pipe.InitTlinear tempUp_C, tempDown_C
   Next i
   
   TempCorrelation = StartEndTemp
   
End Sub
Public Function Calc_Plin_Pwf_atma(PTwf As PTtype, _
                                    Optional Pcas_inj_atma As Double = 1, _
                                    Optional CalcChoke As Boolean = True, _
                                    Optional saveCurve As CALC_RESULTS = noCurves) As Double
' @brief расчет давления на устье через забойное давление (снизу -> вверх)
' @param Pwf - исходное забойное давление и температура
' @CalcCasing - флаг показывает надо ли считать ветку распределения давления по забтрубу - динамический уровень и затрубное давление
' @CalcChoke - показывает надо ли считать штуцер
' @saveCurve - показывает насколько детально надо сохранять результаты расчета
Dim Tintake_esp_C As Double
Dim PT_temp As PTtype
Dim PTcas_temp As PTtype
Dim Tan_C As Double
Dim pcur As TInterpolation
Dim i As Integer
Dim pipe As CPipe
Dim Qgfree_tot_scm3day As Double
Qgfree_tot_scm3day = 0
    
On Error GoTo err1:
    ' 1. Start calculation from Pwf, Tbh
    p_PTwf = PTwf
    PT_temp = PTwf
    PTcas_temp = SetPT(Pcas_inj_atma, p_PTcas.T_C)
    
    ' 2. calculate pressure distribution in annulus
    
    For i = PipesInj.Count To 1 Step -1
        Set pipe = PipesInj(i)
        pipe.Param = ParamCalcFromTop(Gas, TempCorrelation)
        PTcas_temp = pipe.Calc_dPipe(PTcas_temp, saveCurve)
        If Not pipe.GLVin Is Nothing Then
            ' if  there is a valve - save PT in casing at valve intake
            pipe.GLVin.Pin_atma = PTcas_temp.P_atma
            pipe.GLVin.Tin_C = PTcas_temp.T_C
        End If
    Next i
    
    ' 3. calc tubing pressure
    For i = 1 To PipesProd.Count
        ' first segment - from bottom to tubing depth
        Set pipe = PipesProd(i)
        ' check if there is a valve on pipe bottom
        If Not pipe.GLVin Is Nothing Then
            ' if valve set up then estimate gas coming through valve
            pipe.GLVin.Pout_atma = PT_temp.P_atma   ' pressure at pipe bottom from previos step
            pipe.GLVin.Tout_C = PT_temp.T_C
            If pipe.Fluid Is Fluid Then
                Set pipe.Fluid = Fluid.Clone
            End If
            ' adding additional gas coming trough valve
            Qgfree_tot_scm3day = Qgfree_tot_scm3day + pipe.GLVin.Qgas_scm3day(-1, -1, -1)
            pipe.Fluid.Qgfree_scm3day = Qgfree_tot_scm3day
        End If
        pipe.Param = ParamCalcFromBottom(HFlowCorrelation, TempCorrelation)
        PT_temp = pipe.Calc_dPipe(PT_temp, saveCurve)
    Next i
    p_PTbuf = PT_temp
    ' 4. Расчет линейного давления по штуцеру
    If Choke.Dchoke_m > 0 And CalcChoke Then     ' пока отключено
        p_PTlin = Choke.Calc_Choke_Plin(p_PTbuf)
        If p_PTlin.P_atma < 0 Then
            p_PTlin.P_atma = 1
        End If
    Else
        p_PTlin = p_PTbuf
    End If
    Calc_Plin_Pwf_atma = PT_temp.P_atma
    
    If saveCurve > 0 Then
        For i = 1 To PipesProd.Count
            Call Curve(str_PtubHmes_curve).AddPointsCurve(PipesProd(i).PCurve)
            Call Curve(str_TtubHmes_curve).AddPointsCurve(PipesProd(i).TCurve)
            Call Curve(str_TambHmes_curve).AddPointsCurve(PipesProd(i).TambCurve)
            If saveCurve > 1 Then
                Call Curve(str_HlHmes_curve).AddPointsCurve(PipesProd(i).HlCurve)
                Curve(str_HlHmes_curve).yName = "Hl"
            End If
        Next i
        For i = 1 To PipesInj.Count
           Call Curve(str_PcasHmes_curve).AddPointsCurve(PipesInj(i).PCurve)
           Call Curve(str_TcasHmes_curve).AddPointsCurve(PipesInj(i).TCurve)
        Next i
        
        Curve(str_PtubHmes_curve).xName = "hmes ptub"
        Curve(str_PtubHmes_curve).yName = "Ptub"
        
        Curve(str_TtubHmes_curve).xName = "hmes Ttub"
        Curve(str_TtubHmes_curve).yName = "Ttub"
        
        Curve(str_TambHmes_curve).xName = "hmes Tamb"
        Curve(str_TambHmes_curve).yName = "Tamb"
        
        Curve(str_PcasHmes_curve).xName = "hmes pcas"
        Curve(str_PcasHmes_curve).yName = "pcas"
        
        Curve(str_TcasHmes_curve).xName = "hmes pcas"
        Curve(str_TcasHmes_curve).yName = "Tcas"
    End If
    Exit Function
err1:
    RaiseEvent ReportProgress("CWellGL.Calc_Plin_Pwf_atma: ошибка какая то")
    Err.Raise Err.Number, Err.Source, Err.Description
End Function
Public Function Calc_Pwf_Plin_atma(ByVal Plin_atma As Double, _
                                    ByVal Tbh_C As Double, _
                                    Optional Pcas_inj_atma As Double = 1, _
                                    Optional saveCurve As CALC_RESULTS = noCurves)
' @brief Calc_Pwf_Plin_atma расчет забойного давления по известному давлению в линии и конструкции скважины дихотомией
' @param Plin_atma - давление в линии
' @param Hd - динамический уровень
' @param Tbh_C - температура на забое скважины
' @return Подсчитанное для заданного линейного давление
On Error GoTo err1:
    Dim Pwf1 As Double      ' первое приближение
    Dim PwfUp As Double, PwfDown As Double
    Dim PlinUp As Double, PlinDown As Double
    Dim Plin0 As Double, Plin1 As Double
    Dim found_solution As Boolean
    Dim i As Integer
    found_solution = False
    i = 0
    Pwf1 = 60
    PwfUp = -1
    PwfDown = -1
    Do
        ' ищем  приближения
        Plin1 = Calc_Plin_Pwf_atma(SetPT(Pwf1, Tbh_C), Pcas_inj_atma, saveCurve:=noCurves)
        If (Abs(Plin1 - Plin_atma) < const_well_P_tolerance) Then
             found_solution = True
             p_PTwf.P_atma = Pwf1
             p_PTwf.T_C = Tbh_C
        End If
        If Not found_solution Then
          If Plin1 > Plin_atma Then
              PwfUp = Pwf1
              PlinUp = Plin1
              If PwfDown < 0 Then
                  Pwf1 = PwfUp / 2
              Else
                  Pwf1 = PwfDown + (PwfUp - PwfDown) * (Plin_atma - PlinDown) / (PlinUp - PlinDown)
              End If
          Else
              PwfDown = Pwf1
              PlinDown = Plin1
              If PwfUp < 0 Then
                  Pwf1 = Pwf1 * 2
              Else
                  Pwf1 = (PwfUp + PwfDown) / 2
              End If
          End If
        End If
        i = i + 1
    Loop While Not found_solution And i < 20
    p_PTlin = SetPT(Calc_Plin_Pwf_atma(p_PTwf, Pcas_inj_atma, saveCurve:=saveCurve), Tbuf_C)
    
    If Abs(Pline_atma - Plin_atma) > const_well_P_tolerance Then
       addLogMsg "Calc_Pwf_Plin_atma: ошибка расчета забойного давления больше " & const_well_P_tolerance & ". Равна = " & Abs(Me.Pline_atma - Plin_atma)
    End If
    Calc_Pwf_Plin_atma = p_PTwf.P_atma
   ' переводим в состояние "целостность нарушена"
   ' p_Calculated = False
    Exit Function
err1:
    ' тут надо среагировать на ошибку
    Err.Raise 1
 End Function
