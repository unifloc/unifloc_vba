'=======================================================================================
'Unifloc 7.9  Vulpes zerda                                           khabibullin.ra@gubkin.ru
'Petroleum engineering calculations modules (macroses)
'2000 - 2019
'
'=======================================================================================
'
' класс для расчета характеристик штуцера
' потребовался для организации корректного учета "крутой" характеристики штуцера
' особенность штуцера - то что при достижении критического потока через штуцер (движения потока со скоростью звука)
' давление за штуцером в определенном диапазоне перестает оказывать влияние на поток - то есть заднному дебиту
' и давление перед штуцером может соответсвовать несколько значений  давлений после (линейных)
'==============  Cchoke  ==============
' класс для расчета многофазного потока в локальном сопротивлении - штуцере
Option Explicit
Option Base 0
' геометрические параметры штуцера
Public Dup_m As Double
Public Ddown_m As Double
Public Dchoke_m As Double
Public tchoke_C As Double
' флюид протекающий через штуцер
Public fluid As New CPVT
Private p_c_calibration As Double
Private p_c_degrad_choke As Double                             ' choke correction factor
' кривые для текущих характеристик штуцера
' строятся для текущих параметров штуцера
Public curve As New CCurves
Private p_Qlmax_m3day As Double  ' максимальный дебит для заданных давлений на входе и на выходе через штуцер
Private p_TchokeThroat_C As Double ' температура в штуцере
Private p_TchokeAv_C
' набор параметров для которых был проведен последний расчет
'Private p_pbuf_atma As Double
'Private p_plin_atma As Double
' internal vars
' параметры модели штуцера
Private K As Double '  = 0.826,'K - Discharge coefficient (optional, default  is 0.826)
Private F As Double ' = 1.25,'F - Ratio of gas spec. heat capacity at constant pressure to that at constant volume (optional, default  is 1.4)
Private C_vw As Double ' = 4176'Cvw - water specific heat capacity (J/kg K)(optional, default  is 4176)
Private a_u As Double 'upstream area
Private a_c As Double 'choke throat area
Private a_r As Double 'area ratio
Private P_r As Double  ' critical pressure for output
Private v_s As Double  ' sonic velosity
Private q_m As Double  ' mass rate
Private p_dcr As Double ' recovered downstream pressure at critical pressure ratio
Private Sub Class_Initialize()
 K = 0.826
 F = 1.25
 C_vw = 4176
 p_c_calibration = 1
 p_c_degrad_choke = 0
 
 'параметры по умолчанию
 Dup_m = 0.1
 Ddown_m = 0.1
 Dchoke_m = 0.01
 tchoke_C = 30
End Sub
Public Property Get c_calibr_fr() As Double
    c_calibr_fr = p_c_calibration
End Property
Public Property Get c_degrad_fr() As Double
    c_degrad_fr = 1 - p_c_calibration
End Property
Public Property Let c_degrad_fr(val As Double)
    p_c_calibration = 1 - val
End Property
Public Property Let c_calibr_fr(val As Double)
    p_c_calibration = val
End Property
Public Property Get fw_fr() As Double
    fw_fr = fluid.fw_fr ' fw_perc / 100
End Property
Public Property Get Qlmax_m3day()
    Qlmax_m3day = p_Qlmax_m3day
End Property
Public Property Get TchokeThroat_C()
    TchokeThroat_C = p_TchokeThroat_C
End Property
Public Property Get TchokeAv_C()
    TchokeAv_C = p_TchokeAv_C
End Property
Public Property Get PratioCrit()
    PratioCrit = P_r
End Property
Public Property Get VelSonic_msec()
    VelSonic_msec = v_s
End Property
Public Property Get Qm_kgsec()
    Qm_kgsec = q_m
End Property
Public Property Get PdownCrit_atma()
    PdownCrit_atma = p_dcr
End Property
' калибровка модели штуцера по данным измерений
Public Function calc_choke_calibration( _
            ByVal p_intake_atma As Double, _
            ByVal p_out_atma As Double, _
            t_c As Double) As Double
' p_intake_atma   - давление на входе
' p_out_atma      - давление на выходе
' t_C             - температура потока
' дебит и обводненность определяются свойствами потока
' результат коэффициент калибровки обеспечивающий согласование
' давлений и дебитов (если можно определить)
' рассчитывается напрямую как отношение расчетного дебита к фактическому
    Dim qtest As Double
    tchoke_C = t_c
    If (p_intake_atma > p_out_atma) And Dchoke_m > 0 Then
        qtest = choke_liquid_rate(p_intake_atma, p_out_atma, tchoke_C)
        p_c_calibration = fluid.qliq_sm3day / qtest
    Else
        p_c_calibration = 1
    End If
End Function
'Function calculates upstream node pressure for choke
Public Function calc_choke_pbuf(PTline As PTtype) As PTtype
'Arguments
'PTline_atma - line pressure (downstream) ( (atma)) and temperature ( (C))
'Return upstream pressure and temperature
    
    Dim EPS As Double
    Dim eps_q As Double
    EPS = 0.001
    eps_q = 0.1
On Error GoTo ErrorHandler
    If (Dchoke_m > Dup_m - 2 * EPS) Or (Dchoke_m < 0.001) Or (fluid.qliq_sm3day < eps_q) Then
        calc_choke_pbuf = PTline
        Exit Function
    End If
    calc_choke_pbuf = calc_choke_P(PTline, 0)
    Exit Function
ErrorHandler:
    calc_choke_pbuf = SetPT(0, 0)
    addLogMsg ("Cchoke.calc_choke_pbuf: error. set calc_choke_pbuf = 0 : Pline_atma  = " _
                 & PTline.p_atma & "  TChoke_C = " & PTline.t_c)
End Function
'Function calculates downstream node pressure for choke
Public Function calc_choke_plin(PTbuf As PTtype) As PTtype
'PTbuf - well head pressure (upstream) ( (atma)) and temperature ( (C))
'Return downstream pressure and temperature
    
    ' если расчет не возможен (решение не существует), возвращает 0, так как
    ' потенциально может возникнуть ситуация, что при заданном дебите, диаметре штуцера и
    ' получившемся давлении на входе - решения по давлению на выходе не будет существовать
    'PTbuf - well head pressure and  temperature Upstream
    
    Dim EPS As Double
    Dim eps_q As Double
    EPS = 0.001
    eps_q = 0.1
    If (Dchoke_m > Dup_m - 2 * EPS) Or (Dchoke_m < 0.001) Or (fluid.qliq_sm3day < eps_q) Then
        calc_choke_plin = PTbuf
        Exit Function
    End If
    ' Если при расчете линейного давления возникла ошибка, то скорее всего для дебита нет соотвествия для линейного давления
On Error GoTo ErrorHandler
    calc_choke_plin = calc_choke_P(PTbuf, calc_p_down:=1)
    Exit Function
ErrorHandler:
    calc_choke_plin = SetPT(0, 0)
    addLogMsg ("Cchoke.calc_choke_plin_atma: error. set calc_choke_plin_atma = 0 : pbuf_atma  = " _
                 & PTbuf.p_atma & "  TChoke_C = " & PTbuf.t_c)
End Function
Private Function wi_calc(P_r As Double, p_u As Double, t_u As Double, rho_gu As Double, f_o As Double, f_g As Double, f_w As Double, _
                           Alpha As Double, Optional ByRef wi_deriv As Double, Optional ByRef N As Double)
    'Auxilary properties
    Dim t_c As Double
    Dim p_av As Double
    Dim t_av As Double
    'PVT properties
    Dim rs_m3m3 As Double
    Dim bo_m3m3 As Double
    Dim Z As Double
    Dim bg_m3m3 As Double
    Dim bw_m3m3 As Double
    Dim c_vo As Double
    Dim c_vg As Double
    Dim Lambda As Double
    Dim betta As Double
    Dim GAMMA As Double
    Dim Delta As Double
    Dim f_pr As Double
    Dim void As Double
    Z = 1
    'Calculate specific heat capacities
    c_vo = C_vw * (0.238 + 0.302 / fluid.gamma_o + (0.0064 + 0.003 / fluid.gamma_o) * t_u)
    c_vg = Z * const_r / (fluid.m_g_kgmol * (F - 1))
    'Calculate polytropic exponent
    N = (f_g * F * c_vg + f_o * c_vo + f_w * C_vw) / (f_g * c_vg + f_o * c_vo + f_w * C_vw)
    'Calculate choke throat temperature
    t_c = (t_u + 273) * P_r ^ (1 - 1 / N) - 273
    p_TchokeThroat_C = t_c
    'Calculate average pressure and temperature
    p_av = (p_u + P_r * p_u) / 2
    t_av = (t_u + t_c) / 2
    p_TchokeAv_C = t_av
    Call fluid.calc_PVT(p_av, t_av)
    rs_m3m3 = MinReal(fluid.rp_m3m3, rs_m3m3)
    'Recalculate specific heat capacities
    c_vo = C_vw * (0.238 + 0.302 / fluid.gamma_o + (0.0064 + 0.003 / fluid.gamma_o) * t_av)
    c_vg = Z * const_r / (fluid.m_g_kgmol * (F - 1))
    'Recalculate polytropic exponent
    N = (f_g * F * c_vg + f_o * c_vo + f_w * C_vw) / (f_g * c_vg + f_o * c_vo + f_w * C_vw)
    If P_r = 0 Then
      P_r = 0.000001
    End If
    'Calculate auxilary values
    Lambda = (f_g + (f_g * c_vg + f_o * c_vo + f_w * C_vw) / (c_vg * (F - 1)))
    betta = f_g / N * P_r ^ (-1 - 1 / N)
    GAMMA = f_g + Alpha
    Delta = f_g * P_r ^ (-1 / N) + Alpha
    'Calculate isentropic mass flow rate (kg/day)
    P_r = MinReal(P_r, 1)
    wi_calc = 27500000# * a_c * (2 * p_u * rho_gu / Delta ^ 2 * (Lambda * (1 - P_r ^ (1 - 1 / N)) + Alpha * (1 - P_r)) _
                         / (1 - (a_r * GAMMA / Delta) ^ 2)) ^ (1 / 2)
    'Calculate rate derivative
    wi_deriv = (2 * Lambda * (1 - P_r ^ (1 - 1 / N)) + 2 * Alpha * (1 - P_r)) * betta - _
        Delta * (1 - (a_r * GAMMA / Delta) ^ 2) * (Lambda * (1 - 1 / N) * P_r ^ (-1 / N) + Alpha)
End Function
Public Function calc_choke_MaxQliq_m3day(ByVal p_sn As Double, _
                               ByVal t_u As Double, Optional calc_p_down As Integer = 0) As Double
    Dim Max_Ql As Double
    Dim i As Integer
    
    If (calc_p_down = 0) Then
        i = -1
        Do
            i = i + 1
        Loop Until (fluid.qliq_sm3day < 10 ^ i)
        
        If (fluid.qliq_sm3day < 0.5 * 10 ^ i) Then
            Max_Ql = 0.5 * 10 ^ i
        Else
            Max_Ql = 10 ^ i
        End If
        Max_Ql = MaxReal(50, Max_Ql)
        Max_Ql = MinReal(1500, Max_Ql)
    End If
    If (calc_p_down = 1) Then
        Max_Ql = choke_liquid_rate(p_sn, 0, t_u)
    End If
    calc_choke_MaxQliq_m3day = Max_Ql
End Function
Public Function calc_choke_MaxRp_m3m3(ByVal p_sn As Double, _
                               ByVal t_u As Double, Optional calc_p_down As Integer = 0) As Variant
' Функция находит значение максимального газового фактора при даном дебите нефти и данном давлении на входе,
' при котором давление на выходе становится нулевым
       
    Dim Max_Rp As Double
    Dim i As Integer
    Dim A As Double ' нижняя граница отрезка, в которой находится значение максимального газового фактора
    Dim B As Double ' вверхняя граница отрезка, в которой находится значение максимального газового фактора
    Dim P_d As Double
    Dim EPS As Double
    EPS = p_sn * 0.001
    Dim counter As Integer
    counter = 0
    Dim max_iters As Integer
    max_iters = 20
        
    If (calc_p_down = 0) Then
        i = -1
        Do
            i = i + 1
        Loop Until (fluid.rp_m3m3 < 10 ^ i)
        
        If (fluid.rp_m3m3 < 0.5 * 10 ^ i) Then
            Max_Rp = 0.5 * 10 ^ i
        Else
            Max_Rp = 10 ^ i
        End If
        Max_Rp = MaxReal(50, Max_Rp)
        Max_Rp = MinReal(800, Max_Rp)
    End If
    
    If (calc_p_down = 1) Then
        P_d = calc_choke_P(SetPT(p_sn, t_u), calc_p_down).p_atma
                                            
        If P_d < 0 Then
            calc_choke_MaxRp_m3m3 = "Невозможен"
        Else
            i = 1
            Do
                i = 2 * i
                B = fluid.rp_m3m3 * i
                P_d = calc_choke_P(SetPT(p_sn, t_u), calc_p_down).p_atma
            Loop Until P_d < 0
            A = i * fluid.rp_m3m3 / 2
            
            Do
                counter = counter + 1
                Max_Rp = (A + B) / 2
                P_d = calc_choke_P(SetPT(p_sn, t_u), calc_p_down).p_atma
                If P_d > 0 Then
                    A = Max_Rp
                Else
                    B = Max_Rp
                End If
            Loop Until Abs(P_d) < EPS Or counter > max_iters
        End If
    End If
    calc_choke_MaxRp_m3m3 = Max_Rp
End Function
Public Function calc_choke_P(pt As PTtype, Optional calc_p_down As Integer = 0) As PTtype
    'Function calculates end node pressure for choke (weather upstream or downstream)
    Dim p_sn As Double, t_u As Double
    Dim P_en As Double
    Dim counter As Double
    Dim EPS As Double
    Const max_iters As Integer = 25
    Dim void As Double
    Dim q_l As Double
    Dim P_en_min As Double
    Dim P_en_max As Double
    Dim i As Integer
On Error GoTo err1:
    p_sn = pt.p_atma
    t_u = pt.t_c
    counter = 0
    EPS = fluid.qliq_sm3day * 0.001 'set precision equal to 0.1%
    If (calc_p_down = 0) Then 'Calculate upstream pressure given downstream
        'Solve for upstream pressure
        i = 1
        counter = 0
        Do
            ' ищем давление на входе заведомо превышающее необходимое для обеспечения заданного потока
            counter = counter + 1
            i = 2 * i
            P_en_max = p_sn * i
            q_l = choke_liquid_rate(P_en_max, p_sn, t_u)
        Loop Until q_l > fluid.qliq_sm3day Or counter > max_iters
        
        If q_l <= fluid.qliq_sm3day Then   ' значит поиск дебита не увенчался успехом
             addLogMsg "calc_choke_P(calc_p_down = 0): no solution found for rate = " & Format(fluid.qliq_sm3day, "####0.00")
        End If
        
        ' определим нижнюю границу поиска давления
        P_en_min = i * p_sn / 2
        counter = 0
        Do
            ' ищем точное значение давления на входе обеспечивающего дебит
            ' потенциально можно ускорить если не делить отрезок пополам а использовать линейное приближение (характеристика должна быть довольно гладкой)
            counter = counter + 1
            P_en = (P_en_min + P_en_max) / 2
            q_l = choke_liquid_rate(P_en, p_sn, t_u)
            If q_l > fluid.qliq_sm3day Then
                P_en_max = P_en
            Else
                P_en_min = P_en
            End If
        Loop Until Abs(fluid.qliq_sm3day - q_l) < EPS Or counter > max_iters
        If counter > max_iters Then   ' значит поиск дебита не увенчался успехом
            addLogMsg "calc_choke_P(calc_p_down = 0): number of iterations too much, no solution found for rate = " & Format(fluid.qliq_sm3day, "####0.00")
        End If
    End If
    Dim p_cr As Double
    If (calc_p_down = 1) Then 'Calculate downstream pressure given upstream
        'Solve for upstream pressure
        'Calculate critical oil rate
        q_l = choke_liquid_rate(p_sn, 0, t_u)
        If isGreater(fluid.qliq_sm3day, q_l) Then 'Given oil rate can't be archieved
            P_en = -1
        Else
            If isEqual(q_l, fluid.qliq_sm3day) Then
                calc_choke_P = SetPT(0, 0)
                P_en = 0
            Else
                i = 1
                counter = 0
                Do
                    i = 2 * i
                    P_en_min = p_sn / i
                    q_l = choke_liquid_rate(p_sn, P_en_min, t_u)
                Loop Until q_l > fluid.qliq_sm3day Or counter > max_iters
                
                If q_l <= fluid.qliq_sm3day Then   ' значит поиск дебита не увенчался успехом
                    addLogMsg "calc_choke_P(calc_p_down = 1):no solution found for rate = " & Format(fluid.qliq_sm3day, "####0.00")
                End If
                P_en_max = 2 * p_sn / i
                counter = 0
                Do
                    counter = counter + 1
                    P_en = (P_en_min + P_en_max) / 2
                    q_l = choke_liquid_rate(p_sn, P_en, t_u)
                    If q_l > fluid.qliq_sm3day Then
                        P_en_min = P_en
                    Else
                        P_en_max = P_en
                    End If
                Loop Until Abs(fluid.qliq_sm3day - q_l) < EPS Or counter > max_iters
                If counter > max_iters Then   ' значит поиск дебита не увенчался успехом
                   addLogMsg "calc_choke_P(calc_p_down = 1): number of iterations exeeded, no solution found for rate = " & Format(fluid.qliq_sm3day, "####0.00")
                End If
            End If
        End If
    End If
    calc_choke_P.p_atma = P_en
    calc_choke_P.t_c = t_u    ' пока предполагаем для штуцера температура не меняется
    
    Exit Function
err1:
    Dim strError As String
    strError = "CChoke.calc_choke_P: error"
    Call addLogMsg(strError)
    Err.Raise Err.Number, Err.Source, strError & Err.Description
End Function
Private Sub init_params()
    a_u = const_Pi * Dup_m ^ 2 / 4      'upstream area
    a_c = const_Pi * Dchoke_m ^ 2 / 4   'choke throat area
    a_r = a_c / a_u                     'area ratio
End Sub
Public Function choke_liquid_rate(ByVal p_u As Double, ByVal P_d As Double, ByVal t_u As Double) As Double
    'Function calculates oil flow rate through choke given downstream and upstream pressures using Perkins correlation
    'Return ((sm3/day))
    'Arguments
    'p_u - Upstream pressure ( (atma))
    'p_d - Downstream pressure ( (atma))
    'T_u - Upstream temperature ( (C))
    
    'PVT properties
    Dim r_su As Double
    Dim b_ou As Double
    Dim Z_u As Double
    Dim b_gu As Double
    Dim b_wu As Double
    Dim void As Double
    Dim m_s As Double
    Dim f_o As Double
    Dim f_w As Double
    Dim f_g As Double
    Dim rho_ou As Double
    Dim rho_wu As Double
    Dim rho_gu As Double
    'Dim v_gu As Double
    Dim Alpha As Double
    Dim p_co As Double
    Dim min_p_d As Double
    Dim counter As Double
    Dim w_i As Double
    Dim N As Double
    Dim wi_der1 As Double
    Dim wi_der2 As Double
    Dim wi_2_deriv As Double
    Dim d_pr As Double
    Const max_iters As Integer = 10
    Dim EPS As Double
    Dim p_ri As Double
    Dim v_si As Double
    Dim p_dcr As Double
    Dim p_c As Double
    Dim p_ra As Double
    Dim W As Double
    Const p_r_inc As Double = 0.001
On Error GoTo err1:
    ' calc areas
    Call init_params
    ' calc PVT with upstream pressure and temperature
    Call fluid.calc_PVT(p_u, t_u)
    
    ' get nesesary PVT props at specific conditions to internal variables
    r_su = fluid.rs_m3m3   ' gas solution ration
    b_ou = fluid.bo_m3m3   ' oil FVF
    Z_u = fluid.Z          ' z factor
    b_gu = fluid.bg_m3m3   ' gas FVF
    b_wu = fluid.bw_m3m3   ' water FVF
    
    'Calculate mass fractions of flowing phases
    ' correction for gas solution ratio (obsolete?)
    r_su = MinReal(fluid.rp_m3m3, r_su)
    ' mass for 1 liquid rate at surface
    m_s = (1 - fw_fr) * (fluid.rho_oil_sckgm3 + fluid.rp_m3m3 * fluid.rho_gas_sckgm3) + fw_fr * fluid.rho_wat_sckgm3
    ' mass oil fraction at specific condition (acounts for gas in oil)
    f_o = (1 - fw_fr) * (fluid.rho_oil_sckgm3 + r_su * fluid.rho_gas_sckgm3) / m_s
    ' mass gas fraction
    f_g = (1 - fw_fr) * (fluid.rp_m3m3 - r_su) * fluid.rho_gas_sckgm3 / m_s
    ' mass water fraction
    f_w = (fw_fr) * fluid.rho_wat_sckgm3 / m_s
    'Densities at upstream conditions
    'Gas specific volume
    rho_ou = (fluid.rho_oil_sckgm3 + r_su * fluid.rho_gas_sckgm3) / b_ou
    rho_wu = fluid.rho_wat_sckgm3 / b_wu
    rho_gu = fluid.rho_gas_sckgm3 / b_gu
    'v_gu = 1 / rho_gu
    Alpha = rho_gu * (f_o / rho_ou + f_w / rho_wu)
    'Calculate trial output choke pressure
    p_co = p_u - (p_u - P_d) / (1 - (Dchoke_m / Ddown_m) ^ 1.85)
    'Solve for critical pressure ratio
    counter = 0
    If (f_g > 0.0000000000001) Then 'free gas present
        'Calculate specific value of error at p_ri = 0.99
        w_i = wi_calc(0.99, p_u, t_u, rho_gu, f_o, f_g, f_w, Alpha, EPS, N)
        EPS = Abs(EPS * 0.01)
        'Assume pressure ratio
        p_ri = 0.5
        Do
            'Evaluate derivative for two points to find second derivative for Newton-Raphson iteration
            w_i = wi_calc(p_ri, p_u, t_u, rho_gu, f_o, f_g, f_w, Alpha, wi_der1, N)
            w_i = wi_calc(p_ri + p_r_inc, p_u, t_u, rho_gu, f_o, f_g, f_w, Alpha, wi_der2, N)
            wi_2_deriv = (wi_der2 - wi_der1) / p_r_inc
            d_pr = -wi_der1 / wi_2_deriv
            'limit p_ri increment to prevent crossing [0,1] boundary
            d_pr = MaxReal(-p_ri / 2, MinReal(d_pr, (1 - p_ri) / 2))
            p_ri = p_ri + d_pr
            counter = counter + 1
        Loop Until (Abs(wi_der1) < EPS) Or (counter > max_iters)
        If counter > max_iters Then
           addLogMsg ("Cchoke.choke_liquid_rate: iterations not converged. iterations number  = " & counter & "  error wi_der1 " & wi_der1 & " < " & EPS)
        End If
    
        'Calculate sonic velocity of multiphase mixture (used for output)
        v_si = w_i / a_c * (f_o / rho_ou + f_w / rho_wu + f_g / rho_gu * p_ri ^ (-1 / N)) / 86400
    Else 'liquid flow
        p_ri = 0
        v_si = 5000
    End If
    
    ' calc PVT with upstream pressure and temperature
    Call fluid.calc_PVT(p_u, t_u)
    
    p_Qlmax_m3day = K * w_i * f_o / fluid.rho_oil_sckgm3 + K * w_i * f_w / fluid.rho_wat_sckgm3
    p_Qlmax_m3day = p_Qlmax_m3day * p_c_calibration
    
    'Calculate recovered downstream pressure at critical pressure ratio
    p_dcr = p_u * (p_ri * (1 - (Dchoke_m / Ddown_m) ^ 1.85) + (Dchoke_m / Ddown_m) ^ 1.85)
    'Compare trial pressure ratio with critical and assign actual pressure ratio
    'Auxilary properties
    p_c = p_ri * p_u
    p_ra = MaxReal(p_ri, p_co / p_u)
    w_i = wi_calc(p_ra, p_u, t_u, rho_gu, f_o, f_g, f_w, Alpha, wi_der1, N)
    'Calculate isentropic mass flow rate
    W = K * w_i * p_c_calibration
    ' calc PVT with upstream pressure and temperature
    Call fluid.calc_PVT(p_u, t_u)
    
    choke_liquid_rate = W * f_o / fluid.rho_oil_sckgm3 + W * f_w / fluid.rho_wat_sckgm3
    'Asign mass flow rate
    q_m = W / 86400 '/ c_m(Units)
    'Assign output critical pressure ratio (recovered critical pressure ratio)
    P_r = p_dcr / p_u
    'convert sonic velocity
    v_s = v_si '/ c_l(Units)
    Exit Function
err1:
    Dim strError As String
    strError = "CChoke.choke_liquid_rate: error"
    Call addLogMsg(strError)
    Err.Raise Err.Number, Err.Source, strError & Err.Description
End Function
Public Sub BuildCurves()
    'надо будет построить графики для текущих показателей
    curve("pbuf_vs_Ql_curve").ClearPoints
    curve("plin_vs_Ql_curve").ClearPoints
    curve("pbuf_vs_plin_curve").ClearPoints
    
    curve("plin_vs_Ql_curve").ClearPoints
    curve("pbuf_vs_plin_curve").ClearPoints
    
    curve("pbuf_vs_Rp_curve").ClearPoints
    curve("plin_vs_Rp_curve").ClearPoints
    curve("pbuf_vs_Ql_nominal_curve").ClearPoints
    curve("plin_vs_Ql_nominal_curve").ClearPoints
    curve("pbuf_vs_Rp_nominal_curve").ClearPoints
    curve("plin_vs_Rp_nominal_curve").ClearPoints
    
    Dim kCal_temp As Double     ' временное значение для поправочного к-та
    
    Dim i As Integer
    Dim numPoints As Integer
    Dim plin_Min As Double, plin_Max As Double
    Dim pbuf_Min As Double, pbuf_Max As Double
    Dim Ql_Min As Double, Ql_Max As Double
    Dim Rp_Min As Double, Rp_Max As Double
    
    ' временно тут заведем переменные - ранее они были удалены из класса
    Dim p_plin_atma As Double
    Dim p_pbuf_atma As Double
    p_plin_atma = 10
    p_pbuf_atma = 10
    kCal_temp = p_c_calibration
    Ql_Min = 0
    Ql_Max = MaxReal(fluid.qliq_sm3day * 2, 100)
    Rp_Min = 50
    Rp_Max = MaxReal(fluid.rp_m3m3 * 2, 1000)
    plin_Min = 1
    plin_Max = MaxReal(p_plin_atma * 2, 100)
    pbuf_Min = 1
    pbuf_Max = MaxReal(p_pbuf_atma * 2, 100)
    numPoints = const_OutputCurveNumPoints
    Dim Pbuf1 As Double, pbuf_work As Double
    Dim Plin1 As Double, plin_work As Double
    Dim Ql1 As Double, Ql_work As Double
    Ql1 = fluid.qliq_sm3day
    Pbuf1 = p_pbuf_atma
    Plin1 = p_plin_atma
    curve("pbuf_vs_Ql_curve").note = "условия: plin = " & Plin1
    For i = 0 To numPoints - 1
        ' первый график
        fluid.qliq_sm3day = i * (Ql_Max - Ql_Min) / numPoints + Ql_Min
        If Plin1 > 0 Then
            p_c_calibration = 1
            pbuf_work = calc_choke_pbuf(SetPT(Plin1, tchoke_C)).p_atma
            curve("pbuf_vs_Ql_nominal_curve").AddPoint fluid.qliq_sm3day, pbuf_work
            p_c_calibration = kCal_temp
            pbuf_work = calc_choke_pbuf(SetPT(Plin1, tchoke_C)).p_atma
            curve("pbuf_vs_Ql_curve").AddPoint fluid.qliq_sm3day, pbuf_work
        End If
        p_c_calibration = 1
        plin_work = calc_choke_plin(SetPT(Pbuf1, tchoke_C)).p_atma
        curve("plin_vs_Ql_nominal_curve").AddPoint fluid.qliq_sm3day, plin_work
        p_c_calibration = kCal_temp
        plin_work = calc_choke_plin(SetPT(Pbuf1, tchoke_C)).p_atma
        curve("plin_vs_Ql_curve").AddPoint fluid.qliq_sm3day, plin_work
    Next i
    Dim Rptemp As Double, Rsbtemp As Double
    Rptemp = fluid.rp_m3m3
    Rsbtemp = fluid.rsb_m3m3
    fluid.qliq_sm3day = Ql1
    For i = 0 To numPoints - 1
        ' первый график
        fluid.rp_m3m3 = i * (Rp_Max - Rp_Min) / numPoints + Rp_Min
        fluid.rsb_m3m3 = Rsbtemp   ' пытаемся восстановить rsb
        If Plin1 > 0 Then
            p_c_calibration = 1
            pbuf_work = calc_choke_pbuf(SetPT(Plin1, tchoke_C)).p_atma
            curve("pbuf_vs_Rp_nominal_curve").AddPoint fluid.rp_m3m3, pbuf_work
            p_c_calibration = kCal_temp
            pbuf_work = calc_choke_pbuf(SetPT(Plin1, tchoke_C)).p_atma
            curve("pbuf_vs_Rp_curve").AddPoint fluid.rp_m3m3, pbuf_work
        End If
        p_c_calibration = 1
        plin_work = calc_choke_plin(SetPT(Pbuf1, tchoke_C)).p_atma
        curve("plin_vs_Rp_nominal_curve").AddPoint fluid.rp_m3m3, plin_work
        p_c_calibration = kCal_temp
        plin_work = calc_choke_plin(SetPT(Pbuf1, tchoke_C)).p_atma
        curve("plin_vs_Rp_curve").AddPoint fluid.rp_m3m3, plin_work
    Next i
    fluid.rp_m3m3 = Rptemp
    fluid.rsb_m3m3 = Rsbtemp   ' пытаемся восстановить rsb
    Const EPS = 0.0001
    ' для графика зависимости линейного давления от дебита есть четкий максимум по дебиту соответсвующий критическому потоку
    ' через штуцер. Чтобы график был красивый - добавим эти точки в явном виде
    ' eps  используется так как CInterpolation  может хранить только функции
    curve("plin_vs_Ql_curve").AddPoint Qlmax_m3day - EPS, Pbuf1 * PratioCrit
    curve("plin_vs_Ql_curve").AddPoint Qlmax_m3day, 0
    fluid.qliq_sm3day = Ql1
    For i = 0 To numPoints - 1
        plin_work = i * (plin_Max - plin_Min) / numPoints + plin_Min
        pbuf_work = calc_choke_pbuf(SetPT(plin_work, tchoke_C)).p_atma
        curve("pbuf_vs_plin_curve").AddPoint plin_work, pbuf_work
    Next i
    p_plin_atma = Plin1
    p_pbuf_atma = Pbuf1
End Sub
 Public Function Copy(chk As Cchoke)
    Dup_m = chk.Dup_m
    Ddown_m = chk.Ddown_m
    Dchoke_m = chk.Dchoke_m
    Call fluid.Copy(chk.fluid)
    tchoke_C = chk.tchoke_C
    p_c_calibration = chk.c_calibr_fr
 End Function
