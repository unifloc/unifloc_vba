''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2009-2010, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Data types
Public Type Complex
    x As Double
    y As Double
End Type
Public Type RCommState
    Stage As Long
    BA() As Boolean
    IA() As Long
    RA() As Double
    CA() As Complex
End Type
Public Type ALGLIBDataset
    NIn As Long
    NOut As Long
    NClasses As Long
    
    Trn() As Double
    TST() As Double
    val() As Double
    AllDataset() As Double
    
    TrnSize As Long
    TstSize As Long
    ValSize As Long
    TotalSize As Long
End Type
Public Const MachineEpsilon = 5E-16
Public Const MaxRealNumber = 1E+300
Public Const MinRealNumber = 1E-300
Private Const BigNumber As Double = 1E+70
Private Const SmallNumber As Double = 1E-70
Private Const PiNumber As Double = 3.14159265358979
'Data types
Public Type LINMINState
    BRACKT As Boolean
    STAGE1 As Boolean
    INFOC As Long
    DG As Double
    DGM As Double
    DGInit As Double
    DGTEST As Double
    DGX As Double
    DGXM As Double
    DGY As Double
    DGYM As Double
    FInit As Double
    FTEST1 As Double
    FM As Double
    FX As Double
    FXM As Double
    FY As Double
    FYM As Double
    STX As Double
    STY As Double
    STMIN As Double
    STMAX As Double
    WIDTH As Double
    WIDTH1 As Double
    XTRAPF As Double
End Type
'Global constants
Private Const FTOL As Double = 0.001
Private Const XTOL As Double = 100# * MachineEpsilon
Private Const GTOL As Double = 0.3
Private Const MAXFEV As Long = 20#
Private Const STPMIN As Double = 1E-50
Private Const DefSTPMAX As Double = 1E+50
'Data types
Public Type MinASAState
    N As Long
    EpsG As Double
    EpsF As Double
    EpsX As Double
    MaxIts As Long
    XRep As Boolean
    StpMax As Double
    CGType As Long
    K As Long
    NFEV As Long
    MCStage As Long
    BndL() As Double
    BndU() As Double
    CurAlgo As Long
    ACount As Long
    mu As Double
    FInit As Double
    DGInit As Double
    AK() As Double
    XK() As Double
    DK() As Double
    AN() As Double
    XN() As Double
    dn() As Double
    d() As Double
    Fold As Double
    Stp As Double
    WORK() As Double
    YK() As Double
    GC() As Double
    x() As Double
    f As Double
    g() As Double
    NeedFG As Boolean
    XUpdated As Boolean
    RState As RCommState
    RepIterationsCount As Long
    RepNFEV As Long
    RepTerminationType As Long
    DebugRestartsCount As Long
    LState As LINMINState
    BetaHS As Double
    BetaDY As Double
End Type
Public Type MinASAReport
    IterationsCount As Long
    NFEV As Long
    TerminationType As Long
    ActiveConstraints As Long
End Type
'Global constants
Private Const N1 As Long = 2#
Private Const N2 As Long = 2#
'Private Const STPMIN As Double = 1E-300
Private Const GPAFTol As Double = 0.0001
Private Const GPADecay As Double = 0.5
Private Const ASARho As Double = 0.5
'Data types
Public Type MinCGState
    N As Long
    EpsG As Double
    EpsF As Double
    EpsX As Double
    MaxIts As Long
    StpMax As Double
    XRep As Boolean
    CGType As Long
    NFEV As Long
    MCStage As Long
    K As Long
    XK() As Double
    DK() As Double
    XN() As Double
    dn() As Double
    d() As Double
    Fold As Double
    Stp As Double
    WORK() As Double
    YK() As Double
    x() As Double
    f As Double
    g() As Double
    NeedFG As Boolean
    XUpdated As Boolean
    RState As RCommState
    RepIterationsCount As Long
    RepNFEV As Long
    RepTerminationType As Long
    DebugRestartsCount As Long
    LState As LINMINState
    BetaHS As Double
    BetaDY As Double
End Type
Public Type MinCGReport
    IterationsCount As Long
    NFEV As Long
    TerminationType As Long
End Type
'Data types
Public Type MinLBFGSState
    N As Long
    M As Long
    EpsG As Double
    EpsF As Double
    EpsX As Double
    MaxIts As Long
    Flags As Long
    XRep As Boolean
    StpMax As Double
    NFEV As Long
    MCStage As Long
    K As Long
    q As Long
    p As Long
    Rho() As Double
    y() As Double
    s() As Double
    THETA() As Double
    d() As Double
    Stp As Double
    WORK() As Double
    Fold As Double
    GammaK As Double
    x() As Double
    f As Double
    g() As Double
    NeedFG As Boolean
    XUpdated As Boolean
    RState As RCommState
    RepIterationsCount As Long
    RepNFEV As Long
    RepTerminationType As Long
    LState As LINMINState
End Type
Public Type MinLBFGSReport
    IterationsCount As Long
    NFEV As Long
    TerminationType As Long
End Type
Public Type MinLMReport
    IterationsCount As Long
    TerminationType As Long
    NFunc As Long
    NJac As Long
    NGrad As Long
    NHess As Long
    NCholesky As Long
End Type
'Global constants
Private Const LMModeFJ As Long = 0#
Private Const LMModeFGJ As Long = 1#
Private Const LMModeFGH As Long = 2#
Private Const LMFlagNoPreLBFGS As Long = 1#
Private Const LMFlagNoIntLBFGS As Long = 2#
Private Const LMPreLBFGSM As Long = 5#
Private Const LMIntLBFGSIts As Long = 5#
Private Const LBFGSNoRealloc As Long = 1#
Public Type MatInvReport
    R1 As Double
    RInf As Double
End Type
'Data types
Public Type DenseSolverReport
    R1 As Double
    RInf As Double
End Type
Public Type DenseSolverLSReport
    R2 As Double
    cx() As Double
    N As Long
    K As Long
End Type
'Data types
Public Type ODESolverState
    N As Long
    M As Long
    XScale As Double
    h As Double
    eps As Double
    FracEps As Boolean
    YC() As Double
    EScale() As Double
    XG() As Double
    SolverType As Long
    x As Double
    y() As Double
    DY() As Double
    YTbl() As Double
    RepTerminationType As Long
    RepNFEV As Long
    YN() As Double
    YNS() As Double
    RKA() As Double
    RKC() As Double
    RKCS() As Double
    RKB() As Double
    RKK() As Double
    RState As RCommState
End Type
Public Type ODESolverReport
    NFEV As Long
    TerminationType As Long
End Type
'Data types
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'1-dimensional spline inteprolant
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Type Spline1DInterpolant
    Periodic As Boolean
    N As Long
    K As Long
    x() As Double
    C() As Double
End Type
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Spline fitting report:
'    TaskRCond       reciprocal of task's condition number
'    RMSError        RMS error
'    AvgError        average error
'    AvgRelError     average relative error (for non-zero Y[I])
'    MaxError        maximum error
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Type Spline1DFitReport
    TaskRCond As Double
    RMSError As Double
    AvgError As Double
    AvgRelError As Double
    MaxError As Double
End Type
'Global constants
Private Const Spline1DVNum As Long = 11#
'Data types
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'2-dimensional spline inteprolant
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Type Spline2DInterpolant
    K As Long
    C() As Double
End Type
'Global constants
Private Const Spline2DVNum As Long = 12#
'Data types
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Parametric spline inteprolant: 2-dimensional curve.
'
'You should not try to access its members directly - use PSpline2XXXXXXXX()
'functions instead.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Type PSpline2Interpolant
    N As Long
    Periodic As Boolean
    p() As Double
    x As Spline1DInterpolant
    y As Spline1DInterpolant
End Type
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Parametric spline inteprolant: 3-dimensional curve.
'
'You should not try to access its members directly - use PSpline3XXXXXXXX()
'functions instead.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Type PSpline3Interpolant
    N As Long
    Periodic As Boolean
    p() As Double
    x As Spline1DInterpolant
    y As Spline1DInterpolant
    z As Spline1DInterpolant
End Type
'Global constants
Private Const ODESolverMaxGrow As Double = 3#
Private Const ODESolverMaxShrink As Double = 10#
'Data types
Public Type MinLMState
    WrongParams As Boolean
    N As Long
    M As Long
    EpsG As Double
    EpsF As Double
    EpsX As Double
    MaxIts As Long
    XRep As Boolean
    StpMax As Double
    Flags As Long
    UserMode As Long
    x() As Double
    f As Double
    fi() As Double
    j() As Double
    h() As Double
    g() As Double
    NeedF As Boolean
    NeedFG As Boolean
    NeedFGH As Boolean
    NeedFiJ As Boolean
    XUpdated As Boolean
    InternalState As MinLBFGSState
    InternalRep As MinLBFGSReport
    XPrec() As Double
    XBase() As Double
    XDir() As Double
    GBase() As Double
    XPrev() As Double
    FPrev As Double
    RawModel() As Double
    Model() As Double
    WORK() As Double
    RState As RCommState
    RepIterationsCount As Long
    RepTerminationType As Long
    RepNFunc As Long
    RepNJac As Long
    RepNGrad As Long
    RepNHess As Long
    RepNCholesky As Long
    SolverInfo As Long
    SolverRep As DenseSolverReport
    InvInfo As Long
    InvRep As MatInvReport
End Type
Public Type LSFitState
    N As Long
    M As Long
    K As Long
    EpsF As Double
    EpsX As Double
    MaxIts As Long
    StpMax As Double
    TaskX() As Double
    TaskY() As Double
    w() As Double
    CheapFG As Boolean
    HaveHess As Boolean
    NeedF As Boolean
    NeedFG As Boolean
    NeedFGH As Boolean
    PointIndex As Long
    x() As Double
    C() As Double
    f As Double
    g() As Double
    h() As Double
    RepTerminationType As Long
    RepRMSError As Double
    RepAvgError As Double
    RepAvgRelError As Double
    RepMaxError As Double
    OptState As MinLMState
    OptRep As MinLMReport
    RState As RCommState
End Type
'Data types
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Polynomial fitting report:
'    TaskRCond       reciprocal of task's condition number
'    RMSError        RMS error
'    AvgError        average error
'    AvgRelError     average relative error (for non-zero Y[I])
'    MaxError        maximum error
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Type PolynomialFitReport
    TaskRCond As Double
    RMSError As Double
    AvgError As Double
    AvgRelError As Double
    MaxError As Double
End Type
'Data types
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Barycentric interpolant.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Type BarycentricInterpolant
    N As Long
    SY As Double
    x() As Double
    y() As Double
    w() As Double
End Type
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Barycentric fitting report:
'    TaskRCond       reciprocal of task's condition number
'    RMSError        RMS error
'    AvgError        average error
'    AvgRelError     average relative error (for non-zero Y[I])
'    MaxError        maximum error
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Type BarycentricFitReport
    TaskRCond As Double
    DBest As Long
    RMSError As Double
    AvgError As Double
    AvgRelError As Double
    MaxError As Double
End Type
'Global constants
Private Const BRCVNum As Long = 10#
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Least squares fitting report:
'    TaskRCond       reciprocal of task's condition number
'    RMSError        RMS error
'    AvgError        average error
'    AvgRelError     average relative error (for non-zero Y[I])
'    MaxError        maximum error
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Type LSFitReport
    TaskRCond As Double
    RMSError As Double
    AvgError As Double
    AvgRelError As Double
    MaxError As Double
End Type
'Data types
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Portable high quality random number generator state.
'Initialized with HQRNDRandomize() or HQRNDSeed().
'
'Fields:
'    S1, S2      -   seed values
'    V           -   precomputed value
'    MagicV      -   'magic' value used to determine whether State structure
'                    was correctly initialized.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Type HQRNDState
    S1 As Long
    S2 As Long
    V As Double
    MagicV As Long
End Type
'Global constants
Private Const HQRNDMax As Long = 2147483563#
Private Const HQRNDM1 As Long = 2147483563#
Private Const HQRNDM2 As Long = 2147483399#
Private Const HQRNDMagic As Long = 1634357784#
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Data types
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Integration report:
'* TerminationType = completetion code:
'    * -5    non-convergence of Gauss-Kronrod nodes
'            calculation subroutine.
'    * -1    incorrect parameters were specified
'    *  1    OK
'* Rep.NFEV countains number of function calculations
'* Rep.NIntervals contains number of intervals [a,b]
'  was partitioned into.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Type AutoGKReport
    TerminationType As Long
    NFEV As Long
    NIntervals As Long
End Type
Public Type AutoGKInternalState
    a As Double
    B As Double
    eps As Double
    XWidth As Double
    x As Double
    f As Double
    Info As Long
    R As Double
    Heap() As Double
    HeapSize As Long
    HeapWidth As Long
    HeapUsed As Long
    SumErr As Double
    SumAbs As Double
    QN() As Double
    WG() As Double
    WK() As Double
    WR() As Double
    N As Long
    RState As RCommState
End Type
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This structure stores internal state of the integration algorithm  between
'subsequent calls of the AutoGKIteration() subroutine.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Type AutoGKState
    a As Double
    B As Double
    alpha As Double
    beta As Double
    XWidth As Double
    x As Double
    XMinusA As Double
    BMinusX As Double
    f As Double
    WrapperMode As Long
    InternalState As AutoGKInternalState
    RState As RCommState
    V As Double
    TerminationType As Long
    NFEV As Long
    NIntervals As Long
End Type
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Splits matrix length in two parts, left part should match ABLAS block size
'
'INPUT PARAMETERS
'    A   -   real matrix, is passed to ensure that we didn't split
'            complex matrix using real splitting subroutine.
'            matrix itself is not changed.
'    N   -   length, N>0
'
'OUTPUT PARAMETERS
'    N1  -   length
'    N2  -   length
'
'N1+N2=N, N1>=N2, N2 may be zero
'
'  -- ALGLIB routine --
'     15.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub ABLASSplitLength(ByRef a() As Double, _
         ByVal N As Long, _
         ByRef N1 As Long, _
         ByRef N2 As Long)
    If N > ABLASBlockSize(a) Then
        Call ABLASInternalSplitLength(N, ABLASBlockSize(a), N1, N2)
    Else
        Call ABLASInternalSplitLength(N, ABLASMicroBlockSize(), N1, N2)
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Complex ABLASSplitLength
'
'  -- ALGLIB routine --
'     15.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub ABLASComplexSplitLength(ByRef a() As Complex, _
         ByVal N As Long, _
         ByRef N1 As Long, _
         ByRef N2 As Long)
    If N > ABLASComplexBlockSize(a) Then
        Call ABLASInternalSplitLength(N, ABLASComplexBlockSize(a), N1, N2)
    Else
        Call ABLASInternalSplitLength(N, ABLASMicroBlockSize(), N1, N2)
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Returns block size - subdivision size where  cache-oblivious  soubroutines
'switch to the optimized kernel.
'
'INPUT PARAMETERS
'    A   -   real matrix, is passed to ensure that we didn't split
'            complex matrix using real splitting subroutine.
'            matrix itself is not changed.
'
'  -- ALGLIB routine --
'     15.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function ABLASBlockSize(ByRef a() As Double) As Long
    Dim Result As Long
    Result = 32#
    ABLASBlockSize = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Block size for complex subroutines.
'
'  -- ALGLIB routine --
'     15.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function ABLASComplexBlockSize(ByRef a() As Complex) As Long
    Dim Result As Long
    Result = 24#
    ABLASComplexBlockSize = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Microblock size
'
'  -- ALGLIB routine --
'     15.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function ABLASMicroBlockSize() As Long
    Dim Result As Long
    Result = 8#
    ABLASMicroBlockSize = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Cache-oblivous complex "copy-and-transpose"
'
'Input parameters:
'    M   -   number of rows
'    N   -   number of columns
'    A   -   source matrix, MxN submatrix is copied and transposed
'    IA  -   submatrix offset (row index)
'    JA  -   submatrix offset (column index)
'    A   -   destination matrix
'    IB  -   submatrix offset (row index)
'    JB  -   submatrix offset (column index)
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixTranspose(ByVal M As Long, _
         ByVal N As Long, _
         ByRef a() As Complex, _
         ByVal IA As Long, _
         ByVal JA As Long, _
         ByRef B() As Complex, _
         ByVal IB As Long, _
         ByVal JB As Long)
    Dim i As Long
    Dim S1 As Long
    Dim S2 As Long
    Dim i_ As Long
    Dim i1_ As Long
    If M <= 2# * ABLASComplexBlockSize(a) And N <= 2# * ABLASComplexBlockSize(a) Then
        
        '
        ' base case
        '
        For i = 0# To M - 1# Step 1
            i1_ = (JA) - (IB)
            For i_ = IB To IB + N - 1# Step 1
                B(i_, JB + i) = a(IA + i, i_ + i1_)
            Next i_
        Next i
    Else
        
        '
        ' Cache-oblivious recursion
        '
        If M > N Then
            Call ABLASComplexSplitLength(a, M, S1, S2)
            Call CMatrixTranspose(S1, N, a, IA, JA, B, IB, JB)
            Call CMatrixTranspose(S2, N, a, IA + S1, JA, B, IB, JB + S1)
        Else
            Call ABLASComplexSplitLength(a, N, S1, S2)
            Call CMatrixTranspose(M, S1, a, IA, JA, B, IB, JB)
            Call CMatrixTranspose(M, S2, a, IA, JA + S1, B, IB + S1, JB)
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Cache-oblivous real "copy-and-transpose"
'
'Input parameters:
'    M   -   number of rows
'    N   -   number of columns
'    A   -   source matrix, MxN submatrix is copied and transposed
'    IA  -   submatrix offset (row index)
'    JA  -   submatrix offset (column index)
'    A   -   destination matrix
'    IB  -   submatrix offset (row index)
'    JB  -   submatrix offset (column index)
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixTranspose(ByVal M As Long, _
         ByVal N As Long, _
         ByRef a() As Double, _
         ByVal IA As Long, _
         ByVal JA As Long, _
         ByRef B() As Double, _
         ByVal IB As Long, _
         ByVal JB As Long)
    Dim i As Long
    Dim S1 As Long
    Dim S2 As Long
    Dim i_ As Long
    Dim i1_ As Long
    If M <= 2# * ABLASBlockSize(a) And N <= 2# * ABLASBlockSize(a) Then
        
        '
        ' base case
        '
        For i = 0# To M - 1# Step 1
            i1_ = (JA) - (IB)
            For i_ = IB To IB + N - 1# Step 1
                B(i_, JB + i) = a(IA + i, i_ + i1_)
            Next i_
        Next i
    Else
        
        '
        ' Cache-oblivious recursion
        '
        If M > N Then
            Call ABLASSplitLength(a, M, S1, S2)
            Call RMatrixTranspose(S1, N, a, IA, JA, B, IB, JB)
            Call RMatrixTranspose(S2, N, a, IA + S1, JA, B, IB, JB + S1)
        Else
            Call ABLASSplitLength(a, N, S1, S2)
            Call RMatrixTranspose(M, S1, a, IA, JA, B, IB, JB)
            Call RMatrixTranspose(M, S2, a, IA, JA + S1, B, IB + S1, JB)
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copy
'
'Input parameters:
'    M   -   number of rows
'    N   -   number of columns
'    A   -   source matrix, MxN submatrix is copied and transposed
'    IA  -   submatrix offset (row index)
'    JA  -   submatrix offset (column index)
'    B   -   destination matrix
'    IB  -   submatrix offset (row index)
'    JB  -   submatrix offset (column index)
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixCopy(ByVal M As Long, _
         ByVal N As Long, _
         ByRef a() As Complex, _
         ByVal IA As Long, _
         ByVal JA As Long, _
         ByRef B() As Complex, _
         ByVal IB As Long, _
         ByVal JB As Long)
    Dim i As Long
    Dim i_ As Long
    Dim i1_ As Long
    For i = 0# To M - 1# Step 1
        i1_ = (JA) - (JB)
        For i_ = JB To JB + N - 1# Step 1
            B(IB + i, i_) = a(IA + i, i_ + i1_)
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copy
'
'Input parameters:
'    M   -   number of rows
'    N   -   number of columns
'    A   -   source matrix, MxN submatrix is copied and transposed
'    IA  -   submatrix offset (row index)
'    JA  -   submatrix offset (column index)
'    B   -   destination matrix
'    IB  -   submatrix offset (row index)
'    JB  -   submatrix offset (column index)
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixCopy(ByVal M As Long, _
         ByVal N As Long, _
         ByRef a() As Double, _
         ByVal IA As Long, _
         ByVal JA As Long, _
         ByRef B() As Double, _
         ByVal IB As Long, _
         ByVal JB As Long)
    Dim i As Long
    Dim i_ As Long
    Dim i1_ As Long
    For i = 0# To M - 1# Step 1
        i1_ = (JA) - (JB)
        For i_ = JB To JB + N - 1# Step 1
            B(IB + i, i_) = a(IA + i, i_ + i1_)
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Rank-1 correction: A := A + u*v'
'
'INPUT PARAMETERS:
'    M   -   number of rows
'    N   -   number of columns
'    A   -   target matrix, MxN submatrix is updated
'    IA  -   submatrix offset (row index)
'    JA  -   submatrix offset (column index)
'    U   -   vector #1
'    IU  -   subvector offset
'    V   -   vector #2
'    IV  -   subvector offset
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixRank1(ByVal M As Long, _
         ByVal N As Long, _
         ByRef a() As Complex, _
         ByVal IA As Long, _
         ByVal JA As Long, _
         ByRef U() As Complex, _
         ByVal IU As Long, _
         ByRef V() As Complex, _
         ByVal IV As Long)
    Dim i As Long
    Dim s As Complex
    Dim i_ As Long
    Dim i1_ As Long
    If M = 0# Or N = 0# Then
        Exit Sub
    End If
    If CMatrixRank1F(M, N, a, IA, JA, U, IU, V, IV) Then
        Exit Sub
    End If
    For i = 0# To M - 1# Step 1
        s = U(IU + i)
        i1_ = (IV) - (JA)
        For i_ = JA To JA + N - 1# Step 1
            a(IA + i, i_) = C_Add(a(IA + i, i_), C_Mul(s, V(i_ + i1_)))
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Rank-1 correction: A := A + u*v'
'
'INPUT PARAMETERS:
'    M   -   number of rows
'    N   -   number of columns
'    A   -   target matrix, MxN submatrix is updated
'    IA  -   submatrix offset (row index)
'    JA  -   submatrix offset (column index)
'    U   -   vector #1
'    IU  -   subvector offset
'    V   -   vector #2
'    IV  -   subvector offset
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixRank1(ByVal M As Long, _
         ByVal N As Long, _
         ByRef a() As Double, _
         ByVal IA As Long, _
         ByVal JA As Long, _
         ByRef U() As Double, _
         ByVal IU As Long, _
         ByRef V() As Double, _
         ByVal IV As Long)
    Dim i As Long
    Dim s As Double
    Dim i_ As Long
    Dim i1_ As Long
    If M = 0# Or N = 0# Then
        Exit Sub
    End If
    If RMatrixRank1F(M, N, a, IA, JA, U, IU, V, IV) Then
        Exit Sub
    End If
    For i = 0# To M - 1# Step 1
        s = U(IU + i)
        i1_ = (IV) - (JA)
        For i_ = JA To JA + N - 1# Step 1
            a(IA + i, i_) = a(IA + i, i_) + s * V(i_ + i1_)
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Matrix-vector product: y := op(A)*x
'
'INPUT PARAMETERS:
'    M   -   number of rows of op(A)
'            M>=0
'    N   -   number of columns of op(A)
'            N>=0
'    A   -   target matrix
'    IA  -   submatrix offset (row index)
'    JA  -   submatrix offset (column index)
'    OpA -   operation type:
'            * OpA=0     =>  op(A) = A
'            * OpA=1     =>  op(A) = A^T
'            * OpA=2     =>  op(A) = A^H
'    X   -   input vector
'    IX  -   subvector offset
'    IY  -   subvector offset
'
'OUTPUT PARAMETERS:
'    Y   -   vector which stores result
'
'if M=0, then subroutine does nothing.
'if N=0, Y is filled by zeros.
'
'
'  -- ALGLIB routine --
'
'     28.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixMV(ByVal M As Long, _
         ByVal N As Long, _
         ByRef a() As Complex, _
         ByVal IA As Long, _
         ByVal JA As Long, _
         ByVal OpA As Long, _
         ByRef x() As Complex, _
         ByVal IX As Long, _
         ByRef y() As Complex, _
         ByVal IY As Long)
    Dim i As Long
    Dim V As Complex
    Dim i_ As Long
    Dim i1_ As Long
    If M = 0# Then
        Exit Sub
    End If
    If N = 0# Then
        For i = 0# To M - 1# Step 1
            y(IY + i) = C_Complex(0#)
        Next i
        Exit Sub
    End If
    If CMatrixMVF(M, N, a, IA, JA, OpA, x, IX, y, IY) Then
        Exit Sub
    End If
    If OpA = 0# Then
        
        '
        ' y = A*x
        '
        For i = 0# To M - 1# Step 1
            i1_ = (IX) - (JA)
            V = C_Complex(0#)
            For i_ = JA To JA + N - 1# Step 1
                V = C_Add(V, C_Mul(a(IA + i, i_), x(i_ + i1_)))
            Next i_
            y(IY + i) = V
        Next i
        Exit Sub
    End If
    If OpA = 1# Then
        
        '
        ' y = A^T*x
        '
        For i = 0# To M - 1# Step 1
            y(IY + i) = C_Complex(0#)
        Next i
        For i = 0# To N - 1# Step 1
            V = x(IX + i)
            i1_ = (JA) - (IY)
            For i_ = IY To IY + M - 1# Step 1
                y(i_) = C_Add(y(i_), C_Mul(V, a(IA + i, i_ + i1_)))
            Next i_
        Next i
        Exit Sub
    End If
    If OpA = 2# Then
        
        '
        ' y = A^H*x
        '
        For i = 0# To M - 1# Step 1
            y(IY + i) = C_Complex(0#)
        Next i
        For i = 0# To N - 1# Step 1
            V = x(IX + i)
            i1_ = (JA) - (IY)
            For i_ = IY To IY + M - 1# Step 1
                y(i_) = C_Add(y(i_), C_Mul(V, Conj(a(IA + i, i_ + i1_))))
            Next i_
        Next i
        Exit Sub
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Matrix-vector product: y := op(A)*x
'
'INPUT PARAMETERS:
'    M   -   number of rows of op(A)
'    N   -   number of columns of op(A)
'    A   -   target matrix
'    IA  -   submatrix offset (row index)
'    JA  -   submatrix offset (column index)
'    OpA -   operation type:
'            * OpA=0     =>  op(A) = A
'            * OpA=1     =>  op(A) = A^T
'    X   -   input vector
'    IX  -   subvector offset
'    IY  -   subvector offset
'
'OUTPUT PARAMETERS:
'    Y   -   vector which stores result
'
'if M=0, then subroutine does nothing.
'if N=0, Y is filled by zeros.
'
'
'  -- ALGLIB routine --
'
'     28.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixMV(ByVal M As Long, _
         ByVal N As Long, _
         ByRef a() As Double, _
         ByVal IA As Long, _
         ByVal JA As Long, _
         ByVal OpA As Long, _
         ByRef x() As Double, _
         ByVal IX As Long, _
         ByRef y() As Double, _
         ByVal IY As Long)
    Dim i As Long
    Dim V As Double
    Dim i_ As Long
    Dim i1_ As Long
    If M = 0# Then
        Exit Sub
    End If
    If N = 0# Then
        For i = 0# To M - 1# Step 1
            y(IY + i) = 0#
        Next i
        Exit Sub
    End If
    If RMatrixMVF(M, N, a, IA, JA, OpA, x, IX, y, IY) Then
        Exit Sub
    End If
    If OpA = 0# Then
        
        '
        ' y = A*x
        '
        For i = 0# To M - 1# Step 1
            i1_ = (IX) - (JA)
            V = 0#
            For i_ = JA To JA + N - 1# Step 1
                V = V + a(IA + i, i_) * x(i_ + i1_)
            Next i_
            y(IY + i) = V
        Next i
        Exit Sub
    End If
    If OpA = 1# Then
        
        '
        ' y = A^T*x
        '
        For i = 0# To M - 1# Step 1
            y(IY + i) = 0#
        Next i
        For i = 0# To N - 1# Step 1
            V = x(IX + i)
            i1_ = (JA) - (IY)
            For i_ = IY To IY + M - 1# Step 1
                y(i_) = y(i_) + V * a(IA + i, i_ + i1_)
            Next i_
        Next i
        Exit Sub
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This subroutine calculates X*op(A^-1) where:
'* X is MxN general matrix
'* A is NxN upper/lower triangular/unitriangular matrix
'* "op" may be identity transformation, transposition, conjugate transposition
'
'Multiplication result replaces X.
'Cache-oblivious algorithm is used.
'
'INPUT PARAMETERS
'    N   -   matrix size, N>=0
'    M   -   matrix size, N>=0
'    A       -   matrix, actial matrix is stored in A[I1:I1+N-1,J1:J1+N-1]
'    I1      -   submatrix offset
'    J1      -   submatrix offset
'    IsUpper -   whether matrix is upper triangular
'    IsUnit  -   whether matrix is unitriangular
'    OpType  -   transformation type:
'                * 0 - no transformation
'                * 1 - transposition
'                * 2 - conjugate transposition
'    C   -   matrix, actial matrix is stored in C[I2:I2+M-1,J2:J2+N-1]
'    I2  -   submatrix offset
'    J2  -   submatrix offset
'
'  -- ALGLIB routine --
'     15.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixRightTRSM(ByVal M As Long, _
         ByVal N As Long, _
         ByRef a() As Complex, _
         ByVal I1 As Long, _
         ByVal J1 As Long, _
         ByVal IsUpper As Boolean, _
         ByVal Isunit As Boolean, _
         ByVal OpType As Long, _
         ByRef x() As Complex, _
         ByVal I2 As Long, _
         ByVal J2 As Long)
    Dim S1 As Long
    Dim S2 As Long
    Dim BS As Long
    BS = ABLASComplexBlockSize(a)
    If M <= BS And N <= BS Then
        Call CMatrixRightTRSM2(M, N, a, I1, J1, IsUpper, Isunit, OpType, x, I2, J2)
        Exit Sub
    End If
    If M >= N Then
        
        '
        ' Split X: X*A = (X1 X2)^T*A
        '
        Call ABLASComplexSplitLength(a, M, S1, S2)
        Call CMatrixRightTRSM(S1, N, a, I1, J1, IsUpper, Isunit, OpType, x, I2, J2)
        Call CMatrixRightTRSM(S2, N, a, I1, J1, IsUpper, Isunit, OpType, x, I2 + S1, J2)
    Else
        
        '
        ' Split A:
        '               (A1  A12)
        ' X*op(A) = X*op(       )
        '               (     A2)
        '
        ' Different variants depending on
        ' IsUpper/OpType combinations
        '
        Call ABLASComplexSplitLength(a, N, S1, S2)
        If IsUpper And OpType = 0# Then
            
            '
            '                  (A1  A12)-1
            ' X*A^-1 = (X1 X2)*(       )
            '                  (     A2)
            '
            Call CMatrixRightTRSM(M, S1, a, I1, J1, IsUpper, Isunit, OpType, x, I2, J2)
            Call CMatrixGEMM(M, S2, S1, C_Complex(-1#), x, I2, J2, 0#, a, I1, J1 + S1, 0#, C_Complex(1#), x, I2, J2 + S1)
            Call CMatrixRightTRSM(M, S2, a, I1 + S1, J1 + S1, IsUpper, Isunit, OpType, x, I2, J2 + S1)
            Exit Sub
        End If
        If IsUpper And OpType <> 0# Then
            
            '
            '                  (A1'     )-1
            ' X*A^-1 = (X1 X2)*(        )
            '                  (A12' A2')
            '
            Call CMatrixRightTRSM(M, S2, a, I1 + S1, J1 + S1, IsUpper, Isunit, OpType, x, I2, J2 + S1)
            Call CMatrixGEMM(M, S1, S2, C_Complex(-1#), x, I2, J2 + S1, 0#, a, I1, J1 + S1, OpType, C_Complex(1#), x, I2, J2)
            Call CMatrixRightTRSM(M, S1, a, I1, J1, IsUpper, Isunit, OpType, x, I2, J2)
            Exit Sub
        End If
        If Not IsUpper And OpType = 0# Then
            
            '
            '                  (A1     )-1
            ' X*A^-1 = (X1 X2)*(       )
            '                  (A21  A2)
            '
            Call CMatrixRightTRSM(M, S2, a, I1 + S1, J1 + S1, IsUpper, Isunit, OpType, x, I2, J2 + S1)
            Call CMatrixGEMM(M, S1, S2, C_Complex(-1#), x, I2, J2 + S1, 0#, a, I1 + S1, J1, 0#, C_Complex(1#), x, I2, J2)
            Call CMatrixRightTRSM(M, S1, a, I1, J1, IsUpper, Isunit, OpType, x, I2, J2)
            Exit Sub
        End If
        If Not IsUpper And OpType <> 0# Then
            
            '
            '                  (A1' A21')-1
            ' X*A^-1 = (X1 X2)*(        )
            '                  (     A2')
            '
            Call CMatrixRightTRSM(M, S1, a, I1, J1, IsUpper, Isunit, OpType, x, I2, J2)
            Call CMatrixGEMM(M, S2, S1, C_Complex(-1#), x, I2, J2, 0#, a, I1 + S1, J1, OpType, C_Complex(1#), x, I2, J2 + S1)
            Call CMatrixRightTRSM(M, S2, a, I1 + S1, J1 + S1, IsUpper, Isunit, OpType, x, I2, J2 + S1)
            Exit Sub
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This subroutine calculates op(A^-1)*X where:
'* X is MxN general matrix
'* A is MxM upper/lower triangular/unitriangular matrix
'* "op" may be identity transformation, transposition, conjugate transposition
'
'Multiplication result replaces X.
'Cache-oblivious algorithm is used.
'
'INPUT PARAMETERS
'    N   -   matrix size, N>=0
'    M   -   matrix size, N>=0
'    A       -   matrix, actial matrix is stored in A[I1:I1+M-1,J1:J1+M-1]
'    I1      -   submatrix offset
'    J1      -   submatrix offset
'    IsUpper -   whether matrix is upper triangular
'    IsUnit  -   whether matrix is unitriangular
'    OpType  -   transformation type:
'                * 0 - no transformation
'                * 1 - transposition
'                * 2 - conjugate transposition
'    C   -   matrix, actial matrix is stored in C[I2:I2+M-1,J2:J2+N-1]
'    I2  -   submatrix offset
'    J2  -   submatrix offset
'
'  -- ALGLIB routine --
'     15.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixLeftTRSM(ByVal M As Long, _
         ByVal N As Long, _
         ByRef a() As Complex, _
         ByVal I1 As Long, _
         ByVal J1 As Long, _
         ByVal IsUpper As Boolean, _
         ByVal Isunit As Boolean, _
         ByVal OpType As Long, _
         ByRef x() As Complex, _
         ByVal I2 As Long, _
         ByVal J2 As Long)
    Dim S1 As Long
    Dim S2 As Long
    Dim BS As Long
    BS = ABLASComplexBlockSize(a)
    If M <= BS And N <= BS Then
        Call CMatrixLeftTRSM2(M, N, a, I1, J1, IsUpper, Isunit, OpType, x, I2, J2)
        Exit Sub
    End If
    If N >= M Then
        
        '
        ' Split X: op(A)^-1*X = op(A)^-1*(X1 X2)
        '
        Call ABLASComplexSplitLength(x, N, S1, S2)
        Call CMatrixLeftTRSM(M, S1, a, I1, J1, IsUpper, Isunit, OpType, x, I2, J2)
        Call CMatrixLeftTRSM(M, S2, a, I1, J1, IsUpper, Isunit, OpType, x, I2, J2 + S1)
    Else
        
        '
        ' Split A
        '
        Call ABLASComplexSplitLength(a, M, S1, S2)
        If IsUpper And OpType = 0# Then
            
            '
            '           (A1  A12)-1  ( X1 )
            ' A^-1*X* = (       )   *(    )
            '           (     A2)    ( X2 )
            '
            Call CMatrixLeftTRSM(S2, N, a, I1 + S1, J1 + S1, IsUpper, Isunit, OpType, x, I2 + S1, J2)
            Call CMatrixGEMM(S1, N, S2, C_Complex(-1#), a, I1, J1 + S1, 0#, x, I2 + S1, J2, 0#, C_Complex(1#), x, I2, J2)
            Call CMatrixLeftTRSM(S1, N, a, I1, J1, IsUpper, Isunit, OpType, x, I2, J2)
            Exit Sub
        End If
        If IsUpper And OpType <> 0# Then
            
            '
            '          (A1'     )-1 ( X1 )
            ' A^-1*X = (        )  *(    )
            '          (A12' A2')   ( X2 )
            '
            Call CMatrixLeftTRSM(S1, N, a, I1, J1, IsUpper, Isunit, OpType, x, I2, J2)
            Call CMatrixGEMM(S2, N, S1, C_Complex(-1#), a, I1, J1 + S1, OpType, x, I2, J2, 0#, C_Complex(1#), x, I2 + S1, J2)
            Call CMatrixLeftTRSM(S2, N, a, I1 + S1, J1 + S1, IsUpper, Isunit, OpType, x, I2 + S1, J2)
            Exit Sub
        End If
        If Not IsUpper And OpType = 0# Then
            
            '
            '          (A1     )-1 ( X1 )
            ' A^-1*X = (       )  *(    )
            '          (A21  A2)   ( X2 )
            '
            Call CMatrixLeftTRSM(S1, N, a, I1, J1, IsUpper, Isunit, OpType, x, I2, J2)
            Call CMatrixGEMM(S2, N, S1, C_Complex(-1#), a, I1 + S1, J1, 0#, x, I2, J2, 0#, C_Complex(1#), x, I2 + S1, J2)
            Call CMatrixLeftTRSM(S2, N, a, I1 + S1, J1 + S1, IsUpper, Isunit, OpType, x, I2 + S1, J2)
            Exit Sub
        End If
        If Not IsUpper And OpType <> 0# Then
            
            '
            '          (A1' A21')-1 ( X1 )
            ' A^-1*X = (        )  *(    )
            '          (     A2')   ( X2 )
            '
            Call CMatrixLeftTRSM(S2, N, a, I1 + S1, J1 + S1, IsUpper, Isunit, OpType, x, I2 + S1, J2)
            Call CMatrixGEMM(S1, N, S2, C_Complex(-1#), a, I1 + S1, J1, OpType, x, I2 + S1, J2, 0#, C_Complex(1#), x, I2, J2)
            Call CMatrixLeftTRSM(S1, N, a, I1, J1, IsUpper, Isunit, OpType, x, I2, J2)
            Exit Sub
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Same as CMatrixRightTRSM, but for real matrices
'
'OpType may be only 0 or 1.
'
'  -- ALGLIB routine --
'     15.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixRightTRSM(ByVal M As Long, _
         ByVal N As Long, _
         ByRef a() As Double, _
         ByVal I1 As Long, _
         ByVal J1 As Long, _
         ByVal IsUpper As Boolean, _
         ByVal Isunit As Boolean, _
         ByVal OpType As Long, _
         ByRef x() As Double, _
         ByVal I2 As Long, _
         ByVal J2 As Long)
    Dim S1 As Long
    Dim S2 As Long
    Dim BS As Long
    BS = ABLASBlockSize(a)
    If M <= BS And N <= BS Then
        Call RMatrixRightTRSM2(M, N, a, I1, J1, IsUpper, Isunit, OpType, x, I2, J2)
        Exit Sub
    End If
    If M >= N Then
        
        '
        ' Split X: X*A = (X1 X2)^T*A
        '
        Call ABLASSplitLength(a, M, S1, S2)
        Call RMatrixRightTRSM(S1, N, a, I1, J1, IsUpper, Isunit, OpType, x, I2, J2)
        Call RMatrixRightTRSM(S2, N, a, I1, J1, IsUpper, Isunit, OpType, x, I2 + S1, J2)
    Else
        
        '
        ' Split A:
        '               (A1  A12)
        ' X*op(A) = X*op(       )
        '               (     A2)
        '
        ' Different variants depending on
        ' IsUpper/OpType combinations
        '
        Call ABLASSplitLength(a, N, S1, S2)
        If IsUpper And OpType = 0# Then
            
            '
            '                  (A1  A12)-1
            ' X*A^-1 = (X1 X2)*(       )
            '                  (     A2)
            '
            Call RMatrixRightTRSM(M, S1, a, I1, J1, IsUpper, Isunit, OpType, x, I2, J2)
            Call RMatrixGEMM(M, S2, S1, -1#, x, I2, J2, 0#, a, I1, J1 + S1, 0#, 1#, x, I2, J2 + S1)
            Call RMatrixRightTRSM(M, S2, a, I1 + S1, J1 + S1, IsUpper, Isunit, OpType, x, I2, J2 + S1)
            Exit Sub
        End If
        If IsUpper And OpType <> 0# Then
            
            '
            '                  (A1'     )-1
            ' X*A^-1 = (X1 X2)*(        )
            '                  (A12' A2')
            '
            Call RMatrixRightTRSM(M, S2, a, I1 + S1, J1 + S1, IsUpper, Isunit, OpType, x, I2, J2 + S1)
            Call RMatrixGEMM(M, S1, S2, -1#, x, I2, J2 + S1, 0#, a, I1, J1 + S1, OpType, 1#, x, I2, J2)
            Call RMatrixRightTRSM(M, S1, a, I1, J1, IsUpper, Isunit, OpType, x, I2, J2)
            Exit Sub
        End If
        If Not IsUpper And OpType = 0# Then
            
            '
            '                  (A1     )-1
            ' X*A^-1 = (X1 X2)*(       )
            '                  (A21  A2)
            '
            Call RMatrixRightTRSM(M, S2, a, I1 + S1, J1 + S1, IsUpper, Isunit, OpType, x, I2, J2 + S1)
            Call RMatrixGEMM(M, S1, S2, -1#, x, I2, J2 + S1, 0#, a, I1 + S1, J1, 0#, 1#, x, I2, J2)
            Call RMatrixRightTRSM(M, S1, a, I1, J1, IsUpper, Isunit, OpType, x, I2, J2)
            Exit Sub
        End If
        If Not IsUpper And OpType <> 0# Then
            
            '
            '                  (A1' A21')-1
            ' X*A^-1 = (X1 X2)*(        )
            '                  (     A2')
            '
            Call RMatrixRightTRSM(M, S1, a, I1, J1, IsUpper, Isunit, OpType, x, I2, J2)
            Call RMatrixGEMM(M, S2, S1, -1#, x, I2, J2, 0#, a, I1 + S1, J1, OpType, 1#, x, I2, J2 + S1)
            Call RMatrixRightTRSM(M, S2, a, I1 + S1, J1 + S1, IsUpper, Isunit, OpType, x, I2, J2 + S1)
            Exit Sub
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Same as CMatrixLeftTRSM, but for real matrices
'
'OpType may be only 0 or 1.
'
'  -- ALGLIB routine --
'     15.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixLeftTRSM(ByVal M As Long, _
         ByVal N As Long, _
         ByRef a() As Double, _
         ByVal I1 As Long, _
         ByVal J1 As Long, _
         ByVal IsUpper As Boolean, _
         ByVal Isunit As Boolean, _
         ByVal OpType As Long, _
         ByRef x() As Double, _
         ByVal I2 As Long, _
         ByVal J2 As Long)
    Dim S1 As Long
    Dim S2 As Long
    Dim BS As Long
    BS = ABLASBlockSize(a)
    If M <= BS And N <= BS Then
        Call RMatrixLeftTRSM2(M, N, a, I1, J1, IsUpper, Isunit, OpType, x, I2, J2)
        Exit Sub
    End If
    If N >= M Then
        
        '
        ' Split X: op(A)^-1*X = op(A)^-1*(X1 X2)
        '
        Call ABLASSplitLength(x, N, S1, S2)
        Call RMatrixLeftTRSM(M, S1, a, I1, J1, IsUpper, Isunit, OpType, x, I2, J2)
        Call RMatrixLeftTRSM(M, S2, a, I1, J1, IsUpper, Isunit, OpType, x, I2, J2 + S1)
    Else
        
        '
        ' Split A
        '
        Call ABLASSplitLength(a, M, S1, S2)
        If IsUpper And OpType = 0# Then
            
            '
            '           (A1  A12)-1  ( X1 )
            ' A^-1*X* = (       )   *(    )
            '           (     A2)    ( X2 )
            '
            Call RMatrixLeftTRSM(S2, N, a, I1 + S1, J1 + S1, IsUpper, Isunit, OpType, x, I2 + S1, J2)
            Call RMatrixGEMM(S1, N, S2, -1#, a, I1, J1 + S1, 0#, x, I2 + S1, J2, 0#, 1#, x, I2, J2)
            Call RMatrixLeftTRSM(S1, N, a, I1, J1, IsUpper, Isunit, OpType, x, I2, J2)
            Exit Sub
        End If
        If IsUpper And OpType <> 0# Then
            
            '
            '          (A1'     )-1 ( X1 )
            ' A^-1*X = (        )  *(    )
            '          (A12' A2')   ( X2 )
            '
            Call RMatrixLeftTRSM(S1, N, a, I1, J1, IsUpper, Isunit, OpType, x, I2, J2)
            Call RMatrixGEMM(S2, N, S1, -1#, a, I1, J1 + S1, OpType, x, I2, J2, 0#, 1#, x, I2 + S1, J2)
            Call RMatrixLeftTRSM(S2, N, a, I1 + S1, J1 + S1, IsUpper, Isunit, OpType, x, I2 + S1, J2)
            Exit Sub
        End If
        If Not IsUpper And OpType = 0# Then
            
            '
            '          (A1     )-1 ( X1 )
            ' A^-1*X = (       )  *(    )
            '          (A21  A2)   ( X2 )
            '
            Call RMatrixLeftTRSM(S1, N, a, I1, J1, IsUpper, Isunit, OpType, x, I2, J2)
            Call RMatrixGEMM(S2, N, S1, -1#, a, I1 + S1, J1, 0#, x, I2, J2, 0#, 1#, x, I2 + S1, J2)
            Call RMatrixLeftTRSM(S2, N, a, I1 + S1, J1 + S1, IsUpper, Isunit, OpType, x, I2 + S1, J2)
            Exit Sub
        End If
        If Not IsUpper And OpType <> 0# Then
            
            '
            '          (A1' A21')-1 ( X1 )
            ' A^-1*X = (        )  *(    )
            '          (     A2')   ( X2 )
            '
            Call RMatrixLeftTRSM(S2, N, a, I1 + S1, J1 + S1, IsUpper, Isunit, OpType, x, I2 + S1, J2)
            Call RMatrixGEMM(S1, N, S2, -1#, a, I1 + S1, J1, OpType, x, I2 + S1, J2, 0#, 1#, x, I2, J2)
            Call RMatrixLeftTRSM(S1, N, a, I1, J1, IsUpper, Isunit, OpType, x, I2, J2)
            Exit Sub
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This subroutine calculates  C=alpha*A*A^H+beta*C  or  C=alpha*A^H*A+beta*C
'where:
'* C is NxN Hermitian matrix given by its upper/lower triangle
'* A is NxK matrix when A*A^H is calculated, KxN matrix otherwise
'
'Additional info:
'* cache-oblivious algorithm is used.
'* multiplication result replaces C. If Beta=0, C elements are not used in
'  calculations (not multiplied by zero - just not referenced)
'* if Alpha=0, A is not used (not multiplied by zero - just not referenced)
'* if both Beta and Alpha are zero, C is filled by zeros.
'
'INPUT PARAMETERS
'    N       -   matrix size, N>=0
'    K       -   matrix size, K>=0
'    Alpha   -   coefficient
'    A       -   matrix
'    IA      -   submatrix offset
'    JA      -   submatrix offset
'    OpTypeA -   multiplication type:
'                * 0 - A*A^H is calculated
'                * 2 - A^H*A is calculated
'    Beta    -   coefficient
'    C       -   matrix
'    IC      -   submatrix offset
'    JC      -   submatrix offset
'    IsUpper -   whether C is upper triangular or lower triangular
'
'  -- ALGLIB routine --
'     16.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixSYRK(ByVal N As Long, _
         ByVal K As Long, _
         ByVal alpha As Double, _
         ByRef a() As Complex, _
         ByVal IA As Long, _
         ByVal JA As Long, _
         ByVal OpTypeA As Long, _
         ByVal beta As Double, _
         ByRef C() As Complex, _
         ByVal IC As Long, _
         ByVal JC As Long, _
         ByVal IsUpper As Boolean)
    Dim S1 As Long
    Dim S2 As Long
    Dim BS As Long
    BS = ABLASComplexBlockSize(a)
    If N <= BS And K <= BS Then
        Call CMatrixSYRK2(N, K, alpha, a, IA, JA, OpTypeA, beta, C, IC, JC, IsUpper)
        Exit Sub
    End If
    If K >= N Then
        
        '
        ' Split K
        '
        Call ABLASComplexSplitLength(a, K, S1, S2)
        If OpTypeA = 0# Then
            Call CMatrixSYRK(N, S1, alpha, a, IA, JA, OpTypeA, beta, C, IC, JC, IsUpper)
            Call CMatrixSYRK(N, S2, alpha, a, IA, JA + S1, OpTypeA, 1#, C, IC, JC, IsUpper)
        Else
            Call CMatrixSYRK(N, S1, alpha, a, IA, JA, OpTypeA, beta, C, IC, JC, IsUpper)
            Call CMatrixSYRK(N, S2, alpha, a, IA + S1, JA, OpTypeA, 1#, C, IC, JC, IsUpper)
        End If
    Else
        
        '
        ' Split N
        '
        Call ABLASComplexSplitLength(a, N, S1, S2)
        If OpTypeA = 0# And IsUpper Then
            Call CMatrixSYRK(S1, K, alpha, a, IA, JA, OpTypeA, beta, C, IC, JC, IsUpper)
            Call CMatrixGEMM(S1, S2, K, C_Complex(alpha), a, IA, JA, 0#, a, IA + S1, JA, 2#, C_Complex(beta), C, IC, JC + S1)
            Call CMatrixSYRK(S2, K, alpha, a, IA + S1, JA, OpTypeA, beta, C, IC + S1, JC + S1, IsUpper)
            Exit Sub
        End If
        If OpTypeA = 0# And Not IsUpper Then
            Call CMatrixSYRK(S1, K, alpha, a, IA, JA, OpTypeA, beta, C, IC, JC, IsUpper)
            Call CMatrixGEMM(S2, S1, K, C_Complex(alpha), a, IA + S1, JA, 0#, a, IA, JA, 2#, C_Complex(beta), C, IC + S1, JC)
            Call CMatrixSYRK(S2, K, alpha, a, IA + S1, JA, OpTypeA, beta, C, IC + S1, JC + S1, IsUpper)
            Exit Sub
        End If
        If OpTypeA <> 0# And IsUpper Then
            Call CMatrixSYRK(S1, K, alpha, a, IA, JA, OpTypeA, beta, C, IC, JC, IsUpper)
            Call CMatrixGEMM(S1, S2, K, C_Complex(alpha), a, IA, JA, 2#, a, IA, JA + S1, 0#, C_Complex(beta), C, IC, JC + S1)
            Call CMatrixSYRK(S2, K, alpha, a, IA, JA + S1, OpTypeA, beta, C, IC + S1, JC + S1, IsUpper)
            Exit Sub
        End If
        If OpTypeA <> 0# And Not IsUpper Then
            Call CMatrixSYRK(S1, K, alpha, a, IA, JA, OpTypeA, beta, C, IC, JC, IsUpper)
            Call CMatrixGEMM(S2, S1, K, C_Complex(alpha), a, IA, JA + S1, 2#, a, IA, JA, 0#, C_Complex(beta), C, IC + S1, JC)
            Call CMatrixSYRK(S2, K, alpha, a, IA, JA + S1, OpTypeA, beta, C, IC + S1, JC + S1, IsUpper)
            Exit Sub
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Same as CMatrixSYRK, but for real matrices
'
'OpType may be only 0 or 1.
'
'  -- ALGLIB routine --
'     16.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixSYRK(ByVal N As Long, _
         ByVal K As Long, _
         ByVal alpha As Double, _
         ByRef a() As Double, _
         ByVal IA As Long, _
         ByVal JA As Long, _
         ByVal OpTypeA As Long, _
         ByVal beta As Double, _
         ByRef C() As Double, _
         ByVal IC As Long, _
         ByVal JC As Long, _
         ByVal IsUpper As Boolean)
    Dim S1 As Long
    Dim S2 As Long
    Dim BS As Long
    BS = ABLASBlockSize(a)
    If N <= BS And K <= BS Then
        Call RMatrixSYRK2(N, K, alpha, a, IA, JA, OpTypeA, beta, C, IC, JC, IsUpper)
        Exit Sub
    End If
    If K >= N Then
        
        '
        ' Split K
        '
        Call ABLASSplitLength(a, K, S1, S2)
        If OpTypeA = 0# Then
            Call RMatrixSYRK(N, S1, alpha, a, IA, JA, OpTypeA, beta, C, IC, JC, IsUpper)
            Call RMatrixSYRK(N, S2, alpha, a, IA, JA + S1, OpTypeA, 1#, C, IC, JC, IsUpper)
        Else
            Call RMatrixSYRK(N, S1, alpha, a, IA, JA, OpTypeA, beta, C, IC, JC, IsUpper)
            Call RMatrixSYRK(N, S2, alpha, a, IA + S1, JA, OpTypeA, 1#, C, IC, JC, IsUpper)
        End If
    Else
        
        '
        ' Split N
        '
        Call ABLASSplitLength(a, N, S1, S2)
        If OpTypeA = 0# And IsUpper Then
            Call RMatrixSYRK(S1, K, alpha, a, IA, JA, OpTypeA, beta, C, IC, JC, IsUpper)
            Call RMatrixGEMM(S1, S2, K, alpha, a, IA, JA, 0#, a, IA + S1, JA, 1#, beta, C, IC, JC + S1)
            Call RMatrixSYRK(S2, K, alpha, a, IA + S1, JA, OpTypeA, beta, C, IC + S1, JC + S1, IsUpper)
            Exit Sub
        End If
        If OpTypeA = 0# And Not IsUpper Then
            Call RMatrixSYRK(S1, K, alpha, a, IA, JA, OpTypeA, beta, C, IC, JC, IsUpper)
            Call RMatrixGEMM(S2, S1, K, alpha, a, IA + S1, JA, 0#, a, IA, JA, 1#, beta, C, IC + S1, JC)
            Call RMatrixSYRK(S2, K, alpha, a, IA + S1, JA, OpTypeA, beta, C, IC + S1, JC + S1, IsUpper)
            Exit Sub
        End If
        If OpTypeA <> 0# And IsUpper Then
            Call RMatrixSYRK(S1, K, alpha, a, IA, JA, OpTypeA, beta, C, IC, JC, IsUpper)
            Call RMatrixGEMM(S1, S2, K, alpha, a, IA, JA, 1#, a, IA, JA + S1, 0#, beta, C, IC, JC + S1)
            Call RMatrixSYRK(S2, K, alpha, a, IA, JA + S1, OpTypeA, beta, C, IC + S1, JC + S1, IsUpper)
            Exit Sub
        End If
        If OpTypeA <> 0# And Not IsUpper Then
            Call RMatrixSYRK(S1, K, alpha, a, IA, JA, OpTypeA, beta, C, IC, JC, IsUpper)
            Call RMatrixGEMM(S2, S1, K, alpha, a, IA, JA + S1, 1#, a, IA, JA, 0#, beta, C, IC + S1, JC)
            Call RMatrixSYRK(S2, K, alpha, a, IA, JA + S1, OpTypeA, beta, C, IC + S1, JC + S1, IsUpper)
            Exit Sub
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This subroutine calculates C = alpha*op1(A)*op2(B) +beta*C where:
'* C is MxN general matrix
'* op1(A) is MxK matrix
'* op2(B) is KxN matrix
'* "op" may be identity transformation, transposition, conjugate transposition
'
'Additional info:
'* cache-oblivious algorithm is used.
'* multiplication result replaces C. If Beta=0, C elements are not used in
'  calculations (not multiplied by zero - just not referenced)
'* if Alpha=0, A is not used (not multiplied by zero - just not referenced)
'* if both Beta and Alpha are zero, C is filled by zeros.
'
'INPUT PARAMETERS
'    N       -   matrix size, N>0
'    M       -   matrix size, N>0
'    K       -   matrix size, K>0
'    Alpha   -   coefficient
'    A       -   matrix
'    IA      -   submatrix offset
'    JA      -   submatrix offset
'    OpTypeA -   transformation type:
'                * 0 - no transformation
'                * 1 - transposition
'                * 2 - conjugate transposition
'    B       -   matrix
'    IB      -   submatrix offset
'    JB      -   submatrix offset
'    OpTypeB -   transformation type:
'                * 0 - no transformation
'                * 1 - transposition
'                * 2 - conjugate transposition
'    Beta    -   coefficient
'    C       -   matrix
'    IC      -   submatrix offset
'    JC      -   submatrix offset
'
'  -- ALGLIB routine --
'     16.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixGEMM(ByVal M As Long, _
         ByVal N As Long, _
         ByVal K As Long, _
         ByRef Alpha_ As Complex, _
         ByRef a() As Complex, _
         ByVal IA As Long, _
         ByVal JA As Long, _
         ByVal OpTypeA As Long, _
         ByRef B() As Complex, _
         ByVal IB As Long, _
         ByVal JB As Long, _
         ByVal OpTypeB As Long, _
         ByRef Beta_ As Complex, _
         ByRef C() As Complex, _
         ByVal IC As Long, _
         ByVal JC As Long)
    Dim alpha As Complex
    Dim beta As Complex
    Dim S1 As Long
    Dim S2 As Long
    Dim BS As Long
    alpha = Alpha_
    beta = Beta_
    BS = ABLASComplexBlockSize(a)
    If M <= BS And N <= BS And K <= BS Then
        Call CMatrixGEMMK(M, N, K, alpha, a, IA, JA, OpTypeA, B, IB, JB, OpTypeB, beta, C, IC, JC)
        Exit Sub
    End If
    If M >= N And M >= K Then
        
        '
        ' A*B = (A1 A2)^T*B
        '
        Call ABLASComplexSplitLength(a, M, S1, S2)
        Call CMatrixGEMM(S1, N, K, alpha, a, IA, JA, OpTypeA, B, IB, JB, OpTypeB, beta, C, IC, JC)
        If OpTypeA = 0# Then
            Call CMatrixGEMM(S2, N, K, alpha, a, IA + S1, JA, OpTypeA, B, IB, JB, OpTypeB, beta, C, IC + S1, JC)
        Else
            Call CMatrixGEMM(S2, N, K, alpha, a, IA, JA + S1, OpTypeA, B, IB, JB, OpTypeB, beta, C, IC + S1, JC)
        End If
        Exit Sub
    End If
    If N >= M And N >= K Then
        
        '
        ' A*B = A*(B1 B2)
        '
        Call ABLASComplexSplitLength(a, N, S1, S2)
        If OpTypeB = 0# Then
            Call CMatrixGEMM(M, S1, K, alpha, a, IA, JA, OpTypeA, B, IB, JB, OpTypeB, beta, C, IC, JC)
            Call CMatrixGEMM(M, S2, K, alpha, a, IA, JA, OpTypeA, B, IB, JB + S1, OpTypeB, beta, C, IC, JC + S1)
        Else
            Call CMatrixGEMM(M, S1, K, alpha, a, IA, JA, OpTypeA, B, IB, JB, OpTypeB, beta, C, IC, JC)
            Call CMatrixGEMM(M, S2, K, alpha, a, IA, JA, OpTypeA, B, IB + S1, JB, OpTypeB, beta, C, IC, JC + S1)
        End If
        Exit Sub
    End If
    If K >= M And K >= N Then
        
        '
        ' A*B = (A1 A2)*(B1 B2)^T
        '
        Call ABLASComplexSplitLength(a, K, S1, S2)
        If OpTypeA = 0# And OpTypeB = 0# Then
            Call CMatrixGEMM(M, N, S1, alpha, a, IA, JA, OpTypeA, B, IB, JB, OpTypeB, beta, C, IC, JC)
            Call CMatrixGEMM(M, N, S2, alpha, a, IA, JA + S1, OpTypeA, B, IB + S1, JB, OpTypeB, C_Complex(1#), C, IC, JC)
        End If
        If OpTypeA = 0# And OpTypeB <> 0# Then
            Call CMatrixGEMM(M, N, S1, alpha, a, IA, JA, OpTypeA, B, IB, JB, OpTypeB, beta, C, IC, JC)
            Call CMatrixGEMM(M, N, S2, alpha, a, IA, JA + S1, OpTypeA, B, IB, JB + S1, OpTypeB, C_Complex(1#), C, IC, JC)
        End If
        If OpTypeA <> 0# And OpTypeB = 0# Then
            Call CMatrixGEMM(M, N, S1, alpha, a, IA, JA, OpTypeA, B, IB, JB, OpTypeB, beta, C, IC, JC)
            Call CMatrixGEMM(M, N, S2, alpha, a, IA + S1, JA, OpTypeA, B, IB + S1, JB, OpTypeB, C_Complex(1#), C, IC, JC)
        End If
        If OpTypeA <> 0# And OpTypeB <> 0# Then
            Call CMatrixGEMM(M, N, S1, alpha, a, IA, JA, OpTypeA, B, IB, JB, OpTypeB, beta, C, IC, JC)
            Call CMatrixGEMM(M, N, S2, alpha, a, IA + S1, JA, OpTypeA, B, IB, JB + S1, OpTypeB, C_Complex(1#), C, IC, JC)
        End If
        Exit Sub
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Same as CMatrixGEMM, but for real numbers.
'OpType may be only 0 or 1.
'
'  -- ALGLIB routine --
'     16.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixGEMM(ByVal M As Long, _
         ByVal N As Long, _
         ByVal K As Long, _
         ByVal alpha As Double, _
         ByRef a() As Double, _
         ByVal IA As Long, _
         ByVal JA As Long, _
         ByVal OpTypeA As Long, _
         ByRef B() As Double, _
         ByVal IB As Long, _
         ByVal JB As Long, _
         ByVal OpTypeB As Long, _
         ByVal beta As Double, _
         ByRef C() As Double, _
         ByVal IC As Long, _
         ByVal JC As Long)
    Dim S1 As Long
    Dim S2 As Long
    Dim BS As Long
    BS = ABLASBlockSize(a)
    If M <= BS And N <= BS And K <= BS Then
        Call RMatrixGEMMK(M, N, K, alpha, a, IA, JA, OpTypeA, B, IB, JB, OpTypeB, beta, C, IC, JC)
        Exit Sub
    End If
    If M >= N And M >= K Then
        
        '
        ' A*B = (A1 A2)^T*B
        '
        Call ABLASSplitLength(a, M, S1, S2)
        If OpTypeA = 0# Then
            Call RMatrixGEMM(S1, N, K, alpha, a, IA, JA, OpTypeA, B, IB, JB, OpTypeB, beta, C, IC, JC)
            Call RMatrixGEMM(S2, N, K, alpha, a, IA + S1, JA, OpTypeA, B, IB, JB, OpTypeB, beta, C, IC + S1, JC)
        Else
            Call RMatrixGEMM(S1, N, K, alpha, a, IA, JA, OpTypeA, B, IB, JB, OpTypeB, beta, C, IC, JC)
            Call RMatrixGEMM(S2, N, K, alpha, a, IA, JA + S1, OpTypeA, B, IB, JB, OpTypeB, beta, C, IC + S1, JC)
        End If
        Exit Sub
    End If
    If N >= M And N >= K Then
        
        '
        ' A*B = A*(B1 B2)
        '
        Call ABLASSplitLength(a, N, S1, S2)
        If OpTypeB = 0# Then
            Call RMatrixGEMM(M, S1, K, alpha, a, IA, JA, OpTypeA, B, IB, JB, OpTypeB, beta, C, IC, JC)
            Call RMatrixGEMM(M, S2, K, alpha, a, IA, JA, OpTypeA, B, IB, JB + S1, OpTypeB, beta, C, IC, JC + S1)
        Else
            Call RMatrixGEMM(M, S1, K, alpha, a, IA, JA, OpTypeA, B, IB, JB, OpTypeB, beta, C, IC, JC)
            Call RMatrixGEMM(M, S2, K, alpha, a, IA, JA, OpTypeA, B, IB + S1, JB, OpTypeB, beta, C, IC, JC + S1)
        End If
        Exit Sub
    End If
    If K >= M And K >= N Then
        
        '
        ' A*B = (A1 A2)*(B1 B2)^T
        '
        Call ABLASSplitLength(a, K, S1, S2)
        If OpTypeA = 0# And OpTypeB = 0# Then
            Call RMatrixGEMM(M, N, S1, alpha, a, IA, JA, OpTypeA, B, IB, JB, OpTypeB, beta, C, IC, JC)
            Call RMatrixGEMM(M, N, S2, alpha, a, IA, JA + S1, OpTypeA, B, IB + S1, JB, OpTypeB, 1#, C, IC, JC)
        End If
        If OpTypeA = 0# And OpTypeB <> 0# Then
            Call RMatrixGEMM(M, N, S1, alpha, a, IA, JA, OpTypeA, B, IB, JB, OpTypeB, beta, C, IC, JC)
            Call RMatrixGEMM(M, N, S2, alpha, a, IA, JA + S1, OpTypeA, B, IB, JB + S1, OpTypeB, 1#, C, IC, JC)
        End If
        If OpTypeA <> 0# And OpTypeB = 0# Then
            Call RMatrixGEMM(M, N, S1, alpha, a, IA, JA, OpTypeA, B, IB, JB, OpTypeB, beta, C, IC, JC)
            Call RMatrixGEMM(M, N, S2, alpha, a, IA + S1, JA, OpTypeA, B, IB + S1, JB, OpTypeB, 1#, C, IC, JC)
        End If
        If OpTypeA <> 0# And OpTypeB <> 0# Then
            Call RMatrixGEMM(M, N, S1, alpha, a, IA, JA, OpTypeA, B, IB, JB, OpTypeB, beta, C, IC, JC)
            Call RMatrixGEMM(M, N, S2, alpha, a, IA + S1, JA, OpTypeA, B, IB, JB + S1, OpTypeB, 1#, C, IC, JC)
        End If
        Exit Sub
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Complex ABLASSplitLength
'
'  -- ALGLIB routine --
'     15.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub ABLASInternalSplitLength(ByVal N As Long, _
         ByVal NB As Long, _
         ByRef N1 As Long, _
         ByRef N2 As Long)
    Dim R As Long
    If N <= NB Then
        
        '
        ' Block size, no further splitting
        '
        N1 = N
        N2 = 0#
    Else
        
        '
        ' Greater than block size
        '
        If N Mod NB <> 0# Then
            
            '
            ' Split remainder
            '
            N2 = N Mod NB
            N1 = N - N2
        Else
            
            '
            ' Split on block boundaries
            '
            N2 = N \ 2#
            N1 = N - N2
            If N1 Mod NB = 0# Then
                Exit Sub
            End If
            R = NB - N1 Mod NB
            N1 = N1 + R
            N2 = N2 - R
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Level 2 variant of CMatrixRightTRSM
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub CMatrixRightTRSM2(ByVal M As Long, _
         ByVal N As Long, _
         ByRef a() As Complex, _
         ByVal I1 As Long, _
         ByVal J1 As Long, _
         ByVal IsUpper As Boolean, _
         ByVal Isunit As Boolean, _
         ByVal OpType As Long, _
         ByRef x() As Complex, _
         ByVal I2 As Long, _
         ByVal J2 As Long)
    Dim i As Long
    Dim j As Long
    Dim VC As Complex
    Dim VD As Complex
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' Special case
    '
    If N * M = 0# Then
        Exit Sub
    End If
    
    '
    ' Try to call fast TRSM
    '
    If CMatrixRightTRSMF(M, N, a, I1, J1, IsUpper, Isunit, OpType, x, I2, J2) Then
        Exit Sub
    End If
    
    '
    ' General case
    '
    If IsUpper Then
        
        '
        ' Upper triangular matrix
        '
        If OpType = 0# Then
            
            '
            ' X*A^(-1)
            '
            For i = 0# To M - 1# Step 1
                For j = 0# To N - 1# Step 1
                    If Isunit Then
                        VD = C_Complex(1#)
                    Else
                        VD = a(I1 + j, J1 + j)
                    End If
                    x(I2 + i, J2 + j) = C_Div(x(I2 + i, J2 + j), VD)
                    If j < N - 1# Then
                        VC = x(I2 + i, J2 + j)
                        i1_ = (J1 + j + 1#) - (J2 + j + 1#)
                        For i_ = J2 + j + 1# To J2 + N - 1# Step 1
                            x(I2 + i, i_) = C_Sub(x(I2 + i, i_), C_Mul(VC, a(I1 + j, i_ + i1_)))
                        Next i_
                    End If
                Next j
            Next i
            Exit Sub
        End If
        If OpType = 1# Then
            
            '
            ' X*A^(-T)
            '
            For i = 0# To M - 1# Step 1
                For j = N - 1# To 0# Step -1
                    VC = C_Complex(0#)
                    VD = C_Complex(1#)
                    If j < N - 1# Then
                        i1_ = (J1 + j + 1#) - (J2 + j + 1#)
                        VC = C_Complex(0#)
                        For i_ = J2 + j + 1# To J2 + N - 1# Step 1
                            VC = C_Add(VC, C_Mul(x(I2 + i, i_), a(I1 + j, i_ + i1_)))
                        Next i_
                    End If
                    If Not Isunit Then
                        VD = a(I1 + j, J1 + j)
                    End If
                    x(I2 + i, J2 + j) = C_Div(C_Sub(x(I2 + i, J2 + j), VC), VD)
                Next j
            Next i
            Exit Sub
        End If
        If OpType = 2# Then
            
            '
            ' X*A^(-H)
            '
            For i = 0# To M - 1# Step 1
                For j = N - 1# To 0# Step -1
                    VC = C_Complex(0#)
                    VD = C_Complex(1#)
                    If j < N - 1# Then
                        i1_ = (J1 + j + 1#) - (J2 + j + 1#)
                        VC = C_Complex(0#)
                        For i_ = J2 + j + 1# To J2 + N - 1# Step 1
                            VC = C_Add(VC, C_Mul(x(I2 + i, i_), Conj(a(I1 + j, i_ + i1_))))
                        Next i_
                    End If
                    If Not Isunit Then
                        VD = Conj(a(I1 + j, J1 + j))
                    End If
                    x(I2 + i, J2 + j) = C_Div(C_Sub(x(I2 + i, J2 + j), VC), VD)
                Next j
            Next i
            Exit Sub
        End If
    Else
        
        '
        ' Lower triangular matrix
        '
        If OpType = 0# Then
            
            '
            ' X*A^(-1)
            '
            For i = 0# To M - 1# Step 1
                For j = N - 1# To 0# Step -1
                    If Isunit Then
                        VD = C_Complex(1#)
                    Else
                        VD = a(I1 + j, J1 + j)
                    End If
                    x(I2 + i, J2 + j) = C_Div(x(I2 + i, J2 + j), VD)
                    If j > 0# Then
                        VC = x(I2 + i, J2 + j)
                        i1_ = (J1) - (J2)
                        For i_ = J2 To J2 + j - 1# Step 1
                            x(I2 + i, i_) = C_Sub(x(I2 + i, i_), C_Mul(VC, a(I1 + j, i_ + i1_)))
                        Next i_
                    End If
                Next j
            Next i
            Exit Sub
        End If
        If OpType = 1# Then
            
            '
            ' X*A^(-T)
            '
            For i = 0# To M - 1# Step 1
                For j = 0# To N - 1# Step 1
                    VC = C_Complex(0#)
                    VD = C_Complex(1#)
                    If j > 0# Then
                        i1_ = (J1) - (J2)
                        VC = C_Complex(0#)
                        For i_ = J2 To J2 + j - 1# Step 1
                            VC = C_Add(VC, C_Mul(x(I2 + i, i_), a(I1 + j, i_ + i1_)))
                        Next i_
                    End If
                    If Not Isunit Then
                        VD = a(I1 + j, J1 + j)
                    End If
                    x(I2 + i, J2 + j) = C_Div(C_Sub(x(I2 + i, J2 + j), VC), VD)
                Next j
            Next i
            Exit Sub
        End If
        If OpType = 2# Then
            
            '
            ' X*A^(-H)
            '
            For i = 0# To M - 1# Step 1
                For j = 0# To N - 1# Step 1
                    VC = C_Complex(0#)
                    VD = C_Complex(1#)
                    If j > 0# Then
                        i1_ = (J1) - (J2)
                        VC = C_Complex(0#)
                        For i_ = J2 To J2 + j - 1# Step 1
                            VC = C_Add(VC, C_Mul(x(I2 + i, i_), Conj(a(I1 + j, i_ + i1_))))
                        Next i_
                    End If
                    If Not Isunit Then
                        VD = Conj(a(I1 + j, J1 + j))
                    End If
                    x(I2 + i, J2 + j) = C_Div(C_Sub(x(I2 + i, J2 + j), VC), VD)
                Next j
            Next i
            Exit Sub
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Level-2 subroutine
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub CMatrixLeftTRSM2(ByVal M As Long, _
         ByVal N As Long, _
         ByRef a() As Complex, _
         ByVal I1 As Long, _
         ByVal J1 As Long, _
         ByVal IsUpper As Boolean, _
         ByVal Isunit As Boolean, _
         ByVal OpType As Long, _
         ByRef x() As Complex, _
         ByVal I2 As Long, _
         ByVal J2 As Long)
    Dim i As Long
    Dim j As Long
    Dim VC As Complex
    Dim VD As Complex
    Dim i_ As Long
    
    '
    ' Special case
    '
    If N * M = 0# Then
        Exit Sub
    End If
    
    '
    ' Try to call fast TRSM
    '
    If CMatrixLeftTRSMF(M, N, a, I1, J1, IsUpper, Isunit, OpType, x, I2, J2) Then
        Exit Sub
    End If
    
    '
    ' General case
    '
    If IsUpper Then
        
        '
        ' Upper triangular matrix
        '
        If OpType = 0# Then
            
            '
            ' A^(-1)*X
            '
            For i = M - 1# To 0# Step -1
                For j = i + 1# To M - 1# Step 1
                    VC = a(I1 + i, J1 + j)
                    For i_ = J2 To J2 + N - 1# Step 1
                        x(I2 + i, i_) = C_Sub(x(I2 + i, i_), C_Mul(VC, x(I2 + j, i_)))
                    Next i_
                Next j
                If Not Isunit Then
                    VD = C_RDiv(1#, a(I1 + i, J1 + i))
                    For i_ = J2 To J2 + N - 1# Step 1
                        x(I2 + i, i_) = C_Mul(VD, x(I2 + i, i_))
                    Next i_
                End If
            Next i
            Exit Sub
        End If
        If OpType = 1# Then
            
            '
            ' A^(-T)*X
            '
            For i = 0# To M - 1# Step 1
                If Isunit Then
                    VD = C_Complex(1#)
                Else
                    VD = C_RDiv(1#, a(I1 + i, J1 + i))
                End If
                For i_ = J2 To J2 + N - 1# Step 1
                    x(I2 + i, i_) = C_Mul(VD, x(I2 + i, i_))
                Next i_
                For j = i + 1# To M - 1# Step 1
                    VC = a(I1 + i, J1 + j)
                    For i_ = J2 To J2 + N - 1# Step 1
                        x(I2 + j, i_) = C_Sub(x(I2 + j, i_), C_Mul(VC, x(I2 + i, i_)))
                    Next i_
                Next j
            Next i
            Exit Sub
        End If
        If OpType = 2# Then
            
            '
            ' A^(-H)*X
            '
            For i = 0# To M - 1# Step 1
                If Isunit Then
                    VD = C_Complex(1#)
                Else
                    VD = C_RDiv(1#, Conj(a(I1 + i, J1 + i)))
                End If
                For i_ = J2 To J2 + N - 1# Step 1
                    x(I2 + i, i_) = C_Mul(VD, x(I2 + i, i_))
                Next i_
                For j = i + 1# To M - 1# Step 1
                    VC = Conj(a(I1 + i, J1 + j))
                    For i_ = J2 To J2 + N - 1# Step 1
                        x(I2 + j, i_) = C_Sub(x(I2 + j, i_), C_Mul(VC, x(I2 + i, i_)))
                    Next i_
                Next j
            Next i
            Exit Sub
        End If
    Else
        
        '
        ' Lower triangular matrix
        '
        If OpType = 0# Then
            
            '
            ' A^(-1)*X
            '
            For i = 0# To M - 1# Step 1
                For j = 0# To i - 1# Step 1
                    VC = a(I1 + i, J1 + j)
                    For i_ = J2 To J2 + N - 1# Step 1
                        x(I2 + i, i_) = C_Sub(x(I2 + i, i_), C_Mul(VC, x(I2 + j, i_)))
                    Next i_
                Next j
                If Isunit Then
                    VD = C_Complex(1#)
                Else
                    VD = C_RDiv(1#, a(I1 + j, J1 + j))
                End If
                For i_ = J2 To J2 + N - 1# Step 1
                    x(I2 + i, i_) = C_Mul(VD, x(I2 + i, i_))
                Next i_
            Next i
            Exit Sub
        End If
        If OpType = 1# Then
            
            '
            ' A^(-T)*X
            '
            For i = M - 1# To 0# Step -1
                If Isunit Then
                    VD = C_Complex(1#)
                Else
                    VD = C_RDiv(1#, a(I1 + i, J1 + i))
                End If
                For i_ = J2 To J2 + N - 1# Step 1
                    x(I2 + i, i_) = C_Mul(VD, x(I2 + i, i_))
                Next i_
                For j = i - 1# To 0# Step -1
                    VC = a(I1 + i, J1 + j)
                    For i_ = J2 To J2 + N - 1# Step 1
                        x(I2 + j, i_) = C_Sub(x(I2 + j, i_), C_Mul(VC, x(I2 + i, i_)))
                    Next i_
                Next j
            Next i
            Exit Sub
        End If
        If OpType = 2# Then
            
            '
            ' A^(-H)*X
            '
            For i = M - 1# To 0# Step -1
                If Isunit Then
                    VD = C_Complex(1#)
                Else
                    VD = C_RDiv(1#, Conj(a(I1 + i, J1 + i)))
                End If
                For i_ = J2 To J2 + N - 1# Step 1
                    x(I2 + i, i_) = C_Mul(VD, x(I2 + i, i_))
                Next i_
                For j = i - 1# To 0# Step -1
                    VC = Conj(a(I1 + i, J1 + j))
                    For i_ = J2 To J2 + N - 1# Step 1
                        x(I2 + j, i_) = C_Sub(x(I2 + j, i_), C_Mul(VC, x(I2 + i, i_)))
                    Next i_
                Next j
            Next i
            Exit Sub
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Level 2 subroutine
'
'  -- ALGLIB routine --
'     15.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub RMatrixRightTRSM2(ByVal M As Long, _
         ByVal N As Long, _
         ByRef a() As Double, _
         ByVal I1 As Long, _
         ByVal J1 As Long, _
         ByVal IsUpper As Boolean, _
         ByVal Isunit As Boolean, _
         ByVal OpType As Long, _
         ByRef x() As Double, _
         ByVal I2 As Long, _
         ByVal J2 As Long)
    Dim i As Long
    Dim j As Long
    Dim VR As Double
    Dim VD As Double
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' Special case
    '
    If N * M = 0# Then
        Exit Sub
    End If
    
    '
    ' Try to use "fast" code
    '
    If RMatrixRightTRSMF(M, N, a, I1, J1, IsUpper, Isunit, OpType, x, I2, J2) Then
        Exit Sub
    End If
    
    '
    ' General case
    '
    If IsUpper Then
        
        '
        ' Upper triangular matrix
        '
        If OpType = 0# Then
            
            '
            ' X*A^(-1)
            '
            For i = 0# To M - 1# Step 1
                For j = 0# To N - 1# Step 1
                    If Isunit Then
                        VD = 1#
                    Else
                        VD = a(I1 + j, J1 + j)
                    End If
                    x(I2 + i, J2 + j) = x(I2 + i, J2 + j) / VD
                    If j < N - 1# Then
                        VR = x(I2 + i, J2 + j)
                        i1_ = (J1 + j + 1#) - (J2 + j + 1#)
                        For i_ = J2 + j + 1# To J2 + N - 1# Step 1
                            x(I2 + i, i_) = x(I2 + i, i_) - VR * a(I1 + j, i_ + i1_)
                        Next i_
                    End If
                Next j
            Next i
            Exit Sub
        End If
        If OpType = 1# Then
            
            '
            ' X*A^(-T)
            '
            For i = 0# To M - 1# Step 1
                For j = N - 1# To 0# Step -1
                    VR = 0#
                    VD = 1#
                    If j < N - 1# Then
                        i1_ = (J1 + j + 1#) - (J2 + j + 1#)
                        VR = 0#
                        For i_ = J2 + j + 1# To J2 + N - 1# Step 1
                            VR = VR + x(I2 + i, i_) * a(I1 + j, i_ + i1_)
                        Next i_
                    End If
                    If Not Isunit Then
                        VD = a(I1 + j, J1 + j)
                    End If
                    x(I2 + i, J2 + j) = (x(I2 + i, J2 + j) - VR) / VD
                Next j
            Next i
            Exit Sub
        End If
    Else
        
        '
        ' Lower triangular matrix
        '
        If OpType = 0# Then
            
            '
            ' X*A^(-1)
            '
            For i = 0# To M - 1# Step 1
                For j = N - 1# To 0# Step -1
                    If Isunit Then
                        VD = 1#
                    Else
                        VD = a(I1 + j, J1 + j)
                    End If
                    x(I2 + i, J2 + j) = x(I2 + i, J2 + j) / VD
                    If j > 0# Then
                        VR = x(I2 + i, J2 + j)
                        i1_ = (J1) - (J2)
                        For i_ = J2 To J2 + j - 1# Step 1
                            x(I2 + i, i_) = x(I2 + i, i_) - VR * a(I1 + j, i_ + i1_)
                        Next i_
                    End If
                Next j
            Next i
            Exit Sub
        End If
        If OpType = 1# Then
            
            '
            ' X*A^(-T)
            '
            For i = 0# To M - 1# Step 1
                For j = 0# To N - 1# Step 1
                    VR = 0#
                    VD = 1#
                    If j > 0# Then
                        i1_ = (J1) - (J2)
                        VR = 0#
                        For i_ = J2 To J2 + j - 1# Step 1
                            VR = VR + x(I2 + i, i_) * a(I1 + j, i_ + i1_)
                        Next i_
                    End If
                    If Not Isunit Then
                        VD = a(I1 + j, J1 + j)
                    End If
                    x(I2 + i, J2 + j) = (x(I2 + i, J2 + j) - VR) / VD
                Next j
            Next i
            Exit Sub
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Level 2 subroutine
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub RMatrixLeftTRSM2(ByVal M As Long, _
         ByVal N As Long, _
         ByRef a() As Double, _
         ByVal I1 As Long, _
         ByVal J1 As Long, _
         ByVal IsUpper As Boolean, _
         ByVal Isunit As Boolean, _
         ByVal OpType As Long, _
         ByRef x() As Double, _
         ByVal I2 As Long, _
         ByVal J2 As Long)
    Dim i As Long
    Dim j As Long
    Dim VR As Double
    Dim VD As Double
    Dim i_ As Long
    
    '
    ' Special case
    '
    If N * M = 0# Then
        Exit Sub
    End If
    
    '
    ' Try fast code
    '
    If RMatrixLeftTRSMF(M, N, a, I1, J1, IsUpper, Isunit, OpType, x, I2, J2) Then
        Exit Sub
    End If
    
    '
    ' General case
    '
    If IsUpper Then
        
        '
        ' Upper triangular matrix
        '
        If OpType = 0# Then
            
            '
            ' A^(-1)*X
            '
            For i = M - 1# To 0# Step -1
                For j = i + 1# To M - 1# Step 1
                    VR = a(I1 + i, J1 + j)
                    For i_ = J2 To J2 + N - 1# Step 1
                        x(I2 + i, i_) = x(I2 + i, i_) - VR * x(I2 + j, i_)
                    Next i_
                Next j
                If Not Isunit Then
                    VD = 1# / a(I1 + i, J1 + i)
                    For i_ = J2 To J2 + N - 1# Step 1
                        x(I2 + i, i_) = VD * x(I2 + i, i_)
                    Next i_
                End If
            Next i
            Exit Sub
        End If
        If OpType = 1# Then
            
            '
            ' A^(-T)*X
            '
            For i = 0# To M - 1# Step 1
                If Isunit Then
                    VD = 1#
                Else
                    VD = 1# / a(I1 + i, J1 + i)
                End If
                For i_ = J2 To J2 + N - 1# Step 1
                    x(I2 + i, i_) = VD * x(I2 + i, i_)
                Next i_
                For j = i + 1# To M - 1# Step 1
                    VR = a(I1 + i, J1 + j)
                    For i_ = J2 To J2 + N - 1# Step 1
                        x(I2 + j, i_) = x(I2 + j, i_) - VR * x(I2 + i, i_)
                    Next i_
                Next j
            Next i
            Exit Sub
        End If
    Else
        
        '
        ' Lower triangular matrix
        '
        If OpType = 0# Then
            
            '
            ' A^(-1)*X
            '
            For i = 0# To M - 1# Step 1
                For j = 0# To i - 1# Step 1
                    VR = a(I1 + i, J1 + j)
                    For i_ = J2 To J2 + N - 1# Step 1
                        x(I2 + i, i_) = x(I2 + i, i_) - VR * x(I2 + j, i_)
                    Next i_
                Next j
                If Isunit Then
                    VD = 1#
                Else
                    VD = 1# / a(I1 + j, J1 + j)
                End If
                For i_ = J2 To J2 + N - 1# Step 1
                    x(I2 + i, i_) = VD * x(I2 + i, i_)
                Next i_
            Next i
            Exit Sub
        End If
        If OpType = 1# Then
            
            '
            ' A^(-T)*X
            '
            For i = M - 1# To 0# Step -1
                If Isunit Then
                    VD = 1#
                Else
                    VD = 1# / a(I1 + i, J1 + i)
                End If
                For i_ = J2 To J2 + N - 1# Step 1
                    x(I2 + i, i_) = VD * x(I2 + i, i_)
                Next i_
                For j = i - 1# To 0# Step -1
                    VR = a(I1 + i, J1 + j)
                    For i_ = J2 To J2 + N - 1# Step 1
                        x(I2 + j, i_) = x(I2 + j, i_) - VR * x(I2 + i, i_)
                    Next i_
                Next j
            Next i
            Exit Sub
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Level 2 subroutine
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub CMatrixSYRK2(ByVal N As Long, _
         ByVal K As Long, _
         ByVal alpha As Double, _
         ByRef a() As Complex, _
         ByVal IA As Long, _
         ByVal JA As Long, _
         ByVal OpTypeA As Long, _
         ByVal beta As Double, _
         ByRef C() As Complex, _
         ByVal IC As Long, _
         ByVal JC As Long, _
         ByVal IsUpper As Boolean)
    Dim i As Long
    Dim j As Long
    Dim J1 As Long
    Dim J2 As Long
    Dim V As Complex
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' Fast exit (nothing to be done)
    '
    If (alpha = 0# Or K = 0#) And beta = 1# Then
        Exit Sub
    End If
    
    '
    ' Try to call fast SYRK
    '
    If CMatrixSYRKF(N, K, alpha, a, IA, JA, OpTypeA, beta, C, IC, JC, IsUpper) Then
        Exit Sub
    End If
    
    '
    ' SYRK
    '
    If OpTypeA = 0# Then
        
        '
        ' C=alpha*A*A^H+beta*C
        '
        For i = 0# To N - 1# Step 1
            If IsUpper Then
                J1 = i
                J2 = N - 1#
            Else
                J1 = 0#
                J2 = i
            End If
            For j = J1 To J2 Step 1
                If alpha <> 0# And K > 0# Then
                    V = C_Complex(0#)
                    For i_ = JA To JA + K - 1# Step 1
                        V = C_Add(V, C_Mul(a(IA + i, i_), Conj(a(IA + j, i_))))
                    Next i_
                Else
                    V = C_Complex(0#)
                End If
                If beta = 0# Then
                    C(IC + i, JC + j) = C_MulR(V, alpha)
                Else
                    C(IC + i, JC + j) = C_Add(C_MulR(C(IC + i, JC + j), beta), C_MulR(V, alpha))
                End If
            Next j
        Next i
        Exit Sub
    Else
        
        '
        ' C=alpha*A^H*A+beta*C
        '
        For i = 0# To N - 1# Step 1
            If IsUpper Then
                J1 = i
                J2 = N - 1#
            Else
                J1 = 0#
                J2 = i
            End If
            If beta = 0# Then
                For j = J1 To J2 Step 1
                    C(IC + i, JC + j) = C_Complex(0#)
                Next j
            Else
                For i_ = JC + J1 To JC + J2 Step 1
                    C(IC + i, i_) = C_MulR(C(IC + i, i_), beta)
                Next i_
            End If
        Next i
        For i = 0# To K - 1# Step 1
            For j = 0# To N - 1# Step 1
                If IsUpper Then
                    J1 = j
                    J2 = N - 1#
                Else
                    J1 = 0#
                    J2 = j
                End If
                V = C_MulR(Conj(a(IA + i, JA + j)), alpha)
                i1_ = (JA + J1) - (JC + J1)
                For i_ = JC + J1 To JC + J2 Step 1
                    C(IC + j, i_) = C_Add(C(IC + j, i_), C_Mul(V, a(IA + i, i_ + i1_)))
                Next i_
            Next j
        Next i
        Exit Sub
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Level 2 subrotuine
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub RMatrixSYRK2(ByVal N As Long, _
         ByVal K As Long, _
         ByVal alpha As Double, _
         ByRef a() As Double, _
         ByVal IA As Long, _
         ByVal JA As Long, _
         ByVal OpTypeA As Long, _
         ByVal beta As Double, _
         ByRef C() As Double, _
         ByVal IC As Long, _
         ByVal JC As Long, _
         ByVal IsUpper As Boolean)
    Dim i As Long
    Dim j As Long
    Dim J1 As Long
    Dim J2 As Long
    Dim V As Double
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' Fast exit (nothing to be done)
    '
    If (alpha = 0# Or K = 0#) And beta = 1# Then
        Exit Sub
    End If
    
    '
    ' Try to call fast SYRK
    '
    If RMatrixSYRKF(N, K, alpha, a, IA, JA, OpTypeA, beta, C, IC, JC, IsUpper) Then
        Exit Sub
    End If
    
    '
    ' SYRK
    '
    If OpTypeA = 0# Then
        
        '
        ' C=alpha*A*A^H+beta*C
        '
        For i = 0# To N - 1# Step 1
            If IsUpper Then
                J1 = i
                J2 = N - 1#
            Else
                J1 = 0#
                J2 = i
            End If
            For j = J1 To J2 Step 1
                If alpha <> 0# And K > 0# Then
                    V = 0#
                    For i_ = JA To JA + K - 1# Step 1
                        V = V + a(IA + i, i_) * a(IA + j, i_)
                    Next i_
                Else
                    V = 0#
                End If
                If beta = 0# Then
                    C(IC + i, JC + j) = alpha * V
                Else
                    C(IC + i, JC + j) = beta * C(IC + i, JC + j) + alpha * V
                End If
            Next j
        Next i
        Exit Sub
    Else
        
        '
        ' C=alpha*A^H*A+beta*C
        '
        For i = 0# To N - 1# Step 1
            If IsUpper Then
                J1 = i
                J2 = N - 1#
            Else
                J1 = 0#
                J2 = i
            End If
            If beta = 0# Then
                For j = J1 To J2 Step 1
                    C(IC + i, JC + j) = 0#
                Next j
            Else
                For i_ = JC + J1 To JC + J2 Step 1
                    C(IC + i, i_) = beta * C(IC + i, i_)
                Next i_
            End If
        Next i
        For i = 0# To K - 1# Step 1
            For j = 0# To N - 1# Step 1
                If IsUpper Then
                    J1 = j
                    J2 = N - 1#
                Else
                    J1 = 0#
                    J2 = j
                End If
                V = alpha * a(IA + i, JA + j)
                i1_ = (JA + J1) - (JC + J1)
                For i_ = JC + J1 To JC + J2 Step 1
                    C(IC + j, i_) = C(IC + j, i_) + V * a(IA + i, i_ + i1_)
                Next i_
            Next j
        Next i
        Exit Sub
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'GEMM kernel
'
'  -- ALGLIB routine --
'     16.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub CMatrixGEMMK(ByVal M As Long, _
         ByVal N As Long, _
         ByVal K As Long, _
         ByRef Alpha_ As Complex, _
         ByRef a() As Complex, _
         ByVal IA As Long, _
         ByVal JA As Long, _
         ByVal OpTypeA As Long, _
         ByRef B() As Complex, _
         ByVal IB As Long, _
         ByVal JB As Long, _
         ByVal OpTypeB As Long, _
         ByRef Beta_ As Complex, _
         ByRef C() As Complex, _
         ByVal IC As Long, _
         ByVal JC As Long)
    Dim alpha As Complex
    Dim beta As Complex
    Dim i As Long
    Dim j As Long
    Dim V As Complex
    Dim i_ As Long
    Dim i1_ As Long
    alpha = Alpha_
    beta = Beta_
    
    '
    ' Special case
    '
    If M * N = 0# Then
        Exit Sub
    End If
    
    '
    ' Try optimized code
    '
    If CMatrixGEMMF(M, N, K, alpha, a, IA, JA, OpTypeA, B, IB, JB, OpTypeB, beta, C, IC, JC) Then
        Exit Sub
    End If
    
    '
    ' Another special case
    '
    If K = 0# Then
        If C_NotEqualR(beta, 0#) Then
            For i = 0# To M - 1# Step 1
                For j = 0# To N - 1# Step 1
                    C(IC + i, JC + j) = C_Mul(beta, C(IC + i, JC + j))
                Next j
            Next i
        Else
            For i = 0# To M - 1# Step 1
                For j = 0# To N - 1# Step 1
                    C(IC + i, JC + j) = C_Complex(0#)
                Next j
            Next i
        End If
        Exit Sub
    End If
    
    '
    ' General case
    '
    If OpTypeA = 0# And OpTypeB <> 0# Then
        
        '
        ' A*B'
        '
        For i = 0# To M - 1# Step 1
            For j = 0# To N - 1# Step 1
                If K = 0# Or C_EqualR(alpha, 0#) Then
                    V = C_Complex(0#)
                Else
                    If OpTypeB = 1# Then
                        i1_ = (JB) - (JA)
                        V = C_Complex(0#)
                        For i_ = JA To JA + K - 1# Step 1
                            V = C_Add(V, C_Mul(a(IA + i, i_), B(IB + j, i_ + i1_)))
                        Next i_
                    Else
                        i1_ = (JB) - (JA)
                        V = C_Complex(0#)
                        For i_ = JA To JA + K - 1# Step 1
                            V = C_Add(V, C_Mul(a(IA + i, i_), Conj(B(IB + j, i_ + i1_))))
                        Next i_
                    End If
                End If
                If C_EqualR(beta, 0#) Then
                    C(IC + i, JC + j) = C_Mul(alpha, V)
                Else
                    C(IC + i, JC + j) = C_Add(C_Mul(beta, C(IC + i, JC + j)), C_Mul(alpha, V))
                End If
            Next j
        Next i
        Exit Sub
    End If
    If OpTypeA = 0# And OpTypeB = 0# Then
        
        '
        ' A*B
        '
        For i = 0# To M - 1# Step 1
            If C_NotEqualR(beta, 0#) Then
                For i_ = JC To JC + N - 1# Step 1
                    C(IC + i, i_) = C_Mul(beta, C(IC + i, i_))
                Next i_
            Else
                For j = 0# To N - 1# Step 1
                    C(IC + i, JC + j) = C_Complex(0#)
                Next j
            End If
            If C_NotEqualR(alpha, 0#) Then
                For j = 0# To K - 1# Step 1
                    V = C_Mul(alpha, a(IA + i, JA + j))
                    i1_ = (JB) - (JC)
                    For i_ = JC To JC + N - 1# Step 1
                        C(IC + i, i_) = C_Add(C(IC + i, i_), C_Mul(V, B(IB + j, i_ + i1_)))
                    Next i_
                Next j
            End If
        Next i
        Exit Sub
    End If
    If OpTypeA <> 0# And OpTypeB <> 0# Then
        
        '
        ' A'*B'
        '
        For i = 0# To M - 1# Step 1
            For j = 0# To N - 1# Step 1
                If C_EqualR(alpha, 0#) Then
                    V = C_Complex(0#)
                Else
                    If OpTypeA = 1# Then
                        If OpTypeB = 1# Then
                            i1_ = (JB) - (IA)
                            V = C_Complex(0#)
                            For i_ = IA To IA + K - 1# Step 1
                                V = C_Add(V, C_Mul(a(i_, JA + i), B(IB + j, i_ + i1_)))
                            Next i_
                        Else
                            i1_ = (JB) - (IA)
                            V = C_Complex(0#)
                            For i_ = IA To IA + K - 1# Step 1
                                V = C_Add(V, C_Mul(a(i_, JA + i), Conj(B(IB + j, i_ + i1_))))
                            Next i_
                        End If
                    Else
                        If OpTypeB = 1# Then
                            i1_ = (JB) - (IA)
                            V = C_Complex(0#)
                            For i_ = IA To IA + K - 1# Step 1
                                V = C_Add(V, C_Mul(Conj(a(i_, JA + i)), B(IB + j, i_ + i1_)))
                            Next i_
                        Else
                            i1_ = (JB) - (IA)
                            V = C_Complex(0#)
                            For i_ = IA To IA + K - 1# Step 1
                                V = C_Add(V, C_Mul(Conj(a(i_, JA + i)), Conj(B(IB + j, i_ + i1_))))
                            Next i_
                        End If
                    End If
                End If
                If C_EqualR(beta, 0#) Then
                    C(IC + i, JC + j) = C_Mul(alpha, V)
                Else
                    C(IC + i, JC + j) = C_Add(C_Mul(beta, C(IC + i, JC + j)), C_Mul(alpha, V))
                End If
            Next j
        Next i
        Exit Sub
    End If
    If OpTypeA <> 0# And OpTypeB = 0# Then
        
        '
        ' A'*B
        '
        If C_EqualR(beta, 0#) Then
            For i = 0# To M - 1# Step 1
                For j = 0# To N - 1# Step 1
                    C(IC + i, JC + j) = C_Complex(0#)
                Next j
            Next i
        Else
            For i = 0# To M - 1# Step 1
                For i_ = JC To JC + N - 1# Step 1
                    C(IC + i, i_) = C_Mul(beta, C(IC + i, i_))
                Next i_
            Next i
        End If
        If C_NotEqualR(alpha, 0#) Then
            For j = 0# To K - 1# Step 1
                For i = 0# To M - 1# Step 1
                    If OpTypeA = 1# Then
                        V = C_Mul(alpha, a(IA + j, JA + i))
                    Else
                        V = C_Mul(alpha, Conj(a(IA + j, JA + i)))
                    End If
                    i1_ = (JB) - (JC)
                    For i_ = JC To JC + N - 1# Step 1
                        C(IC + i, i_) = C_Add(C(IC + i, i_), C_Mul(V, B(IB + j, i_ + i1_)))
                    Next i_
                Next i
            Next j
        End If
        Exit Sub
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'GEMM kernel
'
'  -- ALGLIB routine --
'     16.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub RMatrixGEMMK(ByVal M As Long, _
         ByVal N As Long, _
         ByVal K As Long, _
         ByVal alpha As Double, _
         ByRef a() As Double, _
         ByVal IA As Long, _
         ByVal JA As Long, _
         ByVal OpTypeA As Long, _
         ByRef B() As Double, _
         ByVal IB As Long, _
         ByVal JB As Long, _
         ByVal OpTypeB As Long, _
         ByVal beta As Double, _
         ByRef C() As Double, _
         ByVal IC As Long, _
         ByVal JC As Long)
    Dim i As Long
    Dim j As Long
    Dim V As Double
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' if matrix size is zero
    '
    If M * N = 0# Then
        Exit Sub
    End If
    
    '
    ' Try optimized code
    '
    If RMatrixGEMMF(M, N, K, alpha, a, IA, JA, OpTypeA, B, IB, JB, OpTypeB, beta, C, IC, JC) Then
        Exit Sub
    End If
    
    '
    ' if K=0, then C=Beta*C
    '
    If K = 0# Then
        If beta <> 1# Then
            If beta <> 0# Then
                For i = 0# To M - 1# Step 1
                    For j = 0# To N - 1# Step 1
                        C(IC + i, JC + j) = beta * C(IC + i, JC + j)
                    Next j
                Next i
            Else
                For i = 0# To M - 1# Step 1
                    For j = 0# To N - 1# Step 1
                        C(IC + i, JC + j) = 0#
                    Next j
                Next i
            End If
        End If
        Exit Sub
    End If
    
    '
    ' General case
    '
    If OpTypeA = 0# And OpTypeB <> 0# Then
        
        '
        ' A*B'
        '
        For i = 0# To M - 1# Step 1
            For j = 0# To N - 1# Step 1
                If K = 0# Or alpha = 0# Then
                    V = 0#
                Else
                    i1_ = (JB) - (JA)
                    V = 0#
                    For i_ = JA To JA + K - 1# Step 1
                        V = V + a(IA + i, i_) * B(IB + j, i_ + i1_)
                    Next i_
                End If
                If beta = 0# Then
                    C(IC + i, JC + j) = alpha * V
                Else
                    C(IC + i, JC + j) = beta * C(IC + i, JC + j) + alpha * V
                End If
            Next j
        Next i
        Exit Sub
    End If
    If OpTypeA = 0# And OpTypeB = 0# Then
        
        '
        ' A*B
        '
        For i = 0# To M - 1# Step 1
            If beta <> 0# Then
                For i_ = JC To JC + N - 1# Step 1
                    C(IC + i, i_) = beta * C(IC + i, i_)
                Next i_
            Else
                For j = 0# To N - 1# Step 1
                    C(IC + i, JC + j) = 0#
                Next j
            End If
            If alpha <> 0# Then
                For j = 0# To K - 1# Step 1
                    V = alpha * a(IA + i, JA + j)
                    i1_ = (JB) - (JC)
                    For i_ = JC To JC + N - 1# Step 1
                        C(IC + i, i_) = C(IC + i, i_) + V * B(IB + j, i_ + i1_)
                    Next i_
                Next j
            End If
        Next i
        Exit Sub
    End If
    If OpTypeA <> 0# And OpTypeB <> 0# Then
        
        '
        ' A'*B'
        '
        For i = 0# To M - 1# Step 1
            For j = 0# To N - 1# Step 1
                If alpha = 0# Then
                    V = 0#
                Else
                    i1_ = (JB) - (IA)
                    V = 0#
                    For i_ = IA To IA + K - 1# Step 1
                        V = V + a(i_, JA + i) * B(IB + j, i_ + i1_)
                    Next i_
                End If
                If beta = 0# Then
                    C(IC + i, JC + j) = alpha * V
                Else
                    C(IC + i, JC + j) = beta * C(IC + i, JC + j) + alpha * V
                End If
            Next j
        Next i
        Exit Sub
    End If
    If OpTypeA <> 0# And OpTypeB = 0# Then
        
        '
        ' A'*B
        '
        If beta = 0# Then
            For i = 0# To M - 1# Step 1
                For j = 0# To N - 1# Step 1
                    C(IC + i, JC + j) = 0#
                Next j
            Next i
        Else
            For i = 0# To M - 1# Step 1
                For i_ = JC To JC + N - 1# Step 1
                    C(IC + i, i_) = beta * C(IC + i, i_)
                Next i_
            Next i
        End If
        If alpha <> 0# Then
            For j = 0# To K - 1# Step 1
                For i = 0# To M - 1# Step 1
                    V = alpha * a(IA + j, JA + i)
                    i1_ = (JB) - (JC)
                    For i_ = JC To JC + N - 1# Step 1
                        C(IC + i, i_) = C(IC + i, i_) + V * B(IB + j, i_ + i1_)
                    Next i_
                Next i
            Next j
        End If
        Exit Sub
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2009, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Fast kernel
'
'  -- ALGLIB routine --
'     19.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function CMatrixRank1F(ByVal M As Long, _
         ByVal N As Long, _
         ByRef a() As Complex, _
         ByVal IA As Long, _
         ByVal JA As Long, _
         ByRef U() As Complex, _
         ByVal IU As Long, _
         ByRef V() As Complex, _
         ByVal IV As Long) As Boolean
    Dim Result As Boolean
    Result = False
    CMatrixRank1F = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Fast kernel
'
'  -- ALGLIB routine --
'     19.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function RMatrixRank1F(ByVal M As Long, _
         ByVal N As Long, _
         ByRef a() As Double, _
         ByVal IA As Long, _
         ByVal JA As Long, _
         ByRef U() As Double, _
         ByVal IU As Long, _
         ByRef V() As Double, _
         ByVal IV As Long) As Boolean
    Dim Result As Boolean
    Result = False
    RMatrixRank1F = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Fast kernel
'
'  -- ALGLIB routine --
'     19.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function CMatrixMVF(ByVal M As Long, _
         ByVal N As Long, _
         ByRef a() As Complex, _
         ByVal IA As Long, _
         ByVal JA As Long, _
         ByVal OpA As Long, _
         ByRef x() As Complex, _
         ByVal IX As Long, _
         ByRef y() As Complex, _
         ByVal IY As Long) As Boolean
    Dim Result As Boolean
    Result = False
    CMatrixMVF = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Fast kernel
'
'  -- ALGLIB routine --
'     19.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function RMatrixMVF(ByVal M As Long, _
         ByVal N As Long, _
         ByRef a() As Double, _
         ByVal IA As Long, _
         ByVal JA As Long, _
         ByVal OpA As Long, _
         ByRef x() As Double, _
         ByVal IX As Long, _
         ByRef y() As Double, _
         ByVal IY As Long) As Boolean
    Dim Result As Boolean
    Result = False
    RMatrixMVF = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Fast kernel
'
'  -- ALGLIB routine --
'     19.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function CMatrixRightTRSMF(ByVal M As Long, _
         ByVal N As Long, _
         ByRef a() As Complex, _
         ByVal I1 As Long, _
         ByVal J1 As Long, _
         ByVal IsUpper As Boolean, _
         ByVal Isunit As Boolean, _
         ByVal OpType As Long, _
         ByRef x() As Complex, _
         ByVal I2 As Long, _
         ByVal J2 As Long) As Boolean
    Dim Result As Boolean
    Result = False
    CMatrixRightTRSMF = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Fast kernel
'
'  -- ALGLIB routine --
'     19.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function CMatrixLeftTRSMF(ByVal M As Long, _
         ByVal N As Long, _
         ByRef a() As Complex, _
         ByVal I1 As Long, _
         ByVal J1 As Long, _
         ByVal IsUpper As Boolean, _
         ByVal Isunit As Boolean, _
         ByVal OpType As Long, _
         ByRef x() As Complex, _
         ByVal I2 As Long, _
         ByVal J2 As Long) As Boolean
    Dim Result As Boolean
    Result = False
    CMatrixLeftTRSMF = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Fast kernel
'
'  -- ALGLIB routine --
'     19.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function RMatrixRightTRSMF(ByVal M As Long, _
         ByVal N As Long, _
         ByRef a() As Double, _
         ByVal I1 As Long, _
         ByVal J1 As Long, _
         ByVal IsUpper As Boolean, _
         ByVal Isunit As Boolean, _
         ByVal OpType As Long, _
         ByRef x() As Double, _
         ByVal I2 As Long, _
         ByVal J2 As Long) As Boolean
    Dim Result As Boolean
    Result = False
    RMatrixRightTRSMF = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Fast kernel
'
'  -- ALGLIB routine --
'     19.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function RMatrixLeftTRSMF(ByVal M As Long, _
         ByVal N As Long, _
         ByRef a() As Double, _
         ByVal I1 As Long, _
         ByVal J1 As Long, _
         ByVal IsUpper As Boolean, _
         ByVal Isunit As Boolean, _
         ByVal OpType As Long, _
         ByRef x() As Double, _
         ByVal I2 As Long, _
         ByVal J2 As Long) As Boolean
    Dim Result As Boolean
    Result = False
    RMatrixLeftTRSMF = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Fast kernel
'
'  -- ALGLIB routine --
'     19.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function CMatrixSYRKF(ByVal N As Long, _
         ByVal K As Long, _
         ByVal alpha As Double, _
         ByRef a() As Complex, _
         ByVal IA As Long, _
         ByVal JA As Long, _
         ByVal OpTypeA As Long, _
         ByVal beta As Double, _
         ByRef C() As Complex, _
         ByVal IC As Long, _
         ByVal JC As Long, _
         ByVal IsUpper As Boolean) As Boolean
    Dim Result As Boolean
    Result = False
    CMatrixSYRKF = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Fast kernel
'
'  -- ALGLIB routine --
'     19.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function RMatrixSYRKF(ByVal N As Long, _
         ByVal K As Long, _
         ByVal alpha As Double, _
         ByRef a() As Double, _
         ByVal IA As Long, _
         ByVal JA As Long, _
         ByVal OpTypeA As Long, _
         ByVal beta As Double, _
         ByRef C() As Double, _
         ByVal IC As Long, _
         ByVal JC As Long, _
         ByVal IsUpper As Boolean) As Boolean
    Dim Result As Boolean
    Result = False
    RMatrixSYRKF = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Fast kernel
'
'  -- ALGLIB routine --
'     19.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function RMatrixGEMMF(ByVal M As Long, _
         ByVal N As Long, _
         ByVal K As Long, _
         ByVal alpha As Double, _
         ByRef a() As Double, _
         ByVal IA As Long, _
         ByVal JA As Long, _
         ByVal OpTypeA As Long, _
         ByRef B() As Double, _
         ByVal IB As Long, _
         ByVal JB As Long, _
         ByVal OpTypeB As Long, _
         ByVal beta As Double, _
         ByRef C() As Double, _
         ByVal IC As Long, _
         ByVal JC As Long) As Boolean
    Dim Result As Boolean
    Result = False
    RMatrixGEMMF = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Fast kernel
'
'  -- ALGLIB routine --
'     19.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function CMatrixGEMMF(ByVal M As Long, _
         ByVal N As Long, _
         ByVal K As Long, _
         ByRef Alpha_ As Complex, _
         ByRef a() As Complex, _
         ByVal IA As Long, _
         ByVal JA As Long, _
         ByVal OpTypeA As Long, _
         ByRef B() As Complex, _
         ByVal IB As Long, _
         ByVal JB As Long, _
         ByVal OpTypeB As Long, _
         ByRef Beta_ As Complex, _
         ByRef C() As Complex, _
         ByVal IC As Long, _
         ByVal JC As Long) As Boolean
    Dim Result As Boolean
    Dim alpha As Complex
    Dim beta As Complex
    alpha = Alpha_
    beta = Beta_
    Result = False
    CMatrixGEMMF = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 1992-2007 The University of Tennessee.  All rights reserved.
'
'Contributors:
'    * Sergey Bochkanov (ALGLIB project). Translation from FORTRAN to
'      pseudocode.
'
'See subroutines comments for additional copyrights.
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Singular value decomposition of a bidiagonal matrix (extended algorithm)
'
'The algorithm performs the singular value decomposition  of  a  bidiagonal
'matrix B (upper or lower) representing it as B = Q*S*P^T, where Q and  P -
'orthogonal matrices, S - diagonal matrix with non-negative elements on the
'main diagonal, in descending order.
'
'The  algorithm  finds  singular  values.  In  addition,  the algorithm can
'calculate  matrices  Q  and P (more precisely, not the matrices, but their
'product  with  given  matrices U and VT - U*Q and (P^T)*VT)).  Of  course,
'matrices U and VT can be of any type, including identity. Furthermore, the
'algorithm can calculate Q'*C (this product is calculated more  effectively
'than U*Q,  because  this calculation operates with rows instead  of matrix
'columns).
'
'The feature of the algorithm is its ability to find  all  singular  values
'including those which are arbitrarily close to 0  with  relative  accuracy
'close to  machine precision. If the parameter IsFractionalAccuracyRequired
'is set to True, all singular values will have high relative accuracy close
'to machine precision. If the parameter is set to False, only  the  biggest
'singular value will have relative accuracy  close  to  machine  precision.
'The absolute error of other singular values is equal to the absolute error
'of the biggest singular value.
'
'Input parameters:
'    D       -   main diagonal of matrix B.
'                Array whose index ranges within [0..N-1].
'    E       -   superdiagonal (or subdiagonal) of matrix B.
'                Array whose index ranges within [0..N-2].
'    N       -   size of matrix B.
'    IsUpper -   True, if the matrix is upper bidiagonal.
'    IsFractionalAccuracyRequired -
'                accuracy to search singular values with.
'    U       -   matrix to be multiplied by Q.
'                Array whose indexes range within [0..NRU-1, 0..N-1].
'                The matrix can be bigger, in that case only the  submatrix
'                [0..NRU-1, 0..N-1] will be multiplied by Q.
'    NRU     -   number of rows in matrix U.
'    C       -   matrix to be multiplied by Q'.
'                Array whose indexes range within [0..N-1, 0..NCC-1].
'                The matrix can be bigger, in that case only the  submatrix
'                [0..N-1, 0..NCC-1] will be multiplied by Q'.
'    NCC     -   number of columns in matrix C.
'    VT      -   matrix to be multiplied by P^T.
'                Array whose indexes range within [0..N-1, 0..NCVT-1].
'                The matrix can be bigger, in that case only the  submatrix
'                [0..N-1, 0..NCVT-1] will be multiplied by P^T.
'    NCVT    -   number of columns in matrix VT.
'
'Output parameters:
'    D       -   singular values of matrix B in descending order.
'    U       -   if NRU>0, contains matrix U*Q.
'    VT      -   if NCVT>0, contains matrix (P^T)*VT.
'    C       -   if NCC>0, contains matrix Q'*C.
'
'Result:
'    True, if the algorithm has converged.
'    False, if the algorithm hasn't converged (rare case).
'
'Additional information:
'    The type of convergence is controlled by the internal  parameter  TOL.
'    If the parameter is greater than 0, the singular values will have
'    relative accuracy TOL. If TOL<0, the singular values will have
'    absolute accuracy ABS(TOL)*norm(B).
'    By default, |TOL| falls within the range of 10*Epsilon and 100*Epsilon,
'    where Epsilon is the machine precision. It is not  recommended  to  use
'    TOL less than 10*Epsilon since this will  considerably  slow  down  the
'    algorithm and may not lead to error decreasing.
'History:
'    * 31 March, 2007.
'        changed MAXITR from 6 to 12.
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     October 31, 1999.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function RMatrixBDSVD(ByRef d() As Double, _
         ByRef E_() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByVal IsFractionalAccuracyRequired As Boolean, _
         ByRef U() As Double, _
         ByVal NRU As Long, _
         ByRef C() As Double, _
         ByVal NCC As Long, _
         ByRef VT() As Double, _
         ByVal NCVT As Long) As Boolean
    Dim Result As Boolean
    Dim e() As Double
    Dim d1() As Double
    Dim E1() As Double
    Dim i_ As Long
    Dim i1_ As Long
    e = E_
    ReDim d1(1# To N)
    i1_ = (0#) - (1#)
    For i_ = 1# To N Step 1
        d1(i_) = d(i_ + i1_)
    Next i_
    If N > 1# Then
        ReDim E1(1# To N - 1#)
        i1_ = (0#) - (1#)
        For i_ = 1# To N - 1# Step 1
            E1(i_) = e(i_ + i1_)
        Next i_
    End If
    Result = BidiagonalSVDDecompositionInternal(d1, E1, N, IsUpper, IsFractionalAccuracyRequired, U, 0#, NRU, C, 0#, NCC, VT, 0#, NCVT)
    i1_ = (1#) - (0#)
    For i_ = 0# To N - 1# Step 1
        d(i_) = d1(i_ + i1_)
    Next i_
    RMatrixBDSVD = Result
End Function
Public Function BidiagonalSVDDecomposition(ByRef d() As Double, _
         ByRef E_() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByVal IsFractionalAccuracyRequired As Boolean, _
         ByRef U() As Double, _
         ByVal NRU As Long, _
         ByRef C() As Double, _
         ByVal NCC As Long, _
         ByRef VT() As Double, _
         ByVal NCVT As Long) As Boolean
    Dim Result As Boolean
    Dim e() As Double
    e = E_
    Result = BidiagonalSVDDecompositionInternal(d, e, N, IsUpper, IsFractionalAccuracyRequired, U, 1#, NRU, C, 1#, NCC, VT, 1#, NCVT)
    BidiagonalSVDDecomposition = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal working subroutine for bidiagonal decomposition
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Function BidiagonalSVDDecompositionInternal(ByRef d() As Double, _
         ByRef E_() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByVal IsFractionalAccuracyRequired As Boolean, _
         ByRef U() As Double, _
         ByVal UStart As Long, _
         ByVal NRU As Long, _
         ByRef C() As Double, _
         ByVal CStart As Long, _
         ByVal NCC As Long, _
         ByRef VT() As Double, _
         ByVal VStart As Long, _
         ByVal NCVT As Long) As Boolean
    Dim Result As Boolean
    Dim e() As Double
    Dim i As Long
    Dim IDIR As Long
    Dim ISUB As Long
    Dim ITER As Long
    Dim j As Long
    Dim LL As Long
    Dim LLL As Long
    Dim M As Long
    Dim MAXIT As Long
    Dim OLDLL As Long
    Dim OLDM As Long
    Dim ABSE As Double
    Dim ABSS As Double
    Dim COSL As Double
    Dim COSR As Double
    Dim cs As Double
    Dim eps As Double
    Dim f As Double
    Dim g As Double
    Dim h As Double
    Dim mu As Double
    Dim OLDCS As Double
    Dim OLDSN As Double
    Dim R As Double
    Dim shift As Double
    Dim SIGMN As Double
    Dim SIGMX As Double
    Dim SINL As Double
    Dim SINR As Double
    Dim SLL As Double
    Dim SMAX As Double
    Dim SMIN As Double
    Dim SMINL As Double
    Dim SMINLO As Double
    Dim SMINOA As Double
    Dim SN As Double
    Dim thresh As Double
    Dim TOL As Double
    Dim TOLMUL As Double
    Dim UNFL As Double
    Dim WORK0() As Double
    Dim WORK1() As Double
    Dim WORK2() As Double
    Dim WORK3() As Double
    Dim MAXITR As Long
    Dim MatrixSplitFlag As Boolean
    Dim IterFlag As Boolean
    Dim UTemp() As Double
    Dim VTTemp() As Double
    Dim CTEMP() As Double
    Dim ETemp() As Double
    Dim RightSide As Boolean
    Dim FwdDir As Boolean
    Dim tmp As Double
    Dim MM1 As Long
    Dim MM0 As Long
    Dim BChangeDir As Boolean
    Dim UEnd As Long
    Dim CEnd As Long
    Dim VEnd As Long
    Dim i_ As Long
    e = E_
    Result = True
    If N = 0# Then
        BidiagonalSVDDecompositionInternal = Result
        Exit Function
    End If
    If N = 1# Then
        If d(1#) < 0# Then
            d(1#) = -d(1#)
            If NCVT > 0# Then
                For i_ = VStart To VStart + NCVT - 1# Step 1
                    VT(VStart, i_) = -1 * VT(VStart, i_)
                Next i_
            End If
        End If
        BidiagonalSVDDecompositionInternal = Result
        Exit Function
    End If
    
    '
    ' init
    '
    ReDim WORK0(1# To N - 1#)
    ReDim WORK1(1# To N - 1#)
    ReDim WORK2(1# To N - 1#)
    ReDim WORK3(1# To N - 1#)
    UEnd = UStart + MaxInt(NRU - 1#, 0#)
    VEnd = VStart + MaxInt(NCVT - 1#, 0#)
    CEnd = CStart + MaxInt(NCC - 1#, 0#)
    ReDim UTemp(UStart To UEnd)
    ReDim VTTemp(VStart To VEnd)
    ReDim CTEMP(CStart To CEnd)
    MAXITR = 12#
    RightSide = True
    FwdDir = True
    
    '
    ' resize E from N-1 to N
    '
    ReDim ETemp(1# To N)
    For i = 1# To N - 1# Step 1
        ETemp(i) = e(i)
    Next i
    ReDim e(1# To N)
    For i = 1# To N - 1# Step 1
        e(i) = ETemp(i)
    Next i
    e(N) = 0#
    IDIR = 0#
    
    '
    ' Get machine constants
    '
    eps = MachineEpsilon
    UNFL = MinRealNumber
    
    '
    ' If matrix lower bidiagonal, rotate to be upper bidiagonal
    ' by applying Givens rotations on the left
    '
    If Not IsUpper Then
        For i = 1# To N - 1# Step 1
            Call GenerateRotation(d(i), e(i), cs, SN, R)
            d(i) = R
            e(i) = SN * d(i + 1#)
            d(i + 1#) = cs * d(i + 1#)
            WORK0(i) = cs
            WORK1(i) = SN
        Next i
        
        '
        ' Update singular vectors if desired
        '
        If NRU > 0# Then
            Call ApplyRotationsFromTheRight(FwdDir, UStart, UEnd, 1# + UStart - 1#, N + UStart - 1#, WORK0, WORK1, U, UTemp)
        End If
        If NCC > 0# Then
            Call ApplyRotationsFromTheLeft(FwdDir, 1# + CStart - 1#, N + CStart - 1#, CStart, CEnd, WORK0, WORK1, C, CTEMP)
        End If
    End If
    
    '
    ' Compute singular values to relative accuracy TOL
    ' (By setting TOL to be negative, algorithm will compute
    ' singular values to absolute accuracy ABS(TOL)*norm(input matrix))
    '
    TOLMUL = MaxReal(10#, MinReal(100#, Power(eps, -0.125)))
    TOL = TOLMUL * eps
    If Not IsFractionalAccuracyRequired Then
        TOL = -TOL
    End If
    
    '
    ' Compute approximate maximum, minimum singular values
    '
    SMAX = 0#
    For i = 1# To N Step 1
        SMAX = MaxReal(SMAX, Abs(d(i)))
    Next i
    For i = 1# To N - 1# Step 1
        SMAX = MaxReal(SMAX, Abs(e(i)))
    Next i
    SMINL = 0#
    If TOL >= 0# Then
        
        '
        ' Relative accuracy desired
        '
        SMINOA = Abs(d(1#))
        If SMINOA <> 0# Then
            mu = SMINOA
            For i = 2# To N Step 1
                mu = Abs(d(i)) * (mu / (mu + Abs(e(i - 1#))))
                SMINOA = MinReal(SMINOA, mu)
                If SMINOA = 0# Then
                    Exit For
                End If
            Next i
        End If
        SMINOA = SMINOA / Sqr(N)
        thresh = MaxReal(TOL * SMINOA, MAXITR * N * N * UNFL)
    Else
        
        '
        ' Absolute accuracy desired
        '
        thresh = MaxReal(Abs(TOL) * SMAX, MAXITR * N * N * UNFL)
    End If
    
    '
    ' Prepare for main iteration loop for the singular values
    ' (MAXIT is the maximum number of passes through the inner
    ' loop permitted before nonconvergence signalled.)
    '
    MAXIT = MAXITR * N * N
    ITER = 0#
    OLDLL = -1#
    OLDM = -1#
    
    '
    ' M points to last element of unconverged part of matrix
    '
    M = N
    
    '
    ' Begin main iteration loop
    '
    Do While True
        
        '
        ' Check for convergence or exceeding iteration count
        '
        If M <= 1# Then
            Exit Do
        End If
        If ITER > MAXIT Then
            Result = False
            BidiagonalSVDDecompositionInternal = Result
            Exit Function
        End If
        
        '
        ' Find diagonal block of matrix to work on
        '
        If TOL < 0# And Abs(d(M)) <= thresh Then
            d(M) = 0#
        End If
        SMAX = Abs(d(M))
        SMIN = SMAX
        MatrixSplitFlag = False
        For LLL = 1# To M - 1# Step 1
            LL = M - LLL
            ABSS = Abs(d(LL))
            ABSE = Abs(e(LL))
            If TOL < 0# And ABSS <= thresh Then
                d(LL) = 0#
            End If
            If ABSE <= thresh Then
                MatrixSplitFlag = True
                Exit For
            End If
            SMIN = MinReal(SMIN, ABSS)
            SMAX = MaxReal(SMAX, MaxReal(ABSS, ABSE))
        Next LLL
        If Not MatrixSplitFlag Then
            LL = 0#
        Else
            
            '
            ' Matrix splits since E(LL) = 0
            '
            e(LL) = 0#
            If LL = M - 1# Then
                
                '
                ' Convergence of bottom singular value, return to top of loop
                '
                M = M - 1#
                GoTo Cont_7
            End If
        End If
        LL = LL + 1#
        
        '
        ' E(LL) through E(M-1) are nonzero, E(LL-1) is zero
        '
        If LL = M - 1# Then
            
            '
            ' 2 by 2 block, handle separately
            '
            Call SvdV2X2(d(M - 1#), e(M - 1#), d(M), SIGMN, SIGMX, SINR, COSR, SINL, COSL)
            d(M - 1#) = SIGMX
            e(M - 1#) = 0#
            d(M) = SIGMN
            
            '
            ' Compute singular vectors, if desired
            '
            If NCVT > 0# Then
                MM0 = M + (VStart - 1#)
                MM1 = M - 1# + (VStart - 1#)
                For i_ = VStart To VEnd Step 1
                    VTTemp(i_) = COSR * VT(MM1, i_)
                Next i_
                For i_ = VStart To VEnd Step 1
                    VTTemp(i_) = VTTemp(i_) + SINR * VT(MM0, i_)
                Next i_
                For i_ = VStart To VEnd Step 1
                    VT(MM0, i_) = COSR * VT(MM0, i_)
                Next i_
                For i_ = VStart To VEnd Step 1
                    VT(MM0, i_) = VT(MM0, i_) - SINR * VT(MM1, i_)
                Next i_
                For i_ = VStart To VEnd Step 1
                    VT(MM1, i_) = VTTemp(i_)
                Next i_
            End If
            If NRU > 0# Then
                MM0 = M + UStart - 1#
                MM1 = M - 1# + UStart - 1#
                For i_ = UStart To UEnd Step 1
                    UTemp(i_) = COSL * U(i_, MM1)
                Next i_
                For i_ = UStart To UEnd Step 1
                    UTemp(i_) = UTemp(i_) + SINL * U(i_, MM0)
                Next i_
                For i_ = UStart To UEnd Step 1
                    U(i_, MM0) = COSL * U(i_, MM0)
                Next i_
                For i_ = UStart To UEnd Step 1
                    U(i_, MM0) = U(i_, MM0) - SINL * U(i_, MM1)
                Next i_
                For i_ = UStart To UEnd Step 1
                    U(i_, MM1) = UTemp(i_)
                Next i_
            End If
            If NCC > 0# Then
                MM0 = M + CStart - 1#
                MM1 = M - 1# + CStart - 1#
                For i_ = CStart To CEnd Step 1
                    CTEMP(i_) = COSL * C(MM1, i_)
                Next i_
                For i_ = CStart To CEnd Step 1
                    CTEMP(i_) = CTEMP(i_) + SINL * C(MM0, i_)
                Next i_
                For i_ = CStart To CEnd Step 1
                    C(MM0, i_) = COSL * C(MM0, i_)
                Next i_
                For i_ = CStart To CEnd Step 1
                    C(MM0, i_) = C(MM0, i_) - SINL * C(MM1, i_)
                Next i_
                For i_ = CStart To CEnd Step 1
                    C(MM1, i_) = CTEMP(i_)
                Next i_
            End If
            M = M - 2#
            GoTo Cont_7
        End If
        
        '
        ' If working on new submatrix, choose shift direction
        ' (from larger end diagonal element towards smaller)
        '
        ' Previously was
        '     "if (LL>OLDM) or (M<OLDLL) then"
        ' fixed thanks to Michael Rolle < m@rolle.name >
        ' Very strange that LAPACK still contains it.
        '
        BChangeDir = False
        If IDIR = 1# And Abs(d(LL)) < 0.001 * Abs(d(M)) Then
            BChangeDir = True
        End If
        If IDIR = 2# And Abs(d(M)) < 0.001 * Abs(d(LL)) Then
            BChangeDir = True
        End If
        If LL <> OLDLL Or M <> OLDM Or BChangeDir Then
            If Abs(d(LL)) >= Abs(d(M)) Then
                
                '
                ' Chase bulge from top (big end) to bottom (small end)
                '
                IDIR = 1#
            Else
                
                '
                ' Chase bulge from bottom (big end) to top (small end)
                '
                IDIR = 2#
            End If
        End If
        
        '
        ' Apply convergence tests
        '
        If IDIR = 1# Then
            
            '
            ' Run convergence test in forward direction
            ' First apply standard test to bottom of matrix
            '
            If Abs(e(M - 1#)) <= Abs(TOL) * Abs(d(M)) Or TOL < 0# And Abs(e(M - 1#)) <= thresh Then
                e(M - 1#) = 0#
                GoTo Cont_7
            End If
            If TOL >= 0# Then
                
                '
                ' If relative accuracy desired,
                ' apply convergence criterion forward
                '
                mu = Abs(d(LL))
                SMINL = mu
                IterFlag = False
                For LLL = LL To M - 1# Step 1
                    If Abs(e(LLL)) <= TOL * mu Then
                        e(LLL) = 0#
                        IterFlag = True
                        Exit For
                    End If
                    SMINLO = SMINL
                    mu = Abs(d(LLL + 1#)) * (mu / (mu + Abs(e(LLL))))
                    SMINL = MinReal(SMINL, mu)
                Next LLL
                If IterFlag Then
                    GoTo Cont_7
                End If
            End If
        Else
            
            '
            ' Run convergence test in backward direction
            ' First apply standard test to top of matrix
            '
            If Abs(e(LL)) <= Abs(TOL) * Abs(d(LL)) Or TOL < 0# And Abs(e(LL)) <= thresh Then
                e(LL) = 0#
                GoTo Cont_7
            End If
            If TOL >= 0# Then
                
                '
                ' If relative accuracy desired,
                ' apply convergence criterion backward
                '
                mu = Abs(d(M))
                SMINL = mu
                IterFlag = False
                For LLL = M - 1# To LL Step -1
                    If Abs(e(LLL)) <= TOL * mu Then
                        e(LLL) = 0#
                        IterFlag = True
                        Exit For
                    End If
                    SMINLO = SMINL
                    mu = Abs(d(LLL)) * (mu / (mu + Abs(e(LLL))))
                    SMINL = MinReal(SMINL, mu)
                Next LLL
                If IterFlag Then
                    GoTo Cont_7
                End If
            End If
        End If
        OLDLL = LL
        OLDM = M
        
        '
        ' Compute shift.  First, test if shifting would ruin relative
        ' accuracy, and if so set the shift to zero.
        '
        If TOL >= 0# And N * TOL * (SMINL / SMAX) <= MaxReal(eps, 0.01 * TOL) Then
            
            '
            ' Use a zero shift to avoid loss of relative accuracy
            '
            shift = 0#
        Else
            
            '
            ' Compute the shift from 2-by-2 block at end of matrix
            '
            If IDIR = 1# Then
                SLL = Abs(d(LL))
                Call Svd2X2(d(M - 1#), e(M - 1#), d(M), shift, R)
            Else
                SLL = Abs(d(M))
                Call Svd2X2(d(LL), e(LL), d(LL + 1#), shift, R)
            End If
            
            '
            ' Test if shift negligible, and if so set to zero
            '
            If SLL > 0# Then
                If Square(shift / SLL) < eps Then
                    shift = 0#
                End If
            End If
        End If
        
        '
        ' Increment iteration count
        '
        ITER = ITER + M - LL
        
        '
        ' If SHIFT = 0, do simplified QR iteration
        '
        If shift = 0# Then
            If IDIR = 1# Then
                
                '
                ' Chase bulge from top to bottom
                ' Save cosines and sines for later singular vector updates
                '
                cs = 1#
                OLDCS = 1#
                For i = LL To M - 1# Step 1
                    Call GenerateRotation(d(i) * cs, e(i), cs, SN, R)
                    If i > LL Then
                        e(i - 1#) = OLDSN * R
                    End If
                    Call GenerateRotation(OLDCS * R, d(i + 1#) * SN, OLDCS, OLDSN, tmp)
                    d(i) = tmp
                    WORK0(i - LL + 1#) = cs
                    WORK1(i - LL + 1#) = SN
                    WORK2(i - LL + 1#) = OLDCS
                    WORK3(i - LL + 1#) = OLDSN
                Next i
                h = d(M) * cs
                d(M) = h * OLDCS
                e(M - 1#) = h * OLDSN
                
                '
                ' Update singular vectors
                '
                If NCVT > 0# Then
                    Call ApplyRotationsFromTheLeft(FwdDir, LL + VStart - 1#, M + VStart - 1#, VStart, VEnd, WORK0, WORK1, VT, VTTemp)
                End If
                If NRU > 0# Then
                    Call ApplyRotationsFromTheRight(FwdDir, UStart, UEnd, LL + UStart - 1#, M + UStart - 1#, WORK2, WORK3, U, UTemp)
                End If
                If NCC > 0# Then
                    Call ApplyRotationsFromTheLeft(FwdDir, LL + CStart - 1#, M + CStart - 1#, CStart, CEnd, WORK2, WORK3, C, CTEMP)
                End If
                
                '
                ' Test convergence
                '
                If Abs(e(M - 1#)) <= thresh Then
                    e(M - 1#) = 0#
                End If
            Else
                
                '
                ' Chase bulge from bottom to top
                ' Save cosines and sines for later singular vector updates
                '
                cs = 1#
                OLDCS = 1#
                For i = M To LL + 1# Step -1
                    Call GenerateRotation(d(i) * cs, e(i - 1#), cs, SN, R)
                    If i < M Then
                        e(i) = OLDSN * R
                    End If
                    Call GenerateRotation(OLDCS * R, d(i - 1#) * SN, OLDCS, OLDSN, tmp)
                    d(i) = tmp
                    WORK0(i - LL) = cs
                    WORK1(i - LL) = -SN
                    WORK2(i - LL) = OLDCS
                    WORK3(i - LL) = -OLDSN
                Next i
                h = d(LL) * cs
                d(LL) = h * OLDCS
                e(LL) = h * OLDSN
                
                '
                ' Update singular vectors
                '
                If NCVT > 0# Then
                    Call ApplyRotationsFromTheLeft(Not FwdDir, LL + VStart - 1#, M + VStart - 1#, VStart, VEnd, WORK2, WORK3, VT, VTTemp)
                End If
                If NRU > 0# Then
                    Call ApplyRotationsFromTheRight(Not FwdDir, UStart, UEnd, LL + UStart - 1#, M + UStart - 1#, WORK0, WORK1, U, UTemp)
                End If
                If NCC > 0# Then
                    Call ApplyRotationsFromTheLeft(Not FwdDir, LL + CStart - 1#, M + CStart - 1#, CStart, CEnd, WORK0, WORK1, C, CTEMP)
                End If
                
                '
                ' Test convergence
                '
                If Abs(e(LL)) <= thresh Then
                    e(LL) = 0#
                End If
            End If
        Else
            
            '
            ' Use nonzero shift
            '
            If IDIR = 1# Then
                
                '
                ' Chase bulge from top to bottom
                ' Save cosines and sines for later singular vector updates
                '
                f = (Abs(d(LL)) - shift) * (ExtSignBDSQR(1#, d(LL)) + shift / d(LL))
                g = e(LL)
                For i = LL To M - 1# Step 1
                    Call GenerateRotation(f, g, COSR, SINR, R)
                    If i > LL Then
                        e(i - 1#) = R
                    End If
                    f = COSR * d(i) + SINR * e(i)
                    e(i) = COSR * e(i) - SINR * d(i)
                    g = SINR * d(i + 1#)
                    d(i + 1#) = COSR * d(i + 1#)
                    Call GenerateRotation(f, g, COSL, SINL, R)
                    d(i) = R
                    f = COSL * e(i) + SINL * d(i + 1#)
                    d(i + 1#) = COSL * d(i + 1#) - SINL * e(i)
                    If i < M - 1# Then
                        g = SINL * e(i + 1#)
                        e(i + 1#) = COSL * e(i + 1#)
                    End If
                    WORK0(i - LL + 1#) = COSR
                    WORK1(i - LL + 1#) = SINR
                    WORK2(i - LL + 1#) = COSL
                    WORK3(i - LL + 1#) = SINL
                Next i
                e(M - 1#) = f
                
                '
                ' Update singular vectors
                '
                If NCVT > 0# Then
                    Call ApplyRotationsFromTheLeft(FwdDir, LL + VStart - 1#, M + VStart - 1#, VStart, VEnd, WORK0, WORK1, VT, VTTemp)
                End If
                If NRU > 0# Then
                    Call ApplyRotationsFromTheRight(FwdDir, UStart, UEnd, LL + UStart - 1#, M + UStart - 1#, WORK2, WORK3, U, UTemp)
                End If
                If NCC > 0# Then
                    Call ApplyRotationsFromTheLeft(FwdDir, LL + CStart - 1#, M + CStart - 1#, CStart, CEnd, WORK2, WORK3, C, CTEMP)
                End If
                
                '
                ' Test convergence
                '
                If Abs(e(M - 1#)) <= thresh Then
                    e(M - 1#) = 0#
                End If
            Else
                
                '
                ' Chase bulge from bottom to top
                ' Save cosines and sines for later singular vector updates
                '
                f = (Abs(d(M)) - shift) * (ExtSignBDSQR(1#, d(M)) + shift / d(M))
                g = e(M - 1#)
                For i = M To LL + 1# Step -1
                    Call GenerateRotation(f, g, COSR, SINR, R)
                    If i < M Then
                        e(i) = R
                    End If
                    f = COSR * d(i) + SINR * e(i - 1#)
                    e(i - 1#) = COSR * e(i - 1#) - SINR * d(i)
                    g = SINR * d(i - 1#)
                    d(i - 1#) = COSR * d(i - 1#)
                    Call GenerateRotation(f, g, COSL, SINL, R)
                    d(i) = R
                    f = COSL * e(i - 1#) + SINL * d(i - 1#)
                    d(i - 1#) = COSL * d(i - 1#) - SINL * e(i - 1#)
                    If i > LL + 1# Then
                        g = SINL * e(i - 2#)
                        e(i - 2#) = COSL * e(i - 2#)
                    End If
                    WORK0(i - LL) = COSR
                    WORK1(i - LL) = -SINR
                    WORK2(i - LL) = COSL
                    WORK3(i - LL) = -SINL
                Next i
                e(LL) = f
                
                '
                ' Test convergence
                '
                If Abs(e(LL)) <= thresh Then
                    e(LL) = 0#
                End If
                
                '
                ' Update singular vectors if desired
                '
                If NCVT > 0# Then
                    Call ApplyRotationsFromTheLeft(Not FwdDir, LL + VStart - 1#, M + VStart - 1#, VStart, VEnd, WORK2, WORK3, VT, VTTemp)
                End If
                If NRU > 0# Then
                    Call ApplyRotationsFromTheRight(Not FwdDir, UStart, UEnd, LL + UStart - 1#, M + UStart - 1#, WORK0, WORK1, U, UTemp)
                End If
                If NCC > 0# Then
                    Call ApplyRotationsFromTheLeft(Not FwdDir, LL + CStart - 1#, M + CStart - 1#, CStart, CEnd, WORK0, WORK1, C, CTEMP)
                End If
            End If
        End If
        
        '
        ' QR iteration finished, go back and check convergence
        '
        GoTo Cont_7
Cont_7:
    Loop
    
    '
    ' All singular values converged, so make them positive
    '
    For i = 1# To N Step 1
        If d(i) < 0# Then
            d(i) = -d(i)
            
            '
            ' Change sign of singular vectors, if desired
            '
            If NCVT > 0# Then
                For i_ = VStart To VEnd Step 1
                    VT(i + VStart - 1#, i_) = -1 * VT(i + VStart - 1#, i_)
                Next i_
            End If
        End If
    Next i
    
    '
    ' Sort the singular values into decreasing order (insertion sort on
    ' singular values, but only one transposition per singular vector)
    '
    For i = 1# To N - 1# Step 1
        
        '
        ' Scan for smallest D(I)
        '
        ISUB = 1#
        SMIN = d(1#)
        For j = 2# To N + 1# - i Step 1
            If d(j) <= SMIN Then
                ISUB = j
                SMIN = d(j)
            End If
        Next j
        If ISUB <> N + 1# - i Then
            
            '
            ' Swap singular values and vectors
            '
            d(ISUB) = d(N + 1# - i)
            d(N + 1# - i) = SMIN
            If NCVT > 0# Then
                j = N + 1# - i
                For i_ = VStart To VEnd Step 1
                    VTTemp(i_) = VT(ISUB + VStart - 1#, i_)
                Next i_
                For i_ = VStart To VEnd Step 1
                    VT(ISUB + VStart - 1#, i_) = VT(j + VStart - 1#, i_)
                Next i_
                For i_ = VStart To VEnd Step 1
                    VT(j + VStart - 1#, i_) = VTTemp(i_)
                Next i_
            End If
            If NRU > 0# Then
                j = N + 1# - i
                For i_ = UStart To UEnd Step 1
                    UTemp(i_) = U(i_, ISUB + UStart - 1#)
                Next i_
                For i_ = UStart To UEnd Step 1
                    U(i_, ISUB + UStart - 1#) = U(i_, j + UStart - 1#)
                Next i_
                For i_ = UStart To UEnd Step 1
                    U(i_, j + UStart - 1#) = UTemp(i_)
                Next i_
            End If
            If NCC > 0# Then
                j = N + 1# - i
                For i_ = CStart To CEnd Step 1
                    CTEMP(i_) = C(ISUB + CStart - 1#, i_)
                Next i_
                For i_ = CStart To CEnd Step 1
                    C(ISUB + CStart - 1#, i_) = C(j + CStart - 1#, i_)
                Next i_
                For i_ = CStart To CEnd Step 1
                    C(j + CStart - 1#, i_) = CTEMP(i_)
                Next i_
            End If
        End If
    Next i
    BidiagonalSVDDecompositionInternal = Result
End Function
Private Function ExtSignBDSQR(ByVal a As Double, ByVal B As Double) As Double
    Dim Result As Double
    If B >= 0# Then
        Result = Abs(a)
    Else
        Result = -Abs(a)
    End If
    ExtSignBDSQR = Result
End Function
Private Sub Svd2X2(ByVal f As Double, _
         ByVal g As Double, _
         ByVal h As Double, _
         ByRef SSMIN As Double, _
         ByRef SSMAX As Double)
    Dim AAS As Double
    Dim AT As Double
    Dim AU As Double
    Dim C As Double
    Dim fa As Double
    Dim FHMN As Double
    Dim FHMX As Double
    Dim GA As Double
    Dim HA As Double
    fa = Abs(f)
    GA = Abs(g)
    HA = Abs(h)
    FHMN = MinReal(fa, HA)
    FHMX = MaxReal(fa, HA)
    If FHMN = 0# Then
        SSMIN = 0#
        If FHMX = 0# Then
            SSMAX = GA
        Else
            SSMAX = MaxReal(FHMX, GA) * Sqr(1# + Square(MinReal(FHMX, GA) / MaxReal(FHMX, GA)))
        End If
    Else
        If GA < FHMX Then
            AAS = 1# + FHMN / FHMX
            AT = (FHMX - FHMN) / FHMX
            AU = Square(GA / FHMX)
            C = 2# / (Sqr(AAS * AAS + AU) + Sqr(AT * AT + AU))
            SSMIN = FHMN * C
            SSMAX = FHMX / C
        Else
            AU = FHMX / GA
            If AU = 0# Then
                
                '
                ' Avoid possible harmful underflow if exponent range
                ' asymmetric (true SSMIN may not underflow even if
                ' AU underflows)
                '
                SSMIN = FHMN * FHMX / GA
                SSMAX = GA
            Else
                AAS = 1# + FHMN / FHMX
                AT = (FHMX - FHMN) / FHMX
                C = 1# / (Sqr(1# + Square(AAS * AU)) + Sqr(1# + Square(AT * AU)))
                SSMIN = FHMN * C * AU
                SSMIN = SSMIN + SSMIN
                SSMAX = GA / (C + C)
            End If
        End If
    End If
End Sub
Private Sub SvdV2X2(ByVal f As Double, _
         ByVal g As Double, _
         ByVal h As Double, _
         ByRef SSMIN As Double, _
         ByRef SSMAX As Double, _
         ByRef SNR As Double, _
         ByRef CSR As Double, _
         ByRef SNL As Double, _
         ByRef CSL As Double)
    Dim GASMAL As Boolean
    Dim SWP As Boolean
    Dim PMAX As Long
    Dim a As Double
    Dim CLT As Double
    Dim CRT As Double
    Dim d As Double
    Dim fa As Double
    Dim FT As Double
    Dim GA As Double
    Dim GT As Double
    Dim HA As Double
    Dim HT As Double
    Dim L As Double
    Dim M As Double
    Dim MM As Double
    Dim R As Double
    Dim s As Double
    Dim SLT As Double
    Dim SRT As Double
    Dim t As Double
    Dim temp As Double
    Dim TSIGN As Double
    Dim TT As Double
    Dim V As Double
    FT = f
    fa = Abs(FT)
    HT = h
    HA = Abs(h)
    
    '
    ' PMAX points to the maximum absolute element of matrix
    '  PMAX = 1 if F largest in absolute values
    '  PMAX = 2 if G largest in absolute values
    '  PMAX = 3 if H largest in absolute values
    '
    PMAX = 1#
    SWP = HA > fa
    If SWP Then
        
        '
        ' Now FA .ge. HA
        '
        PMAX = 3#
        temp = FT
        FT = HT
        HT = temp
        temp = fa
        fa = HA
        HA = temp
    End If
    GT = g
    GA = Abs(GT)
    If GA = 0# Then
        
        '
        ' Diagonal matrix
        '
        SSMIN = HA
        SSMAX = fa
        CLT = 1#
        CRT = 1#
        SLT = 0#
        SRT = 0#
    Else
        GASMAL = True
        If GA > fa Then
            PMAX = 2#
            If fa / GA < MachineEpsilon Then
                
                '
                ' Case of very large GA
                '
                GASMAL = False
                SSMAX = GA
                If HA > 1# Then
                    V = GA / HA
                    SSMIN = fa / V
                Else
                    V = fa / GA
                    SSMIN = V * HA
                End If
                CLT = 1#
                SLT = HT / GT
                SRT = 1#
                CRT = FT / GT
            End If
        End If
        If GASMAL Then
            
            '
            ' Normal case
            '
            d = fa - HA
            If d = fa Then
                L = 1#
            Else
                L = d / fa
            End If
            M = GT / FT
            t = 2# - L
            MM = M * M
            TT = t * t
            s = Sqr(TT + MM)
            If L = 0# Then
                R = Abs(M)
            Else
                R = Sqr(L * L + MM)
            End If
            a = 0.5 * (s + R)
            SSMIN = HA / a
            SSMAX = fa * a
            If MM = 0# Then
                
                '
                ' Note that M is very tiny
                '
                If L = 0# Then
                    t = ExtSignBDSQR(2#, FT) * ExtSignBDSQR(1#, GT)
                Else
                    t = GT / ExtSignBDSQR(d, FT) + M / t
                End If
            Else
                t = (M / (s + t) + M / (R + L)) * (1# + a)
            End If
            L = Sqr(t * t + 4#)
            CRT = 2# / L
            SRT = t / L
            CLT = (CRT + SRT * M) / a
            V = HT / FT
            SLT = V * SRT / a
        End If
    End If
    If SWP Then
        CSL = SRT
        SNL = CRT
        CSR = SLT
        SNR = CLT
    Else
        CSL = CLT
        SNL = SLT
        CSR = CRT
        SNR = SRT
    End If
    
    '
    ' Correct signs of SSMAX and SSMIN
    '
    If PMAX = 1# Then
        TSIGN = ExtSignBDSQR(1#, CSR) * ExtSignBDSQR(1#, CSL) * ExtSignBDSQR(1#, f)
    End If
    If PMAX = 2# Then
        TSIGN = ExtSignBDSQR(1#, SNR) * ExtSignBDSQR(1#, CSL) * ExtSignBDSQR(1#, g)
    End If
    If PMAX = 3# Then
        TSIGN = ExtSignBDSQR(1#, SNR) * ExtSignBDSQR(1#, SNL) * ExtSignBDSQR(1#, h)
    End If
    SSMAX = ExtSignBDSQR(SSMAX, TSIGN)
    SSMIN = ExtSignBDSQR(SSMIN, TSIGN * ExtSignBDSQR(1#, f) * ExtSignBDSQR(1#, h))
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2005-2007, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
Public Function VectorNorm2(ByRef x() As Double, _
         ByVal I1 As Long, _
         ByVal I2 As Long) As Double
    Dim Result As Double
    Dim N As Long
    Dim IX As Long
    Dim ABSXI As Double
    Dim SCL As Double
    Dim SSQ As Double
    N = I2 - I1 + 1#
    If N < 1# Then
        Result = 0#
        VectorNorm2 = Result
        Exit Function
    End If
    If N = 1# Then
        Result = Abs(x(I1))
        VectorNorm2 = Result
        Exit Function
    End If
    SCL = 0#
    SSQ = 1#
    For IX = I1 To I2 Step 1
        If x(IX) <> 0# Then
            ABSXI = Abs(x(IX))
            If SCL < ABSXI Then
                SSQ = 1# + SSQ * Square(SCL / ABSXI)
                SCL = ABSXI
            Else
                SSQ = SSQ + Square(ABSXI / SCL)
            End If
        End If
    Next IX
    Result = SCL * Sqr(SSQ)
    VectorNorm2 = Result
End Function
Public Function VectorIdxAbsMax(ByRef x() As Double, _
         ByVal I1 As Long, _
         ByVal I2 As Long) As Long
    Dim Result As Long
    Dim i As Long
    Dim a As Double
    Result = I1
    a = Abs(x(Result))
    For i = I1 + 1# To I2 Step 1
        If Abs(x(i)) > Abs(x(Result)) Then
            Result = i
        End If
    Next i
    VectorIdxAbsMax = Result
End Function
Public Function ColumnIdxAbsMax(ByRef x() As Double, _
         ByVal I1 As Long, _
         ByVal I2 As Long, _
         ByVal j As Long) As Long
    Dim Result As Long
    Dim i As Long
    Dim a As Double
    Result = I1
    a = Abs(x(Result, j))
    For i = I1 + 1# To I2 Step 1
        If Abs(x(i, j)) > Abs(x(Result, j)) Then
            Result = i
        End If
    Next i
    ColumnIdxAbsMax = Result
End Function
Public Function RowIdxAbsMax(ByRef x() As Double, _
         ByVal J1 As Long, _
         ByVal J2 As Long, _
         ByVal i As Long) As Long
    Dim Result As Long
    Dim j As Long
    Dim a As Double
    Result = J1
    a = Abs(x(i, Result))
    For j = J1 + 1# To J2 Step 1
        If Abs(x(i, j)) > Abs(x(i, Result)) Then
            Result = j
        End If
    Next j
    RowIdxAbsMax = Result
End Function
Public Function UpperHessenberg1Norm(ByRef a() As Double, _
         ByVal I1 As Long, _
         ByVal I2 As Long, _
         ByVal J1 As Long, _
         ByVal J2 As Long, _
         ByRef WORK() As Double) As Double
    Dim Result As Double
    Dim i As Long
    Dim j As Long
    For j = J1 To J2 Step 1
        WORK(j) = 0#
    Next j
    For i = I1 To I2 Step 1
        For j = MaxInt(J1, J1 + i - I1 - 1#) To J2 Step 1
            WORK(j) = WORK(j) + Abs(a(i, j))
        Next j
    Next i
    Result = 0#
    For j = J1 To J2 Step 1
        Result = MaxReal(Result, WORK(j))
    Next j
    UpperHessenberg1Norm = Result
End Function
Public Sub CopyMatrix(ByRef a() As Double, _
         ByVal IS1 As Long, _
         ByVal IS2 As Long, _
         ByVal JS1 As Long, _
         ByVal JS2 As Long, _
         ByRef B() As Double, _
         ByVal ID1 As Long, _
         ByVal ID2 As Long, _
         ByVal JD1 As Long, _
         ByVal JD2 As Long)
    Dim ISRC As Long
    Dim IDST As Long
    Dim i_ As Long
    Dim i1_ As Long
    If IS1 > IS2 Or JS1 > JS2 Then
        Exit Sub
    End If
    For ISRC = IS1 To IS2 Step 1
        IDST = ISRC - IS1 + ID1
        i1_ = (JS1) - (JD1)
        For i_ = JD1 To JD2 Step 1
            B(IDST, i_) = a(ISRC, i_ + i1_)
        Next i_
    Next ISRC
End Sub
Public Sub InplaceTranspose(ByRef a() As Double, _
         ByVal I1 As Long, _
         ByVal I2 As Long, _
         ByVal J1 As Long, _
         ByVal J2 As Long, _
         ByRef WORK() As Double)
    Dim i As Long
    Dim j As Long
    Dim IPS As Long
    Dim JPS As Long
    Dim L As Long
    Dim i_ As Long
    Dim i1_ As Long
    If I1 > I2 Or J1 > J2 Then
        Exit Sub
    End If
    For i = I1 To I2 - 1# Step 1
        j = J1 + i - I1
        IPS = i + 1#
        JPS = J1 + IPS - I1
        L = I2 - i
        i1_ = (IPS) - (1#)
        For i_ = 1# To L Step 1
            WORK(i_) = a(i_ + i1_, j)
        Next i_
        i1_ = (JPS) - (IPS)
        For i_ = IPS To I2 Step 1
            a(i_, j) = a(i, i_ + i1_)
        Next i_
        i1_ = (1#) - (JPS)
        For i_ = JPS To J2 Step 1
            a(i, i_) = WORK(i_ + i1_)
        Next i_
    Next i
End Sub
Public Sub CopyAndTranspose(ByRef a() As Double, _
         ByVal IS1 As Long, _
         ByVal IS2 As Long, _
         ByVal JS1 As Long, _
         ByVal JS2 As Long, _
         ByRef B() As Double, _
         ByVal ID1 As Long, _
         ByVal ID2 As Long, _
         ByVal JD1 As Long, _
         ByVal JD2 As Long)
    Dim ISRC As Long
    Dim JDST As Long
    Dim i_ As Long
    Dim i1_ As Long
    If IS1 > IS2 Or JS1 > JS2 Then
        Exit Sub
    End If
    For ISRC = IS1 To IS2 Step 1
        JDST = ISRC - IS1 + JD1
        i1_ = (JS1) - (ID1)
        For i_ = ID1 To ID2 Step 1
            B(i_, JDST) = a(ISRC, i_ + i1_)
        Next i_
    Next ISRC
End Sub
Public Sub MatrixVectorMultiply(ByRef a() As Double, _
         ByVal I1 As Long, _
         ByVal I2 As Long, _
         ByVal J1 As Long, _
         ByVal J2 As Long, _
         ByVal Trans As Boolean, _
         ByRef x() As Double, _
         ByVal IX1 As Long, _
         ByVal IX2 As Long, _
         ByVal alpha As Double, _
         ByRef y() As Double, _
         ByVal IY1 As Long, _
         ByVal IY2 As Long, _
         ByVal beta As Double)
    Dim i As Long
    Dim V As Double
    Dim i_ As Long
    Dim i1_ As Long
    If Not Trans Then
        
        '
        ' y := alpha*A*x + beta*y;
        '
        If I1 > I2 Or J1 > J2 Then
            Exit Sub
        End If
        
        '
        ' beta*y
        '
        If beta = 0# Then
            For i = IY1 To IY2 Step 1
                y(i) = 0#
            Next i
        Else
            For i_ = IY1 To IY2 Step 1
                y(i_) = beta * y(i_)
            Next i_
        End If
        
        '
        ' alpha*A*x
        '
        For i = I1 To I2 Step 1
            i1_ = (IX1) - (J1)
            V = 0#
            For i_ = J1 To J2 Step 1
                V = V + a(i, i_) * x(i_ + i1_)
            Next i_
            y(IY1 + i - I1) = y(IY1 + i - I1) + alpha * V
        Next i
    Else
        
        '
        ' y := alpha*A'*x + beta*y;
        '
        If I1 > I2 Or J1 > J2 Then
            Exit Sub
        End If
        
        '
        ' beta*y
        '
        If beta = 0# Then
            For i = IY1 To IY2 Step 1
                y(i) = 0#
            Next i
        Else
            For i_ = IY1 To IY2 Step 1
                y(i_) = beta * y(i_)
            Next i_
        End If
        
        '
        ' alpha*A'*x
        '
        For i = I1 To I2 Step 1
            V = alpha * x(IX1 + i - I1)
            i1_ = (J1) - (IY1)
            For i_ = IY1 To IY2 Step 1
                y(i_) = y(i_) + V * a(i, i_ + i1_)
            Next i_
        Next i
    End If
End Sub
Public Function Pythag2(ByVal x As Double, ByVal y As Double) As Double
    Dim Result As Double
    Dim w As Double
    Dim XABS As Double
    Dim YABS As Double
    Dim z As Double
    XABS = Abs(x)
    YABS = Abs(y)
    w = MaxReal(XABS, YABS)
    z = MinReal(XABS, YABS)
    If z = 0# Then
        Result = w
    Else
        Result = w * Sqr(1# + Square(z / w))
    End If
    Pythag2 = Result
End Function
Public Sub MatrixMatrixMultiply(ByRef a() As Double, _
         ByVal AI1 As Long, _
         ByVal AI2 As Long, _
         ByVal AJ1 As Long, _
         ByVal AJ2 As Long, _
         ByVal TransA As Boolean, _
         ByRef B() As Double, _
         ByVal BI1 As Long, _
         ByVal BI2 As Long, _
         ByVal BJ1 As Long, _
         ByVal BJ2 As Long, _
         ByVal TransB As Boolean, _
         ByVal alpha As Double, _
         ByRef C() As Double, _
         ByVal CI1 As Long, _
         ByVal CI2 As Long, _
         ByVal CJ1 As Long, _
         ByVal CJ2 As Long, _
         ByVal beta As Double, _
         ByRef WORK() As Double)
    Dim ARows As Long
    Dim ACols As Long
    Dim BRows As Long
    Dim BCols As Long
    Dim CRows As Long
    Dim CCols As Long
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim L As Long
    Dim R As Long
    Dim V As Double
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' Setup
    '
    If Not TransA Then
        ARows = AI2 - AI1 + 1#
        ACols = AJ2 - AJ1 + 1#
    Else
        ARows = AJ2 - AJ1 + 1#
        ACols = AI2 - AI1 + 1#
    End If
    If Not TransB Then
        BRows = BI2 - BI1 + 1#
        BCols = BJ2 - BJ1 + 1#
    Else
        BRows = BJ2 - BJ1 + 1#
        BCols = BI2 - BI1 + 1#
    End If
    If ARows <= 0# Or ACols <= 0# Or BRows <= 0# Or BCols <= 0# Then
        Exit Sub
    End If
    CRows = ARows
    CCols = BCols
    
    '
    ' Test WORK
    '
    i = MaxInt(ARows, ACols)
    i = MaxInt(BRows, i)
    i = MaxInt(i, BCols)
    WORK(1#) = 0#
    WORK(i) = 0#
    
    '
    ' Prepare C
    '
    If beta = 0# Then
        For i = CI1 To CI2 Step 1
            For j = CJ1 To CJ2 Step 1
                C(i, j) = 0#
            Next j
        Next i
    Else
        For i = CI1 To CI2 Step 1
            For i_ = CJ1 To CJ2 Step 1
                C(i, i_) = beta * C(i, i_)
            Next i_
        Next i
    End If
    
    '
    ' A*B
    '
    If Not TransA And Not TransB Then
        For L = AI1 To AI2 Step 1
            For R = BI1 To BI2 Step 1
                V = alpha * a(L, AJ1 + R - BI1)
                K = CI1 + L - AI1
                i1_ = (BJ1) - (CJ1)
                For i_ = CJ1 To CJ2 Step 1
                    C(K, i_) = C(K, i_) + V * B(R, i_ + i1_)
                Next i_
            Next R
        Next L
        Exit Sub
    End If
    
    '
    ' A*B'
    '
    If Not TransA And TransB Then
        If ARows * ACols < BRows * BCols Then
            For R = BI1 To BI2 Step 1
                For L = AI1 To AI2 Step 1
                    i1_ = (BJ1) - (AJ1)
                    V = 0#
                    For i_ = AJ1 To AJ2 Step 1
                        V = V + a(L, i_) * B(R, i_ + i1_)
                    Next i_
                    C(CI1 + L - AI1, CJ1 + R - BI1) = C(CI1 + L - AI1, CJ1 + R - BI1) + alpha * V
                Next L
            Next R
            Exit Sub
        Else
            For L = AI1 To AI2 Step 1
                For R = BI1 To BI2 Step 1
                    i1_ = (BJ1) - (AJ1)
                    V = 0#
                    For i_ = AJ1 To AJ2 Step 1
                        V = V + a(L, i_) * B(R, i_ + i1_)
                    Next i_
                    C(CI1 + L - AI1, CJ1 + R - BI1) = C(CI1 + L - AI1, CJ1 + R - BI1) + alpha * V
                Next R
            Next L
            Exit Sub
        End If
    End If
    
    '
    ' A'*B
    '
    If TransA And Not TransB Then
        For L = AJ1 To AJ2 Step 1
            For R = BI1 To BI2 Step 1
                V = alpha * a(AI1 + R - BI1, L)
                K = CI1 + L - AJ1
                i1_ = (BJ1) - (CJ1)
                For i_ = CJ1 To CJ2 Step 1
                    C(K, i_) = C(K, i_) + V * B(R, i_ + i1_)
                Next i_
            Next R
        Next L
        Exit Sub
    End If
    
    '
    ' A'*B'
    '
    If TransA And TransB Then
        If ARows * ACols < BRows * BCols Then
            For R = BI1 To BI2 Step 1
                For i = 1# To CRows Step 1
                    WORK(i) = 0#
                Next i
                For L = AI1 To AI2 Step 1
                    V = alpha * B(R, BJ1 + L - AI1)
                    K = CJ1 + R - BI1
                    i1_ = (AJ1) - (1#)
                    For i_ = 1# To CRows Step 1
                        WORK(i_) = WORK(i_) + V * a(L, i_ + i1_)
                    Next i_
                Next L
                i1_ = (1#) - (CI1)
                For i_ = CI1 To CI2 Step 1
                    C(i_, K) = C(i_, K) + WORK(i_ + i1_)
                Next i_
            Next R
            Exit Sub
        Else
            For L = AJ1 To AJ2 Step 1
                K = AI2 - AI1 + 1#
                i1_ = (AI1) - (1#)
                For i_ = 1# To K Step 1
                    WORK(i_) = a(i_ + i1_, L)
                Next i_
                For R = BI1 To BI2 Step 1
                    i1_ = (BJ1) - (1#)
                    V = 0#
                    For i_ = 1# To K Step 1
                        V = V + WORK(i_) * B(R, i_ + i1_)
                    Next i_
                    C(CI1 + L - AJ1, CJ1 + R - BI1) = C(CI1 + L - AJ1, CJ1 + R - BI1) + alpha * V
                Next R
            Next L
            Exit Sub
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This file is a part of ALGLIB project.
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Utility subroutine performing the "safe" solution of system of linear
'equations with triangular coefficient matrices.
'
'The subroutine uses scaling and solves the scaled system A*x=s*b (where  s
'is  a  scalar  value)  instead  of  A*x=b,  choosing  s  so  that x can be
'represented by a floating-point number. The closer the system  gets  to  a
'singular, the less s is. If the system is singular, s=0 and x contains the
'non-trivial solution of equation A*x=0.
'
'The feature of an algorithm is that it could not cause an  overflow  or  a
'division by zero regardless of the matrix used as the input.
'
'The algorithm can solve systems of equations with  upper/lower  triangular
'matrices,  with/without unit diagonal, and systems of type A*x=b or A'*x=b
'(where A' is a transposed matrix A).
'
'Input parameters:
'    A       -   system matrix. Array whose indexes range within [0..N-1, 0..N-1].
'    N       -   size of matrix A.
'    X       -   right-hand member of a system.
'                Array whose index ranges within [0..N-1].
'    IsUpper -   matrix type. If it is True, the system matrix is the upper
'                triangular and is located in  the  corresponding  part  of
'                matrix A.
'    Trans   -   problem type. If it is True, the problem to be  solved  is
'                A'*x=b, otherwise it is A*x=b.
'    Isunit  -   matrix type. If it is True, the system matrix has  a  unit
'                diagonal (the elements on the main diagonal are  not  used
'                in the calculation process), otherwise the matrix is considered
'                to be a general triangular matrix.
'
'Output parameters:
'    X       -   solution. Array whose index ranges within [0..N-1].
'    S       -   scaling factor.
'
'  -- LAPACK auxiliary routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     June 30, 1992
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixTRSafeSolve(ByRef a() As Double, _
         ByVal N As Long, _
         ByRef x() As Double, _
         ByRef s As Double, _
         ByVal IsUpper As Boolean, _
         ByVal IsTrans As Boolean, _
         ByVal Isunit As Boolean)
    Dim NORMIN As Boolean
    Dim CNORM() As Double
    Dim a1() As Double
    Dim X1() As Double
    Dim i As Long
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' From 0-based to 1-based
    '
    NORMIN = False
    ReDim a1(1# To N, 1# To N)
    ReDim X1(1# To N)
    For i = 1# To N Step 1
        i1_ = (0#) - (1#)
        For i_ = 1# To N Step 1
            a1(i, i_) = a(i - 1#, i_ + i1_)
        Next i_
    Next i
    i1_ = (0#) - (1#)
    For i_ = 1# To N Step 1
        X1(i_) = x(i_ + i1_)
    Next i_
    
    '
    ' Solve 1-based
    '
    Call SafeSolveTriangular(a1, N, X1, s, IsUpper, IsTrans, Isunit, NORMIN, CNORM)
    
    '
    ' From 1-based to 0-based
    '
    i1_ = (1#) - (0#)
    For i_ = 0# To N - 1# Step 1
        x(i_) = X1(i_ + i1_)
    Next i_
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Obsolete 1-based subroutine.
'See RMatrixTRSafeSolve for 0-based replacement.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub SafeSolveTriangular(ByRef a() As Double, _
         ByVal N As Long, _
         ByRef x() As Double, _
         ByRef s As Double, _
         ByVal IsUpper As Boolean, _
         ByVal IsTrans As Boolean, _
         ByVal Isunit As Boolean, _
         ByVal NORMIN As Boolean, _
         ByRef CNORM() As Double)
    Dim i As Long
    Dim IMAX As Long
    Dim j As Long
    Dim JFIRST As Long
    Dim JINC As Long
    Dim JLAST As Long
    Dim JM1 As Long
    Dim JP1 As Long
    Dim IP1 As Long
    Dim IM1 As Long
    Dim K As Long
    Dim Flg As Long
    Dim V As Double
    Dim VD As Double
    Dim BIGNUM As Double
    Dim GROW As Double
    Dim REC As Double
    Dim SMLNUM As Double
    Dim SUMJ As Double
    Dim TJJ As Double
    Dim TJJS As Double
    Dim TMAX As Double
    Dim TSCAL As Double
    Dim USCAL As Double
    Dim XBND As Double
    Dim XJ As Double
    Dim XMAX As Double
    Dim NOTRAN As Boolean
    Dim UPPER As Boolean
    Dim NOunit As Boolean
    Dim i_ As Long
    UPPER = IsUpper
    NOTRAN = Not IsTrans
    NOunit = Not Isunit
    
    '
    ' Quick return if possible
    '
    If N = 0# Then
        Exit Sub
    End If
    
    '
    ' Determine machine dependent parameters to control overflow.
    '
    SMLNUM = MinRealNumber / (MachineEpsilon * 2#)
    BIGNUM = 1# / SMLNUM
    s = 1#
    If Not NORMIN Then
        ReDim CNORM(1# To N)
        
        '
        ' Compute the 1-norm of each column, not including the diagonal.
        '
        If UPPER Then
            
            '
            ' A is upper triangular.
            '
            For j = 1# To N Step 1
                V = 0#
                For K = 1# To j - 1# Step 1
                    V = V + Abs(a(K, j))
                Next K
                CNORM(j) = V
            Next j
        Else
            
            '
            ' A is lower triangular.
            '
            For j = 1# To N - 1# Step 1
                V = 0#
                For K = j + 1# To N Step 1
                    V = V + Abs(a(K, j))
                Next K
                CNORM(j) = V
            Next j
            CNORM(N) = 0#
        End If
    End If
    
    '
    ' Scale the column norms by TSCAL if the maximum element in CNORM is
    ' greater than BIGNUM.
    '
    IMAX = 1#
    For K = 2# To N Step 1
        If CNORM(K) > CNORM(IMAX) Then
            IMAX = K
        End If
    Next K
    TMAX = CNORM(IMAX)
    If TMAX <= BIGNUM Then
        TSCAL = 1#
    Else
        TSCAL = 1# / (SMLNUM * TMAX)
        For i_ = 1# To N Step 1
            CNORM(i_) = TSCAL * CNORM(i_)
        Next i_
    End If
    
    '
    ' Compute a bound on the computed solution vector to see if the
    ' Level 2 BLAS routine DTRSV can be used.
    '
    j = 1#
    For K = 2# To N Step 1
        If Abs(x(K)) > Abs(x(j)) Then
            j = K
        End If
    Next K
    XMAX = Abs(x(j))
    XBND = XMAX
    If NOTRAN Then
        
        '
        ' Compute the growth in A * x = b.
        '
        If UPPER Then
            JFIRST = N
            JLAST = 1#
            JINC = -1#
        Else
            JFIRST = 1#
            JLAST = N
            JINC = 1#
        End If
        If TSCAL <> 1# Then
            GROW = 0#
        Else
            If NOunit Then
                
                '
                ' A is non-unit triangular.
                '
                ' Compute GROW = 1/G(j) and XBND = 1/M(j).
                ' Initially, G(0) = max{x(i), i=1,...,n}.
                '
                GROW = 1# / MaxReal(XBND, SMLNUM)
                XBND = GROW
                j = JFIRST
                Do While JINC > 0# And j <= JLAST Or JINC < 0# And j >= JLAST
                    
                    '
                    ' Exit the loop if the growth factor is too small.
                    '
                    If GROW <= SMLNUM Then
                        Exit Do
                    End If
                    
                    '
                    ' M(j) = G(j-1) / abs(A(j,j))
                    '
                    TJJ = Abs(a(j, j))
                    XBND = MinReal(XBND, MinReal(1#, TJJ) * GROW)
                    If TJJ + CNORM(j) >= SMLNUM Then
                        
                        '
                        ' G(j) = G(j-1)*( 1 + CNORM(j) / abs(A(j,j)) )
                        '
                        GROW = GROW * (TJJ / (TJJ + CNORM(j)))
                    Else
                        
                        '
                        ' G(j) could overflow, set GROW to 0.
                        '
                        GROW = 0#
                    End If
                    If j = JLAST Then
                        GROW = XBND
                    End If
                    j = j + JINC
                Loop
            Else
                
                '
                ' A is unit triangular.
                '
                ' Compute GROW = 1/G(j), where G(0) = max{x(i), i=1,...,n}.
                '
                GROW = MinReal(1#, 1# / MaxReal(XBND, SMLNUM))
                j = JFIRST
                Do While JINC > 0# And j <= JLAST Or JINC < 0# And j >= JLAST
                    
                    '
                    ' Exit the loop if the growth factor is too small.
                    '
                    If GROW <= SMLNUM Then
                        Exit Do
                    End If
                    
                    '
                    ' G(j) = G(j-1)*( 1 + CNORM(j) )
                    '
                    GROW = GROW * (1# / (1# + CNORM(j)))
                    j = j + JINC
                Loop
            End If
        End If
    Else
        
        '
        ' Compute the growth in A' * x = b.
        '
        If UPPER Then
            JFIRST = 1#
            JLAST = N
            JINC = 1#
        Else
            JFIRST = N
            JLAST = 1#
            JINC = -1#
        End If
        If TSCAL <> 1# Then
            GROW = 0#
        Else
            If NOunit Then
                
                '
                ' A is non-unit triangular.
                '
                ' Compute GROW = 1/G(j) and XBND = 1/M(j).
                ' Initially, M(0) = max{x(i), i=1,...,n}.
                '
                GROW = 1# / MaxReal(XBND, SMLNUM)
                XBND = GROW
                j = JFIRST
                Do While JINC > 0# And j <= JLAST Or JINC < 0# And j >= JLAST
                    
                    '
                    ' Exit the loop if the growth factor is too small.
                    '
                    If GROW <= SMLNUM Then
                        Exit Do
                    End If
                    
                    '
                    ' G(j) = max( G(j-1), M(j-1)*( 1 + CNORM(j) ) )
                    '
                    XJ = 1# + CNORM(j)
                    GROW = MinReal(GROW, XBND / XJ)
                    
                    '
                    ' M(j) = M(j-1)*( 1 + CNORM(j) ) / abs(A(j,j))
                    '
                    TJJ = Abs(a(j, j))
                    If XJ > TJJ Then
                        XBND = XBND * (TJJ / XJ)
                    End If
                    If j = JLAST Then
                        GROW = MinReal(GROW, XBND)
                    End If
                    j = j + JINC
                Loop
            Else
                
                '
                ' A is unit triangular.
                '
                ' Compute GROW = 1/G(j), where G(0) = max{x(i), i=1,...,n}.
                '
                GROW = MinReal(1#, 1# / MaxReal(XBND, SMLNUM))
                j = JFIRST
                Do While JINC > 0# And j <= JLAST Or JINC < 0# And j >= JLAST
                    
                    '
                    ' Exit the loop if the growth factor is too small.
                    '
                    If GROW <= SMLNUM Then
                        Exit Do
                    End If
                    
                    '
                    ' G(j) = ( 1 + CNORM(j) )*G(j-1)
                    '
                    XJ = 1# + CNORM(j)
                    GROW = GROW / XJ
                    j = j + JINC
                Loop
            End If
        End If
    End If
    If GROW * TSCAL > SMLNUM Then
        
        '
        ' Use the Level 2 BLAS solve if the reciprocal of the bound on
        ' elements of X is not too small.
        '
        If UPPER And NOTRAN Or Not UPPER And Not NOTRAN Then
            If NOunit Then
                VD = a(N, N)
            Else
                VD = 1#
            End If
            x(N) = x(N) / VD
            For i = N - 1# To 1# Step -1
                IP1 = i + 1#
                If UPPER Then
                    V = 0#
                    For i_ = IP1 To N Step 1
                        V = V + a(i, i_) * x(i_)
                    Next i_
                Else
                    V = 0#
                    For i_ = IP1 To N Step 1
                        V = V + a(i_, i) * x(i_)
                    Next i_
                End If
                If NOunit Then
                    VD = a(i, i)
                Else
                    VD = 1#
                End If
                x(i) = (x(i) - V) / VD
            Next i
        Else
            If NOunit Then
                VD = a(1#, 1#)
            Else
                VD = 1#
            End If
            x(1#) = x(1#) / VD
            For i = 2# To N Step 1
                IM1 = i - 1#
                If UPPER Then
                    V = 0#
                    For i_ = 1# To IM1 Step 1
                        V = V + a(i_, i) * x(i_)
                    Next i_
                Else
                    V = 0#
                    For i_ = 1# To IM1 Step 1
                        V = V + a(i, i_) * x(i_)
                    Next i_
                End If
                If NOunit Then
                    VD = a(i, i)
                Else
                    VD = 1#
                End If
                x(i) = (x(i) - V) / VD
            Next i
        End If
    Else
        
        '
        ' Use a Level 1 BLAS solve, scaling intermediate results.
        '
        If XMAX > BIGNUM Then
            
            '
            ' Scale X so that its components are less than or equal to
            ' BIGNUM in absolute value.
            '
            s = BIGNUM / XMAX
            For i_ = 1# To N Step 1
                x(i_) = s * x(i_)
            Next i_
            XMAX = BIGNUM
        End If
        If NOTRAN Then
            
            '
            ' Solve A * x = b
            '
            j = JFIRST
            Do While JINC > 0# And j <= JLAST Or JINC < 0# And j >= JLAST
                
                '
                ' Compute x(j) = b(j) / A(j,j), scaling x if necessary.
                '
                XJ = Abs(x(j))
                Flg = 0#
                If NOunit Then
                    TJJS = a(j, j) * TSCAL
                Else
                    TJJS = TSCAL
                    If TSCAL = 1# Then
                        Flg = 100#
                    End If
                End If
                If Flg <> 100# Then
                    TJJ = Abs(TJJS)
                    If TJJ > SMLNUM Then
                        
                        '
                        ' abs(A(j,j)) > SMLNUM:
                        '
                        If TJJ < 1# Then
                            If XJ > TJJ * BIGNUM Then
                                
                                '
                                ' Scale x by 1/b(j).
                                '
                                REC = 1# / XJ
                                For i_ = 1# To N Step 1
                                    x(i_) = REC * x(i_)
                                Next i_
                                s = s * REC
                                XMAX = XMAX * REC
                            End If
                        End If
                        x(j) = x(j) / TJJS
                        XJ = Abs(x(j))
                    Else
                        If TJJ > 0# Then
                            
                            '
                            ' 0 < abs(A(j,j)) <= SMLNUM:
                            '
                            If XJ > TJJ * BIGNUM Then
                                
                                '
                                ' Scale x by (1/abs(x(j)))*abs(A(j,j))*BIGNUM
                                ' to avoid overflow when dividing by A(j,j).
                                '
                                REC = TJJ * BIGNUM / XJ
                                If CNORM(j) > 1# Then
                                    
                                    '
                                    ' Scale by 1/CNORM(j) to avoid overflow when
                                    ' multiplying x(j) times column j.
                                    '
                                    REC = REC / CNORM(j)
                                End If
                                For i_ = 1# To N Step 1
                                    x(i_) = REC * x(i_)
                                Next i_
                                s = s * REC
                                XMAX = XMAX * REC
                            End If
                            x(j) = x(j) / TJJS
                            XJ = Abs(x(j))
                        Else
                            
                            '
                            ' A(j,j) = 0:  Set x(1:n) = 0, x(j) = 1, and
                            ' scale = 0, and compute a solution to A*x = 0.
                            '
                            For i = 1# To N Step 1
                                x(i) = 0#
                            Next i
                            x(j) = 1#
                            XJ = 1#
                            s = 0#
                            XMAX = 0#
                        End If
                    End If
                End If
                
                '
                ' Scale x if necessary to avoid overflow when adding a
                ' multiple of column j of A.
                '
                If XJ > 1# Then
                    REC = 1# / XJ
                    If CNORM(j) > (BIGNUM - XMAX) * REC Then
                        
                        '
                        ' Scale x by 1/(2*abs(x(j))).
                        '
                        REC = REC * 0.5
                        For i_ = 1# To N Step 1
                            x(i_) = REC * x(i_)
                        Next i_
                        s = s * REC
                    End If
                Else
                    If XJ * CNORM(j) > BIGNUM - XMAX Then
                        
                        '
                        ' Scale x by 1/2.
                        '
                        For i_ = 1# To N Step 1
                            x(i_) = 0.5 * x(i_)
                        Next i_
                        s = s * 0.5
                    End If
                End If
                If UPPER Then
                    If j > 1# Then
                        
                        '
                        ' Compute the update
                        ' x(1:j-1) := x(1:j-1) - x(j) * A(1:j-1,j)
                        '
                        V = x(j) * TSCAL
                        JM1 = j - 1#
                        For i_ = 1# To JM1 Step 1
                            x(i_) = x(i_) - V * a(i_, j)
                        Next i_
                        i = 1#
                        For K = 2# To j - 1# Step 1
                            If Abs(x(K)) > Abs(x(i)) Then
                                i = K
                            End If
                        Next K
                        XMAX = Abs(x(i))
                    End If
                Else
                    If j < N Then
                        
                        '
                        ' Compute the update
                        ' x(j+1:n) := x(j+1:n) - x(j) * A(j+1:n,j)
                        '
                        JP1 = j + 1#
                        V = x(j) * TSCAL
                        For i_ = JP1 To N Step 1
                            x(i_) = x(i_) - V * a(i_, j)
                        Next i_
                        i = j + 1#
                        For K = j + 2# To N Step 1
                            If Abs(x(K)) > Abs(x(i)) Then
                                i = K
                            End If
                        Next K
                        XMAX = Abs(x(i))
                    End If
                End If
                j = j + JINC
            Loop
        Else
            
            '
            ' Solve A' * x = b
            '
            j = JFIRST
            Do While JINC > 0# And j <= JLAST Or JINC < 0# And j >= JLAST
                
                '
                ' Compute x(j) = b(j) - sum A(k,j)*x(k).
                '   k<>j
                '
                XJ = Abs(x(j))
                USCAL = TSCAL
                REC = 1# / MaxReal(XMAX, 1#)
                If CNORM(j) > (BIGNUM - XJ) * REC Then
                    
                    '
                    ' If x(j) could overflow, scale x by 1/(2*XMAX).
                    '
                    REC = REC * 0.5
                    If NOunit Then
                        TJJS = a(j, j) * TSCAL
                    Else
                        TJJS = TSCAL
                    End If
                    TJJ = Abs(TJJS)
                    If TJJ > 1# Then
                        
                        '
                        ' Divide by A(j,j) when scaling x if A(j,j) > 1.
                        '
                        REC = MinReal(1#, REC * TJJ)
                        USCAL = USCAL / TJJS
                    End If
                    If REC < 1# Then
                        For i_ = 1# To N Step 1
                            x(i_) = REC * x(i_)
                        Next i_
                        s = s * REC
                        XMAX = XMAX * REC
                    End If
                End If
                SUMJ = 0#
                If USCAL = 1# Then
                    
                    '
                    ' If the scaling needed for A in the dot product is 1,
                    ' call DDOT to perform the dot product.
                    '
                    If UPPER Then
                        If j > 1# Then
                            JM1 = j - 1#
                            SUMJ = 0#
                            For i_ = 1# To JM1 Step 1
                                SUMJ = SUMJ + a(i_, j) * x(i_)
                            Next i_
                        Else
                            SUMJ = 0#
                        End If
                    Else
                        If j < N Then
                            JP1 = j + 1#
                            SUMJ = 0#
                            For i_ = JP1 To N Step 1
                                SUMJ = SUMJ + a(i_, j) * x(i_)
                            Next i_
                        End If
                    End If
                Else
                    
                    '
                    ' Otherwise, use in-line code for the dot product.
                    '
                    If UPPER Then
                        For i = 1# To j - 1# Step 1
                            V = a(i, j) * USCAL
                            SUMJ = SUMJ + V * x(i)
                        Next i
                    Else
                        If j < N Then
                            For i = j + 1# To N Step 1
                                V = a(i, j) * USCAL
                                SUMJ = SUMJ + V * x(i)
                            Next i
                        End If
                    End If
                End If
                If USCAL = TSCAL Then
                    
                    '
                    ' Compute x(j) := ( x(j) - sumj ) / A(j,j) if 1/A(j,j)
                    ' was not used to scale the dotproduct.
                    '
                    x(j) = x(j) - SUMJ
                    XJ = Abs(x(j))
                    Flg = 0#
                    If NOunit Then
                        TJJS = a(j, j) * TSCAL
                    Else
                        TJJS = TSCAL
                        If TSCAL = 1# Then
                            Flg = 150#
                        End If
                    End If
                    
                    '
                    ' Compute x(j) = x(j) / A(j,j), scaling if necessary.
                    '
                    If Flg <> 150# Then
                        TJJ = Abs(TJJS)
                        If TJJ > SMLNUM Then
                            
                            '
                            ' abs(A(j,j)) > SMLNUM:
                            '
                            If TJJ < 1# Then
                                If XJ > TJJ * BIGNUM Then
                                    
                                    '
                                    ' Scale X by 1/abs(x(j)).
                                    '
                                    REC = 1# / XJ
                                    For i_ = 1# To N Step 1
                                        x(i_) = REC * x(i_)
                                    Next i_
                                    s = s * REC
                                    XMAX = XMAX * REC
                                End If
                            End If
                            x(j) = x(j) / TJJS
                        Else
                            If TJJ > 0# Then
                                
                                '
                                ' 0 < abs(A(j,j)) <= SMLNUM:
                                '
                                If XJ > TJJ * BIGNUM Then
                                    
                                    '
                                    ' Scale x by (1/abs(x(j)))*abs(A(j,j))*BIGNUM.
                                    '
                                    REC = TJJ * BIGNUM / XJ
                                    For i_ = 1# To N Step 1
                                        x(i_) = REC * x(i_)
                                    Next i_
                                    s = s * REC
                                    XMAX = XMAX * REC
                                End If
                                x(j) = x(j) / TJJS
                            Else
                                
                                '
                                ' A(j,j) = 0:  Set x(1:n) = 0, x(j) = 1, and
                                ' scale = 0, and compute a solution to A'*x = 0.
                                '
                                For i = 1# To N Step 1
                                    x(i) = 0#
                                Next i
                                x(j) = 1#
                                s = 0#
                                XMAX = 0#
                            End If
                        End If
                    End If
                Else
                    
                    '
                    ' Compute x(j) := x(j) / A(j,j)  - sumj if the dot
                    ' product has already been divided by 1/A(j,j).
                    '
                    x(j) = x(j) / TJJS - SUMJ
                End If
                XMAX = MaxReal(XMAX, Abs(x(j)))
                j = j + JINC
            Loop
        End If
        s = s / TSCAL
    End If
    
    '
    ' Scale the column norms by 1/TSCAL for return.
    '
    If TSCAL <> 1# Then
        V = 1# / TSCAL
        For i_ = 1# To N Step 1
            CNORM(i_) = V * CNORM(i_)
        Next i_
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 1992-2007 The University of Tennessee. All rights reserved.
'
'Contributors:
'    * Sergey Bochkanov (ALGLIB project). Translation from FORTRAN to
'      pseudocode.
'
'See subroutines comments for additional copyrights.
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'LU decomposition of a general real matrix with row pivoting
'
'A is represented as A = P*L*U, where:
'* L is lower unitriangular matrix
'* U is upper triangular matrix
'* P = P0*P1*...*PK, K=min(M,N)-1,
'  Pi - permutation matrix for I and Pivots[I]
'
'This is cache-oblivous implementation of LU decomposition.
'It is optimized for square matrices. As for rectangular matrices:
'* best case - M>>N
'* worst case - N>>M, small M, large N, matrix does not fit in CPU cache
'
'INPUT PARAMETERS:
'    A       -   array[0..M-1, 0..N-1].
'    M       -   number of rows in matrix A.
'    N       -   number of columns in matrix A.
'
'
'OUTPUT PARAMETERS:
'    A       -   matrices L and U in compact form:
'                * L is stored under main diagonal
'                * U is stored on and above main diagonal
'    Pivots  -   permutation matrix in compact form.
'                array[0..Min(M-1,N-1)].
'
'  -- ALGLIB routine --
'     10.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixLU(ByRef a() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Pivots() As Long)
    Call RMatrixPLU(a, M, N, Pivots)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'LU decomposition of a general complex matrix with row pivoting
'
'A is represented as A = P*L*U, where:
'* L is lower unitriangular matrix
'* U is upper triangular matrix
'* P = P0*P1*...*PK, K=min(M,N)-1,
'  Pi - permutation matrix for I and Pivots[I]
'
'This is cache-oblivous implementation of LU decomposition. It is optimized
'for square matrices. As for rectangular matrices:
'* best case - M>>N
'* worst case - N>>M, small M, large N, matrix does not fit in CPU cache
'
'INPUT PARAMETERS:
'    A       -   array[0..M-1, 0..N-1].
'    M       -   number of rows in matrix A.
'    N       -   number of columns in matrix A.
'
'
'OUTPUT PARAMETERS:
'    A       -   matrices L and U in compact form:
'                * L is stored under main diagonal
'                * U is stored on and above main diagonal
'    Pivots  -   permutation matrix in compact form.
'                array[0..Min(M-1,N-1)].
'
'  -- ALGLIB routine --
'     10.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixLU(ByRef a() As Complex, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Pivots() As Long)
    Call CMatrixPLU(a, M, N, Pivots)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Cache-oblivious Cholesky decomposition
'
'The algorithm computes Cholesky decomposition  of  a  Hermitian  positive-
'definite matrix. The result of an algorithm is a representation  of  A  as
'A=U'*U  or A=L*L' (here X' detones conj(X^T)).
'
'INPUT PARAMETERS:
'    A       -   upper or lower triangle of a factorized matrix.
'                array with elements [0..N-1, 0..N-1].
'    N       -   size of matrix A.
'    IsUpper -   if IsUpper=True, then A contains an upper triangle of
'                a symmetric matrix, otherwise A contains a lower one.
'
'OUTPUT PARAMETERS:
'    A       -   the result of factorization. If IsUpper=True, then
'                the upper triangle contains matrix U, so that A = U'*U,
'                and the elements below the main diagonal are not modified.
'                Similarly, if IsUpper = False.
'
'RESULT:
'    If  the  matrix  is  positive-definite,  the  function  returns  True.
'    Otherwise, the function returns False. Contents of A is not determined
'    in such case.
'
'  -- ALGLIB routine --
'     15.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function HPDMatrixCholesky(ByRef a() As Complex, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean) As Boolean
    Dim Result As Boolean
    Dim tmp() As Complex
    If N < 1# Then
        Result = False
        HPDMatrixCholesky = Result
        Exit Function
    End If
    ReDim tmp(0 To 2# * N - 1)
    Result = HPDMatrixCholeskyRec(a, 0#, N, IsUpper, tmp)
    HPDMatrixCholesky = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Cache-oblivious Cholesky decomposition
'
'The algorithm computes Cholesky decomposition  of  a  symmetric  positive-
'definite matrix. The result of an algorithm is a representation  of  A  as
'A=U^T*U  or A=L*L^T
'
'INPUT PARAMETERS:
'    A       -   upper or lower triangle of a factorized matrix.
'                array with elements [0..N-1, 0..N-1].
'    N       -   size of matrix A.
'    IsUpper -   if IsUpper=True, then A contains an upper triangle of
'                a symmetric matrix, otherwise A contains a lower one.
'
'OUTPUT PARAMETERS:
'    A       -   the result of factorization. If IsUpper=True, then
'                the upper triangle contains matrix U, so that A = U^T*U,
'                and the elements below the main diagonal are not modified.
'                Similarly, if IsUpper = False.
'
'RESULT:
'    If  the  matrix  is  positive-definite,  the  function  returns  True.
'    Otherwise, the function returns False. Contents of A is not determined
'    in such case.
'
'  -- ALGLIB routine --
'     15.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function SPDMatrixCholesky(ByRef a() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean) As Boolean
    Dim Result As Boolean
    Dim tmp() As Double
    If N < 1# Then
        Result = False
        SPDMatrixCholesky = Result
        Exit Function
    End If
    ReDim tmp(0 To 2# * N - 1)
    Result = SPDMatrixCholeskyRec(a, 0#, N, IsUpper, tmp)
    SPDMatrixCholesky = Result
End Function
Public Sub RMatrixLUP(ByRef a() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Pivots() As Long)
    Dim tmp() As Double
    Dim i As Long
    Dim j As Long
    Dim MX As Double
    Dim V As Double
    Dim i_ As Long
    
    '
    ' Internal LU decomposition subroutine.
    ' Never call it directly.
    '
    
    '
    ' Scale matrix to avoid overflows,
    ' decompose it, then scale back.
    '
    MX = 0#
    For i = 0# To M - 1# Step 1
        For j = 0# To N - 1# Step 1
            MX = MaxReal(MX, Abs(a(i, j)))
        Next j
    Next i
    If MX <> 0# Then
        V = 1# / MX
        For i = 0# To M - 1# Step 1
            For i_ = 0# To N - 1# Step 1
                a(i, i_) = V * a(i, i_)
            Next i_
        Next i
    End If
    ReDim Pivots(0 To MinInt(M, N) - 1)
    ReDim tmp(0 To 2# * MaxInt(M, N) - 1)
    Call RMatrixLUPRec(a, 0#, M, N, Pivots, tmp)
    If MX <> 0# Then
        V = MX
        For i = 0# To M - 1# Step 1
            For i_ = 0# To MinInt(i, N - 1#) Step 1
                a(i, i_) = V * a(i, i_)
            Next i_
        Next i
    End If
End Sub
Public Sub CMatrixLUP(ByRef a() As Complex, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Pivots() As Long)
    Dim tmp() As Complex
    Dim i As Long
    Dim j As Long
    Dim MX As Double
    Dim V As Double
    Dim i_ As Long
    
    '
    ' Internal LU decomposition subroutine.
    ' Never call it directly.
    '
    
    '
    ' Scale matrix to avoid overflows,
    ' decompose it, then scale back.
    '
    MX = 0#
    For i = 0# To M - 1# Step 1
        For j = 0# To N - 1# Step 1
            MX = MaxReal(MX, AbsComplex(a(i, j)))
        Next j
    Next i
    If MX <> 0# Then
        V = 1# / MX
        For i = 0# To M - 1# Step 1
            For i_ = 0# To N - 1# Step 1
                a(i, i_) = C_MulR(a(i, i_), V)
            Next i_
        Next i
    End If
    ReDim Pivots(0 To MinInt(M, N) - 1)
    ReDim tmp(0 To 2# * MaxInt(M, N) - 1)
    Call CMatrixLUPRec(a, 0#, M, N, Pivots, tmp)
    If MX <> 0# Then
        V = MX
        For i = 0# To M - 1# Step 1
            For i_ = 0# To MinInt(i, N - 1#) Step 1
                a(i, i_) = C_MulR(a(i, i_), V)
            Next i_
        Next i
    End If
End Sub
Public Sub RMatrixPLU(ByRef a() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Pivots() As Long)
    Dim tmp() As Double
    Dim i As Long
    Dim j As Long
    Dim MX As Double
    Dim V As Double
    Dim i_ As Long
    
    '
    ' Internal LU decomposition subroutine.
    ' Never call it directly.
    '
    ReDim tmp(0 To 2# * MaxInt(M, N) - 1)
    ReDim Pivots(0 To MinInt(M, N) - 1)
    
    '
    ' Scale matrix to avoid overflows,
    ' decompose it, then scale back.
    '
    MX = 0#
    For i = 0# To M - 1# Step 1
        For j = 0# To N - 1# Step 1
            MX = MaxReal(MX, Abs(a(i, j)))
        Next j
    Next i
    If MX <> 0# Then
        V = 1# / MX
        For i = 0# To M - 1# Step 1
            For i_ = 0# To N - 1# Step 1
                a(i, i_) = V * a(i, i_)
            Next i_
        Next i
    End If
    Call RMatrixPLURec(a, 0#, M, N, Pivots, tmp)
    If MX <> 0# Then
        V = MX
        For i = 0# To MinInt(M, N) - 1# Step 1
            For i_ = i To N - 1# Step 1
                a(i, i_) = V * a(i, i_)
            Next i_
        Next i
    End If
End Sub
Public Sub CMatrixPLU(ByRef a() As Complex, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Pivots() As Long)
    Dim tmp() As Complex
    Dim i As Long
    Dim j As Long
    Dim MX As Double
    Dim V As Complex
    Dim i_ As Long
    
    '
    ' Internal LU decomposition subroutine.
    ' Never call it directly.
    '
    ReDim tmp(0 To 2# * MaxInt(M, N) - 1)
    ReDim Pivots(0 To MinInt(M, N) - 1)
    
    '
    ' Scale matrix to avoid overflows,
    ' decompose it, then scale back.
    '
    MX = 0#
    For i = 0# To M - 1# Step 1
        For j = 0# To N - 1# Step 1
            MX = MaxReal(MX, AbsComplex(a(i, j)))
        Next j
    Next i
    If MX <> 0# Then
        V = C_Complex(1# / MX)
        For i = 0# To M - 1# Step 1
            For i_ = 0# To N - 1# Step 1
                a(i, i_) = C_Mul(V, a(i, i_))
            Next i_
        Next i
    End If
    Call CMatrixPLURec(a, 0#, M, N, Pivots, tmp)
    If MX <> 0# Then
        V = C_Complex(MX)
        For i = 0# To MinInt(M, N) - 1# Step 1
            For i_ = i To N - 1# Step 1
                a(i, i_) = C_Mul(V, a(i, i_))
            Next i_
        Next i
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Recurrent complex LU subroutine.
'Never call it directly.
'
'  -- ALGLIB routine --
'     04.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub CMatrixLUPRec(ByRef a() As Complex, _
         ByVal Offs As Long, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Pivots() As Long, _
         ByRef tmp() As Complex)
    Dim i As Long
    Dim M1 As Long
    Dim M2 As Long
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' Kernel case
    '
    If MinInt(M, N) <= ABLASComplexBlockSize(a) Then
        Call CMatrixLUP2(a, Offs, M, N, Pivots, tmp)
        Exit Sub
    End If
    
    '
    ' Preliminary step, make N>=M
    '
    '     ( A1 )
    ' A = (    ), where A1 is square
    '     ( A2 )
    '
    ' Factorize A1, update A2
    '
    If M > N Then
        Call CMatrixLUPRec(a, Offs, N, N, Pivots, tmp)
        For i = 0# To N - 1# Step 1
            i1_ = (Offs + N) - (0#)
            For i_ = 0# To M - N - 1# Step 1
                tmp(i_) = a(i_ + i1_, Offs + i)
            Next i_
            For i_ = Offs + N To Offs + M - 1# Step 1
                a(i_, Offs + i) = a(i_, Pivots(Offs + i))
            Next i_
            i1_ = (0#) - (Offs + N)
            For i_ = Offs + N To Offs + M - 1# Step 1
                a(i_, Pivots(Offs + i)) = tmp(i_ + i1_)
            Next i_
        Next i
        Call CMatrixRightTRSM(M - N, N, a, Offs, Offs, True, True, 0#, a, Offs + N, Offs)
        Exit Sub
    End If
    
    '
    ' Non-kernel case
    '
    Call ABLASComplexSplitLength(a, M, M1, M2)
    Call CMatrixLUPRec(a, Offs, M1, N, Pivots, tmp)
    If M2 > 0# Then
        For i = 0# To M1 - 1# Step 1
            If Offs + i <> Pivots(Offs + i) Then
                i1_ = (Offs + M1) - (0#)
                For i_ = 0# To M2 - 1# Step 1
                    tmp(i_) = a(i_ + i1_, Offs + i)
                Next i_
                For i_ = Offs + M1 To Offs + M - 1# Step 1
                    a(i_, Offs + i) = a(i_, Pivots(Offs + i))
                Next i_
                i1_ = (0#) - (Offs + M1)
                For i_ = Offs + M1 To Offs + M - 1# Step 1
                    a(i_, Pivots(Offs + i)) = tmp(i_ + i1_)
                Next i_
            End If
        Next i
        Call CMatrixRightTRSM(M2, M1, a, Offs, Offs, True, True, 0#, a, Offs + M1, Offs)
        Call CMatrixGEMM(M - M1, N - M1, M1, C_Complex(-1#), a, Offs + M1, Offs, 0#, a, Offs, Offs + M1, 0#, C_Complex(1#), a, Offs + M1, Offs + M1)
        Call CMatrixLUPRec(a, Offs + M1, M - M1, N - M1, Pivots, tmp)
        For i = 0# To M2 - 1# Step 1
            If Offs + M1 + i <> Pivots(Offs + M1 + i) Then
                i1_ = (Offs) - (0#)
                For i_ = 0# To M1 - 1# Step 1
                    tmp(i_) = a(i_ + i1_, Offs + M1 + i)
                Next i_
                For i_ = Offs To Offs + M1 - 1# Step 1
                    a(i_, Offs + M1 + i) = a(i_, Pivots(Offs + M1 + i))
                Next i_
                i1_ = (0#) - (Offs)
                For i_ = Offs To Offs + M1 - 1# Step 1
                    a(i_, Pivots(Offs + M1 + i)) = tmp(i_ + i1_)
                Next i_
            End If
        Next i
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Recurrent real LU subroutine.
'Never call it directly.
'
'  -- ALGLIB routine --
'     04.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub RMatrixLUPRec(ByRef a() As Double, _
         ByVal Offs As Long, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Pivots() As Long, _
         ByRef tmp() As Double)
    Dim i As Long
    Dim M1 As Long
    Dim M2 As Long
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' Kernel case
    '
    If MinInt(M, N) <= ABLASBlockSize(a) Then
        Call RMatrixLUP2(a, Offs, M, N, Pivots, tmp)
        Exit Sub
    End If
    
    '
    ' Preliminary step, make N>=M
    '
    '     ( A1 )
    ' A = (    ), where A1 is square
    '     ( A2 )
    '
    ' Factorize A1, update A2
    '
    If M > N Then
        Call RMatrixLUPRec(a, Offs, N, N, Pivots, tmp)
        For i = 0# To N - 1# Step 1
            If Offs + i <> Pivots(Offs + i) Then
                i1_ = (Offs + N) - (0#)
                For i_ = 0# To M - N - 1# Step 1
                    tmp(i_) = a(i_ + i1_, Offs + i)
                Next i_
                For i_ = Offs + N To Offs + M - 1# Step 1
                    a(i_, Offs + i) = a(i_, Pivots(Offs + i))
                Next i_
                i1_ = (0#) - (Offs + N)
                For i_ = Offs + N To Offs + M - 1# Step 1
                    a(i_, Pivots(Offs + i)) = tmp(i_ + i1_)
                Next i_
            End If
        Next i
        Call RMatrixRightTRSM(M - N, N, a, Offs, Offs, True, True, 0#, a, Offs + N, Offs)
        Exit Sub
    End If
    
    '
    ' Non-kernel case
    '
    Call ABLASSplitLength(a, M, M1, M2)
    Call RMatrixLUPRec(a, Offs, M1, N, Pivots, tmp)
    If M2 > 0# Then
        For i = 0# To M1 - 1# Step 1
            If Offs + i <> Pivots(Offs + i) Then
                i1_ = (Offs + M1) - (0#)
                For i_ = 0# To M2 - 1# Step 1
                    tmp(i_) = a(i_ + i1_, Offs + i)
                Next i_
                For i_ = Offs + M1 To Offs + M - 1# Step 1
                    a(i_, Offs + i) = a(i_, Pivots(Offs + i))
                Next i_
                i1_ = (0#) - (Offs + M1)
                For i_ = Offs + M1 To Offs + M - 1# Step 1
                    a(i_, Pivots(Offs + i)) = tmp(i_ + i1_)
                Next i_
            End If
        Next i
        Call RMatrixRightTRSM(M2, M1, a, Offs, Offs, True, True, 0#, a, Offs + M1, Offs)
        Call RMatrixGEMM(M - M1, N - M1, M1, -1#, a, Offs + M1, Offs, 0#, a, Offs, Offs + M1, 0#, 1#, a, Offs + M1, Offs + M1)
        Call RMatrixLUPRec(a, Offs + M1, M - M1, N - M1, Pivots, tmp)
        For i = 0# To M2 - 1# Step 1
            If Offs + M1 + i <> Pivots(Offs + M1 + i) Then
                i1_ = (Offs) - (0#)
                For i_ = 0# To M1 - 1# Step 1
                    tmp(i_) = a(i_ + i1_, Offs + M1 + i)
                Next i_
                For i_ = Offs To Offs + M1 - 1# Step 1
                    a(i_, Offs + M1 + i) = a(i_, Pivots(Offs + M1 + i))
                Next i_
                i1_ = (0#) - (Offs)
                For i_ = Offs To Offs + M1 - 1# Step 1
                    a(i_, Pivots(Offs + M1 + i)) = tmp(i_ + i1_)
                Next i_
            End If
        Next i
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Recurrent complex LU subroutine.
'Never call it directly.
'
'  -- ALGLIB routine --
'     04.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub CMatrixPLURec(ByRef a() As Complex, _
         ByVal Offs As Long, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Pivots() As Long, _
         ByRef tmp() As Complex)
    Dim i As Long
    Dim N1 As Long
    Dim N2 As Long
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' Kernel case
    '
    If MinInt(M, N) <= ABLASComplexBlockSize(a) Then
        Call CMatrixPLU2(a, Offs, M, N, Pivots, tmp)
        Exit Sub
    End If
    
    '
    ' Preliminary step, make M>=N.
    '
    ' A = (A1 A2), where A1 is square
    ' Factorize A1, update A2
    '
    If N > M Then
        Call CMatrixPLURec(a, Offs, M, M, Pivots, tmp)
        For i = 0# To M - 1# Step 1
            i1_ = (Offs + M) - (0#)
            For i_ = 0# To N - M - 1# Step 1
                tmp(i_) = a(Offs + i, i_ + i1_)
            Next i_
            For i_ = Offs + M To Offs + N - 1# Step 1
                a(Offs + i, i_) = a(Pivots(Offs + i), i_)
            Next i_
            i1_ = (0#) - (Offs + M)
            For i_ = Offs + M To Offs + N - 1# Step 1
                a(Pivots(Offs + i), i_) = tmp(i_ + i1_)
            Next i_
        Next i
        Call CMatrixLeftTRSM(M, N - M, a, Offs, Offs, False, True, 0#, a, Offs, Offs + M)
        Exit Sub
    End If
    
    '
    ' Non-kernel case
    '
    Call ABLASComplexSplitLength(a, N, N1, N2)
    Call CMatrixPLURec(a, Offs, M, N1, Pivots, tmp)
    If N2 > 0# Then
        For i = 0# To N1 - 1# Step 1
            If Offs + i <> Pivots(Offs + i) Then
                i1_ = (Offs + N1) - (0#)
                For i_ = 0# To N2 - 1# Step 1
                    tmp(i_) = a(Offs + i, i_ + i1_)
                Next i_
                For i_ = Offs + N1 To Offs + N - 1# Step 1
                    a(Offs + i, i_) = a(Pivots(Offs + i), i_)
                Next i_
                i1_ = (0#) - (Offs + N1)
                For i_ = Offs + N1 To Offs + N - 1# Step 1
                    a(Pivots(Offs + i), i_) = tmp(i_ + i1_)
                Next i_
            End If
        Next i
        Call CMatrixLeftTRSM(N1, N2, a, Offs, Offs, False, True, 0#, a, Offs, Offs + N1)
        Call CMatrixGEMM(M - N1, N - N1, N1, C_Complex(-1#), a, Offs + N1, Offs, 0#, a, Offs, Offs + N1, 0#, C_Complex(1#), a, Offs + N1, Offs + N1)
        Call CMatrixPLURec(a, Offs + N1, M - N1, N - N1, Pivots, tmp)
        For i = 0# To N2 - 1# Step 1
            If Offs + N1 + i <> Pivots(Offs + N1 + i) Then
                i1_ = (Offs) - (0#)
                For i_ = 0# To N1 - 1# Step 1
                    tmp(i_) = a(Offs + N1 + i, i_ + i1_)
                Next i_
                For i_ = Offs To Offs + N1 - 1# Step 1
                    a(Offs + N1 + i, i_) = a(Pivots(Offs + N1 + i), i_)
                Next i_
                i1_ = (0#) - (Offs)
                For i_ = Offs To Offs + N1 - 1# Step 1
                    a(Pivots(Offs + N1 + i), i_) = tmp(i_ + i1_)
                Next i_
            End If
        Next i
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Recurrent real LU subroutine.
'Never call it directly.
'
'  -- ALGLIB routine --
'     04.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub RMatrixPLURec(ByRef a() As Double, _
         ByVal Offs As Long, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Pivots() As Long, _
         ByRef tmp() As Double)
    Dim i As Long
    Dim N1 As Long
    Dim N2 As Long
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' Kernel case
    '
    If MinInt(M, N) <= ABLASBlockSize(a) Then
        Call RMatrixPLU2(a, Offs, M, N, Pivots, tmp)
        Exit Sub
    End If
    
    '
    ' Preliminary step, make M>=N.
    '
    ' A = (A1 A2), where A1 is square
    ' Factorize A1, update A2
    '
    If N > M Then
        Call RMatrixPLURec(a, Offs, M, M, Pivots, tmp)
        For i = 0# To M - 1# Step 1
            i1_ = (Offs + M) - (0#)
            For i_ = 0# To N - M - 1# Step 1
                tmp(i_) = a(Offs + i, i_ + i1_)
            Next i_
            For i_ = Offs + M To Offs + N - 1# Step 1
                a(Offs + i, i_) = a(Pivots(Offs + i), i_)
            Next i_
            i1_ = (0#) - (Offs + M)
            For i_ = Offs + M To Offs + N - 1# Step 1
                a(Pivots(Offs + i), i_) = tmp(i_ + i1_)
            Next i_
        Next i
        Call RMatrixLeftTRSM(M, N - M, a, Offs, Offs, False, True, 0#, a, Offs, Offs + M)
        Exit Sub
    End If
    
    '
    ' Non-kernel case
    '
    Call ABLASSplitLength(a, N, N1, N2)
    Call RMatrixPLURec(a, Offs, M, N1, Pivots, tmp)
    If N2 > 0# Then
        For i = 0# To N1 - 1# Step 1
            If Offs + i <> Pivots(Offs + i) Then
                i1_ = (Offs + N1) - (0#)
                For i_ = 0# To N2 - 1# Step 1
                    tmp(i_) = a(Offs + i, i_ + i1_)
                Next i_
                For i_ = Offs + N1 To Offs + N - 1# Step 1
                    a(Offs + i, i_) = a(Pivots(Offs + i), i_)
                Next i_
                i1_ = (0#) - (Offs + N1)
                For i_ = Offs + N1 To Offs + N - 1# Step 1
                    a(Pivots(Offs + i), i_) = tmp(i_ + i1_)
                Next i_
            End If
        Next i
        Call RMatrixLeftTRSM(N1, N2, a, Offs, Offs, False, True, 0#, a, Offs, Offs + N1)
        Call RMatrixGEMM(M - N1, N - N1, N1, -1#, a, Offs + N1, Offs, 0#, a, Offs, Offs + N1, 0#, 1#, a, Offs + N1, Offs + N1)
        Call RMatrixPLURec(a, Offs + N1, M - N1, N - N1, Pivots, tmp)
        For i = 0# To N2 - 1# Step 1
            If Offs + N1 + i <> Pivots(Offs + N1 + i) Then
                i1_ = (Offs) - (0#)
                For i_ = 0# To N1 - 1# Step 1
                    tmp(i_) = a(Offs + N1 + i, i_ + i1_)
                Next i_
                For i_ = Offs To Offs + N1 - 1# Step 1
                    a(Offs + N1 + i, i_) = a(Pivots(Offs + N1 + i), i_)
                Next i_
                i1_ = (0#) - (Offs)
                For i_ = Offs To Offs + N1 - 1# Step 1
                    a(Pivots(Offs + N1 + i), i_) = tmp(i_ + i1_)
                Next i_
            End If
        Next i
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Complex LUP kernel
'
'  -- ALGLIB routine --
'     10.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub CMatrixLUP2(ByRef a() As Complex, _
         ByVal Offs As Long, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Pivots() As Long, _
         ByRef tmp() As Complex)
    Dim i As Long
    Dim j As Long
    Dim JP As Long
    Dim s As Complex
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' Quick return if possible
    '
    If M = 0# Or N = 0# Then
        Exit Sub
    End If
    
    '
    ' main cycle
    '
    For j = 0# To MinInt(M - 1#, N - 1#) Step 1
        
        '
        ' Find pivot, swap columns
        '
        JP = j
        For i = j + 1# To N - 1# Step 1
            If AbsComplex(a(Offs + j, Offs + i)) > AbsComplex(a(Offs + j, Offs + JP)) Then
                JP = i
            End If
        Next i
        Pivots(Offs + j) = Offs + JP
        If JP <> j Then
            i1_ = (Offs) - (0#)
            For i_ = 0# To M - 1# Step 1
                tmp(i_) = a(i_ + i1_, Offs + j)
            Next i_
            For i_ = Offs To Offs + M - 1# Step 1
                a(i_, Offs + j) = a(i_, Offs + JP)
            Next i_
            i1_ = (0#) - (Offs)
            For i_ = Offs To Offs + M - 1# Step 1
                a(i_, Offs + JP) = tmp(i_ + i1_)
            Next i_
        End If
        
        '
        ' LU decomposition of 1x(N-J) matrix
        '
        If C_NotEqualR(a(Offs + j, Offs + j), 0#) And j + 1# <= N - 1# Then
            s = C_RDiv(1#, a(Offs + j, Offs + j))
            For i_ = Offs + j + 1# To Offs + N - 1# Step 1
                a(Offs + j, i_) = C_Mul(s, a(Offs + j, i_))
            Next i_
        End If
        
        '
        ' Update trailing (M-J-1)x(N-J-1) matrix
        '
        If j < MinInt(M - 1#, N - 1#) Then
            i1_ = (Offs + j + 1#) - (0#)
            For i_ = 0# To M - j - 2# Step 1
                tmp(i_) = a(i_ + i1_, Offs + j)
            Next i_
            i1_ = (Offs + j + 1#) - (M)
            For i_ = M To M + N - j - 2# Step 1
                tmp(i_) = C_Opposite(a(Offs + j, i_ + i1_))
            Next i_
            Call CMatrixRank1(M - j - 1#, N - j - 1#, a, Offs + j + 1#, Offs + j + 1#, tmp, 0#, tmp, M)
        End If
    Next j
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Real LUP kernel
'
'  -- ALGLIB routine --
'     10.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub RMatrixLUP2(ByRef a() As Double, _
         ByVal Offs As Long, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Pivots() As Long, _
         ByRef tmp() As Double)
    Dim i As Long
    Dim j As Long
    Dim JP As Long
    Dim s As Double
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' Quick return if possible
    '
    If M = 0# Or N = 0# Then
        Exit Sub
    End If
    
    '
    ' main cycle
    '
    For j = 0# To MinInt(M - 1#, N - 1#) Step 1
        
        '
        ' Find pivot, swap columns
        '
        JP = j
        For i = j + 1# To N - 1# Step 1
            If Abs(a(Offs + j, Offs + i)) > Abs(a(Offs + j, Offs + JP)) Then
                JP = i
            End If
        Next i
        Pivots(Offs + j) = Offs + JP
        If JP <> j Then
            i1_ = (Offs) - (0#)
            For i_ = 0# To M - 1# Step 1
                tmp(i_) = a(i_ + i1_, Offs + j)
            Next i_
            For i_ = Offs To Offs + M - 1# Step 1
                a(i_, Offs + j) = a(i_, Offs + JP)
            Next i_
            i1_ = (0#) - (Offs)
            For i_ = Offs To Offs + M - 1# Step 1
                a(i_, Offs + JP) = tmp(i_ + i1_)
            Next i_
        End If
        
        '
        ' LU decomposition of 1x(N-J) matrix
        '
        If a(Offs + j, Offs + j) <> 0# And j + 1# <= N - 1# Then
            s = 1# / a(Offs + j, Offs + j)
            For i_ = Offs + j + 1# To Offs + N - 1# Step 1
                a(Offs + j, i_) = s * a(Offs + j, i_)
            Next i_
        End If
        
        '
        ' Update trailing (M-J-1)x(N-J-1) matrix
        '
        If j < MinInt(M - 1#, N - 1#) Then
            i1_ = (Offs + j + 1#) - (0#)
            For i_ = 0# To M - j - 2# Step 1
                tmp(i_) = a(i_ + i1_, Offs + j)
            Next i_
            i1_ = (Offs + j + 1#) - (M)
            For i_ = M To M + N - j - 2# Step 1
                tmp(i_) = -a(Offs + j, i_ + i1_)
            Next i_
            Call RMatrixRank1(M - j - 1#, N - j - 1#, a, Offs + j + 1#, Offs + j + 1#, tmp, 0#, tmp, M)
        End If
    Next j
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Complex PLU kernel
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     June 30, 1992
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub CMatrixPLU2(ByRef a() As Complex, _
         ByVal Offs As Long, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Pivots() As Long, _
         ByRef tmp() As Complex)
    Dim i As Long
    Dim j As Long
    Dim JP As Long
    Dim s As Complex
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' Quick return if possible
    '
    If M = 0# Or N = 0# Then
        Exit Sub
    End If
    For j = 0# To MinInt(M - 1#, N - 1#) Step 1
        
        '
        ' Find pivot and test for singularity.
        '
        JP = j
        For i = j + 1# To M - 1# Step 1
            If AbsComplex(a(Offs + i, Offs + j)) > AbsComplex(a(Offs + JP, Offs + j)) Then
                JP = i
            End If
        Next i
        Pivots(Offs + j) = Offs + JP
        If C_NotEqualR(a(Offs + JP, Offs + j), 0#) Then
            
            '
            'Apply the interchange to rows
            '
            If JP <> j Then
                For i = 0# To N - 1# Step 1
                    s = a(Offs + j, Offs + i)
                    a(Offs + j, Offs + i) = a(Offs + JP, Offs + i)
                    a(Offs + JP, Offs + i) = s
                Next i
            End If
            
            '
            'Compute elements J+1:M of J-th column.
            '
            If j + 1# <= M - 1# Then
                s = C_RDiv(1#, a(Offs + j, Offs + j))
                For i_ = Offs + j + 1# To Offs + M - 1# Step 1
                    a(i_, Offs + j) = C_Mul(s, a(i_, Offs + j))
                Next i_
            End If
        End If
        If j < MinInt(M, N) - 1# Then
            
            '
            'Update trailing submatrix.
            '
            i1_ = (Offs + j + 1#) - (0#)
            For i_ = 0# To M - j - 2# Step 1
                tmp(i_) = a(i_ + i1_, Offs + j)
            Next i_
            i1_ = (Offs + j + 1#) - (M)
            For i_ = M To M + N - j - 2# Step 1
                tmp(i_) = C_Opposite(a(Offs + j, i_ + i1_))
            Next i_
            Call CMatrixRank1(M - j - 1#, N - j - 1#, a, Offs + j + 1#, Offs + j + 1#, tmp, 0#, tmp, M)
        End If
    Next j
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Real PLU kernel
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     June 30, 1992
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub RMatrixPLU2(ByRef a() As Double, _
         ByVal Offs As Long, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Pivots() As Long, _
         ByRef tmp() As Double)
    Dim i As Long
    Dim j As Long
    Dim JP As Long
    Dim s As Double
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' Quick return if possible
    '
    If M = 0# Or N = 0# Then
        Exit Sub
    End If
    For j = 0# To MinInt(M - 1#, N - 1#) Step 1
        
        '
        ' Find pivot and test for singularity.
        '
        JP = j
        For i = j + 1# To M - 1# Step 1
            If Abs(a(Offs + i, Offs + j)) > Abs(a(Offs + JP, Offs + j)) Then
                JP = i
            End If
        Next i
        Pivots(Offs + j) = Offs + JP
        If a(Offs + JP, Offs + j) <> 0# Then
            
            '
            'Apply the interchange to rows
            '
            If JP <> j Then
                For i = 0# To N - 1# Step 1
                    s = a(Offs + j, Offs + i)
                    a(Offs + j, Offs + i) = a(Offs + JP, Offs + i)
                    a(Offs + JP, Offs + i) = s
                Next i
            End If
            
            '
            'Compute elements J+1:M of J-th column.
            '
            If j + 1# <= M - 1# Then
                s = 1# / a(Offs + j, Offs + j)
                For i_ = Offs + j + 1# To Offs + M - 1# Step 1
                    a(i_, Offs + j) = s * a(i_, Offs + j)
                Next i_
            End If
        End If
        If j < MinInt(M, N) - 1# Then
            
            '
            'Update trailing submatrix.
            '
            i1_ = (Offs + j + 1#) - (0#)
            For i_ = 0# To M - j - 2# Step 1
                tmp(i_) = a(i_ + i1_, Offs + j)
            Next i_
            i1_ = (Offs + j + 1#) - (M)
            For i_ = M To M + N - j - 2# Step 1
                tmp(i_) = -a(Offs + j, i_ + i1_)
            Next i_
            Call RMatrixRank1(M - j - 1#, N - j - 1#, a, Offs + j + 1#, Offs + j + 1#, tmp, 0#, tmp, M)
        End If
    Next j
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Recursive computational subroutine for HPDMatrixCholesky
'
'  -- ALGLIB routine --
'     15.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Function HPDMatrixCholeskyRec(ByRef a() As Complex, _
         ByVal Offs As Long, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef tmp() As Complex) As Boolean
    Dim Result As Boolean
    Dim N1 As Long
    Dim N2 As Long
    
    '
    ' check N
    '
    If N < 1# Then
        Result = False
        HPDMatrixCholeskyRec = Result
        Exit Function
    End If
    
    '
    ' special cases
    '
    If N = 1# Then
        If a(Offs, Offs).x > 0# Then
            a(Offs, Offs) = C_Complex(Sqr(a(Offs, Offs).x))
            Result = True
        Else
            Result = False
        End If
        HPDMatrixCholeskyRec = Result
        Exit Function
    End If
    If N <= ABLASComplexBlockSize(a) Then
        Result = HPDMatrixCholesky2(a, Offs, N, IsUpper, tmp)
        HPDMatrixCholeskyRec = Result
        Exit Function
    End If
    
    '
    ' general case: split task in cache-oblivious manner
    '
    Result = True
    Call ABLASComplexSplitLength(a, N, N1, N2)
    Result = HPDMatrixCholeskyRec(a, Offs, N1, IsUpper, tmp)
    If Not Result Then
        HPDMatrixCholeskyRec = Result
        Exit Function
    End If
    If N2 > 0# Then
        If IsUpper Then
            Call CMatrixLeftTRSM(N1, N2, a, Offs, Offs, IsUpper, False, 2#, a, Offs, Offs + N1)
            Call CMatrixSYRK(N2, N1, -1#, a, Offs, Offs + N1, 2#, 1#, a, Offs + N1, Offs + N1, IsUpper)
        Else
            Call CMatrixRightTRSM(N2, N1, a, Offs, Offs, IsUpper, False, 2#, a, Offs + N1, Offs)
            Call CMatrixSYRK(N2, N1, -1#, a, Offs + N1, Offs, 0#, 1#, a, Offs + N1, Offs + N1, IsUpper)
        End If
        Result = HPDMatrixCholeskyRec(a, Offs + N1, N2, IsUpper, tmp)
        If Not Result Then
            HPDMatrixCholeskyRec = Result
            Exit Function
        End If
    End If
    HPDMatrixCholeskyRec = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Recursive computational subroutine for SPDMatrixCholesky
'
'  -- ALGLIB routine --
'     15.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Function SPDMatrixCholeskyRec(ByRef a() As Double, _
         ByVal Offs As Long, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef tmp() As Double) As Boolean
    Dim Result As Boolean
    Dim N1 As Long
    Dim N2 As Long
    
    '
    ' check N
    '
    If N < 1# Then
        Result = False
        SPDMatrixCholeskyRec = Result
        Exit Function
    End If
    
    '
    ' special cases
    '
    If N = 1# Then
        If a(Offs, Offs) > 0# Then
            a(Offs, Offs) = Sqr(a(Offs, Offs))
            Result = True
        Else
            Result = False
        End If
        SPDMatrixCholeskyRec = Result
        Exit Function
    End If
    If N <= ABLASBlockSize(a) Then
        Result = SPDMatrixCholesky2(a, Offs, N, IsUpper, tmp)
        SPDMatrixCholeskyRec = Result
        Exit Function
    End If
    
    '
    ' general case: split task in cache-oblivious manner
    '
    Result = True
    Call ABLASSplitLength(a, N, N1, N2)
    Result = SPDMatrixCholeskyRec(a, Offs, N1, IsUpper, tmp)
    If Not Result Then
        SPDMatrixCholeskyRec = Result
        Exit Function
    End If
    If N2 > 0# Then
        If IsUpper Then
            Call RMatrixLeftTRSM(N1, N2, a, Offs, Offs, IsUpper, False, 1#, a, Offs, Offs + N1)
            Call RMatrixSYRK(N2, N1, -1#, a, Offs, Offs + N1, 1#, 1#, a, Offs + N1, Offs + N1, IsUpper)
        Else
            Call RMatrixRightTRSM(N2, N1, a, Offs, Offs, IsUpper, False, 1#, a, Offs + N1, Offs)
            Call RMatrixSYRK(N2, N1, -1#, a, Offs + N1, Offs, 0#, 1#, a, Offs + N1, Offs + N1, IsUpper)
        End If
        Result = SPDMatrixCholeskyRec(a, Offs + N1, N2, IsUpper, tmp)
        If Not Result Then
            SPDMatrixCholeskyRec = Result
            Exit Function
        End If
    End If
    SPDMatrixCholeskyRec = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Level-2 Hermitian Cholesky subroutine.
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     February 29, 1992
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Function HPDMatrixCholesky2(ByRef AAA() As Complex, _
         ByVal Offs As Long, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef tmp() As Complex) As Boolean
    Dim Result As Boolean
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim J1 As Long
    Dim J2 As Long
    Dim AJJ As Double
    Dim V As Complex
    Dim R As Double
    Dim i_ As Long
    Dim i1_ As Long
    Result = True
    If N < 0# Then
        Result = False
        HPDMatrixCholesky2 = Result
        Exit Function
    End If
    
    '
    ' Quick return if possible
    '
    If N = 0# Then
        HPDMatrixCholesky2 = Result
        Exit Function
    End If
    If IsUpper Then
        
        '
        ' Compute the Cholesky factorization A = U'*U.
        '
        For j = 0# To N - 1# Step 1
            
            '
            ' Compute U(J,J) and test for non-positive-definiteness.
            '
            V = C_Complex(0#)
            For i_ = Offs To Offs + j - 1# Step 1
                V = C_Add(V, C_Mul(Conj(AAA(i_, Offs + j)), AAA(i_, Offs + j)))
            Next i_
            AJJ = C_Sub(AAA(Offs + j, Offs + j), V).x
            If AJJ <= 0# Then
                AAA(Offs + j, Offs + j) = C_Complex(AJJ)
                Result = False
                HPDMatrixCholesky2 = Result
                Exit Function
            End If
            AJJ = Sqr(AJJ)
            AAA(Offs + j, Offs + j) = C_Complex(AJJ)
            
            '
            ' Compute elements J+1:N-1 of row J.
            '
            If j < N - 1# Then
                If j > 0# Then
                    i1_ = (Offs) - (0#)
                    For i_ = 0# To j - 1# Step 1
                        tmp(i_) = C_Opposite(Conj(AAA(i_ + i1_, Offs + j)))
                    Next i_
                    Call CMatrixMV(N - j - 1#, j, AAA, Offs, Offs + j + 1#, 1#, tmp, 0#, tmp, N)
                    i1_ = (N) - (Offs + j + 1#)
                    For i_ = Offs + j + 1# To Offs + N - 1# Step 1
                        AAA(Offs + j, i_) = C_Add(AAA(Offs + j, i_), tmp(i_ + i1_))
                    Next i_
                End If
                R = 1# / AJJ
                For i_ = Offs + j + 1# To Offs + N - 1# Step 1
                    AAA(Offs + j, i_) = C_MulR(AAA(Offs + j, i_), R)
                Next i_
            End If
        Next j
    Else
        
        '
        ' Compute the Cholesky factorization A = L*L'.
        '
        For j = 0# To N - 1# Step 1
            
            '
            ' Compute L(J+1,J+1) and test for non-positive-definiteness.
            '
            V = C_Complex(0#)
            For i_ = Offs To Offs + j - 1# Step 1
                V = C_Add(V, C_Mul(Conj(AAA(Offs + j, i_)), AAA(Offs + j, i_)))
            Next i_
            AJJ = C_Sub(AAA(Offs + j, Offs + j), V).x
            If AJJ <= 0# Then
                AAA(Offs + j, Offs + j) = C_Complex(AJJ)
                Result = False
                HPDMatrixCholesky2 = Result
                Exit Function
            End If
            AJJ = Sqr(AJJ)
            AAA(Offs + j, Offs + j) = C_Complex(AJJ)
            
            '
            ' Compute elements J+1:N of column J.
            '
            If j < N - 1# Then
                If j > 0# Then
                    i1_ = (Offs) - (0#)
                    For i_ = 0# To j - 1# Step 1
                        tmp(i_) = Conj(AAA(Offs + j, i_ + i1_))
                    Next i_
                    Call CMatrixMV(N - j - 1#, j, AAA, Offs + j + 1#, Offs, 0#, tmp, 0#, tmp, N)
                    For i = 0# To N - j - 2# Step 1
                        AAA(Offs + j + 1# + i, Offs + j) = C_DivR(C_Sub(AAA(Offs + j + 1# + i, Offs + j), tmp(N + i)), AJJ)
                    Next i
                Else
                    For i = 0# To N - j - 2# Step 1
                        AAA(Offs + j + 1# + i, Offs + j) = C_DivR(AAA(Offs + j + 1# + i, Offs + j), AJJ)
                    Next i
                End If
            End If
        Next j
    End If
    HPDMatrixCholesky2 = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Level-2 Cholesky subroutine
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     February 29, 1992
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Function SPDMatrixCholesky2(ByRef AAA() As Double, _
         ByVal Offs As Long, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef tmp() As Double) As Boolean
    Dim Result As Boolean
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim J1 As Long
    Dim J2 As Long
    Dim AJJ As Double
    Dim V As Double
    Dim R As Double
    Dim i_ As Long
    Dim i1_ As Long
    Result = True
    If N < 0# Then
        Result = False
        SPDMatrixCholesky2 = Result
        Exit Function
    End If
    
    '
    ' Quick return if possible
    '
    If N = 0# Then
        SPDMatrixCholesky2 = Result
        Exit Function
    End If
    If IsUpper Then
        
        '
        ' Compute the Cholesky factorization A = U'*U.
        '
        For j = 0# To N - 1# Step 1
            
            '
            ' Compute U(J,J) and test for non-positive-definiteness.
            '
            V = 0#
            For i_ = Offs To Offs + j - 1# Step 1
                V = V + AAA(i_, Offs + j) * AAA(i_, Offs + j)
            Next i_
            AJJ = AAA(Offs + j, Offs + j) - V
            If AJJ <= 0# Then
                AAA(Offs + j, Offs + j) = AJJ
                Result = False
                SPDMatrixCholesky2 = Result
                Exit Function
            End If
            AJJ = Sqr(AJJ)
            AAA(Offs + j, Offs + j) = AJJ
            
            '
            ' Compute elements J+1:N-1 of row J.
            '
            If j < N - 1# Then
                If j > 0# Then
                    i1_ = (Offs) - (0#)
                    For i_ = 0# To j - 1# Step 1
                        tmp(i_) = -AAA(i_ + i1_, Offs + j)
                    Next i_
                    Call RMatrixMV(N - j - 1#, j, AAA, Offs, Offs + j + 1#, 1#, tmp, 0#, tmp, N)
                    i1_ = (N) - (Offs + j + 1#)
                    For i_ = Offs + j + 1# To Offs + N - 1# Step 1
                        AAA(Offs + j, i_) = AAA(Offs + j, i_) + tmp(i_ + i1_)
                    Next i_
                End If
                R = 1# / AJJ
                For i_ = Offs + j + 1# To Offs + N - 1# Step 1
                    AAA(Offs + j, i_) = R * AAA(Offs + j, i_)
                Next i_
            End If
        Next j
    Else
        
        '
        ' Compute the Cholesky factorization A = L*L'.
        '
        For j = 0# To N - 1# Step 1
            
            '
            ' Compute L(J+1,J+1) and test for non-positive-definiteness.
            '
            V = 0#
            For i_ = Offs To Offs + j - 1# Step 1
                V = V + AAA(Offs + j, i_) * AAA(Offs + j, i_)
            Next i_
            AJJ = AAA(Offs + j, Offs + j) - V
            If AJJ <= 0# Then
                AAA(Offs + j, Offs + j) = AJJ
                Result = False
                SPDMatrixCholesky2 = Result
                Exit Function
            End If
            AJJ = Sqr(AJJ)
            AAA(Offs + j, Offs + j) = AJJ
            
            '
            ' Compute elements J+1:N of column J.
            '
            If j < N - 1# Then
                If j > 0# Then
                    i1_ = (Offs) - (0#)
                    For i_ = 0# To j - 1# Step 1
                        tmp(i_) = AAA(Offs + j, i_ + i1_)
                    Next i_
                    Call RMatrixMV(N - j - 1#, j, AAA, Offs + j + 1#, Offs, 0#, tmp, 0#, tmp, N)
                    For i = 0# To N - j - 2# Step 1
                        AAA(Offs + j + 1# + i, Offs + j) = (AAA(Offs + j + 1# + i, Offs + j) - tmp(N + i)) / AJJ
                    Next i
                Else
                    For i = 0# To N - j - 2# Step 1
                        AAA(Offs + j + 1# + i, Offs + j) = AAA(Offs + j + 1# + i, Offs + j) / AJJ
                    Next i
                End If
            End If
        Next j
    End If
    SPDMatrixCholesky2 = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2005-2007, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Singular value decomposition of a rectangular matrix.
'
'The algorithm calculates the singular value decomposition of a matrix of
'size MxN: A = U * S * V^T
'
'The algorithm finds the singular values and, optionally, matrices U and V^T.
'The algorithm can find both first min(M,N) columns of matrix U and rows of
'matrix V^T (singular vectors), and matrices U and V^T wholly (of sizes MxM
'and NxN respectively).
'
'Take into account that the subroutine does not return matrix V but V^T.
'
'Input parameters:
'    A           -   matrix to be decomposed.
'                    Array whose indexes range within [0..M-1, 0..N-1].
'    M           -   number of rows in matrix A.
'    N           -   number of columns in matrix A.
'    UNeeded     -   0, 1 or 2. See the description of the parameter U.
'    VTNeeded    -   0, 1 or 2. See the description of the parameter VT.
'    AdditionalMemory -
'                    If the parameter:
'                     * equals 0, the algorithm doesnt use additional
'                       memory (lower requirements, lower performance).
'                     * equals 1, the algorithm uses additional
'                       memory of size min(M,N)*min(M,N) of real numbers.
'                       It often speeds up the algorithm.
'                     * equals 2, the algorithm uses additional
'                       memory of size M*min(M,N) of real numbers.
'                       It allows to get a maximum performance.
'                    The recommended value of the parameter is 2.
'
'Output parameters:
'    W           -   contains singular values in descending order.
'    U           -   if UNeeded=0, U isn't changed, the left singular vectors
'                    are not calculated.
'                    if Uneeded=1, U contains left singular vectors (first
'                    min(M,N) columns of matrix U). Array whose indexes range
'                    within [0..M-1, 0..Min(M,N)-1].
'                    if UNeeded=2, U contains matrix U wholly. Array whose
'                    indexes range within [0..M-1, 0..M-1].
'    VT          -   if VTNeeded=0, VT isnt changed, the right singular vectors
'                    are not calculated.
'                    if VTNeeded=1, VT contains right singular vectors (first
'                    min(M,N) rows of matrix V^T). Array whose indexes range
'                    within [0..min(M,N)-1, 0..N-1].
'                    if VTNeeded=2, VT contains matrix V^T wholly. Array whose
'                    indexes range within [0..N-1, 0..N-1].
'
'  -- ALGLIB --
'     Copyright 2005 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function RMatrixSVD(ByRef A_() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByVal UNeeded As Long, _
         ByVal VTNeeded As Long, _
         ByVal AdditionalMemory As Long, _
         ByRef w() As Double, _
         ByRef U() As Double, _
         ByRef VT() As Double) As Boolean
    Dim Result As Boolean
    Dim a() As Double
    Dim TauQ() As Double
    Dim TauP() As Double
    Dim Tau() As Double
    Dim e() As Double
    Dim WORK() As Double
    Dim T2() As Double
    Dim IsUpper As Boolean
    Dim MinMN As Long
    Dim NCU As Long
    Dim NRVT As Long
    Dim NRU As Long
    Dim NCVT As Long
    Dim i As Long
    Dim j As Long
    a = A_
    Result = True
    If M = 0# Or N = 0# Then
        RMatrixSVD = Result
        Exit Function
    End If
    
    '
    ' initialize
    '
    MinMN = MinInt(M, N)
    ReDim w(1# To MinMN)
    NCU = 0#
    NRU = 0#
    If UNeeded = 1# Then
        NRU = M
        NCU = MinMN
        ReDim U(0# To NRU - 1#, 0# To NCU - 1#)
    End If
    If UNeeded = 2# Then
        NRU = M
        NCU = M
        ReDim U(0# To NRU - 1#, 0# To NCU - 1#)
    End If
    NRVT = 0#
    NCVT = 0#
    If VTNeeded = 1# Then
        NRVT = MinMN
        NCVT = N
        ReDim VT(0# To NRVT - 1#, 0# To NCVT - 1#)
    End If
    If VTNeeded = 2# Then
        NRVT = N
        NCVT = N
        ReDim VT(0# To NRVT - 1#, 0# To NCVT - 1#)
    End If
    
    '
    ' M much larger than N
    ' Use bidiagonal reduction with QR-decomposition
    '
    If M > 1.6 * N Then
        If UNeeded = 0# Then
            
            '
            ' No left singular vectors to be computed
            '
            Call RMatrixQR(a, M, N, Tau)
            For i = 0# To N - 1# Step 1
                For j = 0# To i - 1# Step 1
                    a(i, j) = 0#
                Next j
            Next i
            Call RMatrixBD(a, N, N, TauQ, TauP)
            Call RMatrixBDUnpackPT(a, N, N, TauP, NRVT, VT)
            Call RMatrixBDUnpackDiagonals(a, N, N, IsUpper, w, e)
            Result = RMatrixBDSVD(w, e, N, IsUpper, False, U, 0#, a, 0#, VT, NCVT)
            RMatrixSVD = Result
            Exit Function
        Else
            
            '
            ' Left singular vectors (may be full matrix U) to be computed
            '
            Call RMatrixQR(a, M, N, Tau)
            Call RMatrixQRUnpackQ(a, M, N, Tau, NCU, U)
            For i = 0# To N - 1# Step 1
                For j = 0# To i - 1# Step 1
                    a(i, j) = 0#
                Next j
            Next i
            Call RMatrixBD(a, N, N, TauQ, TauP)
            Call RMatrixBDUnpackPT(a, N, N, TauP, NRVT, VT)
            Call RMatrixBDUnpackDiagonals(a, N, N, IsUpper, w, e)
            If AdditionalMemory < 1# Then
                
                '
                ' No additional memory can be used
                '
                Call RMatrixBDMultiplyByQ(a, N, N, TauQ, U, M, N, True, False)
                Result = RMatrixBDSVD(w, e, N, IsUpper, False, U, M, a, 0#, VT, NCVT)
            Else
                
                '
                ' Large U. Transforming intermediate matrix T2
                '
                ReDim WORK(1# To MaxInt(M, N))
                Call RMatrixBDUnpackQ(a, N, N, TauQ, N, T2)
                Call CopyMatrix(U, 0#, M - 1#, 0#, N - 1#, a, 0#, M - 1#, 0#, N - 1#)
                Call InplaceTranspose(T2, 0#, N - 1#, 0#, N - 1#, WORK)
                Result = RMatrixBDSVD(w, e, N, IsUpper, False, U, 0#, T2, N, VT, NCVT)
                Call MatrixMatrixMultiply(a, 0#, M - 1#, 0#, N - 1#, False, T2, 0#, N - 1#, 0#, N - 1#, True, 1#, U, 0#, M - 1#, 0#, N - 1#, 0#, WORK)
            End If
            RMatrixSVD = Result
            Exit Function
        End If
    End If
    
    '
    ' N much larger than M
    ' Use bidiagonal reduction with LQ-decomposition
    '
    If N > 1.6 * M Then
        If VTNeeded = 0# Then
            
            '
            ' No right singular vectors to be computed
            '
            Call RMatrixLQ(a, M, N, Tau)
            For i = 0# To M - 1# Step 1
                For j = i + 1# To M - 1# Step 1
                    a(i, j) = 0#
                Next j
            Next i
            Call RMatrixBD(a, M, M, TauQ, TauP)
            Call RMatrixBDUnpackQ(a, M, M, TauQ, NCU, U)
            Call RMatrixBDUnpackDiagonals(a, M, M, IsUpper, w, e)
            ReDim WORK(1# To M)
            Call InplaceTranspose(U, 0#, NRU - 1#, 0#, NCU - 1#, WORK)
            Result = RMatrixBDSVD(w, e, M, IsUpper, False, a, 0#, U, NRU, VT, 0#)
            Call InplaceTranspose(U, 0#, NRU - 1#, 0#, NCU - 1#, WORK)
            RMatrixSVD = Result
            Exit Function
        Else
            
            '
            ' Right singular vectors (may be full matrix VT) to be computed
            '
            Call RMatrixLQ(a, M, N, Tau)
            Call RMatrixLQUnpackQ(a, M, N, Tau, NRVT, VT)
            For i = 0# To M - 1# Step 1
                For j = i + 1# To M - 1# Step 1
                    a(i, j) = 0#
                Next j
            Next i
            Call RMatrixBD(a, M, M, TauQ, TauP)
            Call RMatrixBDUnpackQ(a, M, M, TauQ, NCU, U)
            Call RMatrixBDUnpackDiagonals(a, M, M, IsUpper, w, e)
            ReDim WORK(1# To MaxInt(M, N))
            Call InplaceTranspose(U, 0#, NRU - 1#, 0#, NCU - 1#, WORK)
            If AdditionalMemory < 1# Then
                
                '
                ' No additional memory available
                '
                Call RMatrixBDMultiplyByP(a, M, M, TauP, VT, M, N, False, True)
                Result = RMatrixBDSVD(w, e, M, IsUpper, False, a, 0#, U, NRU, VT, N)
            Else
                
                '
                ' Large VT. Transforming intermediate matrix T2
                '
                Call RMatrixBDUnpackPT(a, M, M, TauP, M, T2)
                Result = RMatrixBDSVD(w, e, M, IsUpper, False, a, 0#, U, NRU, T2, M)
                Call CopyMatrix(VT, 0#, M - 1#, 0#, N - 1#, a, 0#, M - 1#, 0#, N - 1#)
                Call MatrixMatrixMultiply(T2, 0#, M - 1#, 0#, M - 1#, False, a, 0#, M - 1#, 0#, N - 1#, False, 1#, VT, 0#, M - 1#, 0#, N - 1#, 0#, WORK)
            End If
            Call InplaceTranspose(U, 0#, NRU - 1#, 0#, NCU - 1#, WORK)
            RMatrixSVD = Result
            Exit Function
        End If
    End If
    
    '
    ' M<=N
    ' We can use inplace transposition of U to get rid of columnwise operations
    '
    If M <= N Then
        Call RMatrixBD(a, M, N, TauQ, TauP)
        Call RMatrixBDUnpackQ(a, M, N, TauQ, NCU, U)
        Call RMatrixBDUnpackPT(a, M, N, TauP, NRVT, VT)
        Call RMatrixBDUnpackDiagonals(a, M, N, IsUpper, w, e)
        ReDim WORK(1# To M)
        Call InplaceTranspose(U, 0#, NRU - 1#, 0#, NCU - 1#, WORK)
        Result = RMatrixBDSVD(w, e, MinMN, IsUpper, False, a, 0#, U, NRU, VT, NCVT)
        Call InplaceTranspose(U, 0#, NRU - 1#, 0#, NCU - 1#, WORK)
        RMatrixSVD = Result
        Exit Function
    End If
    
    '
    ' Simple bidiagonal reduction
    '
    Call RMatrixBD(a, M, N, TauQ, TauP)
    Call RMatrixBDUnpackQ(a, M, N, TauQ, NCU, U)
    Call RMatrixBDUnpackPT(a, M, N, TauP, NRVT, VT)
    Call RMatrixBDUnpackDiagonals(a, M, N, IsUpper, w, e)
    If AdditionalMemory < 2# Or UNeeded = 0# Then
        
        '
        ' We cant use additional memory or there is no need in such operations
        '
        Result = RMatrixBDSVD(w, e, MinMN, IsUpper, False, U, NRU, a, 0#, VT, NCVT)
    Else
        
        '
        ' We can use additional memory
        '
        ReDim T2(0# To MinMN - 1#, 0# To M - 1#)
        Call CopyAndTranspose(U, 0#, M - 1#, 0#, MinMN - 1#, T2, 0#, MinMN - 1#, 0#, M - 1#)
        Result = RMatrixBDSVD(w, e, MinMN, IsUpper, False, U, 0#, T2, M, VT, NCVT)
        Call CopyAndTranspose(T2, 0#, MinMN - 1#, 0#, M - 1#, U, 0#, M - 1#, 0#, MinMN - 1#)
    End If
    RMatrixSVD = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 1992-2007 The University of Tennessee.  All rights reserved.
'
'Contributors:
'    * Sergey Bochkanov (ALGLIB project). Translation from FORTRAN to
'      pseudocode.
'
'See subroutines comments for additional copyrights.
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Solving  a system  of linear equations  with a system matrix  given by its
'LDLT decomposition
'
'The algorithm solves systems with a square matrix only.
'
'Input parameters:
'    A       -   LDLT decomposition of the matrix (the result of the
'                SMatrixLDLT subroutine).
'    Pivots  -   row permutation table (the result of the SMatrixLDLT subroutine).
'    B       -   right side of a system.
'                Array whose index ranges within [0..N-1].
'    N       -   size of matrix A.
'    IsUpper -   points to the triangle of matrix A in which the LDLT
'                decomposition is stored.
'                If IsUpper=True, the decomposition has the form of U*D*U',
'                matrix U is stored in the upper triangle of  matrix A  (in
'                that case, the lower triangle isn't used and isn't changed
'                by the subroutine).
'                Similarly, if IsUpper=False, the decomposition has the form
'                of L*D*L' and the lower triangle stores matrix L.
'
'Output parameters:
'    X       -   solution of a system.
'                Array whose index ranges within [0..N-1].
'
'Result:
'    True, if the matrix is not singular. X contains the solution.
'    False, if the matrix is singular (the determinant of matrix D is equal
'to 0). In this case, X doesn't contain a solution.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function SMatrixLDLTSolve(ByRef a() As Double, _
         ByRef Pivots() As Long, _
         ByRef B_() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef x() As Double) As Boolean
    Dim Result As Boolean
    Dim B() As Double
    Dim i As Long
    Dim K As Long
    Dim KP As Long
    Dim AK As Double
    Dim AKM1 As Double
    Dim AKM1K As Double
    Dim BK As Double
    Dim BKM1 As Double
    Dim DENOM As Double
    Dim V As Double
    Dim i_ As Long
    B = B_
    
    '
    ' Quick return if possible
    '
    Result = True
    If N = 0# Then
        SMatrixLDLTSolve = Result
        Exit Function
    End If
    
    '
    ' Check that the diagonal matrix D is nonsingular
    '
    If IsUpper Then
        
        '
        ' Upper triangular storage: examine D from bottom to top
        '
        For i = N - 1# To 0# Step -1
            If Pivots(i) >= 0# And a(i, i) = 0# Then
                Result = False
                SMatrixLDLTSolve = Result
                Exit Function
            End If
        Next i
    Else
        
        '
        ' Lower triangular storage: examine D from top to bottom.
        '
        For i = 0# To N - 1# Step 1
            If Pivots(i) >= 0# And a(i, i) = 0# Then
                Result = False
                SMatrixLDLTSolve = Result
                Exit Function
            End If
        Next i
    End If
    
    '
    ' Solve Ax = b
    '
    If IsUpper Then
        
        '
        ' Solve A*X = B, where A = U*D*U'.
        '
        ' First solve U*D*X = B, overwriting B with X.
        '
        ' K+1 is the main loop index, decreasing from N to 1 in steps of
        ' 1 or 2, depending on the size of the diagonal blocks.
        '
        K = N - 1#
        Do While K >= 0#
            If Pivots(K) >= 0# Then
                
                '
                ' 1 x 1 diagonal block
                '
                ' Interchange rows K+1 and IPIV(K+1).
                '
                KP = Pivots(K)
                If KP <> K Then
                    V = B(K)
                    B(K) = B(KP)
                    B(KP) = V
                End If
                
                '
                ' Multiply by inv(U(K+1)), where U(K+1) is the transformation
                ' stored in column K+1 of A.
                '
                V = B(K)
                For i_ = 0# To K - 1# Step 1
                    B(i_) = B(i_) - V * a(i_, K)
                Next i_
                
                '
                ' Multiply by the inverse of the diagonal block.
                '
                B(K) = B(K) / a(K, K)
                K = K - 1#
            Else
                
                '
                ' 2 x 2 diagonal block
                '
                ' Interchange rows K+1-1 and -IPIV(K+1).
                '
                KP = Pivots(K) + N
                If KP <> K - 1# Then
                    V = B(K - 1#)
                    B(K - 1#) = B(KP)
                    B(KP) = V
                End If
                
                '
                ' Multiply by inv(U(K+1)), where U(K+1) is the transformation
                ' stored in columns K+1-1 and K+1 of A.
                '
                V = B(K)
                For i_ = 0# To K - 2# Step 1
                    B(i_) = B(i_) - V * a(i_, K)
                Next i_
                V = B(K - 1#)
                For i_ = 0# To K - 2# Step 1
                    B(i_) = B(i_) - V * a(i_, K - 1#)
                Next i_
                
                '
                ' Multiply by the inverse of the diagonal block.
                '
                AKM1K = a(K - 1#, K)
                AKM1 = a(K - 1#, K - 1#) / AKM1K
                AK = a(K, K) / AKM1K
                DENOM = AKM1 * AK - 1#
                BKM1 = B(K - 1#) / AKM1K
                BK = B(K) / AKM1K
                B(K - 1#) = (AK * BKM1 - BK) / DENOM
                B(K) = (AKM1 * BK - BKM1) / DENOM
                K = K - 2#
            End If
        Loop
        
        '
        ' Next solve U'*X = B, overwriting B with X.
        '
        ' K+1 is the main loop index, increasing from 1 to N in steps of
        ' 1 or 2, depending on the size of the diagonal blocks.
        '
        K = 0#
        Do While K <= N - 1#
            If Pivots(K) >= 0# Then
                
                '
                ' 1 x 1 diagonal block
                '
                ' Multiply by inv(U'(K+1)), where U(K+1) is the transformation
                ' stored in column K+1 of A.
                '
                V = 0#
                For i_ = 0# To K - 1# Step 1
                    V = V + B(i_) * a(i_, K)
                Next i_
                B(K) = B(K) - V
                
                '
                ' Interchange rows K+1 and IPIV(K+1).
                '
                KP = Pivots(K)
                If KP <> K Then
                    V = B(K)
                    B(K) = B(KP)
                    B(KP) = V
                End If
                K = K + 1#
            Else
                
                '
                ' 2 x 2 diagonal block
                '
                ' Multiply by inv(U'(K+1+1)), where U(K+1+1) is the transformation
                ' stored in columns K+1 and K+1+1 of A.
                '
                V = 0#
                For i_ = 0# To K - 1# Step 1
                    V = V + B(i_) * a(i_, K)
                Next i_
                B(K) = B(K) - V
                V = 0#
                For i_ = 0# To K - 1# Step 1
                    V = V + B(i_) * a(i_, K + 1#)
                Next i_
                B(K + 1#) = B(K + 1#) - V
                
                '
                ' Interchange rows K+1 and -IPIV(K+1).
                '
                KP = Pivots(K) + N
                If KP <> K Then
                    V = B(K)
                    B(K) = B(KP)
                    B(KP) = V
                End If
                K = K + 2#
            End If
        Loop
    Else
        
        '
        ' Solve A*X = B, where A = L*D*L'.
        '
        ' First solve L*D*X = B, overwriting B with X.
        '
        ' K+1 is the main loop index, increasing from 1 to N in steps of
        ' 1 or 2, depending on the size of the diagonal blocks.
        '
        K = 0#
        Do While K <= N - 1#
            If Pivots(K) >= 0# Then
                
                '
                ' 1 x 1 diagonal block
                '
                ' Interchange rows K+1 and IPIV(K+1).
                '
                KP = Pivots(K)
                If KP <> K Then
                    V = B(K)
                    B(K) = B(KP)
                    B(KP) = V
                End If
                
                '
                ' Multiply by inv(L(K+1)), where L(K+1) is the transformation
                ' stored in column K+1 of A.
                '
                If K + 1# < N Then
                    V = B(K)
                    For i_ = K + 1# To N - 1# Step 1
                        B(i_) = B(i_) - V * a(i_, K)
                    Next i_
                End If
                
                '
                ' Multiply by the inverse of the diagonal block.
                '
                B(K) = B(K) / a(K, K)
                K = K + 1#
            Else
                
                '
                ' 2 x 2 diagonal block
                '
                ' Interchange rows K+1+1 and -IPIV(K+1).
                '
                KP = Pivots(K) + N
                If KP <> K + 1# Then
                    V = B(K + 1#)
                    B(K + 1#) = B(KP)
                    B(KP) = V
                End If
                
                '
                ' Multiply by inv(L(K+1)), where L(K+1) is the transformation
                ' stored in columns K+1 and K+1+1 of A.
                '
                If K + 1# < N - 1# Then
                    V = B(K)
                    For i_ = K + 2# To N - 1# Step 1
                        B(i_) = B(i_) - V * a(i_, K)
                    Next i_
                    V = B(K + 1#)
                    For i_ = K + 2# To N - 1# Step 1
                        B(i_) = B(i_) - V * a(i_, K + 1#)
                    Next i_
                End If
                
                '
                ' Multiply by the inverse of the diagonal block.
                '
                AKM1K = a(K + 1#, K)
                AKM1 = a(K, K) / AKM1K
                AK = a(K + 1#, K + 1#) / AKM1K
                DENOM = AKM1 * AK - 1#
                BKM1 = B(K) / AKM1K
                BK = B(K + 1#) / AKM1K
                B(K) = (AK * BKM1 - BK) / DENOM
                B(K + 1#) = (AKM1 * BK - BKM1) / DENOM
                K = K + 2#
            End If
        Loop
        
        '
        ' Next solve L'*X = B, overwriting B with X.
        '
        ' K+1 is the main loop index, decreasing from N to 1 in steps of
        ' 1 or 2, depending on the size of the diagonal blocks.
        '
        K = N - 1#
        Do While K >= 0#
            If Pivots(K) >= 0# Then
                
                '
                ' 1 x 1 diagonal block
                '
                ' Multiply by inv(L'(K+1)), where L(K+1) is the transformation
                ' stored in column K+1 of A.
                '
                If K + 1# < N Then
                    V = 0#
                    For i_ = K + 1# To N - 1# Step 1
                        V = V + B(i_) * a(i_, K)
                    Next i_
                    B(K) = B(K) - V
                End If
                
                '
                ' Interchange rows K+1 and IPIV(K+1).
                '
                KP = Pivots(K)
                If KP <> K Then
                    V = B(K)
                    B(K) = B(KP)
                    B(KP) = V
                End If
                K = K - 1#
            Else
                
                '
                ' 2 x 2 diagonal block
                '
                ' Multiply by inv(L'(K+1-1)), where L(K+1-1) is the transformation
                ' stored in columns K+1-1 and K+1 of A.
                '
                If K + 1# < N Then
                    V = 0#
                    For i_ = K + 1# To N - 1# Step 1
                        V = V + B(i_) * a(i_, K)
                    Next i_
                    B(K) = B(K) - V
                    V = 0#
                    For i_ = K + 1# To N - 1# Step 1
                        V = V + B(i_) * a(i_, K - 1#)
                    Next i_
                    B(K - 1#) = B(K - 1#) - V
                End If
                
                '
                ' Interchange rows K+1 and -IPIV(K+1).
                '
                KP = Pivots(K) + N
                If KP <> K Then
                    V = B(K)
                    B(K) = B(KP)
                    B(KP) = V
                End If
                K = K - 2#
            End If
        Loop
    End If
    ReDim x(0# To N - 1#)
    For i_ = 0# To N - 1# Step 1
        x(i_) = B(i_)
    Next i_
    SMatrixLDLTSolve = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Solving a system of linear equations with a symmetric system matrix
'
'Input parameters:
'    A       -   system matrix (upper or lower triangle).
'                Array whose indexes range within [0..N-1, 0..N-1].
'    B       -   right side of a system.
'                Array whose index ranges within [0..N-1].
'    N       -   size of matrix A.
'    IsUpper -   If IsUpper = True, A contains the upper triangle,
'                otherwise A contains the lower triangle.
'
'Output parameters:
'    X       -   solution of a system.
'                Array whose index ranges within [0..N-1].
'
'Result:
'    True, if the matrix is not singular. X contains the solution.
'    False, if the matrix is singular (the determinant of the matrix is equal
'to 0). In this case, X doesn't contain a solution.
'
'  -- ALGLIB --
'     Copyright 2005 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function SMatrixSolve(ByRef A_() As Double, _
         ByRef B() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef x() As Double) As Boolean
    Dim Result As Boolean
    Dim a() As Double
    Dim Pivots() As Long
    a = A_
    Call SMatrixLDLT(a, N, IsUpper, Pivots)
    Result = SMatrixLDLTSolve(a, Pivots, B, N, IsUpper, x)
    SMatrixSolve = Result
End Function
Public Function SolveSystemLDLT(ByRef a() As Double, _
         ByRef Pivots() As Long, _
         ByRef B_() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef x() As Double) As Boolean
    Dim Result As Boolean
    Dim B() As Double
    Dim i As Long
    Dim K As Long
    Dim KP As Long
    Dim KM1 As Long
    Dim KM2 As Long
    Dim KP1 As Long
    Dim KP2 As Long
    Dim AK As Double
    Dim AKM1 As Double
    Dim AKM1K As Double
    Dim BK As Double
    Dim BKM1 As Double
    Dim DENOM As Double
    Dim V As Double
    Dim i_ As Long
    B = B_
    
    '
    ' Quick return if possible
    '
    Result = True
    If N = 0# Then
        SolveSystemLDLT = Result
        Exit Function
    End If
    
    '
    ' Check that the diagonal matrix D is nonsingular
    '
    If IsUpper Then
        
        '
        ' Upper triangular storage: examine D from bottom to top
        '
        For i = N To 1# Step -1
            If Pivots(i) > 0# And a(i, i) = 0# Then
                Result = False
                SolveSystemLDLT = Result
                Exit Function
            End If
        Next i
    Else
        
        '
        ' Lower triangular storage: examine D from top to bottom.
        '
        For i = 1# To N Step 1
            If Pivots(i) > 0# And a(i, i) = 0# Then
                Result = False
                SolveSystemLDLT = Result
                Exit Function
            End If
        Next i
    End If
    
    '
    ' Solve Ax = b
    '
    If IsUpper Then
        
        '
        ' Solve A*X = B, where A = U*D*U'.
        '
        ' First solve U*D*X = B, overwriting B with X.
        '
        ' K is the main loop index, decreasing from N to 1 in steps of
        ' 1 or 2, depending on the size of the diagonal blocks.
        '
        K = N
        Do While K >= 1#
            If Pivots(K) > 0# Then
                
                '
                ' 1 x 1 diagonal block
                '
                ' Interchange rows K and IPIV(K).
                '
                KP = Pivots(K)
                If KP <> K Then
                    V = B(K)
                    B(K) = B(KP)
                    B(KP) = V
                End If
                
                '
                ' Multiply by inv(U(K)), where U(K) is the transformation
                ' stored in column K of A.
                '
                KM1 = K - 1#
                V = B(K)
                For i_ = 1# To KM1 Step 1
                    B(i_) = B(i_) - V * a(i_, K)
                Next i_
                
                '
                ' Multiply by the inverse of the diagonal block.
                '
                B(K) = B(K) / a(K, K)
                K = K - 1#
            Else
                
                '
                ' 2 x 2 diagonal block
                '
                ' Interchange rows K-1 and -IPIV(K).
                '
                KP = -Pivots(K)
                If KP <> K - 1# Then
                    V = B(K - 1#)
                    B(K - 1#) = B(KP)
                    B(KP) = V
                End If
                
                '
                ' Multiply by inv(U(K)), where U(K) is the transformation
                ' stored in columns K-1 and K of A.
                '
                KM2 = K - 2#
                KM1 = K - 1#
                V = B(K)
                For i_ = 1# To KM2 Step 1
                    B(i_) = B(i_) - V * a(i_, K)
                Next i_
                V = B(K - 1#)
                For i_ = 1# To KM2 Step 1
                    B(i_) = B(i_) - V * a(i_, KM1)
                Next i_
                
                '
                ' Multiply by the inverse of the diagonal block.
                '
                AKM1K = a(K - 1#, K)
                AKM1 = a(K - 1#, K - 1#) / AKM1K
                AK = a(K, K) / AKM1K
                DENOM = AKM1 * AK - 1#
                BKM1 = B(K - 1#) / AKM1K
                BK = B(K) / AKM1K
                B(K - 1#) = (AK * BKM1 - BK) / DENOM
                B(K) = (AKM1 * BK - BKM1) / DENOM
                K = K - 2#
            End If
        Loop
        
        '
        ' Next solve U'*X = B, overwriting B with X.
        '
        ' K is the main loop index, increasing from 1 to N in steps of
        ' 1 or 2, depending on the size of the diagonal blocks.
        '
        K = 1#
        Do While K <= N
            If Pivots(K) > 0# Then
                
                '
                ' 1 x 1 diagonal block
                '
                ' Multiply by inv(U'(K)), where U(K) is the transformation
                ' stored in column K of A.
                '
                KM1 = K - 1#
                V = 0#
                For i_ = 1# To KM1 Step 1
                    V = V + B(i_) * a(i_, K)
                Next i_
                B(K) = B(K) - V
                
                '
                ' Interchange rows K and IPIV(K).
                '
                KP = Pivots(K)
                If KP <> K Then
                    V = B(K)
                    B(K) = B(KP)
                    B(KP) = V
                End If
                K = K + 1#
            Else
                
                '
                ' 2 x 2 diagonal block
                '
                ' Multiply by inv(U'(K+1)), where U(K+1) is the transformation
                ' stored in columns K and K+1 of A.
                '
                KM1 = K - 1#
                KP1 = K + 1#
                V = 0#
                For i_ = 1# To KM1 Step 1
                    V = V + B(i_) * a(i_, K)
                Next i_
                B(K) = B(K) - V
                V = 0#
                For i_ = 1# To KM1 Step 1
                    V = V + B(i_) * a(i_, KP1)
                Next i_
                B(K + 1#) = B(K + 1#) - V
                
                '
                ' Interchange rows K and -IPIV(K).
                '
                KP = -Pivots(K)
                If KP <> K Then
                    V = B(K)
                    B(K) = B(KP)
                    B(KP) = V
                End If
                K = K + 2#
            End If
        Loop
    Else
        
        '
        ' Solve A*X = B, where A = L*D*L'.
        '
        ' First solve L*D*X = B, overwriting B with X.
        '
        ' K is the main loop index, increasing from 1 to N in steps of
        ' 1 or 2, depending on the size of the diagonal blocks.
        '
        K = 1#
        Do While K <= N
            If Pivots(K) > 0# Then
                
                '
                ' 1 x 1 diagonal block
                '
                ' Interchange rows K and IPIV(K).
                '
                KP = Pivots(K)
                If KP <> K Then
                    V = B(K)
                    B(K) = B(KP)
                    B(KP) = V
                End If
                
                '
                ' Multiply by inv(L(K)), where L(K) is the transformation
                ' stored in column K of A.
                '
                If K < N Then
                    KP1 = K + 1#
                    V = B(K)
                    For i_ = KP1 To N Step 1
                        B(i_) = B(i_) - V * a(i_, K)
                    Next i_
                End If
                
                '
                ' Multiply by the inverse of the diagonal block.
                '
                B(K) = B(K) / a(K, K)
                K = K + 1#
            Else
                
                '
                ' 2 x 2 diagonal block
                '
                ' Interchange rows K+1 and -IPIV(K).
                '
                KP = -Pivots(K)
                If KP <> K + 1# Then
                    V = B(K + 1#)
                    B(K + 1#) = B(KP)
                    B(KP) = V
                End If
                
                '
                ' Multiply by inv(L(K)), where L(K) is the transformation
                ' stored in columns K and K+1 of A.
                '
                If K < N - 1# Then
                    KP1 = K + 1#
                    KP2 = K + 2#
                    V = B(K)
                    For i_ = KP2 To N Step 1
                        B(i_) = B(i_) - V * a(i_, K)
                    Next i_
                    V = B(K + 1#)
                    For i_ = KP2 To N Step 1
                        B(i_) = B(i_) - V * a(i_, KP1)
                    Next i_
                End If
                
                '
                ' Multiply by the inverse of the diagonal block.
                '
                AKM1K = a(K + 1#, K)
                AKM1 = a(K, K) / AKM1K
                AK = a(K + 1#, K + 1#) / AKM1K
                DENOM = AKM1 * AK - 1#
                BKM1 = B(K) / AKM1K
                BK = B(K + 1#) / AKM1K
                B(K) = (AK * BKM1 - BK) / DENOM
                B(K + 1#) = (AKM1 * BK - BKM1) / DENOM
                K = K + 2#
            End If
        Loop
        
        '
        ' Next solve L'*X = B, overwriting B with X.
        '
        ' K is the main loop index, decreasing from N to 1 in steps of
        ' 1 or 2, depending on the size of the diagonal blocks.
        '
        K = N
        Do While K >= 1#
            If Pivots(K) > 0# Then
                
                '
                ' 1 x 1 diagonal block
                '
                ' Multiply by inv(L'(K)), where L(K) is the transformation
                ' stored in column K of A.
                '
                If K < N Then
                    KP1 = K + 1#
                    V = 0#
                    For i_ = KP1 To N Step 1
                        V = V + B(i_) * a(i_, K)
                    Next i_
                    B(K) = B(K) - V
                End If
                
                '
                ' Interchange rows K and IPIV(K).
                '
                KP = Pivots(K)
                If KP <> K Then
                    V = B(K)
                    B(K) = B(KP)
                    B(KP) = V
                End If
                K = K - 1#
            Else
                
                '
                ' 2 x 2 diagonal block
                '
                ' Multiply by inv(L'(K-1)), where L(K-1) is the transformation
                ' stored in columns K-1 and K of A.
                '
                If K < N Then
                    KP1 = K + 1#
                    KM1 = K - 1#
                    V = 0#
                    For i_ = KP1 To N Step 1
                        V = V + B(i_) * a(i_, K)
                    Next i_
                    B(K) = B(K) - V
                    V = 0#
                    For i_ = KP1 To N Step 1
                        V = V + B(i_) * a(i_, KM1)
                    Next i_
                    B(K - 1#) = B(K - 1#) - V
                End If
                
                '
                ' Interchange rows K and -IPIV(K).
                '
                KP = -Pivots(K)
                If KP <> K Then
                    V = B(K)
                    B(K) = B(KP)
                    B(KP) = V
                End If
                K = K - 2#
            End If
        Loop
    End If
    ReDim x(1# To N)
    For i_ = 1# To N Step 1
        x(i_) = B(i_)
    Next i_
    SolveSystemLDLT = Result
End Function
Public Function SolveSymmetricSystem(ByRef A_() As Double, _
         ByRef B_() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef x() As Double) As Boolean
    Dim Result As Boolean
    Dim a() As Double
    Dim B() As Double
    Dim Pivots() As Long
    a = A_
    B = B_
    Call LDLTDecomposition(a, N, IsUpper, Pivots)
    Result = SolveSystemLDLT(a, Pivots, B, N, IsUpper, x)
    SolveSymmetricSystem = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 1992-2007 The University of Tennessee.  All rights reserved.
'
'Contributors:
'    * Sergey Bochkanov (ALGLIB project). Translation from FORTRAN to
'      pseudocode.
'
'See subroutines comments for additional copyrights.
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Condition number estimate of a symmetric matrix
'
'The algorithm calculates a lower bound of the condition number. In this
'case, the algorithm does not return a lower bound of the condition number,
'but an inverse number (to avoid an overflow in case of a singular matrix).
'
'It should be noted that 1-norm and inf-norm condition numbers of symmetric
'matrices are equal, so the algorithm doesn't take into account the
'differences between these types of norms.
'
'Input parameters:
'    A       -   symmetric definite matrix which is given by its upper or
'                lower triangle depending on IsUpper.
'                Array with elements [0..N-1, 0..N-1].
'    N       -   size of matrix A.
'    IsUpper -   storage format.
'
'Result:
'    1/LowerBound(cond(A))
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function SMatrixRCond(ByRef a() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean) As Double
    Dim Result As Double
    Dim i As Long
    Dim j As Long
    Dim a1() As Double
    ReDim a1(1# To N, 1# To N)
    For i = 1# To N Step 1
        If IsUpper Then
            For j = i To N Step 1
                a1(i, j) = a(i - 1#, j - 1#)
            Next j
        Else
            For j = 1# To i Step 1
                a1(i, j) = a(i - 1#, j - 1#)
            Next j
        End If
    Next i
    Result = RCondSymmetric(a1, N, IsUpper)
    SMatrixRCond = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Condition number estimate of a matrix given by LDLT-decomposition
'
'The algorithm calculates a lower bound of the condition number. In this
'case, the algorithm does not return a lower bound of the condition number,
'but an inverse number (to avoid an overflow in case of a singular matrix).
'
'It should be noted that 1-norm and inf-norm condition numbers of symmetric
'matrices are equal, so the algorithm doesn't take into account the
'differences between these types of norms.
'
'Input parameters:
'    L       -   LDLT-decomposition of matrix A given by the upper or lower
'                triangle depending on IsUpper.
'                Output of SMatrixLDLT subroutine.
'    Pivots  -   table of permutations which were made during LDLT-decomposition,
'                Output of SMatrixLDLT subroutine.
'    N       -   size of matrix A.
'    IsUpper -   storage format.
'
'Result:
'    1/LowerBound(cond(A))
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function SMatrixLDLTRCond(ByRef L() As Double, _
         ByRef Pivots() As Long, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean) As Double
    Dim Result As Double
    Dim i As Long
    Dim j As Long
    Dim L1() As Double
    Dim p1() As Long
    ReDim L1(1# To N, 1# To N)
    For i = 1# To N Step 1
        If IsUpper Then
            For j = i To N Step 1
                L1(i, j) = L(i - 1#, j - 1#)
            Next j
        Else
            For j = 1# To i Step 1
                L1(i, j) = L(i - 1#, j - 1#)
            Next j
        End If
    Next i
    ReDim p1(1# To N)
    For i = 1# To N Step 1
        If Pivots(i - 1#) >= 0# Then
            p1(i) = Pivots(i - 1#) + 1#
        Else
            p1(i) = -(Pivots(i - 1#) + N + 1#)
        End If
    Next i
    Result = RCondLDLT(L1, p1, N, IsUpper)
    SMatrixLDLTRCond = Result
End Function
Public Function RCondSymmetric(ByRef A_() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean) As Double
    Dim Result As Double
    Dim a() As Double
    Dim i As Long
    Dim j As Long
    Dim IM As Long
    Dim JM As Long
    Dim V As Double
    Dim Nrm As Double
    Dim Pivots() As Long
    a = A_
    Nrm = 0#
    For j = 1# To N Step 1
        V = 0#
        For i = 1# To N Step 1
            IM = i
            JM = j
            If IsUpper And j < i Then
                IM = j
                JM = i
            End If
            If Not IsUpper And j > i Then
                IM = j
                JM = i
            End If
            V = V + Abs(a(IM, JM))
        Next i
        Nrm = MaxReal(Nrm, V)
    Next j
    Call LDLTDecomposition(a, N, IsUpper, Pivots)
    Call InternalLDLTRCond(a, Pivots, N, IsUpper, True, Nrm, V)
    Result = V
    RCondSymmetric = Result
End Function
Public Function RCondLDLT(ByRef L() As Double, _
         ByRef Pivots() As Long, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean) As Double
    Dim Result As Double
    Dim V As Double
    Call InternalLDLTRCond(L, Pivots, N, IsUpper, False, 0#, V)
    Result = V
    RCondLDLT = Result
End Function
Public Sub InternalLDLTRCond(ByRef L() As Double, _
         ByRef Pivots() As Long, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByVal IsNormProvided As Boolean, _
         ByVal ANORM As Double, _
         ByRef RCOND As Double)
    Dim i As Long
    Dim KASE As Long
    Dim K As Long
    Dim KM1 As Long
    Dim KM2 As Long
    Dim KP1 As Long
    Dim KP2 As Long
    Dim AINVNM As Double
    Dim WORK0() As Double
    Dim WORK1() As Double
    Dim WORK2() As Double
    Dim IWORK() As Long
    Dim V As Double
    Dim i_ As Long
    
    '
    ' Check that the diagonal matrix D is nonsingular.
    '
    RCOND = 0#
    If IsUpper Then
        For i = N To 1# Step -1
            If Pivots(i) > 0# And L(i, i) = 0# Then
                Exit Sub
            End If
        Next i
    Else
        For i = 1# To N Step 1
            If Pivots(i) > 0# And L(i, i) = 0# Then
                Exit Sub
            End If
        Next i
    End If
    
    '
    ' Estimate the norm of A.
    '
    If Not IsNormProvided Then
        KASE = 0#
        ANORM = 0#
        Do While True
            Call IterativeEstimate1Norm(N, WORK1, WORK0, IWORK, ANORM, KASE)
            If KASE = 0# Then
                Exit Do
            End If
            If IsUpper Then
                
                '
                ' Multiply by U'
                '
                K = N
                Do While K >= 1#
                    If Pivots(K) > 0# Then
                        
                        '
                        ' P(k)
                        '
                        V = WORK0(K)
                        WORK0(K) = WORK0(Pivots(K))
                        WORK0(Pivots(K)) = V
                        
                        '
                        ' U(k)
                        '
                        KM1 = K - 1#
                        V = 0#
                        For i_ = 1# To KM1 Step 1
                            V = V + WORK0(i_) * L(i_, K)
                        Next i_
                        WORK0(K) = WORK0(K) + V
                        
                        '
                        ' Next k
                        '
                        K = K - 1#
                    Else
                        
                        '
                        ' P(k)
                        '
                        V = WORK0(K - 1#)
                        WORK0(K - 1#) = WORK0(-Pivots(K - 1#))
                        WORK0(-Pivots(K - 1#)) = V
                        
                        '
                        ' U(k)
                        '
                        KM1 = K - 1#
                        KM2 = K - 2#
                        V = 0#
                        For i_ = 1# To KM2 Step 1
                            V = V + WORK0(i_) * L(i_, KM1)
                        Next i_
                        WORK0(KM1) = WORK0(KM1) + V
                        V = 0#
                        For i_ = 1# To KM2 Step 1
                            V = V + WORK0(i_) * L(i_, K)
                        Next i_
                        WORK0(K) = WORK0(K) + V
                        
                        '
                        ' Next k
                        '
                        K = K - 2#
                    End If
                Loop
                
                '
                ' Multiply by D
                '
                K = N
                Do While K >= 1#
                    If Pivots(K) > 0# Then
                        WORK0(K) = WORK0(K) * L(K, K)
                        K = K - 1#
                    Else
                        V = WORK0(K - 1#)
                        WORK0(K - 1#) = L(K - 1#, K - 1#) * WORK0(K - 1#) + L(K - 1#, K) * WORK0(K)
                        WORK0(K) = L(K - 1#, K) * V + L(K, K) * WORK0(K)
                        K = K - 2#
                    End If
                Loop
                
                '
                ' Multiply by U
                '
                K = 1#
                Do While K <= N
                    If Pivots(K) > 0# Then
                        
                        '
                        ' U(k)
                        '
                        KM1 = K - 1#
                        V = WORK0(K)
                        For i_ = 1# To KM1 Step 1
                            WORK0(i_) = WORK0(i_) + V * L(i_, K)
                        Next i_
                        
                        '
                        ' P(k)
                        '
                        V = WORK0(K)
                        WORK0(K) = WORK0(Pivots(K))
                        WORK0(Pivots(K)) = V
                        
                        '
                        ' Next k
                        '
                        K = K + 1#
                    Else
                        
                        '
                        ' U(k)
                        '
                        KM1 = K - 1#
                        KP1 = K + 1#
                        V = WORK0(K)
                        For i_ = 1# To KM1 Step 1
                            WORK0(i_) = WORK0(i_) + V * L(i_, K)
                        Next i_
                        V = WORK0(KP1)
                        For i_ = 1# To KM1 Step 1
                            WORK0(i_) = WORK0(i_) + V * L(i_, KP1)
                        Next i_
                        
                        '
                        ' P(k)
                        '
                        V = WORK0(K)
                        WORK0(K) = WORK0(-Pivots(K))
                        WORK0(-Pivots(K)) = V
                        
                        '
                        ' Next k
                        '
                        K = K + 2#
                    End If
                Loop
            Else
                
                '
                ' Multiply by L'
                '
                K = 1#
                Do While K <= N
                    If Pivots(K) > 0# Then
                        
                        '
                        ' P(k)
                        '
                        V = WORK0(K)
                        WORK0(K) = WORK0(Pivots(K))
                        WORK0(Pivots(K)) = V
                        
                        '
                        ' L(k)
                        '
                        KP1 = K + 1#
                        V = 0#
                        For i_ = KP1 To N Step 1
                            V = V + WORK0(i_) * L(i_, K)
                        Next i_
                        WORK0(K) = WORK0(K) + V
                        
                        '
                        ' Next k
                        '
                        K = K + 1#
                    Else
                        
                        '
                        ' P(k)
                        '
                        V = WORK0(K + 1#)
                        WORK0(K + 1#) = WORK0(-Pivots(K + 1#))
                        WORK0(-Pivots(K + 1#)) = V
                        
                        '
                        ' L(k)
                        '
                        KP1 = K + 1#
                        KP2 = K + 2#
                        V = 0#
                        For i_ = KP2 To N Step 1
                            V = V + WORK0(i_) * L(i_, K)
                        Next i_
                        WORK0(K) = WORK0(K) + V
                        V = 0#
                        For i_ = KP2 To N Step 1
                            V = V + WORK0(i_) * L(i_, KP1)
                        Next i_
                        WORK0(KP1) = WORK0(KP1) + V
                        
                        '
                        ' Next k
                        '
                        K = K + 2#
                    End If
                Loop
                
                '
                ' Multiply by D
                '
                K = N
                Do While K >= 1#
                    If Pivots(K) > 0# Then
                        WORK0(K) = WORK0(K) * L(K, K)
                        K = K - 1#
                    Else
                        V = WORK0(K - 1#)
                        WORK0(K - 1#) = L(K - 1#, K - 1#) * WORK0(K - 1#) + L(K, K - 1#) * WORK0(K)
                        WORK0(K) = L(K, K - 1#) * V + L(K, K) * WORK0(K)
                        K = K - 2#
                    End If
                Loop
                
                '
                ' Multiply by L
                '
                K = N
                Do While K >= 1#
                    If Pivots(K) > 0# Then
                        
                        '
                        ' L(k)
                        '
                        KP1 = K + 1#
                        V = WORK0(K)
                        For i_ = KP1 To N Step 1
                            WORK0(i_) = WORK0(i_) + V * L(i_, K)
                        Next i_
                        
                        '
                        ' P(k)
                        '
                        V = WORK0(K)
                        WORK0(K) = WORK0(Pivots(K))
                        WORK0(Pivots(K)) = V
                        
                        '
                        ' Next k
                        '
                        K = K - 1#
                    Else
                        
                        '
                        ' L(k)
                        '
                        KP1 = K + 1#
                        KM1 = K - 1#
                        V = WORK0(K)
                        For i_ = KP1 To N Step 1
                            WORK0(i_) = WORK0(i_) + V * L(i_, K)
                        Next i_
                        V = WORK0(KM1)
                        For i_ = KP1 To N Step 1
                            WORK0(i_) = WORK0(i_) + V * L(i_, KM1)
                        Next i_
                        
                        '
                        ' P(k)
                        '
                        V = WORK0(K)
                        WORK0(K) = WORK0(-Pivots(K))
                        WORK0(-Pivots(K)) = V
                        
                        '
                        ' Next k
                        '
                        K = K - 2#
                    End If
                Loop
            End If
        Loop
    End If
    
    '
    ' Quick return if possible
    '
    RCOND = 0#
    If N = 0# Then
        RCOND = 1#
        Exit Sub
    End If
    If ANORM = 0# Then
        Exit Sub
    End If
    
    '
    ' Estimate the 1-norm of inv(A).
    '
    KASE = 0#
    Do While True
        Call IterativeEstimate1Norm(N, WORK1, WORK0, IWORK, AINVNM, KASE)
        If KASE = 0# Then
            Exit Do
        End If
        Call SolveSystemLDLT(L, Pivots, WORK0, N, IsUpper, WORK2)
        For i_ = 1# To N Step 1
            WORK0(i_) = WORK2(i_)
        Next i_
    Loop
    
    '
    ' Compute the estimate of the reciprocal condition number.
    '
    If AINVNM <> 0# Then
        V = 1# / AINVNM
        RCOND = V / ANORM
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2005-2007, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Algorithm for solving the following generalized symmetric positive-definite
'eigenproblem:
'    A*x = lambda*B*x (1) or
'    A*B*x = lambda*x (2) or
'    B*A*x = lambda*x (3).
'where A is a symmetric matrix, B - symmetric positive-definite matrix.
'The problem is solved by reducing it to an ordinary  symmetric  eigenvalue
'problem.
'
'Input parameters:
'    A           -   symmetric matrix which is given by its upper or lower
'                    triangular part.
'                    Array whose indexes range within [0..N-1, 0..N-1].
'    N           -   size of matrices A and B.
'    IsUpperA    -   storage format of matrix A.
'    B           -   symmetric positive-definite matrix which is given by
'                    its upper or lower triangular part.
'                    Array whose indexes range within [0..N-1, 0..N-1].
'    IsUpperB    -   storage format of matrix B.
'    ZNeeded     -   if ZNeeded is equal to:
'                     * 0, the eigenvectors are not returned;
'                     * 1, the eigenvectors are returned.
'    ProblemType -   if ProblemType is equal to:
'                     * 1, the following problem is solved: A*x = lambda*B*x;
'                     * 2, the following problem is solved: A*B*x = lambda*x;
'                     * 3, the following problem is solved: B*A*x = lambda*x.
'
'Output parameters:
'    D           -   eigenvalues in ascending order.
'                    Array whose index ranges within [0..N-1].
'    Z           -   if ZNeeded is equal to:
'                     * 0, Z hasnt changed;
'                     * 1, Z contains eigenvectors.
'                    Array whose indexes range within [0..N-1, 0..N-1].
'                    The eigenvectors are stored in matrix columns. It should
'                    be noted that the eigenvectors in such problems do not
'                    form an orthogonal system.
'
'Result:
'    True, if the problem was solved successfully.
'    False, if the error occurred during the Cholesky decomposition of matrix
'    B (the matrix isnt positive-definite) or during the work of the iterative
'    algorithm for solving the symmetric eigenproblem.
'
'See also the GeneralizedSymmetricDefiniteEVDReduce subroutine.
'
'  -- ALGLIB --
'     Copyright 1.28.2006 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function SMatrixGEVD(ByRef A_() As Double, _
         ByVal N As Long, _
         ByVal IsUpperA As Boolean, _
         ByRef B() As Double, _
         ByVal IsUpperB As Boolean, _
         ByVal ZNeeded As Long, _
         ByVal ProblemType As Long, _
         ByRef d() As Double, _
         ByRef z() As Double) As Boolean
    Dim Result As Boolean
    Dim a() As Double
    Dim R() As Double
    Dim t() As Double
    Dim IsUpperR As Boolean
    Dim J1 As Long
    Dim J2 As Long
    Dim J1INC As Long
    Dim J2INC As Long
    Dim i As Long
    Dim j As Long
    Dim V As Double
    Dim i_ As Long
    a = A_
    
    '
    ' Reduce and solve
    '
    Result = SMatrixGEVDReduce(a, N, IsUpperA, B, IsUpperB, ProblemType, R, IsUpperR)
    If Not Result Then
        SMatrixGEVD = Result
        Exit Function
    End If
    Result = SMatrixEVD(a, N, ZNeeded, IsUpperA, d, t)
    If Not Result Then
        SMatrixGEVD = Result
        Exit Function
    End If
    
    '
    ' Transform eigenvectors if needed
    '
    If ZNeeded <> 0# Then
        
        '
        ' fill Z with zeros
        '
        ReDim z(0# To N - 1#, 0# To N - 1#)
        For j = 0# To N - 1# Step 1
            z(0#, j) = 0#
        Next j
        For i = 1# To N - 1# Step 1
            For i_ = 0# To N - 1# Step 1
                z(i, i_) = z(0#, i_)
            Next i_
        Next i
        
        '
        ' Setup R properties
        '
        If IsUpperR Then
            J1 = 0#
            J2 = N - 1#
            J1INC = 1#
            J2INC = 0#
        Else
            J1 = 0#
            J2 = 0#
            J1INC = 0#
            J2INC = 1#
        End If
        
        '
        ' Calculate R*Z
        '
        For i = 0# To N - 1# Step 1
            For j = J1 To J2 Step 1
                V = R(i, j)
                For i_ = 0# To N - 1# Step 1
                    z(i, i_) = z(i, i_) + V * t(j, i_)
                Next i_
            Next j
            J1 = J1 + J1INC
            J2 = J2 + J2INC
        Next i
    End If
    SMatrixGEVD = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Algorithm for reduction of the following generalized symmetric positive-
'definite eigenvalue problem:
'    A*x = lambda*B*x (1) or
'    A*B*x = lambda*x (2) or
'    B*A*x = lambda*x (3)
'to the symmetric eigenvalues problem C*y = lambda*y (eigenvalues of this and
'the given problems are the same, and the eigenvectors of the given problem
'could be obtained by multiplying the obtained eigenvectors by the
'transformation matrix x = R*y).
'
'Here A is a symmetric matrix, B - symmetric positive-definite matrix.
'
'Input parameters:
'    A           -   symmetric matrix which is given by its upper or lower
'                    triangular part.
'                    Array whose indexes range within [0..N-1, 0..N-1].
'    N           -   size of matrices A and B.
'    IsUpperA    -   storage format of matrix A.
'    B           -   symmetric positive-definite matrix which is given by
'                    its upper or lower triangular part.
'                    Array whose indexes range within [0..N-1, 0..N-1].
'    IsUpperB    -   storage format of matrix B.
'    ProblemType -   if ProblemType is equal to:
'                     * 1, the following problem is solved: A*x = lambda*B*x;
'                     * 2, the following problem is solved: A*B*x = lambda*x;
'                     * 3, the following problem is solved: B*A*x = lambda*x.
'
'Output parameters:
'    A           -   symmetric matrix which is given by its upper or lower
'                    triangle depending on IsUpperA. Contains matrix C.
'                    Array whose indexes range within [0..N-1, 0..N-1].
'    R           -   upper triangular or low triangular transformation matrix
'                    which is used to obtain the eigenvectors of a given problem
'                    as the product of eigenvectors of C (from the right) and
'                    matrix R (from the left). If the matrix is upper
'                    triangular, the elements below the main diagonal
'                    are equal to 0 (and vice versa). Thus, we can perform
'                    the multiplication without taking into account the
'                    internal structure (which is an easier though less
'                    effective way).
'                    Array whose indexes range within [0..N-1, 0..N-1].
'    IsUpperR    -   type of matrix R (upper or lower triangular).
'
'Result:
'    True, if the problem was reduced successfully.
'    False, if the error occurred during the Cholesky decomposition of
'        matrix B (the matrix is not positive-definite).
'
'  -- ALGLIB --
'     Copyright 1.28.2006 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function SMatrixGEVDReduce(ByRef a() As Double, _
         ByVal N As Long, _
         ByVal IsUpperA As Boolean, _
         ByRef B() As Double, _
         ByVal IsUpperB As Boolean, _
         ByVal ProblemType As Long, _
         ByRef R() As Double, _
         ByRef IsUpperR As Boolean) As Boolean
    Dim Result As Boolean
    Dim t() As Double
    Dim W1() As Double
    Dim W2() As Double
    Dim W3() As Double
    Dim i As Long
    Dim j As Long
    Dim V As Double
    Dim Rep As MatInvReport
    Dim Info As Long
    Dim i_ As Long
    Dim i1_ As Long
    Result = True
    
    '
    ' Problem 1:  A*x = lambda*B*x
    '
    ' Reducing to:
    '     C*y = lambda*y
    '     C = L^(-1) * A * L^(-T)
    '     x = L^(-T) * y
    '
    If ProblemType = 1# Then
        
        '
        ' Factorize B in T: B = LL'
        '
        ReDim t(0# To N - 1#, 0# To N - 1#)
        If IsUpperB Then
            For i = 0# To N - 1# Step 1
                For i_ = i To N - 1# Step 1
                    t(i_, i) = B(i, i_)
                Next i_
            Next i
        Else
            For i = 0# To N - 1# Step 1
                For i_ = 0# To i Step 1
                    t(i, i_) = B(i, i_)
                Next i_
            Next i
        End If
        If Not SPDMatrixCholesky(t, N, False) Then
            Result = False
            SMatrixGEVDReduce = Result
            Exit Function
        End If
        
        '
        ' Invert L in T
        '
        Call RMatrixTRInverse(t, N, False, False, Info, Rep)
        If Info <= 0# Then
            Result = False
            SMatrixGEVDReduce = Result
            Exit Function
        End If
        
        '
        ' Build L^(-1) * A * L^(-T) in R
        '
        ReDim W1(1# To N)
        ReDim W2(1# To N)
        ReDim R(0# To N - 1#, 0# To N - 1#)
        For j = 1# To N Step 1
            
            '
            ' Form w2 = A * l'(j) (here l'(j) is j-th column of L^(-T))
            '
            i1_ = (0#) - (1#)
            For i_ = 1# To j Step 1
                W1(i_) = t(j - 1#, i_ + i1_)
            Next i_
            Call SymmetricMatrixVectorMultiply(a, IsUpperA, 0#, j - 1#, W1, 1#, W2)
            If IsUpperA Then
                Call MatrixVectorMultiply(a, 0#, j - 1#, j, N - 1#, True, W1, 1#, j, 1#, W2, j + 1#, N, 0#)
            Else
                Call MatrixVectorMultiply(a, j, N - 1#, 0#, j - 1#, False, W1, 1#, j, 1#, W2, j + 1#, N, 0#)
            End If
            
            '
            ' Form l(i)*w2 (here l(i) is i-th row of L^(-1))
            '
            For i = 1# To N Step 1
                i1_ = (1#) - (0#)
                V = 0#
                For i_ = 0# To i - 1# Step 1
                    V = V + t(i - 1#, i_) * W2(i_ + i1_)
                Next i_
                R(i - 1#, j - 1#) = V
            Next i
        Next j
        
        '
        ' Copy R to A
        '
        For i = 0# To N - 1# Step 1
            For i_ = 0# To N - 1# Step 1
                a(i, i_) = R(i, i_)
            Next i_
        Next i
        
        '
        ' Copy L^(-1) from T to R and transpose
        '
        IsUpperR = True
        For i = 0# To N - 1# Step 1
            For j = 0# To i - 1# Step 1
                R(i, j) = 0#
            Next j
        Next i
        For i = 0# To N - 1# Step 1
            For i_ = i To N - 1# Step 1
                R(i, i_) = t(i_, i)
            Next i_
        Next i
        SMatrixGEVDReduce = Result
        Exit Function
    End If
    
    '
    ' Problem 2:  A*B*x = lambda*x
    ' or
    ' problem 3:  B*A*x = lambda*x
    '
    ' Reducing to:
    '     C*y = lambda*y
    '     C = U * A * U'
    '     B = U'* U
    '
    If ProblemType = 2# Or ProblemType = 3# Then
        
        '
        ' Factorize B in T: B = U'*U
        '
        ReDim t(0# To N - 1#, 0# To N - 1#)
        If IsUpperB Then
            For i = 0# To N - 1# Step 1
                For i_ = i To N - 1# Step 1
                    t(i, i_) = B(i, i_)
                Next i_
            Next i
        Else
            For i = 0# To N - 1# Step 1
                For i_ = i To N - 1# Step 1
                    t(i, i_) = B(i_, i)
                Next i_
            Next i
        End If
        If Not SPDMatrixCholesky(t, N, True) Then
            Result = False
            SMatrixGEVDReduce = Result
            Exit Function
        End If
        
        '
        ' Build U * A * U' in R
        '
        ReDim W1(1# To N)
        ReDim W2(1# To N)
        ReDim W3(1# To N)
        ReDim R(0# To N - 1#, 0# To N - 1#)
        For j = 1# To N Step 1
            
            '
            ' Form w2 = A * u'(j) (here u'(j) is j-th column of U')
            '
            i1_ = (j - 1#) - (1#)
            For i_ = 1# To N - j + 1# Step 1
                W1(i_) = t(j - 1#, i_ + i1_)
            Next i_
            Call SymmetricMatrixVectorMultiply(a, IsUpperA, j - 1#, N - 1#, W1, 1#, W3)
            i1_ = (1#) - (j)
            For i_ = j To N Step 1
                W2(i_) = W3(i_ + i1_)
            Next i_
            i1_ = (j - 1#) - (j)
            For i_ = j To N Step 1
                W1(i_) = t(j - 1#, i_ + i1_)
            Next i_
            If IsUpperA Then
                Call MatrixVectorMultiply(a, 0#, j - 2#, j - 1#, N - 1#, False, W1, j, N, 1#, W2, 1#, j - 1#, 0#)
            Else
                Call MatrixVectorMultiply(a, j - 1#, N - 1#, 0#, j - 2#, True, W1, j, N, 1#, W2, 1#, j - 1#, 0#)
            End If
            
            '
            ' Form u(i)*w2 (here u(i) is i-th row of U)
            '
            For i = 1# To N Step 1
                i1_ = (i) - (i - 1#)
                V = 0#
                For i_ = i - 1# To N - 1# Step 1
                    V = V + t(i - 1#, i_) * W2(i_ + i1_)
                Next i_
                R(i - 1#, j - 1#) = V
            Next i
        Next j
        
        '
        ' Copy R to A
        '
        For i = 0# To N - 1# Step 1
            For i_ = 0# To N - 1# Step 1
                a(i, i_) = R(i, i_)
            Next i_
        Next i
        If ProblemType = 2# Then
            
            '
            ' Invert U in T
            '
            Call RMatrixTRInverse(t, N, True, False, Info, Rep)
            If Info <= 0# Then
                Result = False
                SMatrixGEVDReduce = Result
                Exit Function
            End If
            
            '
            ' Copy U^-1 from T to R
            '
            IsUpperR = True
            For i = 0# To N - 1# Step 1
                For j = 0# To i - 1# Step 1
                    R(i, j) = 0#
                Next j
            Next i
            For i = 0# To N - 1# Step 1
                For i_ = i To N - 1# Step 1
                    R(i, i_) = t(i, i_)
                Next i_
            Next i
        Else
            
            '
            ' Copy U from T to R and transpose
            '
            IsUpperR = False
            For i = 0# To N - 1# Step 1
                For j = i + 1# To N - 1# Step 1
                    R(i, j) = 0#
                Next j
            Next i
            For i = 0# To N - 1# Step 1
                For i_ = i To N - 1# Step 1
                    R(i_, i) = t(i, i_)
                Next i_
            Next i
        End If
    End If
    SMatrixGEVDReduce = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 1992-2007 The University of Tennessee.  All rights reserved.
'
'Contributors:
'    * Sergey Bochkanov (ALGLIB project). Translation from FORTRAN to
'      pseudocode.
'
'See subroutines comments for additional copyrights.
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Inversion of a symmetric indefinite matrix
'
'The algorithm gets an LDLT-decomposition as an input, generates matrix A^-1
'and saves the lower or upper triangle of an inverse matrix depending on the
'input (U*D*U' or L*D*L').
'
'Input parameters:
'    A       -   LDLT-decomposition of the matrix,
'                Output of subroutine SMatrixLDLT.
'    N       -   size of matrix A.
'    IsUpper -   storage format. If IsUpper = True, then the symmetric matrix
'                is given as decomposition A = U*D*U' and this decomposition
'                is stored in the upper triangle of matrix A and on the main
'                diagonal, and the lower triangle of matrix A is not used.
'    Pivots  -   a table of permutations, output of subroutine SMatrixLDLT.
'
'Output parameters:
'    A       -   inverse of the matrix, whose LDLT-decomposition was stored
'                in matrix A as a subroutine input.
'                Array with elements [0..N-1, 0..N-1].
'                If IsUpper = True, then A contains the upper triangle of
'                matrix A^-1, and the elements below the main diagonal are
'                not used nor changed. The same applies if IsUpper = False.
'
'Result:
'    True, if the matrix is not singular.
'    False, if the matrix is singular and could not be inverted.
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     March 31, 1993
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function SMatrixLDLTInverse(ByRef a() As Double, _
         ByRef Pivots() As Long, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean) As Boolean
    Dim Result As Boolean
    Dim WORK() As Double
    Dim WORK2() As Double
    Dim i As Long
    Dim K As Long
    Dim KP As Long
    Dim KSTEP As Long
    Dim AK As Double
    Dim AKKP1 As Double
    Dim AKP1 As Double
    Dim d As Double
    Dim t As Double
    Dim temp As Double
    Dim KM1 As Long
    Dim KP1 As Long
    Dim L As Long
    Dim I1 As Long
    Dim I2 As Long
    Dim V As Double
    Dim i_ As Long
    Dim i1_ As Long
    ReDim WORK(1# To N)
    ReDim WORK2(1# To N)
    Result = True
    
    '
    ' Quick return if possible
    '
    If N = 0# Then
        SMatrixLDLTInverse = Result
        Exit Function
    End If
    
    '
    ' Check that the diagonal matrix D is nonsingular.
    '
    For i = 0# To N - 1# Step 1
        If Pivots(i) >= 0# And a(i, i) = 0# Then
            Result = False
            SMatrixLDLTInverse = Result
            Exit Function
        End If
    Next i
    If IsUpper Then
        
        '
        ' Compute inv(A) from the factorization A = U*D*U'.
        '
        ' K+1 is the main loop index, increasing from 1 to N in steps of
        ' 1 or 2, depending on the size of the diagonal blocks.
        '
        K = 0#
        Do While K <= N - 1#
            If Pivots(K) >= 0# Then
                
                '
                ' 1 x 1 diagonal block
                '
                ' Invert the diagonal block.
                '
                a(K, K) = 1# / a(K, K)
                
                '
                ' Compute column K+1 of the inverse.
                '
                If K > 0# Then
                    i1_ = (0#) - (1#)
                    For i_ = 1# To K Step 1
                        WORK(i_) = a(i_ + i1_, K)
                    Next i_
                    Call SymmetricMatrixVectorMultiply(a, IsUpper, 1# - 1#, K + 1# - 1# - 1#, WORK, -1#, WORK2)
                    i1_ = (1#) - (0#)
                    For i_ = 0# To K - 1# Step 1
                        a(i_, K) = WORK2(i_ + i1_)
                    Next i_
                    V = 0#
                    For i_ = 1# To K Step 1
                        V = V + WORK2(i_) * WORK(i_)
                    Next i_
                    a(K, K) = a(K, K) - V
                End If
                KSTEP = 1#
            Else
                
                '
                ' 2 x 2 diagonal block
                '
                ' Invert the diagonal block.
                '
                t = Abs(a(K, K + 1#))
                AK = a(K, K) / t
                AKP1 = a(K + 1#, K + 1#) / t
                AKKP1 = a(K, K + 1#) / t
                d = t * (AK * AKP1 - 1#)
                a(K, K) = AKP1 / d
                a(K + 1#, K + 1#) = AK / d
                a(K, K + 1#) = -(AKKP1 / d)
                
                '
                ' Compute columns K+1 and K+1+1 of the inverse.
                '
                If K > 0# Then
                    i1_ = (0#) - (1#)
                    For i_ = 1# To K Step 1
                        WORK(i_) = a(i_ + i1_, K)
                    Next i_
                    Call SymmetricMatrixVectorMultiply(a, IsUpper, 0#, K - 1#, WORK, -1#, WORK2)
                    i1_ = (1#) - (0#)
                    For i_ = 0# To K - 1# Step 1
                        a(i_, K) = WORK2(i_ + i1_)
                    Next i_
                    V = 0#
                    For i_ = 1# To K Step 1
                        V = V + WORK(i_) * WORK2(i_)
                    Next i_
                    a(K, K) = a(K, K) - V
                    V = 0#
                    For i_ = 0# To K - 1# Step 1
                        V = V + a(i_, K) * a(i_, K + 1#)
                    Next i_
                    a(K, K + 1#) = a(K, K + 1#) - V
                    i1_ = (0#) - (1#)
                    For i_ = 1# To K Step 1
                        WORK(i_) = a(i_ + i1_, K + 1#)
                    Next i_
                    Call SymmetricMatrixVectorMultiply(a, IsUpper, 0#, K - 1#, WORK, -1#, WORK2)
                    i1_ = (1#) - (0#)
                    For i_ = 0# To K - 1# Step 1
                        a(i_, K + 1#) = WORK2(i_ + i1_)
                    Next i_
                    V = 0#
                    For i_ = 1# To K Step 1
                        V = V + WORK(i_) * WORK2(i_)
                    Next i_
                    a(K + 1#, K + 1#) = a(K + 1#, K + 1#) - V
                End If
                KSTEP = 2#
            End If
            If Pivots(K) >= 0# Then
                KP = Pivots(K)
            Else
                KP = N + Pivots(K)
            End If
            If KP <> K Then
                
                '
                ' Interchange rows and columns K and KP in the leading
                ' submatrix
                '
                i1_ = (0#) - (1#)
                For i_ = 1# To KP Step 1
                    WORK(i_) = a(i_ + i1_, K)
                Next i_
                For i_ = 0# To KP - 1# Step 1
                    a(i_, K) = a(i_, KP)
                Next i_
                i1_ = (1#) - (0#)
                For i_ = 0# To KP - 1# Step 1
                    a(i_, KP) = WORK(i_ + i1_)
                Next i_
                i1_ = (KP + 1#) - (1#)
                For i_ = 1# To K - 1# - KP Step 1
                    WORK(i_) = a(i_ + i1_, K)
                Next i_
                For i_ = KP + 1# To K - 1# Step 1
                    a(i_, K) = a(KP, i_)
                Next i_
                i1_ = (1#) - (KP + 1#)
                For i_ = KP + 1# To K - 1# Step 1
                    a(KP, i_) = WORK(i_ + i1_)
                Next i_
                temp = a(K, K)
                a(K, K) = a(KP, KP)
                a(KP, KP) = temp
                If KSTEP = 2# Then
                    temp = a(K, K + 1#)
                    a(K, K + 1#) = a(KP, K + 1#)
                    a(KP, K + 1#) = temp
                End If
            End If
            K = K + KSTEP
        Loop
    Else
        
        '
        ' Compute inv(A) from the factorization A = L*D*L'.
        '
        ' K is the main loop index, increasing from 0 to N-1 in steps of
        ' 1 or 2, depending on the size of the diagonal blocks.
        '
        K = N - 1#
        Do While K >= 0#
            If Pivots(K) >= 0# Then
                
                '
                ' 1 x 1 diagonal block
                '
                ' Invert the diagonal block.
                '
                a(K, K) = 1# / a(K, K)
                
                '
                ' Compute column K+1 of the inverse.
                '
                If K < N - 1# Then
                    i1_ = (K + 1#) - (1#)
                    For i_ = 1# To N - K - 1# Step 1
                        WORK(i_) = a(i_ + i1_, K)
                    Next i_
                    Call SymmetricMatrixVectorMultiply(a, IsUpper, K + 1#, N - 1#, WORK, -1#, WORK2)
                    i1_ = (1#) - (K + 1#)
                    For i_ = K + 1# To N - 1# Step 1
                        a(i_, K) = WORK2(i_ + i1_)
                    Next i_
                    V = 0#
                    For i_ = 1# To N - K - 1# Step 1
                        V = V + WORK(i_) * WORK2(i_)
                    Next i_
                    a(K, K) = a(K, K) - V
                End If
                KSTEP = 1#
            Else
                
                '
                ' 2 x 2 diagonal block
                '
                ' Invert the diagonal block.
                '
                t = Abs(a(K, K - 1#))
                AK = a(K - 1#, K - 1#) / t
                AKP1 = a(K, K) / t
                AKKP1 = a(K, K - 1#) / t
                d = t * (AK * AKP1 - 1#)
                a(K - 1#, K - 1#) = AKP1 / d
                a(K, K) = AK / d
                a(K, K - 1#) = -(AKKP1 / d)
                
                '
                ' Compute columns K+1-1 and K+1 of the inverse.
                '
                If K < N - 1# Then
                    i1_ = (K + 1#) - (1#)
                    For i_ = 1# To N - K - 1# Step 1
                        WORK(i_) = a(i_ + i1_, K)
                    Next i_
                    Call SymmetricMatrixVectorMultiply(a, IsUpper, K + 1#, N - 1#, WORK, -1#, WORK2)
                    i1_ = (1#) - (K + 1#)
                    For i_ = K + 1# To N - 1# Step 1
                        a(i_, K) = WORK2(i_ + i1_)
                    Next i_
                    V = 0#
                    For i_ = 1# To N - K - 1# Step 1
                        V = V + WORK(i_) * WORK2(i_)
                    Next i_
                    a(K, K) = a(K, K) - V
                    V = 0#
                    For i_ = K + 1# To N - 1# Step 1
                        V = V + a(i_, K) * a(i_, K - 1#)
                    Next i_
                    a(K, K - 1#) = a(K, K - 1#) - V
                    i1_ = (K + 1#) - (1#)
                    For i_ = 1# To N - K - 1# Step 1
                        WORK(i_) = a(i_ + i1_, K - 1#)
                    Next i_
                    Call SymmetricMatrixVectorMultiply(a, IsUpper, K + 1#, N - 1#, WORK, -1#, WORK2)
                    i1_ = (1#) - (K + 1#)
                    For i_ = K + 1# To N - 1# Step 1
                        a(i_, K - 1#) = WORK2(i_ + i1_)
                    Next i_
                    V = 0#
                    For i_ = 1# To N - K - 1# Step 1
                        V = V + WORK(i_) * WORK2(i_)
                    Next i_
                    a(K - 1#, K - 1#) = a(K - 1#, K - 1#) - V
                End If
                KSTEP = 2#
            End If
            If Pivots(K) >= 0# Then
                KP = Pivots(K)
            Else
                KP = Pivots(K) + N
            End If
            If KP <> K Then
                
                '
                ' Interchange rows and columns K and KP
                '
                If KP < N - 1# Then
                    i1_ = (KP + 1#) - (1#)
                    For i_ = 1# To N - KP - 1# Step 1
                        WORK(i_) = a(i_ + i1_, K)
                    Next i_
                    For i_ = KP + 1# To N - 1# Step 1
                        a(i_, K) = a(i_, KP)
                    Next i_
                    i1_ = (1#) - (KP + 1#)
                    For i_ = KP + 1# To N - 1# Step 1
                        a(i_, KP) = WORK(i_ + i1_)
                    Next i_
                End If
                i1_ = (K + 1#) - (1#)
                For i_ = 1# To KP - K - 1# Step 1
                    WORK(i_) = a(i_ + i1_, K)
                Next i_
                For i_ = K + 1# To KP - 1# Step 1
                    a(i_, K) = a(KP, i_)
                Next i_
                i1_ = (1#) - (K + 1#)
                For i_ = K + 1# To KP - 1# Step 1
                    a(KP, i_) = WORK(i_ + i1_)
                Next i_
                temp = a(K, K)
                a(K, K) = a(KP, KP)
                a(KP, KP) = temp
                If KSTEP = 2# Then
                    temp = a(K, K - 1#)
                    a(K, K - 1#) = a(KP, K - 1#)
                    a(KP, K - 1#) = temp
                End If
            End If
            K = K - KSTEP
        Loop
    End If
    SMatrixLDLTInverse = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Inversion of a symmetric indefinite matrix
'
'Given a lower or upper triangle of matrix A, the algorithm generates
'matrix A^-1 and saves the lower or upper triangle depending on the input.
'
'Input parameters:
'    A       -   matrix to be inverted (upper or lower triangle).
'                Array with elements [0..N-1, 0..N-1].
'    N       -   size of matrix A.
'    IsUpper -   storage format. If IsUpper = True, then the upper
'                triangle of matrix A is given, otherwise the lower
'                triangle is given.
'
'Output parameters:
'    A       -   inverse of matrix A.
'                Array with elements [0..N-1, 0..N-1].
'                If IsUpper = True, then A contains the upper triangle of
'                matrix A^-1, and the elements below the main diagonal are
'                not used nor changed.
'                The same applies if IsUpper = False.
'
'Result:
'    True, if the matrix is not singular.
'    False, if the matrix is singular and could not be inverted.
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     March 31, 1993
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function SMatrixInverse(ByRef a() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean) As Boolean
    Dim Result As Boolean
    Dim Pivots() As Long
    Call SMatrixLDLT(a, N, IsUpper, Pivots)
    Result = SMatrixLDLTInverse(a, Pivots, N, IsUpper)
    SMatrixInverse = Result
End Function
Public Function InverseLDLT(ByRef a() As Double, _
         ByRef Pivots() As Long, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean) As Boolean
    Dim Result As Boolean
    Dim WORK() As Double
    Dim WORK2() As Double
    Dim i As Long
    Dim K As Long
    Dim KP As Long
    Dim KSTEP As Long
    Dim AK As Double
    Dim AKKP1 As Double
    Dim AKP1 As Double
    Dim d As Double
    Dim t As Double
    Dim temp As Double
    Dim KM1 As Long
    Dim KP1 As Long
    Dim L As Long
    Dim I1 As Long
    Dim I2 As Long
    Dim V As Double
    Dim i_ As Long
    Dim i1_ As Long
    ReDim WORK(1# To N)
    ReDim WORK2(1# To N)
    Result = True
    
    '
    ' Quick return if possible
    '
    If N = 0# Then
        InverseLDLT = Result
        Exit Function
    End If
    
    '
    ' Check that the diagonal matrix D is nonsingular.
    '
    For i = 1# To N Step 1
        If Pivots(i) > 0# And a(i, i) = 0# Then
            Result = False
            InverseLDLT = Result
            Exit Function
        End If
    Next i
    If IsUpper Then
        
        '
        ' Compute inv(A) from the factorization A = U*D*U'.
        '
        ' K is the main loop index, increasing from 1 to N in steps of
        ' 1 or 2, depending on the size of the diagonal blocks.
        '
        K = 1#
        Do While K <= N
            If Pivots(K) > 0# Then
                
                '
                ' 1 x 1 diagonal block
                '
                ' Invert the diagonal block.
                '
                a(K, K) = 1# / a(K, K)
                
                '
                ' Compute column K of the inverse.
                '
                If K > 1# Then
                    KM1 = K - 1#
                    For i_ = 1# To KM1 Step 1
                        WORK(i_) = a(i_, K)
                    Next i_
                    Call SymmetricMatrixVectorMultiply(a, IsUpper, 1#, K - 1#, WORK, -1#, WORK2)
                    For i_ = 1# To KM1 Step 1
                        a(i_, K) = WORK2(i_)
                    Next i_
                    V = 0#
                    For i_ = 1# To KM1 Step 1
                        V = V + WORK2(i_) * WORK(i_)
                    Next i_
                    a(K, K) = a(K, K) - V
                End If
                KSTEP = 1#
            Else
                
                '
                ' 2 x 2 diagonal block
                '
                ' Invert the diagonal block.
                '
                t = Abs(a(K, K + 1#))
                AK = a(K, K) / t
                AKP1 = a(K + 1#, K + 1#) / t
                AKKP1 = a(K, K + 1#) / t
                d = t * (AK * AKP1 - 1#)
                a(K, K) = AKP1 / d
                a(K + 1#, K + 1#) = AK / d
                a(K, K + 1#) = -(AKKP1 / d)
                
                '
                ' Compute columns K and K+1 of the inverse.
                '
                If K > 1# Then
                    KM1 = K - 1#
                    KP1 = K + 1#
                    For i_ = 1# To KM1 Step 1
                        WORK(i_) = a(i_, K)
                    Next i_
                    Call SymmetricMatrixVectorMultiply(a, IsUpper, 1#, K - 1#, WORK, -1#, WORK2)
                    For i_ = 1# To KM1 Step 1
                        a(i_, K) = WORK2(i_)
                    Next i_
                    V = 0#
                    For i_ = 1# To KM1 Step 1
                        V = V + WORK(i_) * WORK2(i_)
                    Next i_
                    a(K, K) = a(K, K) - V
                    V = 0#
                    For i_ = 1# To KM1 Step 1
                        V = V + a(i_, K) * a(i_, KP1)
                    Next i_
                    a(K, K + 1#) = a(K, K + 1#) - V
                    For i_ = 1# To KM1 Step 1
                        WORK(i_) = a(i_, KP1)
                    Next i_
                    Call SymmetricMatrixVectorMultiply(a, IsUpper, 1#, K - 1#, WORK, -1#, WORK2)
                    For i_ = 1# To KM1 Step 1
                        a(i_, KP1) = WORK2(i_)
                    Next i_
                    V = 0#
                    For i_ = 1# To KM1 Step 1
                        V = V + WORK(i_) * WORK2(i_)
                    Next i_
                    a(K + 1#, K + 1#) = a(K + 1#, K + 1#) - V
                End If
                KSTEP = 2#
            End If
            KP = Abs(Pivots(K))
            If KP <> K Then
                
                '
                ' Interchange rows and columns K and KP in the leading
                ' submatrix A(1:k+1,1:k+1)
                '
                L = KP - 1#
                For i_ = 1# To L Step 1
                    WORK(i_) = a(i_, K)
                Next i_
                For i_ = 1# To L Step 1
                    a(i_, K) = a(i_, KP)
                Next i_
                For i_ = 1# To L Step 1
                    a(i_, KP) = WORK(i_)
                Next i_
                L = K - KP - 1#
                I1 = KP + 1#
                I2 = K - 1#
                i1_ = (I1) - (1#)
                For i_ = 1# To L Step 1
                    WORK(i_) = a(i_ + i1_, K)
                Next i_
                For i_ = I1 To I2 Step 1
                    a(i_, K) = a(KP, i_)
                Next i_
                i1_ = (1#) - (I1)
                For i_ = I1 To I2 Step 1
                    a(KP, i_) = WORK(i_ + i1_)
                Next i_
                temp = a(K, K)
                a(K, K) = a(KP, KP)
                a(KP, KP) = temp
                If KSTEP = 2# Then
                    temp = a(K, K + 1#)
                    a(K, K + 1#) = a(KP, K + 1#)
                    a(KP, K + 1#) = temp
                End If
            End If
            K = K + KSTEP
        Loop
    Else
        
        '
        ' Compute inv(A) from the factorization A = L*D*L'.
        '
        ' K is the main loop index, increasing from 1 to N in steps of
        ' 1 or 2, depending on the size of the diagonal blocks.
        '
        K = N
        Do While K >= 1#
            If Pivots(K) > 0# Then
                
                '
                ' 1 x 1 diagonal block
                '
                ' Invert the diagonal block.
                '
                a(K, K) = 1# / a(K, K)
                
                '
                ' Compute column K of the inverse.
                '
                If K < N Then
                    KP1 = K + 1#
                    KM1 = K - 1#
                    L = N - K
                    i1_ = (KP1) - (1#)
                    For i_ = 1# To L Step 1
                        WORK(i_) = a(i_ + i1_, K)
                    Next i_
                    Call SymmetricMatrixVectorMultiply(a, IsUpper, K + 1#, N, WORK, -1#, WORK2)
                    i1_ = (1#) - (KP1)
                    For i_ = KP1 To N Step 1
                        a(i_, K) = WORK2(i_ + i1_)
                    Next i_
                    V = 0#
                    For i_ = 1# To L Step 1
                        V = V + WORK(i_) * WORK2(i_)
                    Next i_
                    a(K, K) = a(K, K) - V
                End If
                KSTEP = 1#
            Else
                
                '
                ' 2 x 2 diagonal block
                '
                ' Invert the diagonal block.
                '
                t = Abs(a(K, K - 1#))
                AK = a(K - 1#, K - 1#) / t
                AKP1 = a(K, K) / t
                AKKP1 = a(K, K - 1#) / t
                d = t * (AK * AKP1 - 1#)
                a(K - 1#, K - 1#) = AKP1 / d
                a(K, K) = AK / d
                a(K, K - 1#) = -(AKKP1 / d)
                
                '
                ' Compute columns K-1 and K of the inverse.
                '
                If K < N Then
                    KP1 = K + 1#
                    KM1 = K - 1#
                    L = N - K
                    i1_ = (KP1) - (1#)
                    For i_ = 1# To L Step 1
                        WORK(i_) = a(i_ + i1_, K)
                    Next i_
                    Call SymmetricMatrixVectorMultiply(a, IsUpper, K + 1#, N, WORK, -1#, WORK2)
                    i1_ = (1#) - (KP1)
                    For i_ = KP1 To N Step 1
                        a(i_, K) = WORK2(i_ + i1_)
                    Next i_
                    V = 0#
                    For i_ = 1# To L Step 1
                        V = V + WORK(i_) * WORK2(i_)
                    Next i_
                    a(K, K) = a(K, K) - V
                    V = 0#
                    For i_ = KP1 To N Step 1
                        V = V + a(i_, K) * a(i_, KM1)
                    Next i_
                    a(K, K - 1#) = a(K, K - 1#) - V
                    i1_ = (KP1) - (1#)
                    For i_ = 1# To L Step 1
                        WORK(i_) = a(i_ + i1_, KM1)
                    Next i_
                    Call SymmetricMatrixVectorMultiply(a, IsUpper, K + 1#, N, WORK, -1#, WORK2)
                    i1_ = (1#) - (KP1)
                    For i_ = KP1 To N Step 1
                        a(i_, KM1) = WORK2(i_ + i1_)
                    Next i_
                    V = 0#
                    For i_ = 1# To L Step 1
                        V = V + WORK(i_) * WORK2(i_)
                    Next i_
                    a(K - 1#, K - 1#) = a(K - 1#, K - 1#) - V
                End If
                KSTEP = 2#
            End If
            KP = Abs(Pivots(K))
            If KP <> K Then
                
                '
                ' Interchange rows and columns K and KP in the trailing
                ' submatrix A(k-1:n,k-1:n)
                '
                If KP < N Then
                    L = N - KP
                    KP1 = KP + 1#
                    i1_ = (KP1) - (1#)
                    For i_ = 1# To L Step 1
                        WORK(i_) = a(i_ + i1_, K)
                    Next i_
                    For i_ = KP1 To N Step 1
                        a(i_, K) = a(i_, KP)
                    Next i_
                    i1_ = (1#) - (KP1)
                    For i_ = KP1 To N Step 1
                        a(i_, KP) = WORK(i_ + i1_)
                    Next i_
                End If
                L = KP - K - 1#
                I1 = K + 1#
                I2 = KP - 1#
                i1_ = (I1) - (1#)
                For i_ = 1# To L Step 1
                    WORK(i_) = a(i_ + i1_, K)
                Next i_
                For i_ = I1 To I2 Step 1
                    a(i_, K) = a(KP, i_)
                Next i_
                i1_ = (1#) - (I1)
                For i_ = I1 To I2 Step 1
                    a(KP, i_) = WORK(i_ + i1_)
                Next i_
                temp = a(K, K)
                a(K, K) = a(KP, KP)
                a(KP, KP) = temp
                If KSTEP = 2# Then
                    temp = a(K, K - 1#)
                    a(K, K - 1#) = a(KP, K - 1#)
                    a(KP, K - 1#) = temp
                End If
            End If
            K = K - KSTEP
        Loop
    End If
    InverseLDLT = Result
End Function
Public Function InverseSymmetricIndefinite(ByRef a() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean) As Boolean
    Dim Result As Boolean
    Dim Pivots() As Long
    Call LDLTDecomposition(a, N, IsUpper, Pivots)
    Result = InverseLDLT(a, Pivots, N, IsUpper)
    InverseSymmetricIndefinite = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2005-2007, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Determinant calculation of the matrix given by LDLT decomposition.
'
'Input parameters:
'    A       -   LDLT-decomposition of the matrix,
'                output of subroutine SMatrixLDLT.
'    Pivots  -   table of permutations which were made during
'                LDLT decomposition, output of subroutine SMatrixLDLT.
'    N       -   size of matrix A.
'    IsUpper -   matrix storage format. The value is equal to the input
'                parameter of subroutine SMatrixLDLT.
'
'Result:
'    matrix determinant.
'
'  -- ALGLIB --
'     Copyright 2005-2008 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function SMatrixLDLTDet(ByRef a() As Double, _
         ByRef Pivots() As Long, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean) As Double
    Dim Result As Double
    Dim K As Long
    Result = 1#
    If IsUpper Then
        K = 0#
        Do While K < N
            If Pivots(K) >= 0# Then
                Result = Result * a(K, K)
                K = K + 1#
            Else
                Result = Result * (a(K, K) * a(K + 1#, K + 1#) - a(K, K + 1#) * a(K, K + 1#))
                K = K + 2#
            End If
        Loop
    Else
        K = N - 1#
        Do While K >= 0#
            If Pivots(K) >= 0# Then
                Result = Result * a(K, K)
                K = K - 1#
            Else
                Result = Result * (a(K - 1#, K - 1#) * a(K, K) - a(K, K - 1#) * a(K, K - 1#))
                K = K - 2#
            End If
        Loop
    End If
    SMatrixLDLTDet = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Determinant calculation of the symmetric matrix
'
'Input parameters:
'    A       -   matrix. Array with elements [0..N-1, 0..N-1].
'    N       -   size of matrix A.
'    IsUpper -   if IsUpper = True, then symmetric matrix A is given by its
'                upper triangle, and the lower triangle isnt used by
'                subroutine. Similarly, if IsUpper = False, then A is given
'                by its lower triangle.
'
'Result:
'    determinant of matrix A.
'
'  -- ALGLIB --
'     Copyright 2005-2008 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function SMatrixDet(ByRef A_() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean) As Double
    Dim Result As Double
    Dim a() As Double
    Dim Pivots() As Long
    a = A_
    Call SMatrixLDLT(a, N, IsUpper, Pivots)
    Result = SMatrixLDLTDet(a, Pivots, N, IsUpper)
    SMatrixDet = Result
End Function
Public Function DeterminantLDLT(ByRef a() As Double, _
         ByRef Pivots() As Long, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean) As Double
    Dim Result As Double
    Dim K As Long
    Result = 1#
    If IsUpper Then
        K = 1#
        Do While K <= N
            If Pivots(K) > 0# Then
                Result = Result * a(K, K)
                K = K + 1#
            Else
                Result = Result * (a(K, K) * a(K + 1#, K + 1#) - a(K, K + 1#) * a(K, K + 1#))
                K = K + 2#
            End If
        Loop
    Else
        K = N
        Do While K >= 1#
            If Pivots(K) > 0# Then
                Result = Result * a(K, K)
                K = K - 1#
            Else
                Result = Result * (a(K - 1#, K - 1#) * a(K, K) - a(K, K - 1#) * a(K, K - 1#))
                K = K - 2#
            End If
        Loop
    End If
    DeterminantLDLT = Result
End Function
Public Function DeterminantSymmetric(ByRef A_() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean) As Double
    Dim Result As Double
    Dim a() As Double
    Dim Pivots() As Long
    a = A_
    Call LDLTDecomposition(a, N, IsUpper, Pivots)
    Result = DeterminantLDLT(a, Pivots, N, IsUpper)
    DeterminantSymmetric = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 1992-2007 The University of Tennessee.  All rights reserved.
'
'Contributors:
'    * Sergey Bochkanov (ALGLIB project). Translation from FORTRAN to
'      pseudocode.
'
'See subroutines comments for additional copyrights.
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
Public Sub SymmetricMatrixVectorMultiply(ByRef a() As Double, _
         ByVal IsUpper As Boolean, _
         ByVal I1 As Long, _
         ByVal I2 As Long, _
         ByRef x() As Double, _
         ByVal alpha As Double, _
         ByRef y() As Double)
    Dim i As Long
    Dim BA1 As Long
    Dim Ba2 As Long
    Dim BY1 As Long
    Dim BY2 As Long
    Dim BX1 As Long
    Dim BX2 As Long
    Dim N As Long
    Dim V As Double
    Dim i_ As Long
    Dim i1_ As Long
    N = I2 - I1 + 1#
    If N <= 0# Then
        Exit Sub
    End If
    '
    ' Let A = L + D + U, where
    '  L is strictly lower triangular (main diagonal is zero)
    '  D is diagonal
    '  U is strictly upper triangular (main diagonal is zero)
    '
    ' A*x = L*x + D*x + U*x
    '
    ' Calculate D*x first
    '
    For i = I1 To I2 Step 1
        y(i - I1 + 1#) = a(i, i) * x(i - I1 + 1#)
    Next i
    '
    ' Add L*x + U*x
    '
    If IsUpper Then
        For i = I1 To I2 - 1# Step 1
            '
            ' Add L*x to the result
            '
            V = x(i - I1 + 1#)
            BY1 = i - I1 + 2#
            BY2 = N
            BA1 = i + 1#
            Ba2 = I2
            i1_ = (BA1) - (BY1)
            For i_ = BY1 To BY2 Step 1
                y(i_) = y(i_) + V * a(i, i_ + i1_)
            Next i_
            '
            ' Add U*x to the result
            '
            BX1 = i - I1 + 2#
            BX2 = N
            BA1 = i + 1#
            Ba2 = I2
            i1_ = (BA1) - (BX1)
            V = 0#
            For i_ = BX1 To BX2 Step 1
                V = V + x(i_) * a(i, i_ + i1_)
            Next i_
            y(i - I1 + 1#) = y(i - I1 + 1#) + V
        Next i
    Else
        For i = I1 + 1# To I2 Step 1
            '
            ' Add L*x to the result
            '
            BX1 = 1#
            BX2 = i - I1
            BA1 = I1
            Ba2 = i - 1#
            i1_ = (BA1) - (BX1)
            V = 0#
            For i_ = BX1 To BX2 Step 1
                V = V + x(i_) * a(i, i_ + i1_)
            Next i_
            y(i - I1 + 1#) = y(i - I1 + 1#) + V
            '
            ' Add U*x to the result
            '
            V = x(i - I1 + 1#)
            BY1 = 1#
            BY2 = i - I1
            BA1 = I1
            Ba2 = i - 1#
            i1_ = (BA1) - (BY1)
            For i_ = BY1 To BY2 Step 1
                y(i_) = y(i_) + V * a(i, i_ + i1_)
            Next i_
        Next i
    End If
    For i_ = 1# To N Step 1
        y(i_) = alpha * y(i_)
    Next i_
End Sub
Public Sub SymmetricRank2Update(ByRef a() As Double, _
         ByVal IsUpper As Boolean, _
         ByVal I1 As Long, _
         ByVal I2 As Long, _
         ByRef x() As Double, _
         ByRef y() As Double, _
         ByRef t() As Double, _
         ByVal alpha As Double)
    Dim i As Long
    Dim TP1 As Long
    Dim TP2 As Long
    Dim V As Double
    Dim i_ As Long
    Dim i1_ As Long
    If IsUpper Then
        For i = I1 To I2 Step 1
            TP1 = i + 1# - I1
            TP2 = I2 - I1 + 1#
            V = x(i + 1# - I1)
            For i_ = TP1 To TP2 Step 1
                t(i_) = V * y(i_)
            Next i_
            V = y(i + 1# - I1)
            For i_ = TP1 To TP2 Step 1
                t(i_) = t(i_) + V * x(i_)
            Next i_
            For i_ = TP1 To TP2 Step 1
                t(i_) = alpha * t(i_)
            Next i_
            i1_ = (TP1) - (i)
            For i_ = i To I2 Step 1
                a(i, i_) = a(i, i_) + t(i_ + i1_)
            Next i_
        Next i
    Else
        For i = I1 To I2 Step 1
            TP1 = 1#
            TP2 = i + 1# - I1
            V = x(i + 1# - I1)
            For i_ = TP1 To TP2 Step 1
                t(i_) = V * y(i_)
            Next i_
            V = y(i + 1# - I1)
            For i_ = TP1 To TP2 Step 1
                t(i_) = t(i_) + V * x(i_)
            Next i_
            For i_ = TP1 To TP2 Step 1
                t(i_) = alpha * t(i_)
            Next i_
            i1_ = (TP1) - (I1)
            For i_ = I1 To i Step 1
                a(i, i_) = a(i, i_) + t(i_ + i1_)
            Next i_
        Next i
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This file is a part of ALGLIB project.
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Real implementation of CMatrixScaledTRSafeSolve
'
'  -- ALGLIB routine --
'     21.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function RMatrixScaledTRSafeSolve(ByRef a() As Double, _
         ByVal SA As Double, _
         ByVal N As Long, _
         ByRef x() As Double, _
         ByVal IsUpper As Boolean, _
         ByVal Trans As Long, _
         ByVal Isunit As Boolean, _
         ByVal MaxGrowth As Double) As Boolean
    Dim Result As Boolean
    Dim LnMax As Double
    Dim NrmB As Double
    Dim NrmX As Double
    Dim i As Long
    Dim alpha As Complex
    Dim beta As Complex
    Dim VR As Double
    Dim cx As Complex
    Dim tmp() As Double
    Dim i_ As Long
    Result = True
    LnMax = Log(MaxRealNumber)
    '
    ' Quick return if possible
    '
    If N <= 0# Then
        RMatrixScaledTRSafeSolve = Result
        Exit Function
    End If
    '
    ' Load norms: right part and X
    '
    NrmB = 0#
    For i = 0# To N - 1# Step 1
        NrmB = MaxReal(NrmB, Abs(x(i)))
    Next i
    NrmX = 0#
    '
    ' Solve
    '
    ReDim tmp(0 To N - 1)
    Result = True
    If IsUpper And Trans = 0# Then
        '
        ' U*x = b
        '
        For i = N - 1# To 0# Step -1
            '
            ' Task is reduced to alpha*x[i] = beta
            '
            If Isunit Then
                alpha = C_Complex(SA)
            Else
                alpha = C_Complex(a(i, i) * SA)
            End If
            If i < N - 1# Then
                For i_ = i + 1# To N - 1# Step 1
                    tmp(i_) = SA * a(i, i_)
                Next i_
                VR = 0#
                For i_ = i + 1# To N - 1# Step 1
                    VR = VR + tmp(i_) * x(i_)
                Next i_
                beta = C_Complex(x(i) - VR)
            Else
                beta = C_Complex(x(i))
            End If
            '
            ' solve alpha*x[i] = beta
            '
            Result = CBasicSolveAndUpdate(alpha, beta, LnMax, NrmB, MaxGrowth, NrmX, cx)
            If Not Result Then
                RMatrixScaledTRSafeSolve = Result
                Exit Function
            End If
            x(i) = cx.x
        Next i
        RMatrixScaledTRSafeSolve = Result
        Exit Function
    End If
    If Not IsUpper And Trans = 0# Then
        '
        ' L*x = b
        '
        For i = 0# To N - 1# Step 1
            '
            ' Task is reduced to alpha*x[i] = beta
            '
            If Isunit Then
                alpha = C_Complex(SA)
            Else
                alpha = C_Complex(a(i, i) * SA)
            End If
            If i > 0# Then
                For i_ = 0# To i - 1# Step 1
                    tmp(i_) = SA * a(i, i_)
                Next i_
                VR = 0#
                For i_ = 0# To i - 1# Step 1
                    VR = VR + tmp(i_) * x(i_)
                Next i_
                beta = C_Complex(x(i) - VR)
            Else
                beta = C_Complex(x(i))
            End If
            '
            ' solve alpha*x[i] = beta
            '
            Result = CBasicSolveAndUpdate(alpha, beta, LnMax, NrmB, MaxGrowth, NrmX, cx)
            If Not Result Then
                RMatrixScaledTRSafeSolve = Result
                Exit Function
            End If
            x(i) = cx.x
        Next i
        RMatrixScaledTRSafeSolve = Result
        Exit Function
    End If
    If IsUpper And Trans = 1# Then
        '
        ' U^T*x = b
        '
        For i = 0# To N - 1# Step 1
            '
            ' Task is reduced to alpha*x[i] = beta
            '
            If Isunit Then
                alpha = C_Complex(SA)
            Else
                alpha = C_Complex(a(i, i) * SA)
            End If
            beta = C_Complex(x(i))
            '
            ' solve alpha*x[i] = beta
            '
            Result = CBasicSolveAndUpdate(alpha, beta, LnMax, NrmB, MaxGrowth, NrmX, cx)
            If Not Result Then
                RMatrixScaledTRSafeSolve = Result
                Exit Function
            End If
            x(i) = cx.x
            '
            ' update the rest of right part
            '
            If i < N - 1# Then
                VR = cx.x
                For i_ = i + 1# To N - 1# Step 1
                    tmp(i_) = SA * a(i, i_)
                Next i_
                For i_ = i + 1# To N - 1# Step 1
                    x(i_) = x(i_) - VR * tmp(i_)
                Next i_
            End If
        Next i
        RMatrixScaledTRSafeSolve = Result
        Exit Function
    End If
    If Not IsUpper And Trans = 1# Then
        '
        ' L^T*x = b
        '
        For i = N - 1# To 0# Step -1
            '
            ' Task is reduced to alpha*x[i] = beta
            '
            If Isunit Then
                alpha = C_Complex(SA)
            Else
                alpha = C_Complex(a(i, i) * SA)
            End If
            beta = C_Complex(x(i))
            '
            ' solve alpha*x[i] = beta
            '
            Result = CBasicSolveAndUpdate(alpha, beta, LnMax, NrmB, MaxGrowth, NrmX, cx)
            If Not Result Then
                RMatrixScaledTRSafeSolve = Result
                Exit Function
            End If
            x(i) = cx.x
            '
            ' update the rest of right part
            '
            If i > 0# Then
                VR = cx.x
                For i_ = 0# To i - 1# Step 1
                    tmp(i_) = SA * a(i, i_)
                Next i_
                For i_ = 0# To i - 1# Step 1
                    x(i_) = x(i_) - VR * tmp(i_)
                Next i_
            End If
        Next i
        RMatrixScaledTRSafeSolve = Result
        Exit Function
    End If
    Result = False
    RMatrixScaledTRSafeSolve = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal subroutine for safe solution of
'
'    SA*op(A)=b
'
'where  A  is  NxN  upper/lower  triangular/unitriangular  matrix, op(A) is
'either identity transform, transposition or Hermitian transposition, SA is
'a scaling factor such that max(|SA*A[i,j]|) is close to 1.0 in magnutude.
'
'This subroutine  limits  relative  growth  of  solution  (in inf-norm)  by
'MaxGrowth,  returning  False  if  growth  exceeds MaxGrowth. Degenerate or
'near-degenerate matrices are handled correctly (False is returned) as long
'as MaxGrowth is significantly less than MaxRealNumber/norm(b).
'
'  -- ALGLIB routine --
'     21.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function CMatrixScaledTRSafeSolve(ByRef a() As Complex, _
         ByVal SA As Double, _
         ByVal N As Long, _
         ByRef x() As Complex, _
         ByVal IsUpper As Boolean, _
         ByVal Trans As Long, _
         ByVal Isunit As Boolean, _
         ByVal MaxGrowth As Double) As Boolean
    Dim Result As Boolean
    Dim LnMax As Double
    Dim NrmB As Double
    Dim NrmX As Double
    Dim i As Long
    Dim alpha As Complex
    Dim beta As Complex
    Dim VC As Complex
    Dim tmp() As Complex
    Dim i_ As Long
    Result = True
    LnMax = Log(MaxRealNumber)
    '
    ' Quick return if possible
    '
    If N <= 0# Then
        CMatrixScaledTRSafeSolve = Result
        Exit Function
    End If
    '
    ' Load norms: right part and X
    '
    NrmB = 0#
    For i = 0# To N - 1# Step 1
        NrmB = MaxReal(NrmB, AbsComplex(x(i)))
    Next i
    NrmX = 0#
    '
    ' Solve
    '
    ReDim tmp(0 To N - 1)
    Result = True
    If IsUpper And Trans = 0# Then
        '
        ' U*x = b
        '
        For i = N - 1# To 0# Step -1
            '
            ' Task is reduced to alpha*x[i] = beta
            '
            If Isunit Then
                alpha = C_Complex(SA)
            Else
                alpha = C_MulR(a(i, i), SA)
            End If
            If i < N - 1# Then
                For i_ = i + 1# To N - 1# Step 1
                    tmp(i_) = C_MulR(a(i, i_), SA)
                Next i_
                VC = C_Complex(0#)
                For i_ = i + 1# To N - 1# Step 1
                    VC = C_Add(VC, C_Mul(tmp(i_), x(i_)))
                Next i_
                beta = C_Sub(x(i), VC)
            Else
                beta = x(i)
            End If
            '
            ' solve alpha*x[i] = beta
            '
            Result = CBasicSolveAndUpdate(alpha, beta, LnMax, NrmB, MaxGrowth, NrmX, VC)
            If Not Result Then
                CMatrixScaledTRSafeSolve = Result
                Exit Function
            End If
            x(i) = VC
        Next i
        CMatrixScaledTRSafeSolve = Result
        Exit Function
    End If
    If Not IsUpper And Trans = 0# Then
        '
        ' L*x = b
        '
        For i = 0# To N - 1# Step 1
            '
            ' Task is reduced to alpha*x[i] = beta
            '
            If Isunit Then
                alpha = C_Complex(SA)
            Else
                alpha = C_MulR(a(i, i), SA)
            End If
            If i > 0# Then
                For i_ = 0# To i - 1# Step 1
                    tmp(i_) = C_MulR(a(i, i_), SA)
                Next i_
                VC = C_Complex(0#)
                For i_ = 0# To i - 1# Step 1
                    VC = C_Add(VC, C_Mul(tmp(i_), x(i_)))
                Next i_
                beta = C_Sub(x(i), VC)
            Else
                beta = x(i)
            End If
            '
            ' solve alpha*x[i] = beta
            '
            Result = CBasicSolveAndUpdate(alpha, beta, LnMax, NrmB, MaxGrowth, NrmX, VC)
            If Not Result Then
                CMatrixScaledTRSafeSolve = Result
                Exit Function
            End If
            x(i) = VC
        Next i
        CMatrixScaledTRSafeSolve = Result
        Exit Function
    End If
    If IsUpper And Trans = 1# Then
        '
        ' U^T*x = b
        '
        For i = 0# To N - 1# Step 1
            '
            ' Task is reduced to alpha*x[i] = beta
            '
            If Isunit Then
                alpha = C_Complex(SA)
            Else
                alpha = C_MulR(a(i, i), SA)
            End If
            beta = x(i)
            '
            ' solve alpha*x[i] = beta
            '
            Result = CBasicSolveAndUpdate(alpha, beta, LnMax, NrmB, MaxGrowth, NrmX, VC)
            If Not Result Then
                CMatrixScaledTRSafeSolve = Result
                Exit Function
            End If
            x(i) = VC
            '
            ' update the rest of right part
            '
            If i < N - 1# Then
                For i_ = i + 1# To N - 1# Step 1
                    tmp(i_) = C_MulR(a(i, i_), SA)
                Next i_
                For i_ = i + 1# To N - 1# Step 1
                    x(i_) = C_Sub(x(i_), C_Mul(VC, tmp(i_)))
                Next i_
            End If
        Next i
        CMatrixScaledTRSafeSolve = Result
        Exit Function
    End If
    If Not IsUpper And Trans = 1# Then
        '
        ' L^T*x = b
        '
        For i = N - 1# To 0# Step -1
            '
            ' Task is reduced to alpha*x[i] = beta
            '
            If Isunit Then
                alpha = C_Complex(SA)
            Else
                alpha = C_MulR(a(i, i), SA)
            End If
            beta = x(i)
            '
            ' solve alpha*x[i] = beta
            '
            Result = CBasicSolveAndUpdate(alpha, beta, LnMax, NrmB, MaxGrowth, NrmX, VC)
            If Not Result Then
                CMatrixScaledTRSafeSolve = Result
                Exit Function
            End If
            x(i) = VC
            '
            ' update the rest of right part
            '
            If i > 0# Then
                For i_ = 0# To i - 1# Step 1
                    tmp(i_) = C_MulR(a(i, i_), SA)
                Next i_
                For i_ = 0# To i - 1# Step 1
                    x(i_) = C_Sub(x(i_), C_Mul(VC, tmp(i_)))
                Next i_
            End If
        Next i
        CMatrixScaledTRSafeSolve = Result
        Exit Function
    End If
    If IsUpper And Trans = 2# Then
        '
        ' U^H*x = b
        '
        For i = 0# To N - 1# Step 1
            '
            ' Task is reduced to alpha*x[i] = beta
            '
            If Isunit Then
                alpha = C_Complex(SA)
            Else
                alpha = C_MulR(Conj(a(i, i)), SA)
            End If
            beta = x(i)
            '
            ' solve alpha*x[i] = beta
            '
            Result = CBasicSolveAndUpdate(alpha, beta, LnMax, NrmB, MaxGrowth, NrmX, VC)
            If Not Result Then
                CMatrixScaledTRSafeSolve = Result
                Exit Function
            End If
            x(i) = VC
            '
            ' update the rest of right part
            '
            If i < N - 1# Then
                For i_ = i + 1# To N - 1# Step 1
                    tmp(i_) = C_MulR(Conj(a(i, i_)), SA)
                Next i_
                For i_ = i + 1# To N - 1# Step 1
                    x(i_) = C_Sub(x(i_), C_Mul(VC, tmp(i_)))
                Next i_
            End If
        Next i
        CMatrixScaledTRSafeSolve = Result
        Exit Function
    End If
    If Not IsUpper And Trans = 2# Then
        '
        ' L^T*x = b
        '
        For i = N - 1# To 0# Step -1
            '
            ' Task is reduced to alpha*x[i] = beta
            '
            If Isunit Then
                alpha = C_Complex(SA)
            Else
                alpha = C_MulR(Conj(a(i, i)), SA)
            End If
            beta = x(i)
            '
            ' solve alpha*x[i] = beta
            '
            Result = CBasicSolveAndUpdate(alpha, beta, LnMax, NrmB, MaxGrowth, NrmX, VC)
            If Not Result Then
                CMatrixScaledTRSafeSolve = Result
                Exit Function
            End If
            x(i) = VC
            '
            ' update the rest of right part
            '
            If i > 0# Then
                For i_ = 0# To i - 1# Step 1
                    tmp(i_) = C_MulR(Conj(a(i, i_)), SA)
                Next i_
                For i_ = 0# To i - 1# Step 1
                    x(i_) = C_Sub(x(i_), C_Mul(VC, tmp(i_)))
                Next i_
            End If
        Next i
        CMatrixScaledTRSafeSolve = Result
        Exit Function
    End If
    Result = False
    CMatrixScaledTRSafeSolve = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'complex basic solver-updater for reduced linear system
'
'    alpha*x[i] = beta
'
'solves this equation and updates it in overlfow-safe manner (keeping track
'of relative growth of solution).
'
'Parameters:
'    Alpha   -   alpha
'    Beta    -   beta
'    LnMax   -   precomputed Ln(MaxRealNumber)
'    BNorm   -   inf-norm of b (right part of original system)
'    MaxGrowth-  maximum growth of norm(x) relative to norm(b)
'    XNorm   -   inf-norm of other components of X (which are already processed)
'                it is updated by CBasicSolveAndUpdate.
'    X       -   solution
'
'  -- ALGLIB routine --
'     26.01.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Function CBasicSolveAndUpdate(ByRef Alpha_ As Complex, _
         ByRef Beta_ As Complex, _
         ByVal LnMax As Double, _
         ByVal BNorm As Double, _
         ByVal MaxGrowth As Double, _
         ByRef XNorm As Double, _
         ByRef x As Complex) As Boolean
    Dim Result As Boolean
    Dim alpha As Complex
    Dim beta As Complex
    Dim V As Double
    alpha = Alpha_
    beta = Beta_
    Result = False
    If C_EqualR(alpha, 0#) Then
        CBasicSolveAndUpdate = Result
        Exit Function
    End If
    If C_NotEqualR(beta, 0#) Then
        '
        ' alpha*x[i]=beta
        '
        V = Log(AbsComplex(beta)) - Log(AbsComplex(alpha))
        If V > LnMax Then
            CBasicSolveAndUpdate = Result
            Exit Function
        End If
        x = C_Div(beta, alpha)
    Else
        '
        ' alpha*x[i]=0
        '
        x = C_Complex(0#)
    End If
    '
    ' update NrmX, test growth limit
    '
    XNorm = MaxReal(XNorm, AbsComplex(x))
    If XNorm > MaxGrowth * BNorm Then
        CBasicSolveAndUpdate = Result
        Exit Function
    End If
    Result = True
    CBasicSolveAndUpdate = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 1992-2007 The University of Tennessee.  All rights reserved.
'
'Contributors:
'    * Sergey Bochkanov (ALGLIB project). Translation from FORTRAN to
'      pseudocode.
'
'See subroutines comments for additional copyrights.
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Estimate of a matrix condition number (1-norm)
'
'The algorithm calculates a lower bound of the condition number. In this case,
'the algorithm does not return a lower bound of the condition number, but an
'inverse number (to avoid an overflow in case of a singular matrix).
'
'Input parameters:
'    A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
'    N   -   size of matrix A.
'
'Result: 1/LowerBound(cond(A))
'
'NOTE:
'    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
'    0.0 is returned in such cases.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function RMatrixRCond1(ByRef A_() As Double, ByVal N As Long) As Double
    Dim Result As Double
    Dim a() As Double
    Dim i As Long
    Dim j As Long
    Dim V As Double
    Dim Nrm As Double
    Dim Pivots() As Long
    Dim t() As Double
    a = A_
    ReDim t(0 To N - 1)
    For i = 0# To N - 1# Step 1
        t(i) = 0#
    Next i
    For i = 0# To N - 1# Step 1
        For j = 0# To N - 1# Step 1
            t(j) = t(j) + Abs(a(i, j))
        Next j
    Next i
    Nrm = 0#
    For i = 0# To N - 1# Step 1
        Nrm = MaxReal(Nrm, t(i))
    Next i
    Call RMatrixLU(a, N, N, Pivots)
    Call RMatrixRCondLUInternal(a, N, True, True, Nrm, V)
    Result = V
    RMatrixRCond1 = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Estimate of a matrix condition number (infinity-norm).
'
'The algorithm calculates a lower bound of the condition number. In this case,
'the algorithm does not return a lower bound of the condition number, but an
'inverse number (to avoid an overflow in case of a singular matrix).
'
'Input parameters:
'    A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
'    N   -   size of matrix A.
'
'Result: 1/LowerBound(cond(A))
'
'NOTE:
'    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
'    0.0 is returned in such cases.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function RMatrixRCondInf(ByRef A_() As Double, _
         ByVal N As Long) As Double
    Dim Result As Double
    Dim a() As Double
    Dim i As Long
    Dim j As Long
    Dim V As Double
    Dim Nrm As Double
    Dim Pivots() As Long
    a = A_
    Nrm = 0#
    For i = 0# To N - 1# Step 1
        V = 0#
        For j = 0# To N - 1# Step 1
            V = V + Abs(a(i, j))
        Next j
        Nrm = MaxReal(Nrm, V)
    Next i
    Call RMatrixLU(a, N, N, Pivots)
    Call RMatrixRCondLUInternal(a, N, False, True, Nrm, V)
    Result = V
    RMatrixRCondInf = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Condition number estimate of a symmetric positive definite matrix.
'
'The algorithm calculates a lower bound of the condition number. In this case,
'the algorithm does not return a lower bound of the condition number, but an
'inverse number (to avoid an overflow in case of a singular matrix).
'
'It should be noted that 1-norm and inf-norm of condition numbers of symmetric
'matrices are equal, so the algorithm doesn't take into account the
'differences between these types of norms.
'
'Input parameters:
'    A       -   symmetric positive definite matrix which is given by its
'                upper or lower triangle depending on the value of
'                IsUpper. Array with elements [0..N-1, 0..N-1].
'    N       -   size of matrix A.
'    IsUpper -   storage format.
'
'Result:
'    1/LowerBound(cond(A)), if matrix A is positive definite,
'   -1, if matrix A is not positive definite, and its condition number
'    could not be found by this algorithm.
'
'NOTE:
'    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
'    0.0 is returned in such cases.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function SPDMatrixRCond(ByRef A_() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean) As Double
    Dim Result As Double
    Dim a() As Double
    Dim i As Long
    Dim j As Long
    Dim J1 As Long
    Dim J2 As Long
    Dim V As Double
    Dim Nrm As Double
    Dim t() As Double
    a = A_
    ReDim t(0 To N - 1)
    For i = 0# To N - 1# Step 1
        t(i) = 0#
    Next i
    For i = 0# To N - 1# Step 1
        If IsUpper Then
            J1 = i
            J2 = N - 1#
        Else
            J1 = 0#
            J2 = i
        End If
        For j = J1 To J2 Step 1
            If i = j Then
                t(i) = t(i) + Abs(a(i, i))
            Else
                t(i) = t(i) + Abs(a(i, j))
                t(j) = t(j) + Abs(a(i, j))
            End If
        Next j
    Next i
    Nrm = 0#
    For i = 0# To N - 1# Step 1
        Nrm = MaxReal(Nrm, t(i))
    Next i
    If SPDMatrixCholesky(a, N, IsUpper) Then
        Call SPDMatrixRCondCholeskyInternal(a, N, IsUpper, True, Nrm, V)
        Result = V
    Else
        Result = -1#
    End If
    SPDMatrixRCond = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Triangular matrix: estimate of a condition number (1-norm)
'
'The algorithm calculates a lower bound of the condition number. In this case,
'the algorithm does not return a lower bound of the condition number, but an
'inverse number (to avoid an overflow in case of a singular matrix).
'
'Input parameters:
'    A       -   matrix. Array[0..N-1, 0..N-1].
'    N       -   size of A.
'    IsUpper -   True, if the matrix is upper triangular.
'    IsUnit  -   True, if the matrix has a unit diagonal.
'
'Result: 1/LowerBound(cond(A))
'
'NOTE:
'    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
'    0.0 is returned in such cases.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function RMatrixTRRCond1(ByRef a() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByVal Isunit As Boolean) As Double
    Dim Result As Double
    Dim i As Long
    Dim j As Long
    Dim V As Double
    Dim Nrm As Double
    Dim Pivots() As Long
    Dim t() As Double
    Dim J1 As Long
    Dim J2 As Long
    ReDim t(0 To N - 1)
    For i = 0# To N - 1# Step 1
        t(i) = 0#
    Next i
    For i = 0# To N - 1# Step 1
        If IsUpper Then
            J1 = i + 1#
            J2 = N - 1#
        Else
            J1 = 0#
            J2 = i - 1#
        End If
        For j = J1 To J2 Step 1
            t(j) = t(j) + Abs(a(i, j))
        Next j
        If Isunit Then
            t(i) = t(i) + 1#
        Else
            t(i) = t(i) + Abs(a(i, i))
        End If
    Next i
    Nrm = 0#
    For i = 0# To N - 1# Step 1
        Nrm = MaxReal(Nrm, t(i))
    Next i
    Call RMatrixRCondTRInternal(a, N, IsUpper, Isunit, True, Nrm, V)
    Result = V
    RMatrixTRRCond1 = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Triangular matrix: estimate of a matrix condition number (infinity-norm).
'
'The algorithm calculates a lower bound of the condition number. In this case,
'the algorithm does not return a lower bound of the condition number, but an
'inverse number (to avoid an overflow in case of a singular matrix).
'
'Input parameters:
'    A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
'    N   -   size of matrix A.
'    IsUpper -   True, if the matrix is upper triangular.
'    IsUnit  -   True, if the matrix has a unit diagonal.
'
'Result: 1/LowerBound(cond(A))
'
'NOTE:
'    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
'    0.0 is returned in such cases.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function RMatrixTRRCondInf(ByRef a() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByVal Isunit As Boolean) As Double
    Dim Result As Double
    Dim i As Long
    Dim j As Long
    Dim V As Double
    Dim Nrm As Double
    Dim Pivots() As Long
    Dim J1 As Long
    Dim J2 As Long
    Nrm = 0#
    For i = 0# To N - 1# Step 1
        If IsUpper Then
            J1 = i + 1#
            J2 = N - 1#
        Else
            J1 = 0#
            J2 = i - 1#
        End If
        V = 0#
        For j = J1 To J2 Step 1
            V = V + Abs(a(i, j))
        Next j
        If Isunit Then
            V = V + 1#
        Else
            V = V + Abs(a(i, i))
        End If
        Nrm = MaxReal(Nrm, V)
    Next i
    Call RMatrixRCondTRInternal(a, N, IsUpper, Isunit, False, Nrm, V)
    Result = V
    RMatrixTRRCondInf = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Condition number estimate of a Hermitian positive definite matrix.
'
'The algorithm calculates a lower bound of the condition number. In this case,
'the algorithm does not return a lower bound of the condition number, but an
'inverse number (to avoid an overflow in case of a singular matrix).
'
'It should be noted that 1-norm and inf-norm of condition numbers of symmetric
'matrices are equal, so the algorithm doesn't take into account the
'differences between these types of norms.
'
'Input parameters:
'    A       -   Hermitian positive definite matrix which is given by its
'                upper or lower triangle depending on the value of
'                IsUpper. Array with elements [0..N-1, 0..N-1].
'    N       -   size of matrix A.
'    IsUpper -   storage format.
'
'Result:
'    1/LowerBound(cond(A)), if matrix A is positive definite,
'   -1, if matrix A is not positive definite, and its condition number
'    could not be found by this algorithm.
'
'NOTE:
'    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
'    0.0 is returned in such cases.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function HPDMatrixRCond(ByRef A_() As Complex, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean) As Double
    Dim Result As Double
    Dim a() As Complex
    Dim i As Long
    Dim j As Long
    Dim J1 As Long
    Dim J2 As Long
    Dim V As Double
    Dim Nrm As Double
    Dim t() As Double
    a = A_
    ReDim t(0 To N - 1)
    For i = 0# To N - 1# Step 1
        t(i) = 0#
    Next i
    For i = 0# To N - 1# Step 1
        If IsUpper Then
            J1 = i
            J2 = N - 1#
        Else
            J1 = 0#
            J2 = i
        End If
        For j = J1 To J2 Step 1
            If i = j Then
                t(i) = t(i) + AbsComplex(a(i, i))
            Else
                t(i) = t(i) + AbsComplex(a(i, j))
                t(j) = t(j) + AbsComplex(a(i, j))
            End If
        Next j
    Next i
    Nrm = 0#
    For i = 0# To N - 1# Step 1
        Nrm = MaxReal(Nrm, t(i))
    Next i
    If HPDMatrixCholesky(a, N, IsUpper) Then
        Call HPDMatrixRCondCholeskyInternal(a, N, IsUpper, True, Nrm, V)
        Result = V
    Else
        Result = -1#
    End If
    HPDMatrixRCond = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Estimate of a matrix condition number (1-norm)
'
'The algorithm calculates a lower bound of the condition number. In this case,
'the algorithm does not return a lower bound of the condition number, but an
'inverse number (to avoid an overflow in case of a singular matrix).
'
'Input parameters:
'    A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
'    N   -   size of matrix A.
'
'Result: 1/LowerBound(cond(A))
'
'NOTE:
'    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
'    0.0 is returned in such cases.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function CMatrixRCond1(ByRef A_() As Complex, ByVal N As Long) As Double
    Dim Result As Double
    Dim a() As Complex
    Dim i As Long
    Dim j As Long
    Dim V As Double
    Dim Nrm As Double
    Dim Pivots() As Long
    Dim t() As Double
    a = A_
    ReDim t(0 To N - 1)
    For i = 0# To N - 1# Step 1
        t(i) = 0#
    Next i
    For i = 0# To N - 1# Step 1
        For j = 0# To N - 1# Step 1
            t(j) = t(j) + AbsComplex(a(i, j))
        Next j
    Next i
    Nrm = 0#
    For i = 0# To N - 1# Step 1
        Nrm = MaxReal(Nrm, t(i))
    Next i
    Call CMatrixLU(a, N, N, Pivots)
    Call CMatrixRCondLUInternal(a, N, True, True, Nrm, V)
    Result = V
    CMatrixRCond1 = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Estimate of a matrix condition number (infinity-norm).
'
'The algorithm calculates a lower bound of the condition number. In this case,
'the algorithm does not return a lower bound of the condition number, but an
'inverse number (to avoid an overflow in case of a singular matrix).
'
'Input parameters:
'    A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
'    N   -   size of matrix A.
'
'Result: 1/LowerBound(cond(A))
'
'NOTE:
'    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
'    0.0 is returned in such cases.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function CMatrixRCondInf(ByRef A_() As Complex, _
         ByVal N As Long) As Double
    Dim Result As Double
    Dim a() As Complex
    Dim i As Long
    Dim j As Long
    Dim V As Double
    Dim Nrm As Double
    Dim Pivots() As Long
    a = A_
    Nrm = 0#
    For i = 0# To N - 1# Step 1
        V = 0#
        For j = 0# To N - 1# Step 1
            V = V + AbsComplex(a(i, j))
        Next j
        Nrm = MaxReal(Nrm, V)
    Next i
    Call CMatrixLU(a, N, N, Pivots)
    Call CMatrixRCondLUInternal(a, N, False, True, Nrm, V)
    Result = V
    CMatrixRCondInf = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Estimate of the condition number of a matrix given by its LU decomposition (1-norm)
'
'The algorithm calculates a lower bound of the condition number. In this case,
'the algorithm does not return a lower bound of the condition number, but an
'inverse number (to avoid an overflow in case of a singular matrix).
'
'Input parameters:
'    LUA         -   LU decomposition of a matrix in compact form. Output of
'                    the RMatrixLU subroutine.
'    N           -   size of matrix A.
'
'Result: 1/LowerBound(cond(A))
'
'NOTE:
'    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
'    0.0 is returned in such cases.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function RMatrixLURCond1(ByRef LUA() As Double, _
         ByVal N As Long) As Double
    Dim Result As Double
    Dim V As Double
    Call RMatrixRCondLUInternal(LUA, N, True, False, 0#, V)
    Result = V
    RMatrixLURCond1 = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Estimate of the condition number of a matrix given by its LU decomposition
'(infinity norm).
'
'The algorithm calculates a lower bound of the condition number. In this case,
'the algorithm does not return a lower bound of the condition number, but an
'inverse number (to avoid an overflow in case of a singular matrix).
'
'Input parameters:
'    LUA     -   LU decomposition of a matrix in compact form. Output of
'                the RMatrixLU subroutine.
'    N       -   size of matrix A.
'
'Result: 1/LowerBound(cond(A))
'
'NOTE:
'    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
'    0.0 is returned in such cases.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function RMatrixLURCondInf(ByRef LUA() As Double, _
         ByVal N As Long) As Double
    Dim Result As Double
    Dim V As Double
    Call RMatrixRCondLUInternal(LUA, N, False, False, 0#, V)
    Result = V
    RMatrixLURCondInf = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Condition number estimate of a symmetric positive definite matrix given by
'Cholesky decomposition.
'
'The algorithm calculates a lower bound of the condition number. In this
'case, the algorithm does not return a lower bound of the condition number,
'but an inverse number (to avoid an overflow in case of a singular matrix).
'
'It should be noted that 1-norm and inf-norm condition numbers of symmetric
'matrices are equal, so the algorithm doesn't take into account the
'differences between these types of norms.
'
'Input parameters:
'    CD  - Cholesky decomposition of matrix A,
'          output of SMatrixCholesky subroutine.
'    N   - size of matrix A.
'
'Result: 1/LowerBound(cond(A))
'
'NOTE:
'    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
'    0.0 is returned in such cases.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function SPDMatrixCholeskyRCond(ByRef a() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean) As Double
    Dim Result As Double
    Dim V As Double
    Call SPDMatrixRCondCholeskyInternal(a, N, IsUpper, False, 0#, V)
    Result = V
    SPDMatrixCholeskyRCond = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Condition number estimate of a Hermitian positive definite matrix given by
'Cholesky decomposition.
'
'The algorithm calculates a lower bound of the condition number. In this
'case, the algorithm does not return a lower bound of the condition number,
'but an inverse number (to avoid an overflow in case of a singular matrix).
'
'It should be noted that 1-norm and inf-norm condition numbers of symmetric
'matrices are equal, so the algorithm doesn't take into account the
'differences between these types of norms.
'
'Input parameters:
'    CD  - Cholesky decomposition of matrix A,
'          output of SMatrixCholesky subroutine.
'    N   - size of matrix A.
'
'Result: 1/LowerBound(cond(A))
'
'NOTE:
'    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
'    0.0 is returned in such cases.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function HPDMatrixCholeskyRCond(ByRef a() As Complex, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean) As Double
    Dim Result As Double
    Dim V As Double
    Call HPDMatrixRCondCholeskyInternal(a, N, IsUpper, False, 0#, V)
    Result = V
    HPDMatrixCholeskyRCond = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Estimate of the condition number of a matrix given by its LU decomposition (1-norm)
'
'The algorithm calculates a lower bound of the condition number. In this case,
'the algorithm does not return a lower bound of the condition number, but an
'inverse number (to avoid an overflow in case of a singular matrix).
'
'Input parameters:
'    LUA         -   LU decomposition of a matrix in compact form. Output of
'                    the CMatrixLU subroutine.
'    N           -   size of matrix A.
'
'Result: 1/LowerBound(cond(A))
'
'NOTE:
'    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
'    0.0 is returned in such cases.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function CMatrixLURCond1(ByRef LUA() As Complex, _
         ByVal N As Long) As Double
    Dim Result As Double
    Dim V As Double
    Call CMatrixRCondLUInternal(LUA, N, True, False, 0#, V)
    Result = V
    CMatrixLURCond1 = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Estimate of the condition number of a matrix given by its LU decomposition
'(infinity norm).
'
'The algorithm calculates a lower bound of the condition number. In this case,
'the algorithm does not return a lower bound of the condition number, but an
'inverse number (to avoid an overflow in case of a singular matrix).
'
'Input parameters:
'    LUA     -   LU decomposition of a matrix in compact form. Output of
'                the CMatrixLU subroutine.
'    N       -   size of matrix A.
'
'Result: 1/LowerBound(cond(A))
'
'NOTE:
'    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
'    0.0 is returned in such cases.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function CMatrixLURCondInf(ByRef LUA() As Complex, _
         ByVal N As Long) As Double
    Dim Result As Double
    Dim V As Double
    Call CMatrixRCondLUInternal(LUA, N, False, False, 0#, V)
    Result = V
    CMatrixLURCondInf = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Triangular matrix: estimate of a condition number (1-norm)
'
'The algorithm calculates a lower bound of the condition number. In this case,
'the algorithm does not return a lower bound of the condition number, but an
'inverse number (to avoid an overflow in case of a singular matrix).
'
'Input parameters:
'    A       -   matrix. Array[0..N-1, 0..N-1].
'    N       -   size of A.
'    IsUpper -   True, if the matrix is upper triangular.
'    IsUnit  -   True, if the matrix has a unit diagonal.
'
'Result: 1/LowerBound(cond(A))
'
'NOTE:
'    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
'    0.0 is returned in such cases.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function CMatrixTRRCond1(ByRef a() As Complex, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByVal Isunit As Boolean) As Double
    Dim Result As Double
    Dim i As Long
    Dim j As Long
    Dim V As Double
    Dim Nrm As Double
    Dim Pivots() As Long
    Dim t() As Double
    Dim J1 As Long
    Dim J2 As Long
    ReDim t(0 To N - 1)
    For i = 0# To N - 1# Step 1
        t(i) = 0#
    Next i
    For i = 0# To N - 1# Step 1
        If IsUpper Then
            J1 = i + 1#
            J2 = N - 1#
        Else
            J1 = 0#
            J2 = i - 1#
        End If
        For j = J1 To J2 Step 1
            t(j) = t(j) + AbsComplex(a(i, j))
        Next j
        If Isunit Then
            t(i) = t(i) + 1#
        Else
            t(i) = t(i) + AbsComplex(a(i, i))
        End If
    Next i
    Nrm = 0#
    For i = 0# To N - 1# Step 1
        Nrm = MaxReal(Nrm, t(i))
    Next i
    Call CMatrixRCondTRInternal(a, N, IsUpper, Isunit, True, Nrm, V)
    Result = V
    CMatrixTRRCond1 = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Triangular matrix: estimate of a matrix condition number (infinity-norm).
'
'The algorithm calculates a lower bound of the condition number. In this case,
'the algorithm does not return a lower bound of the condition number, but an
'inverse number (to avoid an overflow in case of a singular matrix).
'
'Input parameters:
'    A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
'    N   -   size of matrix A.
'    IsUpper -   True, if the matrix is upper triangular.
'    IsUnit  -   True, if the matrix has a unit diagonal.
'
'Result: 1/LowerBound(cond(A))
'
'NOTE:
'    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
'    0.0 is returned in such cases.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function CMatrixTRRCondInf(ByRef a() As Complex, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByVal Isunit As Boolean) As Double
    Dim Result As Double
    Dim i As Long
    Dim j As Long
    Dim V As Double
    Dim Nrm As Double
    Dim Pivots() As Long
    Dim J1 As Long
    Dim J2 As Long
    Nrm = 0#
    For i = 0# To N - 1# Step 1
        If IsUpper Then
            J1 = i + 1#
            J2 = N - 1#
        Else
            J1 = 0#
            J2 = i - 1#
        End If
        V = 0#
        For j = J1 To J2 Step 1
            V = V + AbsComplex(a(i, j))
        Next j
        If Isunit Then
            V = V + 1#
        Else
            V = V + AbsComplex(a(i, i))
        End If
        Nrm = MaxReal(Nrm, V)
    Next i
    Call CMatrixRCondTRInternal(a, N, IsUpper, Isunit, False, Nrm, V)
    Result = V
    CMatrixTRRCondInf = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Threshold for rcond: matrices with condition number beyond this  threshold
'are considered singular.
'
'Threshold must be far enough from underflow, at least Sqr(Threshold)  must
'be greater than underflow.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function RCondThreshold() As Double
    Dim Result As Double
    Result = Sqr(Sqr(MinRealNumber))
    RCondThreshold = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal subroutine for condition number estimation
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     February 29, 1992
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub RMatrixRCondTRInternal(ByRef a() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByVal Isunit As Boolean, _
         ByVal OneNorm As Boolean, _
         ByVal ANORM As Double, _
         ByRef RC As Double)
    Dim EX() As Double
    Dim EV() As Double
    Dim IWORK() As Long
    Dim tmp() As Double
    Dim V As Double
    Dim i As Long
    Dim j As Long
    Dim KASE As Long
    Dim KASE1 As Long
    Dim J1 As Long
    Dim J2 As Long
    Dim AINVNM As Double
    Dim MaxGrowth As Double
    Dim s As Double
    Dim MUpper As Boolean
    Dim MTrans As Boolean
    Dim Munit As Boolean
    '
    ' RC=0 if something happens
    '
    RC = 0#
    '
    ' init
    '
    If OneNorm Then
        KASE1 = 1#
    Else
        KASE1 = 2#
    End If
    MUpper = True
    MTrans = True
    Munit = True
    ReDim IWORK(0 To N + 1# - 1)
    ReDim tmp(0 To N - 1)
    '
    ' prepare parameters for triangular solver
    '
    MaxGrowth = 1# / RCondThreshold()
    s = 0#
    For i = 0# To N - 1# Step 1
        If IsUpper Then
            J1 = i + 1#
            J2 = N - 1#
        Else
            J1 = 0#
            J2 = i - 1#
        End If
        For j = J1 To J2 Step 1
            s = MaxReal(s, Abs(a(i, j)))
        Next j
        If Isunit Then
            s = MaxReal(s, 1#)
        Else
            s = MaxReal(s, Abs(a(i, i)))
        End If
    Next i
    If s = 0# Then
        s = 1#
    End If
    s = 1# / s
    '
    ' Scale according to S
    '
    ANORM = ANORM * s
    '
    ' Quick return if possible
    ' We assume that ANORM<>0 after this block
    '
    If ANORM = 0# Then
        Exit Sub
    End If
    If N = 1# Then
        RC = 1#
        Exit Sub
    End If
    '
    ' Estimate the norm of inv(A).
    '
    AINVNM = 0#
    KASE = 0#
    Do While True
        Call RMatrixEstimateNorm(N, EV, EX, IWORK, AINVNM, KASE)
        If KASE = 0# Then
            Exit Do
        End If
        '
        ' from 1-based array to 0-based
        '
        For i = 0# To N - 1# Step 1
            EX(i) = EX(i + 1#)
        Next i
        '
        ' multiply by inv(A) or inv(A')
        '
        If KASE = KASE1 Then
            '
            ' multiply by inv(A)
            '
            If Not RMatrixScaledTRSafeSolve(a, s, N, EX, IsUpper, 0#, Isunit, MaxGrowth) Then
                Exit Sub
            End If
        Else
            '
            ' multiply by inv(A')
            '
            If Not RMatrixScaledTRSafeSolve(a, s, N, EX, IsUpper, 1#, Isunit, MaxGrowth) Then
                Exit Sub
            End If
        End If
        '
        ' from 0-based array to 1-based
        '
        For i = N - 1# To 0# Step -1
            EX(i + 1#) = EX(i)
        Next i
    Loop
    '
    ' Compute the estimate of the reciprocal condition number.
    '
    If AINVNM <> 0# Then
        RC = 1# / AINVNM
        RC = RC / ANORM
        If RC < RCondThreshold() Then
            RC = 0#
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Condition number estimation
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     March 31, 1993
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub CMatrixRCondTRInternal(ByRef a() As Complex, _
         ByRef N As Long, _
         ByVal IsUpper As Boolean, _
         ByVal Isunit As Boolean, _
         ByVal OneNorm As Boolean, _
         ByVal ANORM As Double, _
         ByRef RC As Double)
    Dim EX() As Complex
    Dim CWORK2() As Complex
    Dim CWORK3() As Complex
    Dim CWORK4() As Complex
    Dim ISAVE() As Long
    Dim RSAVE() As Double
    Dim KASE As Long
    Dim KASE1 As Long
    Dim AINVNM As Double
    Dim V As Complex
    Dim i As Long
    Dim j As Long
    Dim J1 As Long
    Dim J2 As Long
    Dim s As Double
    Dim MaxGrowth As Double
    '
    ' RC=0 if something happens
    '
    RC = 0#
    '
    ' init
    '
    If N <= 0# Then
        Exit Sub
    End If
    If N = 0# Then
        RC = 1#
        Exit Sub
    End If
    ReDim CWORK2(0 To N + 1# - 1)
    '
    ' prepare parameters for triangular solver
    '
    MaxGrowth = 1# / RCondThreshold()
    s = 0#
    For i = 0# To N - 1# Step 1
        If IsUpper Then
            J1 = i + 1#
            J2 = N - 1#
        Else
            J1 = 0#
            J2 = i - 1#
        End If
        For j = J1 To J2 Step 1
            s = MaxReal(s, AbsComplex(a(i, j)))
        Next j
        If Isunit Then
            s = MaxReal(s, 1#)
        Else
            s = MaxReal(s, AbsComplex(a(i, i)))
        End If
    Next i
    If s = 0# Then
        s = 1#
    End If
    s = 1# / s
    '
    ' Scale according to S
    '
    ANORM = ANORM * s
    '
    ' Quick return if possible
    '
    If ANORM = 0# Then
        Exit Sub
    End If
    '
    ' Estimate the norm of inv(A).
    '
    AINVNM = 0#
    If OneNorm Then
        KASE1 = 1#
    Else
        KASE1 = 2#
    End If
    KASE = 0#
    Do While True
        Call CMatrixEstimateNorm(N, CWORK4, EX, AINVNM, KASE, ISAVE, RSAVE)
        If KASE = 0# Then
            Exit Do
        End If
        '
        ' From 1-based to 0-based
        '
        For i = 0# To N - 1# Step 1
            EX(i) = EX(i + 1#)
        Next i
        '
        ' multiply by inv(A) or inv(A')
        '
        If KASE = KASE1 Then
            '
            ' multiply by inv(A)
            '
            If Not CMatrixScaledTRSafeSolve(a, s, N, EX, IsUpper, 0#, Isunit, MaxGrowth) Then
                Exit Sub
            End If
        Else
            '
            ' multiply by inv(A')
            '
            If Not CMatrixScaledTRSafeSolve(a, s, N, EX, IsUpper, 2#, Isunit, MaxGrowth) Then
                Exit Sub
            End If
        End If
        '
        ' from 0-based to 1-based
        '
        For i = N - 1# To 0# Step -1
            EX(i + 1#) = EX(i)
        Next i
    Loop
    '
    ' Compute the estimate of the reciprocal condition number.
    '
    If AINVNM <> 0# Then
        RC = 1# / AINVNM
        RC = RC / ANORM
        If RC < RCondThreshold() Then
            RC = 0#
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal subroutine for condition number estimation
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     February 29, 1992
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub SPDMatrixRCondCholeskyInternal(ByRef CHA() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByVal IsNormProvided As Boolean, _
         ByVal ANORM As Double, _
         ByRef RC As Double)
    Dim i As Long
    Dim j As Long
    Dim KASE As Long
    Dim AINVNM As Double
    Dim EX() As Double
    Dim EV() As Double
    Dim tmp() As Double
    Dim IWORK() As Long
    Dim SA As Double
    Dim V As Double
    Dim MaxGrowth As Double
    Dim i_ As Long
    Dim i1_ As Long
    ReDim tmp(0 To N - 1)
    '
    ' RC=0 if something happens
    '
    RC = 0#
    '
    ' prepare parameters for triangular solver
    '
    MaxGrowth = 1# / RCondThreshold()
    SA = 0#
    If IsUpper Then
        For i = 0# To N - 1# Step 1
            For j = i To N - 1# Step 1
                SA = MaxReal(SA, AbsComplex(C_Complex(CHA(i, j))))
            Next j
        Next i
    Else
        For i = 0# To N - 1# Step 1
            For j = 0# To i Step 1
                SA = MaxReal(SA, AbsComplex(C_Complex(CHA(i, j))))
            Next j
        Next i
    End If
    If SA = 0# Then
        SA = 1#
    End If
    SA = 1# / SA
    '
    ' Estimate the norm of A.
    '
    If Not IsNormProvided Then
        KASE = 0#
        ANORM = 0#
        Do While True
            Call RMatrixEstimateNorm(N, EV, EX, IWORK, ANORM, KASE)
            If KASE = 0# Then
                Exit Do
            End If
            If IsUpper Then
                '
                ' Multiply by U
                '
                For i = 1# To N Step 1
                    i1_ = (i) - (i - 1#)
                    V = 0#
                    For i_ = i - 1# To N - 1# Step 1
                        V = V + CHA(i - 1#, i_) * EX(i_ + i1_)
                    Next i_
                    EX(i) = V
                Next i
                For i_ = 1# To N Step 1
                    EX(i_) = SA * EX(i_)
                Next i_
                '
                ' Multiply by U'
                '
                For i = 0# To N - 1# Step 1
                    tmp(i) = 0#
                Next i
                For i = 0# To N - 1# Step 1
                    V = EX(i + 1#)
                    For i_ = i To N - 1# Step 1
                        tmp(i_) = tmp(i_) + V * CHA(i, i_)
                    Next i_
                Next i
                i1_ = (0#) - (1#)
                For i_ = 1# To N Step 1
                    EX(i_) = tmp(i_ + i1_)
                Next i_
                For i_ = 1# To N Step 1
                    EX(i_) = SA * EX(i_)
                Next i_
            Else
                '
                ' Multiply by L'
                '
                For i = 0# To N - 1# Step 1
                    tmp(i) = 0#
                Next i
                For i = 0# To N - 1# Step 1
                    V = EX(i + 1#)
                    For i_ = 0# To i Step 1
                        tmp(i_) = tmp(i_) + V * CHA(i, i_)
                    Next i_
                Next i
                i1_ = (0#) - (1#)
                For i_ = 1# To N Step 1
                    EX(i_) = tmp(i_ + i1_)
                Next i_
                For i_ = 1# To N Step 1
                    EX(i_) = SA * EX(i_)
                Next i_
                '
                ' Multiply by L
                '
                For i = N To 1# Step -1
                    i1_ = (1#) - (0#)
                    V = 0#
                    For i_ = 0# To i - 1# Step 1
                        V = V + CHA(i - 1#, i_) * EX(i_ + i1_)
                    Next i_
                    EX(i) = V
                Next i
                For i_ = 1# To N Step 1
                    EX(i_) = SA * EX(i_)
                Next i_
            End If
        Loop
    End If
    '
    ' Quick return if possible
    '
    If ANORM = 0# Then
        Exit Sub
    End If
    If N = 1# Then
        RC = 1#
        Exit Sub
    End If
    '
    ' Estimate the 1-norm of inv(A).
    '
    KASE = 0#
    Do While True
        Call RMatrixEstimateNorm(N, EV, EX, IWORK, AINVNM, KASE)
        If KASE = 0# Then
            Exit Do
        End If
        For i = 0# To N - 1# Step 1
            EX(i) = EX(i + 1#)
        Next i
        If IsUpper Then
            '
            ' Multiply by inv(U').
            '
            If Not RMatrixScaledTRSafeSolve(CHA, SA, N, EX, IsUpper, 1#, False, MaxGrowth) Then
                Exit Sub
            End If
            '
            ' Multiply by inv(U).
            '
            If Not RMatrixScaledTRSafeSolve(CHA, SA, N, EX, IsUpper, 0#, False, MaxGrowth) Then
                Exit Sub
            End If
        Else
            '
            ' Multiply by inv(L).
            '
            If Not RMatrixScaledTRSafeSolve(CHA, SA, N, EX, IsUpper, 0#, False, MaxGrowth) Then
                Exit Sub
            End If
            '
            ' Multiply by inv(L').
            '
            If Not RMatrixScaledTRSafeSolve(CHA, SA, N, EX, IsUpper, 1#, False, MaxGrowth) Then
                Exit Sub
            End If
        End If
        For i = N - 1# To 0# Step -1
            EX(i + 1#) = EX(i)
        Next i
    Loop
    '
    ' Compute the estimate of the reciprocal condition number.
    '
    If AINVNM <> 0# Then
        V = 1# / AINVNM
        RC = V / ANORM
        If RC < RCondThreshold() Then
            RC = 0#
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal subroutine for condition number estimation
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     February 29, 1992
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub HPDMatrixRCondCholeskyInternal(ByRef CHA() As Complex, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByVal IsNormProvided As Boolean, _
         ByVal ANORM As Double, _
         ByRef RC As Double)
    Dim ISAVE() As Long
    Dim RSAVE() As Double
    Dim EX() As Complex
    Dim EV() As Complex
    Dim tmp() As Complex
    Dim KASE As Long
    Dim AINVNM As Double
    Dim V As Complex
    Dim i As Long
    Dim j As Long
    Dim SA As Double
    Dim MaxGrowth As Double
    Dim i_ As Long
    Dim i1_ As Long
    ReDim tmp(0 To N - 1)
    '
    ' RC=0 if something happens
    '
    RC = 0#
    '
    ' prepare parameters for triangular solver
    '
    MaxGrowth = 1# / RCondThreshold()
    SA = 0#
    If IsUpper Then
        For i = 0# To N - 1# Step 1
            For j = i To N - 1# Step 1
                SA = MaxReal(SA, AbsComplex(CHA(i, j)))
            Next j
        Next i
    Else
        For i = 0# To N - 1# Step 1
            For j = 0# To i Step 1
                SA = MaxReal(SA, AbsComplex(CHA(i, j)))
            Next j
        Next i
    End If
    If SA = 0# Then
        SA = 1#
    End If
    SA = 1# / SA
    '
    ' Estimate the norm of A
    '
    If Not IsNormProvided Then
        ANORM = 0#
        KASE = 0#
        Do While True
            Call CMatrixEstimateNorm(N, EV, EX, ANORM, KASE, ISAVE, RSAVE)
            If KASE = 0# Then
                Exit Do
            End If
            If IsUpper Then
                '
                ' Multiply by U
                '
                For i = 1# To N Step 1
                    i1_ = (i) - (i - 1#)
                    V = C_Complex(0#)
                    For i_ = i - 1# To N - 1# Step 1
                        V = C_Add(V, C_Mul(CHA(i - 1#, i_), EX(i_ + i1_)))
                    Next i_
                    EX(i) = V
                Next i
                For i_ = 1# To N Step 1
                    EX(i_) = C_MulR(EX(i_), SA)
                Next i_
                '
                ' Multiply by U'
                '
                For i = 0# To N - 1# Step 1
                    tmp(i) = C_Complex(0#)
                Next i
                For i = 0# To N - 1# Step 1
                    V = EX(i + 1#)
                    For i_ = i To N - 1# Step 1
                        tmp(i_) = C_Add(tmp(i_), C_Mul(V, Conj(CHA(i, i_))))
                    Next i_
                Next i
                i1_ = (0#) - (1#)
                For i_ = 1# To N Step 1
                    EX(i_) = tmp(i_ + i1_)
                Next i_
                For i_ = 1# To N Step 1
                    EX(i_) = C_MulR(EX(i_), SA)
                Next i_
            Else
                '
                ' Multiply by L'
                '
                For i = 0# To N - 1# Step 1
                    tmp(i) = C_Complex(0#)
                Next i
                For i = 0# To N - 1# Step 1
                    V = EX(i + 1#)
                    For i_ = 0# To i Step 1
                        tmp(i_) = C_Add(tmp(i_), C_Mul(V, Conj(CHA(i, i_))))
                    Next i_
                Next i
                i1_ = (0#) - (1#)
                For i_ = 1# To N Step 1
                    EX(i_) = tmp(i_ + i1_)
                Next i_
                For i_ = 1# To N Step 1
                    EX(i_) = C_MulR(EX(i_), SA)
                Next i_
                '
                ' Multiply by L
                '
                For i = N To 1# Step -1
                    i1_ = (1#) - (0#)
                    V = C_Complex(0#)
                    For i_ = 0# To i - 1# Step 1
                        V = C_Add(V, C_Mul(CHA(i - 1#, i_), EX(i_ + i1_)))
                    Next i_
                    EX(i) = V
                Next i
                For i_ = 1# To N Step 1
                    EX(i_) = C_MulR(EX(i_), SA)
                Next i_
            End If
        Loop
    End If
    '
    ' Quick return if possible
    ' After this block we assume that ANORM<>0
    '
    If ANORM = 0# Then
        Exit Sub
    End If
    If N = 1# Then
        RC = 1#
        Exit Sub
    End If
    '
    ' Estimate the norm of inv(A).
    '
    AINVNM = 0#
    KASE = 0#
    Do While True
        Call CMatrixEstimateNorm(N, EV, EX, AINVNM, KASE, ISAVE, RSAVE)
        If KASE = 0# Then
            Exit Do
        End If
        For i = 0# To N - 1# Step 1
            EX(i) = EX(i + 1#)
        Next i
        If IsUpper Then
            '
            ' Multiply by inv(U').
            '
            If Not CMatrixScaledTRSafeSolve(CHA, SA, N, EX, IsUpper, 2#, False, MaxGrowth) Then
                Exit Sub
            End If
            '
            ' Multiply by inv(U).
            '
            If Not CMatrixScaledTRSafeSolve(CHA, SA, N, EX, IsUpper, 0#, False, MaxGrowth) Then
                Exit Sub
            End If
        Else
            '
            ' Multiply by inv(L).
            '
            If Not CMatrixScaledTRSafeSolve(CHA, SA, N, EX, IsUpper, 0#, False, MaxGrowth) Then
                Exit Sub
            End If
            '
            ' Multiply by inv(L').
            '
            If Not CMatrixScaledTRSafeSolve(CHA, SA, N, EX, IsUpper, 2#, False, MaxGrowth) Then
                Exit Sub
            End If
        End If
        For i = N - 1# To 0# Step -1
            EX(i + 1#) = EX(i)
        Next i
    Loop
    '
    ' Compute the estimate of the reciprocal condition number.
    '
    If AINVNM <> 0# Then
        RC = 1# / AINVNM
        RC = RC / ANORM
        If RC < RCondThreshold() Then
            RC = 0#
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal subroutine for condition number estimation
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     February 29, 1992
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub RMatrixRCondLUInternal(ByRef LUA() As Double, _
         ByVal N As Long, _
         ByVal OneNorm As Boolean, _
         ByVal IsANormProvided As Boolean, _
         ByVal ANORM As Double, _
         ByRef RC As Double)
    Dim EX() As Double
    Dim EV() As Double
    Dim IWORK() As Long
    Dim tmp() As Double
    Dim V As Double
    Dim i As Long
    Dim j As Long
    Dim KASE As Long
    Dim KASE1 As Long
    Dim AINVNM As Double
    Dim MaxGrowth As Double
    Dim SU As Double
    Dim SL As Double
    Dim MUpper As Boolean
    Dim MTrans As Boolean
    Dim Munit As Boolean
    Dim i_ As Long
    Dim i1_ As Long
    '
    ' RC=0 if something happens
    '
    RC = 0#
    '
    ' init
    '
    If OneNorm Then
        KASE1 = 1#
    Else
        KASE1 = 2#
    End If
    MUpper = True
    MTrans = True
    Munit = True
    ReDim IWORK(0 To N + 1# - 1)
    ReDim tmp(0 To N - 1)
    '
    ' prepare parameters for triangular solver
    '
    MaxGrowth = 1# / RCondThreshold()
    SU = 0#
    SL = 1#
    For i = 0# To N - 1# Step 1
        For j = 0# To i - 1# Step 1
            SL = MaxReal(SL, Abs(LUA(i, j)))
        Next j
        For j = i To N - 1# Step 1
            SU = MaxReal(SU, Abs(LUA(i, j)))
        Next j
    Next i
    If SU = 0# Then
        SU = 1#
    End If
    SU = 1# / SU
    SL = 1# / SL
    '
    ' Estimate the norm of A.
    '
    If Not IsANormProvided Then
        KASE = 0#
        ANORM = 0#
        Do While True
            Call RMatrixEstimateNorm(N, EV, EX, IWORK, ANORM, KASE)
            If KASE = 0# Then
                Exit Do
            End If
            If KASE = KASE1 Then
                '
                ' Multiply by U
                '
                For i = 1# To N Step 1
                    i1_ = (i) - (i - 1#)
                    V = 0#
                    For i_ = i - 1# To N - 1# Step 1
                        V = V + LUA(i - 1#, i_) * EX(i_ + i1_)
                    Next i_
                    EX(i) = V
                Next i
                '
                ' Multiply by L
                '
                For i = N To 1# Step -1
                    If i > 1# Then
                        i1_ = (1#) - (0#)
                        V = 0#
                        For i_ = 0# To i - 2# Step 1
                            V = V + LUA(i - 1#, i_) * EX(i_ + i1_)
                        Next i_
                    Else
                        V = 0#
                    End If
                    EX(i) = EX(i) + V
                Next i
            Else
                '
                ' Multiply by L'
                '
                For i = 0# To N - 1# Step 1
                    tmp(i) = 0#
                Next i
                For i = 0# To N - 1# Step 1
                    V = EX(i + 1#)
                    If i >= 1# Then
                        For i_ = 0# To i - 1# Step 1
                            tmp(i_) = tmp(i_) + V * LUA(i, i_)
                        Next i_
                    End If
                    tmp(i) = tmp(i) + V
                Next i
                i1_ = (0#) - (1#)
                For i_ = 1# To N Step 1
                    EX(i_) = tmp(i_ + i1_)
                Next i_
                '
                ' Multiply by U'
                '
                For i = 0# To N - 1# Step 1
                    tmp(i) = 0#
                Next i
                For i = 0# To N - 1# Step 1
                    V = EX(i + 1#)
                    For i_ = i To N - 1# Step 1
                        tmp(i_) = tmp(i_) + V * LUA(i, i_)
                    Next i_
                Next i
                i1_ = (0#) - (1#)
                For i_ = 1# To N Step 1
                    EX(i_) = tmp(i_ + i1_)
                Next i_
            End If
        Loop
    End If
    '
    ' Scale according to SU/SL
    '
    ANORM = ANORM * SU * SL
    '
    ' Quick return if possible
    ' We assume that ANORM<>0 after this block
    '
    If ANORM = 0# Then
        Exit Sub
    End If
    If N = 1# Then
        RC = 1#
        Exit Sub
    End If
    '
    ' Estimate the norm of inv(A).
    '
    AINVNM = 0#
    KASE = 0#
    Do While True
        Call RMatrixEstimateNorm(N, EV, EX, IWORK, AINVNM, KASE)
        If KASE = 0# Then
            Exit Do
        End If
        '
        ' from 1-based array to 0-based
        '
        For i = 0# To N - 1# Step 1
            EX(i) = EX(i + 1#)
        Next i
        '
        ' multiply by inv(A) or inv(A')
        '
        If KASE = KASE1 Then
            '
            ' Multiply by inv(L).
            '
            If Not RMatrixScaledTRSafeSolve(LUA, SL, N, EX, Not MUpper, 0#, Munit, MaxGrowth) Then
                Exit Sub
            End If
            '
            ' Multiply by inv(U).
            '
            If Not RMatrixScaledTRSafeSolve(LUA, SU, N, EX, MUpper, 0#, Not Munit, MaxGrowth) Then
                Exit Sub
            End If
        Else
            '
            ' Multiply by inv(U').
            '
            If Not RMatrixScaledTRSafeSolve(LUA, SU, N, EX, MUpper, 1#, Not Munit, MaxGrowth) Then
                Exit Sub
            End If
            '
            ' Multiply by inv(L').
            '
            If Not RMatrixScaledTRSafeSolve(LUA, SL, N, EX, Not MUpper, 1#, Munit, MaxGrowth) Then
                Exit Sub
            End If
        End If
        '
        ' from 0-based array to 1-based
        '
        For i = N - 1# To 0# Step -1
            EX(i + 1#) = EX(i)
        Next i
    Loop
    '
    ' Compute the estimate of the reciprocal condition number.
    '
    If AINVNM <> 0# Then
        RC = 1# / AINVNM
        RC = RC / ANORM
        If RC < RCondThreshold() Then
            RC = 0#
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Condition number estimation
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     March 31, 1993
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub CMatrixRCondLUInternal(ByRef LUA() As Complex, _
         ByRef N As Long, _
         ByVal OneNorm As Boolean, _
         ByVal IsANormProvided As Boolean, _
         ByVal ANORM As Double, _
         ByRef RC As Double)
    Dim EX() As Complex
    Dim CWORK2() As Complex
    Dim CWORK3() As Complex
    Dim CWORK4() As Complex
    Dim ISAVE() As Long
    Dim RSAVE() As Double
    Dim KASE As Long
    Dim KASE1 As Long
    Dim AINVNM As Double
    Dim V As Complex
    Dim i As Long
    Dim j As Long
    Dim SU As Double
    Dim SL As Double
    Dim MaxGrowth As Double
    Dim i_ As Long
    Dim i1_ As Long
    If N <= 0# Then
        Exit Sub
    End If
    ReDim CWORK2(0 To N + 1# - 1)
    RC = 0#
    If N = 0# Then
        RC = 1#
        Exit Sub
    End If
    '
    ' prepare parameters for triangular solver
    '
    MaxGrowth = 1# / RCondThreshold()
    SU = 0#
    SL = 1#
    For i = 0# To N - 1# Step 1
        For j = 0# To i - 1# Step 1
            SL = MaxReal(SL, AbsComplex(LUA(i, j)))
        Next j
        For j = i To N - 1# Step 1
            SU = MaxReal(SU, AbsComplex(LUA(i, j)))
        Next j
    Next i
    If SU = 0# Then
        SU = 1#
    End If
    SU = 1# / SU
    SL = 1# / SL
    '
    ' Estimate the norm of SU*SL*A.
    '
    If Not IsANormProvided Then
        ANORM = 0#
        If OneNorm Then
            KASE1 = 1#
        Else
            KASE1 = 2#
        End If
        KASE = 0#
        Do
            Call CMatrixEstimateNorm(N, CWORK4, EX, ANORM, KASE, ISAVE, RSAVE)
            If KASE <> 0# Then
                If KASE = KASE1 Then
                    '
                    ' Multiply by U
                    '
                    For i = 1# To N Step 1
                        i1_ = (i) - (i - 1#)
                        V = C_Complex(0#)
                        For i_ = i - 1# To N - 1# Step 1
                            V = C_Add(V, C_Mul(LUA(i - 1#, i_), EX(i_ + i1_)))
                        Next i_
                        EX(i) = V
                    Next i
                    '
                    ' Multiply by L
                    '
                    For i = N To 1# Step -1
                        V = C_Complex(0#)
                        If i > 1# Then
                            i1_ = (1#) - (0#)
                            V = C_Complex(0#)
                            For i_ = 0# To i - 2# Step 1
                                V = C_Add(V, C_Mul(LUA(i - 1#, i_), EX(i_ + i1_)))
                            Next i_
                        End If
                        EX(i) = C_Add(V, EX(i))
                    Next i
                Else
                    '
                    ' Multiply by L'
                    '
                    For i = 1# To N Step 1
                        CWORK2(i) = C_Complex(0#)
                    Next i
                    For i = 1# To N Step 1
                        V = EX(i)
                        If i > 1# Then
                            i1_ = (0#) - (1#)
                            For i_ = 1# To i - 1# Step 1
                                CWORK2(i_) = C_Add(CWORK2(i_), C_Mul(V, Conj(LUA(i - 1#, i_ + i1_))))
                            Next i_
                        End If
                        CWORK2(i) = C_Add(CWORK2(i), V)
                    Next i
                    '
                    ' Multiply by U'
                    '
                    For i = 1# To N Step 1
                        EX(i) = C_Complex(0#)
                    Next i
                    For i = 1# To N Step 1
                        V = CWORK2(i)
                        i1_ = (i - 1#) - (i)
                        For i_ = i To N Step 1
                            EX(i_) = C_Add(EX(i_), C_Mul(V, Conj(LUA(i - 1#, i_ + i1_))))
                        Next i_
                    Next i
                End If
            End If
        Loop Until KASE = 0#
    End If
    '
    ' Scale according to SU/SL
    '
    ANORM = ANORM * SU * SL
    '
    ' Quick return if possible
    '
    If ANORM = 0# Then
        Exit Sub
    End If
    '
    ' Estimate the norm of inv(A).
    '
    AINVNM = 0#
    If OneNorm Then
        KASE1 = 1#
    Else
        KASE1 = 2#
    End If
    KASE = 0#
    Do While True
        Call CMatrixEstimateNorm(N, CWORK4, EX, AINVNM, KASE, ISAVE, RSAVE)
        If KASE = 0# Then
            Exit Do
        End If
        '
        ' From 1-based to 0-based
        '
        For i = 0# To N - 1# Step 1
            EX(i) = EX(i + 1#)
        Next i
        '
        ' multiply by inv(A) or inv(A')
        '
        If KASE = KASE1 Then
            '
            ' Multiply by inv(L).
            '
            If Not CMatrixScaledTRSafeSolve(LUA, SL, N, EX, False, 0#, True, MaxGrowth) Then
                RC = 0#
                Exit Sub
            End If
            '
            ' Multiply by inv(U).
            '
            If Not CMatrixScaledTRSafeSolve(LUA, SU, N, EX, True, 0#, False, MaxGrowth) Then
                RC = 0#
                Exit Sub
            End If
        Else
            '
            ' Multiply by inv(U').
            '
            If Not CMatrixScaledTRSafeSolve(LUA, SU, N, EX, True, 2#, False, MaxGrowth) Then
                RC = 0#
                Exit Sub
            End If
            '
            ' Multiply by inv(L').
            '
            If Not CMatrixScaledTRSafeSolve(LUA, SL, N, EX, False, 2#, True, MaxGrowth) Then
                RC = 0#
                Exit Sub
            End If
        End If
        '
        ' from 0-based to 1-based
        '
        For i = N - 1# To 0# Step -1
            EX(i + 1#) = EX(i)
        Next i
    Loop
    '
    ' Compute the estimate of the reciprocal condition number.
    '
    If AINVNM <> 0# Then
        RC = 1# / AINVNM
        RC = RC / ANORM
        If RC < RCondThreshold() Then
            RC = 0#
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal subroutine for matrix norm estimation
'
'  -- LAPACK auxiliary routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     February 29, 1992
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub RMatrixEstimateNorm(ByVal N As Long, _
         ByRef V() As Double, _
         ByRef x() As Double, _
         ByRef ISGN() As Long, _
         ByRef EST As Double, _
         ByRef KASE As Long)
    Dim ITMAX As Long
    Dim i As Long
    Dim t As Double
    Dim Flg As Boolean
    Dim PosITER As Long
    Dim PosJ As Long
    Dim PosJLAST As Long
    Dim PosJUMP As Long
    Dim PosALTSGN As Long
    Dim PosESTOLD As Long
    Dim PosTEMP As Long
    Dim i_ As Long
    ITMAX = 5#
    PosALTSGN = N + 1#
    PosESTOLD = N + 2#
    PosTEMP = N + 3#
    PosITER = N + 1#
    PosJ = N + 2#
    PosJLAST = N + 3#
    PosJUMP = N + 4#
    If KASE = 0# Then
        ReDim V(0 To N + 4# - 1)
        ReDim x(0 To N + 1# - 1)
        ReDim ISGN(0 To N + 5# - 1)
        t = 1# / N
        For i = 1# To N Step 1
            x(i) = t
        Next i
        KASE = 1#
        ISGN(PosJUMP) = 1#
        Exit Sub
    End If
    '
    '     ................ ENTRY   (JUMP = 1)
    '     FIRST ITERATION.  X HAS BEEN OVERWRITTEN BY A*X.
    '
    If ISGN(PosJUMP) = 1# Then
        If N = 1# Then
            V(1#) = x(1#)
            EST = Abs(V(1#))
            KASE = 0#
            Exit Sub
        End If
        EST = 0#
        For i = 1# To N Step 1
            EST = EST + Abs(x(i))
        Next i
        For i = 1# To N Step 1
            If x(i) >= 0# Then
                x(i) = 1#
            Else
                x(i) = -1#
            End If
            ISGN(i) = Sgn(x(i))
        Next i
        KASE = 2#
        ISGN(PosJUMP) = 2#
        Exit Sub
    End If
    '
    '     ................ ENTRY   (JUMP = 2)
    '     FIRST ITERATION.  X HAS BEEN OVERWRITTEN BY TRANDPOSE(A)*X.
    '
    If ISGN(PosJUMP) = 2# Then
        ISGN(PosJ) = 1#
        For i = 2# To N Step 1
            If Abs(x(i)) > Abs(x(ISGN(PosJ))) Then
                ISGN(PosJ) = i
            End If
        Next i
        ISGN(PosITER) = 2#
        '
        ' MAIN LOOP - ITERATIONS 2,3,...,ITMAX.
        '
        For i = 1# To N Step 1
            x(i) = 0#
        Next i
        x(ISGN(PosJ)) = 1#
        KASE = 1#
        ISGN(PosJUMP) = 3#
        Exit Sub
    End If
    '
    '     ................ ENTRY   (JUMP = 3)
    '     X HAS BEEN OVERWRITTEN BY A*X.
    '
    If ISGN(PosJUMP) = 3# Then
        For i_ = 1# To N Step 1
            V(i_) = x(i_)
        Next i_
        V(PosESTOLD) = EST
        EST = 0#
        For i = 1# To N Step 1
            EST = EST + Abs(V(i))
        Next i
        Flg = False
        For i = 1# To N Step 1
            If x(i) >= 0# And ISGN(i) < 0# Or x(i) < 0# And ISGN(i) >= 0# Then
                Flg = True
            End If
        Next i
        '
        ' REPEATED SIGN VECTOR DETECTED, HENCE ALGORITHM HAS CONVERGED.
        ' OR MAY BE CYCLING.
        '
        If Not Flg Or EST <= V(PosESTOLD) Then
            V(PosALTSGN) = 1#
            For i = 1# To N Step 1
                x(i) = V(PosALTSGN) * (1# + (i - 1#) / (N - 1#))
                V(PosALTSGN) = -V(PosALTSGN)
            Next i
            KASE = 1#
            ISGN(PosJUMP) = 5#
            Exit Sub
        End If
        For i = 1# To N Step 1
            If x(i) >= 0# Then
                x(i) = 1#
                ISGN(i) = 1#
            Else
                x(i) = -1#
                ISGN(i) = -1#
            End If
        Next i
        KASE = 2#
        ISGN(PosJUMP) = 4#
        Exit Sub
    End If
    '
    '     ................ ENTRY   (JUMP = 4)
    '     X HAS BEEN OVERWRITTEN BY TRANDPOSE(A)*X.
    '
    If ISGN(PosJUMP) = 4# Then
        ISGN(PosJLAST) = ISGN(PosJ)
        ISGN(PosJ) = 1#
        For i = 2# To N Step 1
            If Abs(x(i)) > Abs(x(ISGN(PosJ))) Then
                ISGN(PosJ) = i
            End If
        Next i
        If x(ISGN(PosJLAST)) <> Abs(x(ISGN(PosJ))) And ISGN(PosITER) < ITMAX Then
            ISGN(PosITER) = ISGN(PosITER) + 1#
            For i = 1# To N Step 1
                x(i) = 0#
            Next i
            x(ISGN(PosJ)) = 1#
            KASE = 1#
            ISGN(PosJUMP) = 3#
            Exit Sub
        End If
        '
        ' ITERATION COMPLETE.  FINAL STAGE.
        '
        V(PosALTSGN) = 1#
        For i = 1# To N Step 1
            x(i) = V(PosALTSGN) * (1# + (i - 1#) / (N - 1#))
            V(PosALTSGN) = -V(PosALTSGN)
        Next i
        KASE = 1#
        ISGN(PosJUMP) = 5#
        Exit Sub
    End If
    '
    '     ................ ENTRY   (JUMP = 5)
    '     X HAS BEEN OVERWRITTEN BY A*X.
    '
    If ISGN(PosJUMP) = 5# Then
        V(PosTEMP) = 0#
        For i = 1# To N Step 1
            V(PosTEMP) = V(PosTEMP) + Abs(x(i))
        Next i
        V(PosTEMP) = 2# * V(PosTEMP) / (3# * N)
        If V(PosTEMP) > EST Then
            For i_ = 1# To N Step 1
                V(i_) = x(i_)
            Next i_
            EST = V(PosTEMP)
        End If
        KASE = 0#
        Exit Sub
    End If
End Sub
Private Sub CMatrixEstimateNorm(ByRef N As Long, _
         ByRef V() As Complex, _
         ByRef x() As Complex, _
         ByRef EST As Double, _
         ByRef KASE As Long, _
         ByRef ISAVE() As Long, _
         ByRef RSAVE() As Double)
    Dim ITMAX As Long
    Dim i As Long
    Dim ITER As Long
    Dim j As Long
    Dim JLAST As Long
    Dim JUMP As Long
    Dim ABSXI As Double
    Dim ALTSGN As Double
    Dim ESTOLD As Double
    Dim SAFMIN As Double
    Dim temp As Double
    Dim i_ As Long
    '
    'Executable Statements ..
    '
    ITMAX = 5#
    SAFMIN = MinRealNumber
    If KASE = 0# Then
        ReDim V(0 To N + 1# - 1)
        ReDim x(0 To N + 1# - 1)
        ReDim ISAVE(0 To 5# - 1)
        ReDim RSAVE(0 To 4# - 1)
        For i = 1# To N Step 1
            x(i) = C_Complex(1# / N)
        Next i
        KASE = 1#
        JUMP = 1#
        Call InternalComplexRCondSaveAll(ISAVE, RSAVE, i, ITER, j, JLAST, JUMP, ABSXI, ALTSGN, ESTOLD, temp)
        Exit Sub
    End If
    Call InternalComplexRCondLoadAll(ISAVE, RSAVE, i, ITER, j, JLAST, JUMP, ABSXI, ALTSGN, ESTOLD, temp)
    '
    ' ENTRY   (JUMP = 1)
    ' FIRST ITERATION.  X HAS BEEN OVERWRITTEN BY A*X.
    '
    If JUMP = 1# Then
        If N = 1# Then
            V(1#) = x(1#)
            EST = AbsComplex(V(1#))
            KASE = 0#
            Call InternalComplexRCondSaveAll(ISAVE, RSAVE, i, ITER, j, JLAST, JUMP, ABSXI, ALTSGN, ESTOLD, temp)
            Exit Sub
        End If
        EST = InternalComplexRCondSCSUM1(x, N)
        For i = 1# To N Step 1
            ABSXI = AbsComplex(x(i))
            If ABSXI > SAFMIN Then
                x(i) = C_DivR(x(i), ABSXI)
            Else
                x(i) = C_Complex(1#)
            End If
        Next i
        KASE = 2#
        JUMP = 2#
        Call InternalComplexRCondSaveAll(ISAVE, RSAVE, i, ITER, j, JLAST, JUMP, ABSXI, ALTSGN, ESTOLD, temp)
        Exit Sub
    End If
    '
    ' ENTRY   (JUMP = 2)
    ' FIRST ITERATION.  X HAS BEEN OVERWRITTEN BY CTRANS(A)*X.
    '
    If JUMP = 2# Then
        j = InternalComplexRCondICMAX1(x, N)
        ITER = 2#
        '
        ' MAIN LOOP - ITERATIONS 2,3,...,ITMAX.
        '
        For i = 1# To N Step 1
            x(i) = C_Complex(0#)
        Next i
        x(j) = C_Complex(1#)
        KASE = 1#
        JUMP = 3#
        Call InternalComplexRCondSaveAll(ISAVE, RSAVE, i, ITER, j, JLAST, JUMP, ABSXI, ALTSGN, ESTOLD, temp)
        Exit Sub
    End If
    '
    ' ENTRY   (JUMP = 3)
    ' X HAS BEEN OVERWRITTEN BY A*X.
    '
    If JUMP = 3# Then
        For i_ = 1# To N Step 1
            V(i_) = x(i_)
        Next i_
        ESTOLD = EST
        EST = InternalComplexRCondSCSUM1(V, N)
        '
        ' TEST FOR CYCLING.
        '
        If EST <= ESTOLD Then
            '
            ' ITERATION COMPLETE.  FINAL STAGE.
            '
            ALTSGN = 1#
            For i = 1# To N Step 1
                x(i) = C_Complex(ALTSGN * (1# + (i - 1#) / (N - 1#)))
                ALTSGN = -ALTSGN
            Next i
            KASE = 1#
            JUMP = 5#
            Call InternalComplexRCondSaveAll(ISAVE, RSAVE, i, ITER, j, JLAST, JUMP, ABSXI, ALTSGN, ESTOLD, temp)
            Exit Sub
        End If
        For i = 1# To N Step 1
            ABSXI = AbsComplex(x(i))
            If ABSXI > SAFMIN Then
                x(i) = C_DivR(x(i), ABSXI)
            Else
                x(i) = C_Complex(1#)
            End If
        Next i
        KASE = 2#
        JUMP = 4#
        Call InternalComplexRCondSaveAll(ISAVE, RSAVE, i, ITER, j, JLAST, JUMP, ABSXI, ALTSGN, ESTOLD, temp)
        Exit Sub
    End If
    '
    ' ENTRY   (JUMP = 4)
    ' X HAS BEEN OVERWRITTEN BY CTRANS(A)*X.
    '
    If JUMP = 4# Then
        JLAST = j
        j = InternalComplexRCondICMAX1(x, N)
        If AbsComplex(x(JLAST)) <> AbsComplex(x(j)) And ITER < ITMAX Then
            ITER = ITER + 1#
            '
            ' MAIN LOOP - ITERATIONS 2,3,...,ITMAX.
            '
            For i = 1# To N Step 1
                x(i) = C_Complex(0#)
            Next i
            x(j) = C_Complex(1#)
            KASE = 1#
            JUMP = 3#
            Call InternalComplexRCondSaveAll(ISAVE, RSAVE, i, ITER, j, JLAST, JUMP, ABSXI, ALTSGN, ESTOLD, temp)
            Exit Sub
        End If
        '
        ' ITERATION COMPLETE.  FINAL STAGE.
        '
        ALTSGN = 1#
        For i = 1# To N Step 1
            x(i) = C_Complex(ALTSGN * (1# + (i - 1#) / (N - 1#)))
            ALTSGN = -ALTSGN
        Next i
        KASE = 1#
        JUMP = 5#
        Call InternalComplexRCondSaveAll(ISAVE, RSAVE, i, ITER, j, JLAST, JUMP, ABSXI, ALTSGN, ESTOLD, temp)
        Exit Sub
    End If
    '
    ' ENTRY   (JUMP = 5)
    ' X HAS BEEN OVERWRITTEN BY A*X.
    '
    If JUMP = 5# Then
        temp = 2# * (InternalComplexRCondSCSUM1(x, N) / (3# * N))
        If temp > EST Then
            For i_ = 1# To N Step 1
                V(i_) = x(i_)
            Next i_
            EST = temp
        End If
        KASE = 0#
        Call InternalComplexRCondSaveAll(ISAVE, RSAVE, i, ITER, j, JLAST, JUMP, ABSXI, ALTSGN, ESTOLD, temp)
        Exit Sub
    End If
End Sub
Private Function InternalComplexRCondSCSUM1(ByRef x() As Complex, _
         ByVal N As Long) As Double
    Dim Result As Double
    Dim i As Long
    Result = 0#
    For i = 1# To N Step 1
        Result = Result + AbsComplex(x(i))
    Next i
    InternalComplexRCondSCSUM1 = Result
End Function
Private Function InternalComplexRCondICMAX1(ByRef x() As Complex, _
         ByVal N As Long) As Long
    Dim Result As Long
    Dim i As Long
    Dim M As Double
    Result = 1#
    M = AbsComplex(x(1#))
    For i = 2# To N Step 1
        If AbsComplex(x(i)) > M Then
            Result = i
            M = AbsComplex(x(i))
        End If
    Next i
    InternalComplexRCondICMAX1 = Result
End Function
Private Sub InternalComplexRCondSaveAll(ByRef ISAVE() As Long, _
         ByRef RSAVE() As Double, _
         ByRef i As Long, _
         ByRef ITER As Long, _
         ByRef j As Long, _
         ByRef JLAST As Long, _
         ByRef JUMP As Long, _
         ByRef ABSXI As Double, _
         ByRef ALTSGN As Double, _
         ByRef ESTOLD As Double, _
         ByRef temp As Double)
    ISAVE(0#) = i
    ISAVE(1#) = ITER
    ISAVE(2#) = j
    ISAVE(3#) = JLAST
    ISAVE(4#) = JUMP
    RSAVE(0#) = ABSXI
    RSAVE(1#) = ALTSGN
    RSAVE(2#) = ESTOLD
    RSAVE(3#) = temp
End Sub
Private Sub InternalComplexRCondLoadAll(ByRef ISAVE() As Long, _
         ByRef RSAVE() As Double, _
         ByRef i As Long, _
         ByRef ITER As Long, _
         ByRef j As Long, _
         ByRef JLAST As Long, _
         ByRef JUMP As Long, _
         ByRef ABSXI As Double, _
         ByRef ALTSGN As Double, _
         ByRef ESTOLD As Double, _
         ByRef temp As Double)
    i = ISAVE(0#)
    ITER = ISAVE(1#)
    j = ISAVE(2#)
    JLAST = ISAVE(3#)
    JUMP = ISAVE(4#)
    ABSXI = RSAVE(0#)
    ALTSGN = RSAVE(1#)
    ESTOLD = RSAVE(2#)
    temp = RSAVE(3#)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2005-2010 Sergey Bochkanov.
'
'Additional copyrights:
'    1992-2007 The University of Tennessee (as indicated in subroutines
'    comments).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'QR decomposition of a rectangular matrix of size MxN
'
'Input parameters:
'    A   -   matrix A whose indexes range within [0..M-1, 0..N-1].
'    M   -   number of rows in matrix A.
'    N   -   number of columns in matrix A.
'
'Output parameters:
'    A   -   matrices Q and R in compact form (see below).
'    Tau -   array of scalar factors which are used to form
'            matrix Q. Array whose index ranges within [0.. Min(M-1,N-1)].
'
'Matrix A is represented as A = QR, where Q is an orthogonal matrix of size
'MxM, R - upper triangular (or upper trapezoid) matrix of size M x N.
'
'The elements of matrix R are located on and above the main diagonal of
'matrix A. The elements which are located in Tau array and below the main
'diagonal of matrix A are used to form matrix Q as follows:
'
'Matrix Q is represented as a product of elementary reflections
'
'Q = H(0)*H(2)*...*H(k-1),
'
'where k = min(m,n), and each H(i) is in the form
'
'H(i) = 1 - tau * v * (v^T)
'
'where tau is a scalar stored in Tau[I]; v - real vector,
'so that v(0:i-1) = 0, v(i) = 1, v(i+1:m-1) stored in A(i+1:m-1,i).
'
'  -- ALGLIB routine --
'     17.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixQR(ByRef a() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Tau() As Double)
    Dim WORK() As Double
    Dim t() As Double
    Dim TauBuf() As Double
    Dim MinMN As Long
    Dim TmpA() As Double
    Dim TmpT() As Double
    Dim TmpR() As Double
    Dim BlockStart As Long
    Dim BlockSize As Long
    Dim RowsCount As Long
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim V As Double
    Dim i_ As Long
    Dim i1_ As Long
    If M <= 0# Or N <= 0# Then
        Exit Sub
    End If
    MinMN = MinInt(M, N)
    ReDim WORK(0 To MaxInt(M, N) + 1# - 1)
    ReDim t(0 To MaxInt(M, N) + 1# - 1)
    ReDim Tau(0 To MinMN - 1)
    ReDim TauBuf(0 To MinMN - 1)
    ReDim TmpA(0 To M - 1, 0 To ABLASBlockSize(a) - 1)
    ReDim TmpT(0 To ABLASBlockSize(a) - 1, 0 To 2# * ABLASBlockSize(a) - 1)
    ReDim TmpR(0 To 2# * ABLASBlockSize(a) - 1, 0 To N - 1)
    
    '
    ' Blocked code
    '
    BlockStart = 0#
    Do While BlockStart <> MinMN
        
        '
        ' Determine block size
        '
        BlockSize = MinMN - BlockStart
        If BlockSize > ABLASBlockSize(a) Then
            BlockSize = ABLASBlockSize(a)
        End If
        RowsCount = M - BlockStart
        
        '
        ' QR decomposition of submatrix.
        ' Matrix is copied to temporary storage to solve
        ' some TLB issues arising from non-contiguous memory
        ' access pattern.
        '
        Call RMatrixCopy(RowsCount, BlockSize, a, BlockStart, BlockStart, TmpA, 0#, 0#)
        Call RMatrixQRBaseCase(TmpA, RowsCount, BlockSize, WORK, t, TauBuf)
        Call RMatrixCopy(RowsCount, BlockSize, TmpA, 0#, 0#, a, BlockStart, BlockStart)
        i1_ = (0#) - (BlockStart)
        For i_ = BlockStart To BlockStart + BlockSize - 1# Step 1
            Tau(i_) = TauBuf(i_ + i1_)
        Next i_
        
        '
        ' Update the rest, choose between:
        ' a) Level 2 algorithm (when the rest of the matrix is small enough)
        ' b) blocked algorithm, see algorithm 5 from  'A storage efficient WY
        '    representation for products of Householder transformations',
        '    by R. Schreiber and C. Van Loan.
        '
        If BlockStart + BlockSize <= N - 1# Then
            If N - BlockStart - BlockSize >= 2# * ABLASBlockSize(a) Or RowsCount >= 4# * ABLASBlockSize(a) Then
                
                '
                ' Prepare block reflector
                '
                Call RMatrixBlockReflector(TmpA, TauBuf, True, RowsCount, BlockSize, TmpT, WORK)
                
                '
                ' Multiply the rest of A by Q'.
                '
                ' Q  = E + Y*T*Y'  = E + TmpA*TmpT*TmpA'
                ' Q' = E + Y*T'*Y' = E + TmpA*TmpT'*TmpA'
                '
                Call RMatrixGEMM(BlockSize, N - BlockStart - BlockSize, RowsCount, 1#, TmpA, 0#, 0#, 1#, a, BlockStart, BlockStart + BlockSize, 0#, 0#, TmpR, 0#, 0#)
                Call RMatrixGEMM(BlockSize, N - BlockStart - BlockSize, BlockSize, 1#, TmpT, 0#, 0#, 1#, TmpR, 0#, 0#, 0#, 0#, TmpR, BlockSize, 0#)
                Call RMatrixGEMM(RowsCount, N - BlockStart - BlockSize, BlockSize, 1#, TmpA, 0#, 0#, 0#, TmpR, BlockSize, 0#, 0#, 1#, a, BlockStart, BlockStart + BlockSize)
            Else
                
                '
                ' Level 2 algorithm
                '
                For i = 0# To BlockSize - 1# Step 1
                    i1_ = (i) - (1#)
                    For i_ = 1# To RowsCount - i Step 1
                        t(i_) = TmpA(i_ + i1_, i)
                    Next i_
                    t(1#) = 1#
                    Call ApplyReflectionFromTheLeft(a, TauBuf(i), t, BlockStart + i, M - 1#, BlockStart + BlockSize, N - 1#, WORK)
                Next i
            End If
        End If
        
        '
        ' Advance
        '
        BlockStart = BlockStart + BlockSize
    Loop
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'LQ decomposition of a rectangular matrix of size MxN
'
'Input parameters:
'    A   -   matrix A whose indexes range within [0..M-1, 0..N-1].
'    M   -   number of rows in matrix A.
'    N   -   number of columns in matrix A.
'
'Output parameters:
'    A   -   matrices L and Q in compact form (see below)
'    Tau -   array of scalar factors which are used to form
'            matrix Q. Array whose index ranges within [0..Min(M,N)-1].
'
'Matrix A is represented as A = LQ, where Q is an orthogonal matrix of size
'MxM, L - lower triangular (or lower trapezoid) matrix of size M x N.
'
'The elements of matrix L are located on and below  the  main  diagonal  of
'matrix A. The elements which are located in Tau array and above  the  main
'diagonal of matrix A are used to form matrix Q as follows:
'
'Matrix Q is represented as a product of elementary reflections
'
'Q = H(k-1)*H(k-2)*...*H(1)*H(0),
'
'where k = min(m,n), and each H(i) is of the form
'
'H(i) = 1 - tau * v * (v^T)
'
'where tau is a scalar stored in Tau[I]; v - real vector, so that v(0:i-1)=0,
'v(i) = 1, v(i+1:n-1) stored in A(i,i+1:n-1).
'
'  -- ALGLIB routine --
'     17.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixLQ(ByRef a() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Tau() As Double)
    Dim WORK() As Double
    Dim t() As Double
    Dim TauBuf() As Double
    Dim MinMN As Long
    Dim TmpA() As Double
    Dim TmpT() As Double
    Dim TmpR() As Double
    Dim BlockStart As Long
    Dim BlockSize As Long
    Dim ColumnsCount As Long
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim V As Double
    Dim i_ As Long
    Dim i1_ As Long
    If M <= 0# Or N <= 0# Then
        Exit Sub
    End If
    MinMN = MinInt(M, N)
    ReDim WORK(0 To MaxInt(M, N) + 1# - 1)
    ReDim t(0 To MaxInt(M, N) + 1# - 1)
    ReDim Tau(0 To MinMN - 1)
    ReDim TauBuf(0 To MinMN - 1)
    ReDim TmpA(0 To ABLASBlockSize(a) - 1, 0 To N - 1)
    ReDim TmpT(0 To ABLASBlockSize(a) - 1, 0 To 2# * ABLASBlockSize(a) - 1)
    ReDim TmpR(0 To M - 1, 0 To 2# * ABLASBlockSize(a) - 1)
    
    '
    ' Blocked code
    '
    BlockStart = 0#
    Do While BlockStart <> MinMN
        
        '
        ' Determine block size
        '
        BlockSize = MinMN - BlockStart
        If BlockSize > ABLASBlockSize(a) Then
            BlockSize = ABLASBlockSize(a)
        End If
        ColumnsCount = N - BlockStart
        
        '
        ' LQ decomposition of submatrix.
        ' Matrix is copied to temporary storage to solve
        ' some TLB issues arising from non-contiguous memory
        ' access pattern.
        '
        Call RMatrixCopy(BlockSize, ColumnsCount, a, BlockStart, BlockStart, TmpA, 0#, 0#)
        Call RMatrixLQBaseCase(TmpA, BlockSize, ColumnsCount, WORK, t, TauBuf)
        Call RMatrixCopy(BlockSize, ColumnsCount, TmpA, 0#, 0#, a, BlockStart, BlockStart)
        i1_ = (0#) - (BlockStart)
        For i_ = BlockStart To BlockStart + BlockSize - 1# Step 1
            Tau(i_) = TauBuf(i_ + i1_)
        Next i_
        
        '
        ' Update the rest, choose between:
        ' a) Level 2 algorithm (when the rest of the matrix is small enough)
        ' b) blocked algorithm, see algorithm 5 from  'A storage efficient WY
        '    representation for products of Householder transformations',
        '    by R. Schreiber and C. Van Loan.
        '
        If BlockStart + BlockSize <= M - 1# Then
            If M - BlockStart - BlockSize >= 2# * ABLASBlockSize(a) Then
                
                '
                ' Prepare block reflector
                '
                Call RMatrixBlockReflector(TmpA, TauBuf, False, ColumnsCount, BlockSize, TmpT, WORK)
                
                '
                ' Multiply the rest of A by Q.
                '
                ' Q  = E + Y*T*Y'  = E + TmpA'*TmpT*TmpA
                '
                Call RMatrixGEMM(M - BlockStart - BlockSize, BlockSize, ColumnsCount, 1#, a, BlockStart + BlockSize, BlockStart, 0#, TmpA, 0#, 0#, 1#, 0#, TmpR, 0#, 0#)
                Call RMatrixGEMM(M - BlockStart - BlockSize, BlockSize, BlockSize, 1#, TmpR, 0#, 0#, 0#, TmpT, 0#, 0#, 0#, 0#, TmpR, 0#, BlockSize)
                Call RMatrixGEMM(M - BlockStart - BlockSize, ColumnsCount, BlockSize, 1#, TmpR, 0#, BlockSize, 0#, TmpA, 0#, 0#, 0#, 1#, a, BlockStart + BlockSize, BlockStart)
            Else
                
                '
                ' Level 2 algorithm
                '
                For i = 0# To BlockSize - 1# Step 1
                    i1_ = (i) - (1#)
                    For i_ = 1# To ColumnsCount - i Step 1
                        t(i_) = TmpA(i, i_ + i1_)
                    Next i_
                    t(1#) = 1#
                    Call ApplyReflectionFromTheRight(a, TauBuf(i), t, BlockStart + BlockSize, M - 1#, BlockStart + i, N - 1#, WORK)
                Next i
            End If
        End If
        
        '
        ' Advance
        '
        BlockStart = BlockStart + BlockSize
    Loop
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'QR decomposition of a rectangular complex matrix of size MxN
'
'Input parameters:
'    A   -   matrix A whose indexes range within [0..M-1, 0..N-1]
'    M   -   number of rows in matrix A.
'    N   -   number of columns in matrix A.
'
'Output parameters:
'    A   -   matrices Q and R in compact form
'    Tau -   array of scalar factors which are used to form matrix Q. Array
'            whose indexes range within [0.. Min(M,N)-1]
'
'Matrix A is represented as A = QR, where Q is an orthogonal matrix of size
'MxM, R - upper triangular (or upper trapezoid) matrix of size MxN.
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     September 30, 1994
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixQR(ByRef a() As Complex, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Tau() As Complex)
    Dim WORK() As Complex
    Dim t() As Complex
    Dim TauBuf() As Complex
    Dim MinMN As Long
    Dim TmpA() As Complex
    Dim TmpT() As Complex
    Dim TmpR() As Complex
    Dim BlockStart As Long
    Dim BlockSize As Long
    Dim RowsCount As Long
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim V As Complex
    Dim i_ As Long
    Dim i1_ As Long
    If M <= 0# Or N <= 0# Then
        Exit Sub
    End If
    MinMN = MinInt(M, N)
    ReDim WORK(0 To MaxInt(M, N) + 1# - 1)
    ReDim t(0 To MaxInt(M, N) + 1# - 1)
    ReDim Tau(0 To MinMN - 1)
    ReDim TauBuf(0 To MinMN - 1)
    ReDim TmpA(0 To M - 1, 0 To ABLASComplexBlockSize(a) - 1)
    ReDim TmpT(0 To ABLASComplexBlockSize(a) - 1, 0 To ABLASComplexBlockSize(a) - 1)
    ReDim TmpR(0 To 2# * ABLASComplexBlockSize(a) - 1, 0 To N - 1)
    
    '
    ' Blocked code
    '
    BlockStart = 0#
    Do While BlockStart <> MinMN
        
        '
        ' Determine block size
        '
        BlockSize = MinMN - BlockStart
        If BlockSize > ABLASComplexBlockSize(a) Then
            BlockSize = ABLASComplexBlockSize(a)
        End If
        RowsCount = M - BlockStart
        
        '
        ' QR decomposition of submatrix.
        ' Matrix is copied to temporary storage to solve
        ' some TLB issues arising from non-contiguous memory
        ' access pattern.
        '
        Call CMatrixCopy(RowsCount, BlockSize, a, BlockStart, BlockStart, TmpA, 0#, 0#)
        Call CMatrixQRBaseCase(TmpA, RowsCount, BlockSize, WORK, t, TauBuf)
        Call CMatrixCopy(RowsCount, BlockSize, TmpA, 0#, 0#, a, BlockStart, BlockStart)
        i1_ = (0#) - (BlockStart)
        For i_ = BlockStart To BlockStart + BlockSize - 1# Step 1
            Tau(i_) = TauBuf(i_ + i1_)
        Next i_
        
        '
        ' Update the rest, choose between:
        ' a) Level 2 algorithm (when the rest of the matrix is small enough)
        ' b) blocked algorithm, see algorithm 5 from  'A storage efficient WY
        '    representation for products of Householder transformations',
        '    by R. Schreiber and C. Van Loan.
        '
        If BlockStart + BlockSize <= N - 1# Then
            If N - BlockStart - BlockSize >= 2# * ABLASComplexBlockSize(a) Then
                
                '
                ' Prepare block reflector
                '
                Call CMatrixBlockReflector(TmpA, TauBuf, True, RowsCount, BlockSize, TmpT, WORK)
                
                '
                ' Multiply the rest of A by Q'.
                '
                ' Q  = E + Y*T*Y'  = E + TmpA*TmpT*TmpA'
                ' Q' = E + Y*T'*Y' = E + TmpA*TmpT'*TmpA'
                '
                Call CMatrixGEMM(BlockSize, N - BlockStart - BlockSize, RowsCount, C_Complex(1#), TmpA, 0#, 0#, 2#, a, BlockStart, BlockStart + BlockSize, 0#, C_Complex(0#), TmpR, 0#, 0#)
                Call CMatrixGEMM(BlockSize, N - BlockStart - BlockSize, BlockSize, C_Complex(1#), TmpT, 0#, 0#, 2#, TmpR, 0#, 0#, 0#, C_Complex(0#), TmpR, BlockSize, 0#)
                Call CMatrixGEMM(RowsCount, N - BlockStart - BlockSize, BlockSize, C_Complex(1#), TmpA, 0#, 0#, 0#, TmpR, BlockSize, 0#, 0#, C_Complex(1#), a, BlockStart, BlockStart + BlockSize)
            Else
                
                '
                ' Level 2 algorithm
                '
                For i = 0# To BlockSize - 1# Step 1
                    i1_ = (i) - (1#)
                    For i_ = 1# To RowsCount - i Step 1
                        t(i_) = TmpA(i_ + i1_, i)
                    Next i_
                    t(1#) = C_Complex(1#)
                    Call ComplexApplyReflectionFromTheLeft(a, Conj(TauBuf(i)), t, BlockStart + i, M - 1#, BlockStart + BlockSize, N - 1#, WORK)
                Next i
            End If
        End If
        
        '
        ' Advance
        '
        BlockStart = BlockStart + BlockSize
    Loop
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'LQ decomposition of a rectangular complex matrix of size MxN
'
'Input parameters:
'    A   -   matrix A whose indexes range within [0..M-1, 0..N-1]
'    M   -   number of rows in matrix A.
'    N   -   number of columns in matrix A.
'
'Output parameters:
'    A   -   matrices Q and L in compact form
'    Tau -   array of scalar factors which are used to form matrix Q. Array
'            whose indexes range within [0.. Min(M,N)-1]
'
'Matrix A is represented as A = LQ, where Q is an orthogonal matrix of size
'MxM, L - lower triangular (or lower trapezoid) matrix of size MxN.
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     September 30, 1994
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixLQ(ByRef a() As Complex, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Tau() As Complex)
    Dim WORK() As Complex
    Dim t() As Complex
    Dim TauBuf() As Complex
    Dim MinMN As Long
    Dim TmpA() As Complex
    Dim TmpT() As Complex
    Dim TmpR() As Complex
    Dim BlockStart As Long
    Dim BlockSize As Long
    Dim ColumnsCount As Long
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim V As Complex
    Dim i_ As Long
    Dim i1_ As Long
    If M <= 0# Or N <= 0# Then
        Exit Sub
    End If
    MinMN = MinInt(M, N)
    ReDim WORK(0 To MaxInt(M, N) + 1# - 1)
    ReDim t(0 To MaxInt(M, N) + 1# - 1)
    ReDim Tau(0 To MinMN - 1)
    ReDim TauBuf(0 To MinMN - 1)
    ReDim TmpA(0 To ABLASComplexBlockSize(a) - 1, 0 To N - 1)
    ReDim TmpT(0 To ABLASComplexBlockSize(a) - 1, 0 To ABLASComplexBlockSize(a) - 1)
    ReDim TmpR(0 To M - 1, 0 To 2# * ABLASComplexBlockSize(a) - 1)
    
    '
    ' Blocked code
    '
    BlockStart = 0#
    Do While BlockStart <> MinMN
        
        '
        ' Determine block size
        '
        BlockSize = MinMN - BlockStart
        If BlockSize > ABLASComplexBlockSize(a) Then
            BlockSize = ABLASComplexBlockSize(a)
        End If
        ColumnsCount = N - BlockStart
        
        '
        ' LQ decomposition of submatrix.
        ' Matrix is copied to temporary storage to solve
        ' some TLB issues arising from non-contiguous memory
        ' access pattern.
        '
        Call CMatrixCopy(BlockSize, ColumnsCount, a, BlockStart, BlockStart, TmpA, 0#, 0#)
        Call CMatrixLQBaseCase(TmpA, BlockSize, ColumnsCount, WORK, t, TauBuf)
        Call CMatrixCopy(BlockSize, ColumnsCount, TmpA, 0#, 0#, a, BlockStart, BlockStart)
        i1_ = (0#) - (BlockStart)
        For i_ = BlockStart To BlockStart + BlockSize - 1# Step 1
            Tau(i_) = TauBuf(i_ + i1_)
        Next i_
        
        '
        ' Update the rest, choose between:
        ' a) Level 2 algorithm (when the rest of the matrix is small enough)
        ' b) blocked algorithm, see algorithm 5 from  'A storage efficient WY
        '    representation for products of Householder transformations',
        '    by R. Schreiber and C. Van Loan.
        '
        If BlockStart + BlockSize <= M - 1# Then
            If M - BlockStart - BlockSize >= 2# * ABLASComplexBlockSize(a) Then
                
                '
                ' Prepare block reflector
                '
                Call CMatrixBlockReflector(TmpA, TauBuf, False, ColumnsCount, BlockSize, TmpT, WORK)
                
                '
                ' Multiply the rest of A by Q.
                '
                ' Q  = E + Y*T*Y'  = E + TmpA'*TmpT*TmpA
                '
                Call CMatrixGEMM(M - BlockStart - BlockSize, BlockSize, ColumnsCount, C_Complex(1#), a, BlockStart + BlockSize, BlockStart, 0#, TmpA, 0#, 0#, 2#, C_Complex(0#), TmpR, 0#, 0#)
                Call CMatrixGEMM(M - BlockStart - BlockSize, BlockSize, BlockSize, C_Complex(1#), TmpR, 0#, 0#, 0#, TmpT, 0#, 0#, 0#, C_Complex(0#), TmpR, 0#, BlockSize)
                Call CMatrixGEMM(M - BlockStart - BlockSize, ColumnsCount, BlockSize, C_Complex(1#), TmpR, 0#, BlockSize, 0#, TmpA, 0#, 0#, 0#, C_Complex(1#), a, BlockStart + BlockSize, BlockStart)
            Else
                
                '
                ' Level 2 algorithm
                '
                For i = 0# To BlockSize - 1# Step 1
                    i1_ = (i) - (1#)
                    For i_ = 1# To ColumnsCount - i Step 1
                        t(i_) = Conj(TmpA(i, i_ + i1_))
                    Next i_
                    t(1#) = C_Complex(1#)
                    Call ComplexApplyReflectionFromTheRight(a, TauBuf(i), t, BlockStart + BlockSize, M - 1#, BlockStart + i, N - 1#, WORK)
                Next i
            End If
        End If
        
        '
        ' Advance
        '
        BlockStart = BlockStart + BlockSize
    Loop
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Partial unpacking of matrix Q from the QR decomposition of a matrix A
'
'Input parameters:
'    A       -   matrices Q and R in compact form.
'                Output of RMatrixQR subroutine.
'    M       -   number of rows in given matrix A. M>=0.
'    N       -   number of columns in given matrix A. N>=0.
'    Tau     -   scalar factors which are used to form Q.
'                Output of the RMatrixQR subroutine.
'    QColumns -  required number of columns of matrix Q. M>=QColumns>=0.
'
'Output parameters:
'    Q       -   first QColumns columns of matrix Q.
'                Array whose indexes range within [0..M-1, 0..QColumns-1].
'                If QColumns=0, the array remains unchanged.
'
'  -- ALGLIB routine --
'     17.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixQRUnpackQ(ByRef a() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Tau() As Double, _
         ByVal QColumns As Long, _
         ByRef q() As Double)
    Dim WORK() As Double
    Dim t() As Double
    Dim TauBuf() As Double
    Dim MinMN As Long
    Dim RefCnt As Long
    Dim TmpA() As Double
    Dim TmpT() As Double
    Dim TmpR() As Double
    Dim BlockStart As Long
    Dim BlockSize As Long
    Dim RowsCount As Long
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim V As Double
    Dim i_ As Long
    Dim i1_ As Long
    If M <= 0# Or N <= 0# Or QColumns <= 0# Then
        Exit Sub
    End If
    
    '
    ' init
    '
    MinMN = MinInt(M, N)
    RefCnt = MinInt(MinMN, QColumns)
    ReDim q(0 To M - 1, 0 To QColumns - 1)
    For i = 0# To M - 1# Step 1
        For j = 0# To QColumns - 1# Step 1
            If i = j Then
                q(i, j) = 1#
            Else
                q(i, j) = 0#
            End If
        Next j
    Next i
    ReDim WORK(0 To MaxInt(M, QColumns) + 1# - 1)
    ReDim t(0 To MaxInt(M, QColumns) + 1# - 1)
    ReDim TauBuf(0 To MinMN - 1)
    ReDim TmpA(0 To M - 1, 0 To ABLASBlockSize(a) - 1)
    ReDim TmpT(0 To ABLASBlockSize(a) - 1, 0 To 2# * ABLASBlockSize(a) - 1)
    ReDim TmpR(0 To 2# * ABLASBlockSize(a) - 1, 0 To QColumns - 1)
    
    '
    ' Blocked code
    '
    BlockStart = ABLASBlockSize(a) * (RefCnt \ ABLASBlockSize(a))
    BlockSize = RefCnt - BlockStart
    Do While BlockStart >= 0#
        RowsCount = M - BlockStart
        
        '
        ' Copy current block
        '
        Call RMatrixCopy(RowsCount, BlockSize, a, BlockStart, BlockStart, TmpA, 0#, 0#)
        i1_ = (BlockStart) - (0#)
        For i_ = 0# To BlockSize - 1# Step 1
            TauBuf(i_) = Tau(i_ + i1_)
        Next i_
        
        '
        ' Update, choose between:
        ' a) Level 2 algorithm (when the rest of the matrix is small enough)
        ' b) blocked algorithm, see algorithm 5 from  'A storage efficient WY
        '    representation for products of Householder transformations',
        '    by R. Schreiber and C. Van Loan.
        '
        If QColumns >= 2# * ABLASBlockSize(a) Then
            
            '
            ' Prepare block reflector
            '
            Call RMatrixBlockReflector(TmpA, TauBuf, True, RowsCount, BlockSize, TmpT, WORK)
            
            '
            ' Multiply matrix by Q.
            '
            ' Q  = E + Y*T*Y'  = E + TmpA*TmpT*TmpA'
            '
            Call RMatrixGEMM(BlockSize, QColumns, RowsCount, 1#, TmpA, 0#, 0#, 1#, q, BlockStart, 0#, 0#, 0#, TmpR, 0#, 0#)
            Call RMatrixGEMM(BlockSize, QColumns, BlockSize, 1#, TmpT, 0#, 0#, 0#, TmpR, 0#, 0#, 0#, 0#, TmpR, BlockSize, 0#)
            Call RMatrixGEMM(RowsCount, QColumns, BlockSize, 1#, TmpA, 0#, 0#, 0#, TmpR, BlockSize, 0#, 0#, 1#, q, BlockStart, 0#)
        Else
            
            '
            ' Level 2 algorithm
            '
            For i = BlockSize - 1# To 0# Step -1
                i1_ = (i) - (1#)
                For i_ = 1# To RowsCount - i Step 1
                    t(i_) = TmpA(i_ + i1_, i)
                Next i_
                t(1#) = 1#
                Call ApplyReflectionFromTheLeft(q, TauBuf(i), t, BlockStart + i, M - 1#, 0#, QColumns - 1#, WORK)
            Next i
        End If
        
        '
        ' Advance
        '
        BlockStart = BlockStart - ABLASBlockSize(a)
        BlockSize = ABLASBlockSize(a)
    Loop
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Unpacking of matrix R from the QR decomposition of a matrix A
'
'Input parameters:
'    A       -   matrices Q and R in compact form.
'                Output of RMatrixQR subroutine.
'    M       -   number of rows in given matrix A. M>=0.
'    N       -   number of columns in given matrix A. N>=0.
'
'Output parameters:
'    R       -   matrix R, array[0..M-1, 0..N-1].
'
'  -- ALGLIB routine --
'     17.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixQRUnpackR(ByRef a() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef R() As Double)
    Dim i As Long
    Dim K As Long
    Dim i_ As Long
    If M <= 0# Or N <= 0# Then
        Exit Sub
    End If
    K = MinInt(M, N)
    ReDim R(0 To M - 1, 0 To N - 1)
    For i = 0# To N - 1# Step 1
        R(0#, i) = 0#
    Next i
    For i = 1# To M - 1# Step 1
        For i_ = 0# To N - 1# Step 1
            R(i, i_) = R(0#, i_)
        Next i_
    Next i
    For i = 0# To K - 1# Step 1
        For i_ = i To N - 1# Step 1
            R(i, i_) = a(i, i_)
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Partial unpacking of matrix Q from the LQ decomposition of a matrix A
'
'Input parameters:
'    A       -   matrices L and Q in compact form.
'                Output of RMatrixLQ subroutine.
'    M       -   number of rows in given matrix A. M>=0.
'    N       -   number of columns in given matrix A. N>=0.
'    Tau     -   scalar factors which are used to form Q.
'                Output of the RMatrixLQ subroutine.
'    QRows   -   required number of rows in matrix Q. N>=QRows>=0.
'
'Output parameters:
'    Q       -   first QRows rows of matrix Q. Array whose indexes range
'                within [0..QRows-1, 0..N-1]. If QRows=0, the array remains
'                unchanged.
'
'  -- ALGLIB routine --
'     17.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixLQUnpackQ(ByRef a() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Tau() As Double, _
         ByVal QRows As Long, _
         ByRef q() As Double)
    Dim WORK() As Double
    Dim t() As Double
    Dim TauBuf() As Double
    Dim MinMN As Long
    Dim RefCnt As Long
    Dim TmpA() As Double
    Dim TmpT() As Double
    Dim TmpR() As Double
    Dim BlockStart As Long
    Dim BlockSize As Long
    Dim ColumnsCount As Long
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim V As Double
    Dim i_ As Long
    Dim i1_ As Long
    If M <= 0# Or N <= 0# Or QRows <= 0# Then
        Exit Sub
    End If
    
    '
    ' init
    '
    MinMN = MinInt(M, N)
    RefCnt = MinInt(MinMN, QRows)
    ReDim WORK(0 To MaxInt(M, N) + 1# - 1)
    ReDim t(0 To MaxInt(M, N) + 1# - 1)
    ReDim TauBuf(0 To MinMN - 1)
    ReDim TmpA(0 To ABLASBlockSize(a) - 1, 0 To N - 1)
    ReDim TmpT(0 To ABLASBlockSize(a) - 1, 0 To 2# * ABLASBlockSize(a) - 1)
    ReDim TmpR(0 To QRows - 1, 0 To 2# * ABLASBlockSize(a) - 1)
    ReDim q(0 To QRows - 1, 0 To N - 1)
    For i = 0# To QRows - 1# Step 1
        For j = 0# To N - 1# Step 1
            If i = j Then
                q(i, j) = 1#
            Else
                q(i, j) = 0#
            End If
        Next j
    Next i
    
    '
    ' Blocked code
    '
    BlockStart = ABLASBlockSize(a) * (RefCnt \ ABLASBlockSize(a))
    BlockSize = RefCnt - BlockStart
    Do While BlockStart >= 0#
        ColumnsCount = N - BlockStart
        
        '
        ' Copy submatrix
        '
        Call RMatrixCopy(BlockSize, ColumnsCount, a, BlockStart, BlockStart, TmpA, 0#, 0#)
        i1_ = (BlockStart) - (0#)
        For i_ = 0# To BlockSize - 1# Step 1
            TauBuf(i_) = Tau(i_ + i1_)
        Next i_
        
        '
        ' Update matrix, choose between:
        ' a) Level 2 algorithm (when the rest of the matrix is small enough)
        ' b) blocked algorithm, see algorithm 5 from  'A storage efficient WY
        '    representation for products of Householder transformations',
        '    by R. Schreiber and C. Van Loan.
        '
        If QRows >= 2# * ABLASBlockSize(a) Then
            
            '
            ' Prepare block reflector
            '
            Call RMatrixBlockReflector(TmpA, TauBuf, False, ColumnsCount, BlockSize, TmpT, WORK)
            
            '
            ' Multiply the rest of A by Q'.
            '
            ' Q'  = E + Y*T'*Y'  = E + TmpA'*TmpT'*TmpA
            '
            Call RMatrixGEMM(QRows, BlockSize, ColumnsCount, 1#, q, 0#, BlockStart, 0#, TmpA, 0#, 0#, 1#, 0#, TmpR, 0#, 0#)
            Call RMatrixGEMM(QRows, BlockSize, BlockSize, 1#, TmpR, 0#, 0#, 0#, TmpT, 0#, 0#, 1#, 0#, TmpR, 0#, BlockSize)
            Call RMatrixGEMM(QRows, ColumnsCount, BlockSize, 1#, TmpR, 0#, BlockSize, 0#, TmpA, 0#, 0#, 0#, 1#, q, 0#, BlockStart)
        Else
            
            '
            ' Level 2 algorithm
            '
            For i = BlockSize - 1# To 0# Step -1
                i1_ = (i) - (1#)
                For i_ = 1# To ColumnsCount - i Step 1
                    t(i_) = TmpA(i, i_ + i1_)
                Next i_
                t(1#) = 1#
                Call ApplyReflectionFromTheRight(q, TauBuf(i), t, 0#, QRows - 1#, BlockStart + i, N - 1#, WORK)
            Next i
        End If
        
        '
        ' Advance
        '
        BlockStart = BlockStart - ABLASBlockSize(a)
        BlockSize = ABLASBlockSize(a)
    Loop
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Unpacking of matrix L from the LQ decomposition of a matrix A
'
'Input parameters:
'    A       -   matrices Q and L in compact form.
'                Output of RMatrixLQ subroutine.
'    M       -   number of rows in given matrix A. M>=0.
'    N       -   number of columns in given matrix A. N>=0.
'
'Output parameters:
'    L       -   matrix L, array[0..M-1, 0..N-1].
'
'  -- ALGLIB routine --
'     17.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixLQUnpackL(ByRef a() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef L() As Double)
    Dim i As Long
    Dim K As Long
    Dim i_ As Long
    If M <= 0# Or N <= 0# Then
        Exit Sub
    End If
    ReDim L(0 To M - 1, 0 To N - 1)
    For i = 0# To N - 1# Step 1
        L(0#, i) = 0#
    Next i
    For i = 1# To M - 1# Step 1
        For i_ = 0# To N - 1# Step 1
            L(i, i_) = L(0#, i_)
        Next i_
    Next i
    For i = 0# To M - 1# Step 1
        K = MinInt(i, N - 1#)
        For i_ = 0# To K Step 1
            L(i, i_) = a(i, i_)
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Partial unpacking of matrix Q from QR decomposition of a complex matrix A.
'
'Input parameters:
'    A           -   matrices Q and R in compact form.
'                    Output of CMatrixQR subroutine .
'    M           -   number of rows in matrix A. M>=0.
'    N           -   number of columns in matrix A. N>=0.
'    Tau         -   scalar factors which are used to form Q.
'                    Output of CMatrixQR subroutine .
'    QColumns    -   required number of columns in matrix Q. M>=QColumns>=0.
'
'Output parameters:
'    Q           -   first QColumns columns of matrix Q.
'                    Array whose index ranges within [0..M-1, 0..QColumns-1].
'                    If QColumns=0, array isn't changed.
'
'  -- ALGLIB routine --
'     17.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixQRUnpackQ(ByRef a() As Complex, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Tau() As Complex, _
         ByVal QColumns As Long, _
         ByRef q() As Complex)
    Dim WORK() As Complex
    Dim t() As Complex
    Dim TauBuf() As Complex
    Dim MinMN As Long
    Dim RefCnt As Long
    Dim TmpA() As Complex
    Dim TmpT() As Complex
    Dim TmpR() As Complex
    Dim BlockStart As Long
    Dim BlockSize As Long
    Dim RowsCount As Long
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim V As Complex
    Dim i_ As Long
    Dim i1_ As Long
    If M <= 0# Or N <= 0# Then
        Exit Sub
    End If
    
    '
    ' init
    '
    MinMN = MinInt(M, N)
    RefCnt = MinInt(MinMN, QColumns)
    ReDim WORK(0 To MaxInt(M, N) + 1# - 1)
    ReDim t(0 To MaxInt(M, N) + 1# - 1)
    ReDim TauBuf(0 To MinMN - 1)
    ReDim TmpA(0 To M - 1, 0 To ABLASComplexBlockSize(a) - 1)
    ReDim TmpT(0 To ABLASComplexBlockSize(a) - 1, 0 To ABLASComplexBlockSize(a) - 1)
    ReDim TmpR(0 To 2# * ABLASComplexBlockSize(a) - 1, 0 To QColumns - 1)
    ReDim q(0 To M - 1, 0 To QColumns - 1)
    For i = 0# To M - 1# Step 1
        For j = 0# To QColumns - 1# Step 1
            If i = j Then
                q(i, j) = C_Complex(1#)
            Else
                q(i, j) = C_Complex(0#)
            End If
        Next j
    Next i
    
    '
    ' Blocked code
    '
    BlockStart = ABLASComplexBlockSize(a) * (RefCnt \ ABLASComplexBlockSize(a))
    BlockSize = RefCnt - BlockStart
    Do While BlockStart >= 0#
        RowsCount = M - BlockStart
        
        '
        ' QR decomposition of submatrix.
        ' Matrix is copied to temporary storage to solve
        ' some TLB issues arising from non-contiguous memory
        ' access pattern.
        '
        Call CMatrixCopy(RowsCount, BlockSize, a, BlockStart, BlockStart, TmpA, 0#, 0#)
        i1_ = (BlockStart) - (0#)
        For i_ = 0# To BlockSize - 1# Step 1
            TauBuf(i_) = Tau(i_ + i1_)
        Next i_
        
        '
        ' Update matrix, choose between:
        ' a) Level 2 algorithm (when the rest of the matrix is small enough)
        ' b) blocked algorithm, see algorithm 5 from  'A storage efficient WY
        '    representation for products of Householder transformations',
        '    by R. Schreiber and C. Van Loan.
        '
        If QColumns >= 2# * ABLASComplexBlockSize(a) Then
            
            '
            ' Prepare block reflector
            '
            Call CMatrixBlockReflector(TmpA, TauBuf, True, RowsCount, BlockSize, TmpT, WORK)
            
            '
            ' Multiply the rest of A by Q.
            '
            ' Q  = E + Y*T*Y'  = E + TmpA*TmpT*TmpA'
            '
            Call CMatrixGEMM(BlockSize, QColumns, RowsCount, C_Complex(1#), TmpA, 0#, 0#, 2#, q, BlockStart, 0#, 0#, C_Complex(0#), TmpR, 0#, 0#)
            Call CMatrixGEMM(BlockSize, QColumns, BlockSize, C_Complex(1#), TmpT, 0#, 0#, 0#, TmpR, 0#, 0#, 0#, C_Complex(0#), TmpR, BlockSize, 0#)
            Call CMatrixGEMM(RowsCount, QColumns, BlockSize, C_Complex(1#), TmpA, 0#, 0#, 0#, TmpR, BlockSize, 0#, 0#, C_Complex(1#), q, BlockStart, 0#)
        Else
            
            '
            ' Level 2 algorithm
            '
            For i = BlockSize - 1# To 0# Step -1
                i1_ = (i) - (1#)
                For i_ = 1# To RowsCount - i Step 1
                    t(i_) = TmpA(i_ + i1_, i)
                Next i_
                t(1#) = C_Complex(1#)
                Call ComplexApplyReflectionFromTheLeft(q, TauBuf(i), t, BlockStart + i, M - 1#, 0#, QColumns - 1#, WORK)
            Next i
        End If
        
        '
        ' Advance
        '
        BlockStart = BlockStart - ABLASComplexBlockSize(a)
        BlockSize = ABLASComplexBlockSize(a)
    Loop
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Unpacking of matrix R from the QR decomposition of a matrix A
'
'Input parameters:
'    A       -   matrices Q and R in compact form.
'                Output of CMatrixQR subroutine.
'    M       -   number of rows in given matrix A. M>=0.
'    N       -   number of columns in given matrix A. N>=0.
'
'Output parameters:
'    R       -   matrix R, array[0..M-1, 0..N-1].
'
'  -- ALGLIB routine --
'     17.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixQRUnpackR(ByRef a() As Complex, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef R() As Complex)
    Dim i As Long
    Dim K As Long
    Dim i_ As Long
    If M <= 0# Or N <= 0# Then
        Exit Sub
    End If
    K = MinInt(M, N)
    ReDim R(0 To M - 1, 0 To N - 1)
    For i = 0# To N - 1# Step 1
        R(0#, i) = C_Complex(0#)
    Next i
    For i = 1# To M - 1# Step 1
        For i_ = 0# To N - 1# Step 1
            R(i, i_) = R(0#, i_)
        Next i_
    Next i
    For i = 0# To K - 1# Step 1
        For i_ = i To N - 1# Step 1
            R(i, i_) = a(i, i_)
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Partial unpacking of matrix Q from LQ decomposition of a complex matrix A.
'
'Input parameters:
'    A           -   matrices Q and R in compact form.
'                    Output of CMatrixLQ subroutine .
'    M           -   number of rows in matrix A. M>=0.
'    N           -   number of columns in matrix A. N>=0.
'    Tau         -   scalar factors which are used to form Q.
'                    Output of CMatrixLQ subroutine .
'    QRows       -   required number of rows in matrix Q. N>=QColumns>=0.
'
'Output parameters:
'    Q           -   first QRows rows of matrix Q.
'                    Array whose index ranges within [0..QRows-1, 0..N-1].
'                    If QRows=0, array isn't changed.
'
'  -- ALGLIB routine --
'     17.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixLQUnpackQ(ByRef a() As Complex, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Tau() As Complex, _
         ByVal QRows As Long, _
         ByRef q() As Complex)
    Dim WORK() As Complex
    Dim t() As Complex
    Dim TauBuf() As Complex
    Dim MinMN As Long
    Dim RefCnt As Long
    Dim TmpA() As Complex
    Dim TmpT() As Complex
    Dim TmpR() As Complex
    Dim BlockStart As Long
    Dim BlockSize As Long
    Dim ColumnsCount As Long
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim V As Complex
    Dim i_ As Long
    Dim i1_ As Long
    If M <= 0# Or N <= 0# Then
        Exit Sub
    End If
    
    '
    ' Init
    '
    MinMN = MinInt(M, N)
    RefCnt = MinInt(MinMN, QRows)
    ReDim WORK(0 To MaxInt(M, N) + 1# - 1)
    ReDim t(0 To MaxInt(M, N) + 1# - 1)
    ReDim TauBuf(0 To MinMN - 1)
    ReDim TmpA(0 To ABLASComplexBlockSize(a) - 1, 0 To N - 1)
    ReDim TmpT(0 To ABLASComplexBlockSize(a) - 1, 0 To ABLASComplexBlockSize(a) - 1)
    ReDim TmpR(0 To QRows - 1, 0 To 2# * ABLASComplexBlockSize(a) - 1)
    ReDim q(0 To QRows - 1, 0 To N - 1)
    For i = 0# To QRows - 1# Step 1
        For j = 0# To N - 1# Step 1
            If i = j Then
                q(i, j) = C_Complex(1#)
            Else
                q(i, j) = C_Complex(0#)
            End If
        Next j
    Next i
    
    '
    ' Blocked code
    '
    BlockStart = ABLASComplexBlockSize(a) * (RefCnt \ ABLASComplexBlockSize(a))
    BlockSize = RefCnt - BlockStart
    Do While BlockStart >= 0#
        ColumnsCount = N - BlockStart
        
        '
        ' LQ decomposition of submatrix.
        ' Matrix is copied to temporary storage to solve
        ' some TLB issues arising from non-contiguous memory
        ' access pattern.
        '
        Call CMatrixCopy(BlockSize, ColumnsCount, a, BlockStart, BlockStart, TmpA, 0#, 0#)
        i1_ = (BlockStart) - (0#)
        For i_ = 0# To BlockSize - 1# Step 1
            TauBuf(i_) = Tau(i_ + i1_)
        Next i_
        
        '
        ' Update matrix, choose between:
        ' a) Level 2 algorithm (when the rest of the matrix is small enough)
        ' b) blocked algorithm, see algorithm 5 from  'A storage efficient WY
        '    representation for products of Householder transformations',
        '    by R. Schreiber and C. Van Loan.
        '
        If QRows >= 2# * ABLASComplexBlockSize(a) Then
            
            '
            ' Prepare block reflector
            '
            Call CMatrixBlockReflector(TmpA, TauBuf, False, ColumnsCount, BlockSize, TmpT, WORK)
            
            '
            ' Multiply the rest of A by Q'.
            '
            ' Q'  = E + Y*T'*Y'  = E + TmpA'*TmpT'*TmpA
            '
            Call CMatrixGEMM(QRows, BlockSize, ColumnsCount, C_Complex(1#), q, 0#, BlockStart, 0#, TmpA, 0#, 0#, 2#, C_Complex(0#), TmpR, 0#, 0#)
            Call CMatrixGEMM(QRows, BlockSize, BlockSize, C_Complex(1#), TmpR, 0#, 0#, 0#, TmpT, 0#, 0#, 2#, C_Complex(0#), TmpR, 0#, BlockSize)
            Call CMatrixGEMM(QRows, ColumnsCount, BlockSize, C_Complex(1#), TmpR, 0#, BlockSize, 0#, TmpA, 0#, 0#, 0#, C_Complex(1#), q, 0#, BlockStart)
        Else
            
            '
            ' Level 2 algorithm
            '
            For i = BlockSize - 1# To 0# Step -1
                i1_ = (i) - (1#)
                For i_ = 1# To ColumnsCount - i Step 1
                    t(i_) = Conj(TmpA(i, i_ + i1_))
                Next i_
                t(1#) = C_Complex(1#)
                Call ComplexApplyReflectionFromTheRight(q, Conj(TauBuf(i)), t, 0#, QRows - 1#, BlockStart + i, N - 1#, WORK)
            Next i
        End If
        
        '
        ' Advance
        '
        BlockStart = BlockStart - ABLASComplexBlockSize(a)
        BlockSize = ABLASComplexBlockSize(a)
    Loop
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Unpacking of matrix L from the LQ decomposition of a matrix A
'
'Input parameters:
'    A       -   matrices Q and L in compact form.
'                Output of CMatrixLQ subroutine.
'    M       -   number of rows in given matrix A. M>=0.
'    N       -   number of columns in given matrix A. N>=0.
'
'Output parameters:
'    L       -   matrix L, array[0..M-1, 0..N-1].
'
'  -- ALGLIB routine --
'     17.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixLQUnpackL(ByRef a() As Complex, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef L() As Complex)
    Dim i As Long
    Dim K As Long
    Dim i_ As Long
    If M <= 0# Or N <= 0# Then
        Exit Sub
    End If
    ReDim L(0 To M - 1, 0 To N - 1)
    For i = 0# To N - 1# Step 1
        L(0#, i) = C_Complex(0#)
    Next i
    For i = 1# To M - 1# Step 1
        For i_ = 0# To N - 1# Step 1
            L(i, i_) = L(0#, i_)
        Next i_
    Next i
    For i = 0# To M - 1# Step 1
        K = MinInt(i, N - 1#)
        For i_ = 0# To K Step 1
            L(i, i_) = a(i, i_)
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Reduction of a rectangular matrix to  bidiagonal form
'
'The algorithm reduces the rectangular matrix A to  bidiagonal form by
'orthogonal transformations P and Q: A = Q*B*P.
'
'Input parameters:
'    A       -   source matrix. array[0..M-1, 0..N-1]
'    M       -   number of rows in matrix A.
'    N       -   number of columns in matrix A.
'
'Output parameters:
'    A       -   matrices Q, B, P in compact form (see below).
'    TauQ    -   scalar factors which are used to form matrix Q.
'    TauP    -   scalar factors which are used to form matrix P.
'
'The main diagonal and one of the  secondary  diagonals  of  matrix  A  are
'replaced with bidiagonal  matrix  B.  Other  elements  contain  elementary
'reflections which form MxM matrix Q and NxN matrix P, respectively.
'
'If M>=N, B is the upper  bidiagonal  MxN  matrix  and  is  stored  in  the
'corresponding  elements  of  matrix  A.  Matrix  Q  is  represented  as  a
'product   of   elementary   reflections   Q = H(0)*H(1)*...*H(n-1),  where
'H(i) = 1-tau*v*v'. Here tau is a scalar which is stored  in  TauQ[i],  and
'vector v has the following  structure:  v(0:i-1)=0, v(i)=1, v(i+1:m-1)  is
'stored   in   elements   A(i+1:m-1,i).   Matrix   P  is  as  follows:  P =
'G(0)*G(1)*...*G(n-2), where G(i) = 1 - tau*u*u'. Tau is stored in TauP[i],
'u(0:i)=0, u(i+1)=1, u(i+2:n-1) is stored in elements A(i,i+2:n-1).
'
'If M<N, B is the  lower  bidiagonal  MxN  matrix  and  is  stored  in  the
'corresponding   elements  of  matrix  A.  Q = H(0)*H(1)*...*H(m-2),  where
'H(i) = 1 - tau*v*v', tau is stored in TauQ, v(0:i)=0, v(i+1)=1, v(i+2:m-1)
'is    stored    in   elements   A(i+2:m-1,i).    P = G(0)*G(1)*...*G(m-1),
'G(i) = 1-tau*u*u', tau is stored in  TauP,  u(0:i-1)=0, u(i)=1, u(i+1:n-1)
'is stored in A(i,i+1:n-1).
'
'EXAMPLE:
'
'm=6, n=5 (m > n):               m=5, n=6 (m < n):
'
'(  d   e   u1  u1  u1 )         (  d   u1  u1  u1  u1  u1 )
'(  v1  d   e   u2  u2 )         (  e   d   u2  u2  u2  u2 )
'(  v1  v2  d   e   u3 )         (  v1  e   d   u3  u3  u3 )
'(  v1  v2  v3  d   e  )         (  v1  v2  e   d   u4  u4 )
'(  v1  v2  v3  v4  d  )         (  v1  v2  v3  e   d   u5 )
'(  v1  v2  v3  v4  v5 )
'
'Here vi and ui are vectors which form H(i) and G(i), and d and e -
'are the diagonal and off-diagonal elements of matrix B.
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     September 30, 1994.
'     Sergey Bochkanov, ALGLIB project, translation from FORTRAN to
'     pseudocode, 2007-2010.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixBD(ByRef a() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef TauQ() As Double, _
         ByRef TauP() As Double)
    Dim WORK() As Double
    Dim t() As Double
    Dim MinMN As Long
    Dim MaxMN As Long
    Dim i As Long
    Dim LTau As Double
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' Prepare
    '
    If N <= 0# Or M <= 0# Then
        Exit Sub
    End If
    MinMN = MinInt(M, N)
    MaxMN = MaxInt(M, N)
    ReDim WORK(0 To MaxMN + 1# - 1)
    ReDim t(0 To MaxMN + 1# - 1)
    If M >= N Then
        ReDim TauQ(0 To N - 1)
        ReDim TauP(0 To N - 1)
    Else
        ReDim TauQ(0 To M - 1)
        ReDim TauP(0 To M - 1)
    End If
    If M >= N Then
        
        '
        ' Reduce to upper bidiagonal form
        '
        For i = 0# To N - 1# Step 1
            
            '
            ' Generate elementary reflector H(i) to annihilate A(i+1:m-1,i)
            '
            i1_ = (i) - (1#)
            For i_ = 1# To M - i Step 1
                t(i_) = a(i_ + i1_, i)
            Next i_
            Call GenerateReflection(t, M - i, LTau)
            TauQ(i) = LTau
            i1_ = (1#) - (i)
            For i_ = i To M - 1# Step 1
                a(i_, i) = t(i_ + i1_)
            Next i_
            t(1#) = 1#
            
            '
            ' Apply H(i) to A(i:m-1,i+1:n-1) from the left
            '
            Call ApplyReflectionFromTheLeft(a, LTau, t, i, M - 1#, i + 1#, N - 1#, WORK)
            If i < N - 1# Then
                
                '
                ' Generate elementary reflector G(i) to annihilate
                ' A(i,i+2:n-1)
                '
                i1_ = (i + 1#) - (1#)
                For i_ = 1# To N - i - 1# Step 1
                    t(i_) = a(i, i_ + i1_)
                Next i_
                Call GenerateReflection(t, N - 1# - i, LTau)
                TauP(i) = LTau
                i1_ = (1#) - (i + 1#)
                For i_ = i + 1# To N - 1# Step 1
                    a(i, i_) = t(i_ + i1_)
                Next i_
                t(1#) = 1#
                
                '
                ' Apply G(i) to A(i+1:m-1,i+1:n-1) from the right
                '
                Call ApplyReflectionFromTheRight(a, LTau, t, i + 1#, M - 1#, i + 1#, N - 1#, WORK)
            Else
                TauP(i) = 0#
            End If
        Next i
    Else
        
        '
        ' Reduce to lower bidiagonal form
        '
        For i = 0# To M - 1# Step 1
            
            '
            ' Generate elementary reflector G(i) to annihilate A(i,i+1:n-1)
            '
            i1_ = (i) - (1#)
            For i_ = 1# To N - i Step 1
                t(i_) = a(i, i_ + i1_)
            Next i_
            Call GenerateReflection(t, N - i, LTau)
            TauP(i) = LTau
            i1_ = (1#) - (i)
            For i_ = i To N - 1# Step 1
                a(i, i_) = t(i_ + i1_)
            Next i_
            t(1#) = 1#
            
            '
            ' Apply G(i) to A(i+1:m-1,i:n-1) from the right
            '
            Call ApplyReflectionFromTheRight(a, LTau, t, i + 1#, M - 1#, i, N - 1#, WORK)
            If i < M - 1# Then
                
                '
                ' Generate elementary reflector H(i) to annihilate
                ' A(i+2:m-1,i)
                '
                i1_ = (i + 1#) - (1#)
                For i_ = 1# To M - 1# - i Step 1
                    t(i_) = a(i_ + i1_, i)
                Next i_
                Call GenerateReflection(t, M - 1# - i, LTau)
                TauQ(i) = LTau
                i1_ = (1#) - (i + 1#)
                For i_ = i + 1# To M - 1# Step 1
                    a(i_, i) = t(i_ + i1_)
                Next i_
                t(1#) = 1#
                
                '
                ' Apply H(i) to A(i+1:m-1,i+1:n-1) from the left
                '
                Call ApplyReflectionFromTheLeft(a, LTau, t, i + 1#, M - 1#, i + 1#, N - 1#, WORK)
            Else
                TauQ(i) = 0#
            End If
        Next i
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Unpacking matrix Q which reduces a matrix to bidiagonal form.
'
'Input parameters:
'    QP          -   matrices Q and P in compact form.
'                    Output of ToBidiagonal subroutine.
'    M           -   number of rows in matrix A.
'    N           -   number of columns in matrix A.
'    TAUQ        -   scalar factors which are used to form Q.
'                    Output of ToBidiagonal subroutine.
'    QColumns    -   required number of columns in matrix Q.
'                    M>=QColumns>=0.
'
'Output parameters:
'    Q           -   first QColumns columns of matrix Q.
'                    Array[0..M-1, 0..QColumns-1]
'                    If QColumns=0, the array is not modified.
'
'  -- ALGLIB --
'     2005-2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixBDUnpackQ(ByRef QP() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef TauQ() As Double, _
         ByVal QColumns As Long, _
         ByRef q() As Double)
    Dim i As Long
    Dim j As Long
    If M = 0# Or N = 0# Or QColumns = 0# Then
        Exit Sub
    End If
    
    '
    ' prepare Q
    '
    ReDim q(0 To M - 1, 0 To QColumns - 1)
    For i = 0# To M - 1# Step 1
        For j = 0# To QColumns - 1# Step 1
            If i = j Then
                q(i, j) = 1#
            Else
                q(i, j) = 0#
            End If
        Next j
    Next i
    
    '
    ' Calculate
    '
    Call RMatrixBDMultiplyByQ(QP, M, N, TauQ, q, M, QColumns, False, False)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Multiplication by matrix Q which reduces matrix A to  bidiagonal form.
'
'The algorithm allows pre- or post-multiply by Q or Q'.
'
'Input parameters:
'    QP          -   matrices Q and P in compact form.
'                    Output of ToBidiagonal subroutine.
'    M           -   number of rows in matrix A.
'    N           -   number of columns in matrix A.
'    TAUQ        -   scalar factors which are used to form Q.
'                    Output of ToBidiagonal subroutine.
'    Z           -   multiplied matrix.
'                    array[0..ZRows-1,0..ZColumns-1]
'    ZRows       -   number of rows in matrix Z. If FromTheRight=False,
'                    ZRows=M, otherwise ZRows can be arbitrary.
'    ZColumns    -   number of columns in matrix Z. If FromTheRight=True,
'                    ZColumns=M, otherwise ZColumns can be arbitrary.
'    FromTheRight -  pre- or post-multiply.
'    DoTranspose -   multiply by Q or Q'.
'
'Output parameters:
'    Z           -   product of Z and Q.
'                    Array[0..ZRows-1,0..ZColumns-1]
'                    If ZRows=0 or ZColumns=0, the array is not modified.
'
'  -- ALGLIB --
'     2005-2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixBDMultiplyByQ(ByRef QP() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef TauQ() As Double, _
         ByRef z() As Double, _
         ByVal ZRows As Long, _
         ByVal ZColumns As Long, _
         ByVal FromTheRight As Boolean, _
         ByVal DoTranspose As Boolean)
    Dim i As Long
    Dim I1 As Long
    Dim I2 As Long
    Dim IStep As Long
    Dim V() As Double
    Dim WORK() As Double
    Dim MX As Long
    Dim i_ As Long
    Dim i1_ As Long
    If M <= 0# Or N <= 0# Or ZRows <= 0# Or ZColumns <= 0# Then
        Exit Sub
    End If
    
    '
    ' init
    '
    MX = MaxInt(M, N)
    MX = MaxInt(MX, ZRows)
    MX = MaxInt(MX, ZColumns)
    ReDim V(0 To MX + 1# - 1)
    ReDim WORK(0 To MX + 1# - 1)
    If M >= N Then
        
        '
        ' setup
        '
        If FromTheRight Then
            I1 = 0#
            I2 = N - 1#
            IStep = 1#
        Else
            I1 = N - 1#
            I2 = 0#
            IStep = -1#
        End If
        If DoTranspose Then
            i = I1
            I1 = I2
            I2 = i
            IStep = -IStep
        End If
        
        '
        ' Process
        '
        i = I1
        Do
            i1_ = (i) - (1#)
            For i_ = 1# To M - i Step 1
                V(i_) = QP(i_ + i1_, i)
            Next i_
            V(1#) = 1#
            If FromTheRight Then
                Call ApplyReflectionFromTheRight(z, TauQ(i), V, 0#, ZRows - 1#, i, M - 1#, WORK)
            Else
                Call ApplyReflectionFromTheLeft(z, TauQ(i), V, i, M - 1#, 0#, ZColumns - 1#, WORK)
            End If
            i = i + IStep
        Loop Until i = I2 + IStep
    Else
        
        '
        ' setup
        '
        If FromTheRight Then
            I1 = 0#
            I2 = M - 2#
            IStep = 1#
        Else
            I1 = M - 2#
            I2 = 0#
            IStep = -1#
        End If
        If DoTranspose Then
            i = I1
            I1 = I2
            I2 = i
            IStep = -IStep
        End If
        
        '
        ' Process
        '
        If M - 1# > 0# Then
            i = I1
            Do
                i1_ = (i + 1#) - (1#)
                For i_ = 1# To M - i - 1# Step 1
                    V(i_) = QP(i_ + i1_, i)
                Next i_
                V(1#) = 1#
                If FromTheRight Then
                    Call ApplyReflectionFromTheRight(z, TauQ(i), V, 0#, ZRows - 1#, i + 1#, M - 1#, WORK)
                Else
                    Call ApplyReflectionFromTheLeft(z, TauQ(i), V, i + 1#, M - 1#, 0#, ZColumns - 1#, WORK)
                End If
                i = i + IStep
            Loop Until i = I2 + IStep
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Unpacking matrix P which reduces matrix A to bidiagonal form.
'The subroutine returns transposed matrix P.
'
'Input parameters:
'    QP      -   matrices Q and P in compact form.
'                Output of ToBidiagonal subroutine.
'    M       -   number of rows in matrix A.
'    N       -   number of columns in matrix A.
'    TAUP    -   scalar factors which are used to form P.
'                Output of ToBidiagonal subroutine.
'    PTRows  -   required number of rows of matrix P^T. N >= PTRows >= 0.
'
'Output parameters:
'    PT      -   first PTRows columns of matrix P^T
'                Array[0..PTRows-1, 0..N-1]
'                If PTRows=0, the array is not modified.
'
'  -- ALGLIB --
'     2005-2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixBDUnpackPT(ByRef QP() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef TauP() As Double, _
         ByVal PTRows As Long, _
         ByRef PT() As Double)
    Dim i As Long
    Dim j As Long
    If M = 0# Or N = 0# Or PTRows = 0# Then
        Exit Sub
    End If
    
    '
    ' prepare PT
    '
    ReDim PT(0 To PTRows - 1, 0 To N - 1)
    For i = 0# To PTRows - 1# Step 1
        For j = 0# To N - 1# Step 1
            If i = j Then
                PT(i, j) = 1#
            Else
                PT(i, j) = 0#
            End If
        Next j
    Next i
    
    '
    ' Calculate
    '
    Call RMatrixBDMultiplyByP(QP, M, N, TauP, PT, PTRows, N, True, True)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Multiplication by matrix P which reduces matrix A to  bidiagonal form.
'
'The algorithm allows pre- or post-multiply by P or P'.
'
'Input parameters:
'    QP          -   matrices Q and P in compact form.
'                    Output of RMatrixBD subroutine.
'    M           -   number of rows in matrix A.
'    N           -   number of columns in matrix A.
'    TAUP        -   scalar factors which are used to form P.
'                    Output of RMatrixBD subroutine.
'    Z           -   multiplied matrix.
'                    Array whose indexes range within [0..ZRows-1,0..ZColumns-1].
'    ZRows       -   number of rows in matrix Z. If FromTheRight=False,
'                    ZRows=N, otherwise ZRows can be arbitrary.
'    ZColumns    -   number of columns in matrix Z. If FromTheRight=True,
'                    ZColumns=N, otherwise ZColumns can be arbitrary.
'    FromTheRight -  pre- or post-multiply.
'    DoTranspose -   multiply by P or P'.
'
'Output parameters:
'    Z - product of Z and P.
'                Array whose indexes range within [0..ZRows-1,0..ZColumns-1].
'                If ZRows=0 or ZColumns=0, the array is not modified.
'
'  -- ALGLIB --
'     2005-2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixBDMultiplyByP(ByRef QP() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef TauP() As Double, _
         ByRef z() As Double, _
         ByVal ZRows As Long, _
         ByVal ZColumns As Long, _
         ByVal FromTheRight As Boolean, _
         ByVal DoTranspose As Boolean)
    Dim i As Long
    Dim V() As Double
    Dim WORK() As Double
    Dim MX As Long
    Dim I1 As Long
    Dim I2 As Long
    Dim IStep As Long
    Dim i_ As Long
    Dim i1_ As Long
    If M <= 0# Or N <= 0# Or ZRows <= 0# Or ZColumns <= 0# Then
        Exit Sub
    End If
    
    '
    ' init
    '
    MX = MaxInt(M, N)
    MX = MaxInt(MX, ZRows)
    MX = MaxInt(MX, ZColumns)
    ReDim V(0 To MX + 1# - 1)
    ReDim WORK(0 To MX + 1# - 1)
    If M >= N Then
        
        '
        ' setup
        '
        If FromTheRight Then
            I1 = N - 2#
            I2 = 0#
            IStep = -1#
        Else
            I1 = 0#
            I2 = N - 2#
            IStep = 1#
        End If
        If Not DoTranspose Then
            i = I1
            I1 = I2
            I2 = i
            IStep = -IStep
        End If
        
        '
        ' Process
        '
        If N - 1# > 0# Then
            i = I1
            Do
                i1_ = (i + 1#) - (1#)
                For i_ = 1# To N - 1# - i Step 1
                    V(i_) = QP(i, i_ + i1_)
                Next i_
                V(1#) = 1#
                If FromTheRight Then
                    Call ApplyReflectionFromTheRight(z, TauP(i), V, 0#, ZRows - 1#, i + 1#, N - 1#, WORK)
                Else
                    Call ApplyReflectionFromTheLeft(z, TauP(i), V, i + 1#, N - 1#, 0#, ZColumns - 1#, WORK)
                End If
                i = i + IStep
            Loop Until i = I2 + IStep
        End If
    Else
        
        '
        ' setup
        '
        If FromTheRight Then
            I1 = M - 1#
            I2 = 0#
            IStep = -1#
        Else
            I1 = 0#
            I2 = M - 1#
            IStep = 1#
        End If
        If Not DoTranspose Then
            i = I1
            I1 = I2
            I2 = i
            IStep = -IStep
        End If
        
        '
        ' Process
        '
        i = I1
        Do
            i1_ = (i) - (1#)
            For i_ = 1# To N - i Step 1
                V(i_) = QP(i, i_ + i1_)
            Next i_
            V(1#) = 1#
            If FromTheRight Then
                Call ApplyReflectionFromTheRight(z, TauP(i), V, 0#, ZRows - 1#, i, N - 1#, WORK)
            Else
                Call ApplyReflectionFromTheLeft(z, TauP(i), V, i, N - 1#, 0#, ZColumns - 1#, WORK)
            End If
            i = i + IStep
        Loop Until i = I2 + IStep
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Unpacking of the main and secondary diagonals of bidiagonal decomposition
'of matrix A.
'
'Input parameters:
'    B   -   output of RMatrixBD subroutine.
'    M   -   number of rows in matrix B.
'    N   -   number of columns in matrix B.
'
'Output parameters:
'    IsUpper -   True, if the matrix is upper bidiagonal.
'                otherwise IsUpper is False.
'    D       -   the main diagonal.
'                Array whose index ranges within [0..Min(M,N)-1].
'    E       -   the secondary diagonal (upper or lower, depending on
'                the value of IsUpper).
'                Array index ranges within [0..Min(M,N)-1], the last
'                element is not used.
'
'  -- ALGLIB --
'     2005-2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixBDUnpackDiagonals(ByRef B() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef IsUpper As Boolean, _
         ByRef d() As Double, _
         ByRef e() As Double)
    Dim i As Long
    IsUpper = M >= N
    If M <= 0# Or N <= 0# Then
        Exit Sub
    End If
    If IsUpper Then
        ReDim d(0 To N - 1)
        ReDim e(0 To N - 1)
        For i = 0# To N - 2# Step 1
            d(i) = B(i, i)
            e(i) = B(i, i + 1#)
        Next i
        d(N - 1#) = B(N - 1#, N - 1#)
    Else
        ReDim d(0 To M - 1)
        ReDim e(0 To M - 1)
        For i = 0# To M - 2# Step 1
            d(i) = B(i, i)
            e(i) = B(i + 1#, i)
        Next i
        d(M - 1#) = B(M - 1#, M - 1#)
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Reduction of a square matrix to  upper Hessenberg form: Q'*A*Q = H,
'where Q is an orthogonal matrix, H - Hessenberg matrix.
'
'Input parameters:
'    A       -   matrix A with elements [0..N-1, 0..N-1]
'    N       -   size of matrix A.
'
'Output parameters:
'    A       -   matrices Q and P in  compact form (see below).
'    Tau     -   array of scalar factors which are used to form matrix Q.
'                Array whose index ranges within [0..N-2]
'
'Matrix H is located on the main diagonal, on the lower secondary  diagonal
'and above the main diagonal of matrix A. The elements which are used to
'form matrix Q are situated in array Tau and below the lower secondary
'diagonal of matrix A as follows:
'
'Matrix Q is represented as a product of elementary reflections
'
'Q = H(0)*H(2)*...*H(n-2),
'
'where each H(i) is given by
'
'H(i) = 1 - tau * v * (v^T)
'
'where tau is a scalar stored in Tau[I]; v - is a real vector,
'so that v(0:i) = 0, v(i+1) = 1, v(i+2:n-1) stored in A(i+2:n-1,i).
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     October 31, 1992
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixHessenberg(ByRef a() As Double, _
         ByVal N As Long, _
         ByRef Tau() As Double)
    Dim i As Long
    Dim V As Double
    Dim t() As Double
    Dim WORK() As Double
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' Quick return if possible
    '
    If N <= 1# Then
        Exit Sub
    End If
    ReDim Tau(0# To N - 2#)
    ReDim t(1# To N)
    ReDim WORK(0# To N - 1#)
    For i = 0# To N - 2# Step 1
        
        '
        ' Compute elementary reflector H(i) to annihilate A(i+2:ihi,i)
        '
        i1_ = (i + 1#) - (1#)
        For i_ = 1# To N - i - 1# Step 1
            t(i_) = a(i_ + i1_, i)
        Next i_
        Call GenerateReflection(t, N - i - 1#, V)
        i1_ = (1#) - (i + 1#)
        For i_ = i + 1# To N - 1# Step 1
            a(i_, i) = t(i_ + i1_)
        Next i_
        Tau(i) = V
        t(1#) = 1#
        
        '
        ' Apply H(i) to A(1:ihi,i+1:ihi) from the right
        '
        Call ApplyReflectionFromTheRight(a, V, t, 0#, N - 1#, i + 1#, N - 1#, WORK)
        
        '
        ' Apply H(i) to A(i+1:ihi,i+1:n) from the left
        '
        Call ApplyReflectionFromTheLeft(a, V, t, i + 1#, N - 1#, i + 1#, N - 1#, WORK)
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Unpacking matrix Q which reduces matrix A to upper Hessenberg form
'
'Input parameters:
'    A   -   output of RMatrixHessenberg subroutine.
'    N   -   size of matrix A.
'    Tau -   scalar factors which are used to form Q.
'            Output of RMatrixHessenberg subroutine.
'
'Output parameters:
'    Q   -   matrix Q.
'            Array whose indexes range within [0..N-1, 0..N-1].
'
'  -- ALGLIB --
'     2005-2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixHessenbergUnpackQ(ByRef a() As Double, _
         ByVal N As Long, _
         ByRef Tau() As Double, _
         ByRef q() As Double)
    Dim i As Long
    Dim j As Long
    Dim V() As Double
    Dim WORK() As Double
    Dim i_ As Long
    Dim i1_ As Long
    If N = 0# Then
        Exit Sub
    End If
    
    '
    ' init
    '
    ReDim q(0# To N - 1#, 0# To N - 1#)
    ReDim V(0# To N - 1#)
    ReDim WORK(0# To N - 1#)
    For i = 0# To N - 1# Step 1
        For j = 0# To N - 1# Step 1
            If i = j Then
                q(i, j) = 1#
            Else
                q(i, j) = 0#
            End If
        Next j
    Next i
    
    '
    ' unpack Q
    '
    For i = 0# To N - 2# Step 1
        
        '
        ' Apply H(i)
        '
        i1_ = (i + 1#) - (1#)
        For i_ = 1# To N - i - 1# Step 1
            V(i_) = a(i_ + i1_, i)
        Next i_
        V(1#) = 1#
        Call ApplyReflectionFromTheRight(q, Tau(i), V, 0#, N - 1#, i + 1#, N - 1#, WORK)
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Unpacking matrix H (the result of matrix A reduction to upper Hessenberg form)
'
'Input parameters:
'    A   -   output of RMatrixHessenberg subroutine.
'    N   -   size of matrix A.
'
'Output parameters:
'    H   -   matrix H. Array whose indexes range within [0..N-1, 0..N-1].
'
'  -- ALGLIB --
'     2005-2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixHessenbergUnpackH(ByRef a() As Double, _
         ByVal N As Long, _
         ByRef h() As Double)
    Dim i As Long
    Dim j As Long
    Dim V() As Double
    Dim WORK() As Double
    Dim i_ As Long
    If N = 0# Then
        Exit Sub
    End If
    ReDim h(0# To N - 1#, 0# To N - 1#)
    For i = 0# To N - 1# Step 1
        For j = 0# To i - 2# Step 1
            h(i, j) = 0#
        Next j
        j = MaxInt(0#, i - 1#)
        For i_ = j To N - 1# Step 1
            h(i, i_) = a(i, i_)
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Reduction of a symmetric matrix which is given by its higher or lower
'triangular part to a tridiagonal matrix using orthogonal similarity
'transformation: Q'*A*Q=T.
'
'Input parameters:
'    A       -   matrix to be transformed
'                array with elements [0..N-1, 0..N-1].
'    N       -   size of matrix A.
'    IsUpper -   storage format. If IsUpper = True, then matrix A is given
'                by its upper triangle, and the lower triangle is not used
'                and not modified by the algorithm, and vice versa
'                if IsUpper = False.
'
'Output parameters:
'    A       -   matrices T and Q in  compact form (see lower)
'    Tau     -   array of factors which are forming matrices H(i)
'                array with elements [0..N-2].
'    D       -   main diagonal of symmetric matrix T.
'                array with elements [0..N-1].
'    E       -   secondary diagonal of symmetric matrix T.
'                array with elements [0..N-2].
'
'
'  If IsUpper=True, the matrix Q is represented as a product of elementary
'  reflectors
'
'     Q = H(n-2) . . . H(2) H(0).
'
'  Each H(i) has the form
'
'     H(i) = I - tau * v * v'
'
'  where tau is a real scalar, and v is a real vector with
'  v(i+1:n-1) = 0, v(i) = 1, v(0:i-1) is stored on exit in
'  A(0:i-1,i+1), and tau in TAU(i).
'
'  If IsUpper=False, the matrix Q is represented as a product of elementary
'  reflectors
'
'     Q = H(0) H(2) . . . H(n-2).
'
'  Each H(i) has the form
'
'     H(i) = I - tau * v * v'
'
'  where tau is a real scalar, and v is a real vector with
'  v(0:i) = 0, v(i+1) = 1, v(i+2:n-1) is stored on exit in A(i+2:n-1,i),
'  and tau in TAU(i).
'
'  The contents of A on exit are illustrated by the following examples
'  with n = 5:
'
'  if UPLO = 'U':                       if UPLO = 'L':
'
'    (  d   e   v1  v2  v3 )              (  d                  )
'    (      d   e   v2  v3 )              (  e   d              )
'    (          d   e   v3 )              (  v0  e   d          )
'    (              d   e  )              (  v0  v1  e   d      )
'    (                  d  )              (  v0  v1  v2  e   d  )
'
'  where d and e denote diagonal and off-diagonal elements of T, and vi
'  denotes an element of the vector defining H(i).
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     October 31, 1992
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub SMatrixTD(ByRef a() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef Tau() As Double, _
         ByRef d() As Double, _
         ByRef e() As Double)
    Dim i As Long
    Dim alpha As Double
    Dim TauI As Double
    Dim V As Double
    Dim t() As Double
    Dim T2() As Double
    Dim T3() As Double
    Dim i_ As Long
    Dim i1_ As Long
    If N <= 0# Then
        Exit Sub
    End If
    ReDim t(1# To N)
    ReDim T2(1# To N)
    ReDim T3(1# To N)
    If N > 1# Then
        ReDim Tau(0# To N - 2#)
    End If
    ReDim d(0# To N - 1#)
    If N > 1# Then
        ReDim e(0# To N - 2#)
    End If
    If IsUpper Then
        
        '
        ' Reduce the upper triangle of A
        '
        For i = N - 2# To 0# Step -1
            
            '
            ' Generate elementary reflector H() = E - tau * v * v'
            '
            If i >= 1# Then
                i1_ = (0#) - (2#)
                For i_ = 2# To i + 1# Step 1
                    t(i_) = a(i_ + i1_, i + 1#)
                Next i_
            End If
            t(1#) = a(i, i + 1#)
            Call GenerateReflection(t, i + 1#, TauI)
            If i >= 1# Then
                i1_ = (2#) - (0#)
                For i_ = 0# To i - 1# Step 1
                    a(i_, i + 1#) = t(i_ + i1_)
                Next i_
            End If
            a(i, i + 1#) = t(1#)
            e(i) = a(i, i + 1#)
            If TauI <> 0# Then
                
                '
                ' Apply H from both sides to A
                '
                a(i, i + 1#) = 1#
                
                '
                ' Compute  x := tau * A * v  storing x in TAU
                '
                i1_ = (0#) - (1#)
                For i_ = 1# To i + 1# Step 1
                    t(i_) = a(i_ + i1_, i + 1#)
                Next i_
                Call SymmetricMatrixVectorMultiply(a, IsUpper, 0#, i, t, TauI, T3)
                i1_ = (1#) - (0#)
                For i_ = 0# To i Step 1
                    Tau(i_) = T3(i_ + i1_)
                Next i_
                
                '
                ' Compute  w := x - 1/2 * tau * (x'*v) * v
                '
                V = 0#
                For i_ = 0# To i Step 1
                    V = V + Tau(i_) * a(i_, i + 1#)
                Next i_
                alpha = -(0.5 * TauI * V)
                For i_ = 0# To i Step 1
                    Tau(i_) = Tau(i_) + alpha * a(i_, i + 1#)
                Next i_
                
                '
                ' Apply the transformation as a rank-2 update:
                '    A := A - v * w' - w * v'
                '
                i1_ = (0#) - (1#)
                For i_ = 1# To i + 1# Step 1
                    t(i_) = a(i_ + i1_, i + 1#)
                Next i_
                i1_ = (0#) - (1#)
                For i_ = 1# To i + 1# Step 1
                    T3(i_) = Tau(i_ + i1_)
                Next i_
                Call SymmetricRank2Update(a, IsUpper, 0#, i, t, T3, T2, -1#)
                a(i, i + 1#) = e(i)
            End If
            d(i + 1#) = a(i + 1#, i + 1#)
            Tau(i) = TauI
        Next i
        d(0#) = a(0#, 0#)
    Else
        
        '
        ' Reduce the lower triangle of A
        '
        For i = 0# To N - 2# Step 1
            
            '
            ' Generate elementary reflector H = E - tau * v * v'
            '
            i1_ = (i + 1#) - (1#)
            For i_ = 1# To N - i - 1# Step 1
                t(i_) = a(i_ + i1_, i)
            Next i_
            Call GenerateReflection(t, N - i - 1#, TauI)
            i1_ = (1#) - (i + 1#)
            For i_ = i + 1# To N - 1# Step 1
                a(i_, i) = t(i_ + i1_)
            Next i_
            e(i) = a(i + 1#, i)
            If TauI <> 0# Then
                
                '
                ' Apply H from both sides to A
                '
                a(i + 1#, i) = 1#
                
                '
                ' Compute  x := tau * A * v  storing y in TAU
                '
                i1_ = (i + 1#) - (1#)
                For i_ = 1# To N - i - 1# Step 1
                    t(i_) = a(i_ + i1_, i)
                Next i_
                Call SymmetricMatrixVectorMultiply(a, IsUpper, i + 1#, N - 1#, t, TauI, T2)
                i1_ = (1#) - (i)
                For i_ = i To N - 2# Step 1
                    Tau(i_) = T2(i_ + i1_)
                Next i_
                
                '
                ' Compute  w := x - 1/2 * tau * (x'*v) * v
                '
                i1_ = (i + 1#) - (i)
                V = 0#
                For i_ = i To N - 2# Step 1
                    V = V + Tau(i_) * a(i_ + i1_, i)
                Next i_
                alpha = -(0.5 * TauI * V)
                i1_ = (i + 1#) - (i)
                For i_ = i To N - 2# Step 1
                    Tau(i_) = Tau(i_) + alpha * a(i_ + i1_, i)
                Next i_
                
                '
                ' Apply the transformation as a rank-2 update:
                '     A := A - v * w' - w * v'
                '
                '
                i1_ = (i + 1#) - (1#)
                For i_ = 1# To N - i - 1# Step 1
                    t(i_) = a(i_ + i1_, i)
                Next i_
                i1_ = (i) - (1#)
                For i_ = 1# To N - i - 1# Step 1
                    T2(i_) = Tau(i_ + i1_)
                Next i_
                Call SymmetricRank2Update(a, IsUpper, i + 1#, N - 1#, t, T2, T3, -1#)
                a(i + 1#, i) = e(i)
            End If
            d(i) = a(i, i)
            Tau(i) = TauI
        Next i
        d(N - 1#) = a(N - 1#, N - 1#)
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Unpacking matrix Q which reduces symmetric matrix to a tridiagonal
'form.
'
'Input parameters:
'    A       -   the result of a SMatrixTD subroutine
'    N       -   size of matrix A.
'    IsUpper -   storage format (a parameter of SMatrixTD subroutine)
'    Tau     -   the result of a SMatrixTD subroutine
'
'Output parameters:
'    Q       -   transformation matrix.
'                array with elements [0..N-1, 0..N-1].
'
'  -- ALGLIB --
'     Copyright 2005-2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub SMatrixTDUnpackQ(ByRef a() As Double, _
         ByRef N As Long, _
         ByRef IsUpper As Boolean, _
         ByRef Tau() As Double, _
         ByRef q() As Double)
    Dim i As Long
    Dim j As Long
    Dim V() As Double
    Dim WORK() As Double
    Dim i_ As Long
    Dim i1_ As Long
    If N = 0# Then
        Exit Sub
    End If
    
    '
    ' init
    '
    ReDim q(0# To N - 1#, 0# To N - 1#)
    ReDim V(1# To N)
    ReDim WORK(0# To N - 1#)
    For i = 0# To N - 1# Step 1
        For j = 0# To N - 1# Step 1
            If i = j Then
                q(i, j) = 1#
            Else
                q(i, j) = 0#
            End If
        Next j
    Next i
    
    '
    ' unpack Q
    '
    If IsUpper Then
        For i = 0# To N - 2# Step 1
            
            '
            ' Apply H(i)
            '
            i1_ = (0#) - (1#)
            For i_ = 1# To i + 1# Step 1
                V(i_) = a(i_ + i1_, i + 1#)
            Next i_
            V(i + 1#) = 1#
            Call ApplyReflectionFromTheLeft(q, Tau(i), V, 0#, i, 0#, N - 1#, WORK)
        Next i
    Else
        For i = N - 2# To 0# Step -1
            
            '
            ' Apply H(i)
            '
            i1_ = (i + 1#) - (1#)
            For i_ = 1# To N - i - 1# Step 1
                V(i_) = a(i_ + i1_, i)
            Next i_
            V(1#) = 1#
            Call ApplyReflectionFromTheLeft(q, Tau(i), V, i + 1#, N - 1#, 0#, N - 1#, WORK)
        Next i
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Reduction of a Hermitian matrix which is given  by  its  higher  or  lower
'triangular part to a real  tridiagonal  matrix  using  unitary  similarity
'transformation: Q'*A*Q = T.
'
'Input parameters:
'    A       -   matrix to be transformed
'                array with elements [0..N-1, 0..N-1].
'    N       -   size of matrix A.
'    IsUpper -   storage format. If IsUpper = True, then matrix A is  given
'                by its upper triangle, and the lower triangle is not  used
'                and not modified by the algorithm, and vice versa
'                if IsUpper = False.
'
'Output parameters:
'    A       -   matrices T and Q in  compact form (see lower)
'    Tau     -   array of factors which are forming matrices H(i)
'                array with elements [0..N-2].
'    D       -   main diagonal of real symmetric matrix T.
'                array with elements [0..N-1].
'    E       -   secondary diagonal of real symmetric matrix T.
'                array with elements [0..N-2].
'
'
'  If IsUpper=True, the matrix Q is represented as a product of elementary
'  reflectors
'
'     Q = H(n-2) . . . H(2) H(0).
'
'  Each H(i) has the form
'
'     H(i) = I - tau * v * v'
'
'  where tau is a complex scalar, and v is a complex vector with
'  v(i+1:n-1) = 0, v(i) = 1, v(0:i-1) is stored on exit in
'  A(0:i-1,i+1), and tau in TAU(i).
'
'  If IsUpper=False, the matrix Q is represented as a product of elementary
'  reflectors
'
'     Q = H(0) H(2) . . . H(n-2).
'
'  Each H(i) has the form
'
'     H(i) = I - tau * v * v'
'
'  where tau is a complex scalar, and v is a complex vector with
'  v(0:i) = 0, v(i+1) = 1, v(i+2:n-1) is stored on exit in A(i+2:n-1,i),
'  and tau in TAU(i).
'
'  The contents of A on exit are illustrated by the following examples
'  with n = 5:
'
'  if UPLO = 'U':                       if UPLO = 'L':
'
'    (  d   e   v1  v2  v3 )              (  d                  )
'    (      d   e   v2  v3 )              (  e   d              )
'    (          d   e   v3 )              (  v0  e   d          )
'    (              d   e  )              (  v0  v1  e   d      )
'    (                  d  )              (  v0  v1  v2  e   d  )
'
'where d and e denote diagonal and off-diagonal elements of T, and vi
'denotes an element of the vector defining H(i).
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     October 31, 1992
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub HMatrixTD(ByRef a() As Complex, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef Tau() As Complex, _
         ByRef d() As Double, _
         ByRef e() As Double)
    Dim i As Long
    Dim alpha As Complex
    Dim TauI As Complex
    Dim V As Complex
    Dim t() As Complex
    Dim T2() As Complex
    Dim T3() As Complex
    Dim i_ As Long
    Dim i1_ As Long
    If N <= 0# Then
        Exit Sub
    End If
    For i = 0# To N - 1# Step 1
    Next i
    If N > 1# Then
        ReDim Tau(0# To N - 2#)
        ReDim e(0# To N - 2#)
    End If
    ReDim d(0# To N - 1#)
    ReDim t(0# To N - 1#)
    ReDim T2(0# To N - 1#)
    ReDim T3(0# To N - 1#)
    If IsUpper Then
        
        '
        ' Reduce the upper triangle of A
        '
        a(N - 1#, N - 1#) = C_Complex(a(N - 1#, N - 1#).x)
        For i = N - 2# To 0# Step -1
            
            '
            ' Generate elementary reflector H = I+1 - tau * v * v'
            '
            alpha = a(i, i + 1#)
            t(1#) = alpha
            If i >= 1# Then
                i1_ = (0#) - (2#)
                For i_ = 2# To i + 1# Step 1
                    t(i_) = a(i_ + i1_, i + 1#)
                Next i_
            End If
            Call ComplexGenerateReflection(t, i + 1#, TauI)
            If i >= 1# Then
                i1_ = (2#) - (0#)
                For i_ = 0# To i - 1# Step 1
                    a(i_, i + 1#) = t(i_ + i1_)
                Next i_
            End If
            alpha = t(1#)
            e(i) = alpha.x
            If C_NotEqualR(TauI, 0#) Then
                
                '
                ' Apply H(I+1) from both sides to A
                '
                a(i, i + 1#) = C_Complex(1#)
                
                '
                ' Compute  x := tau * A * v  storing x in TAU
                '
                i1_ = (0#) - (1#)
                For i_ = 1# To i + 1# Step 1
                    t(i_) = a(i_ + i1_, i + 1#)
                Next i_
                Call HermitianMatrixVectorMultiply(a, IsUpper, 0#, i, t, TauI, T2)
                i1_ = (1#) - (0#)
                For i_ = 0# To i Step 1
                    Tau(i_) = T2(i_ + i1_)
                Next i_
                
                '
                ' Compute  w := x - 1/2 * tau * (x'*v) * v
                '
                V = C_Complex(0#)
                For i_ = 0# To i Step 1
                    V = C_Add(V, C_Mul(Conj(Tau(i_)), a(i_, i + 1#)))
                Next i_
                alpha = C_Opposite(C_Mul(C_MulR(TauI, 0.5), V))
                For i_ = 0# To i Step 1
                    Tau(i_) = C_Add(Tau(i_), C_Mul(alpha, a(i_, i + 1#)))
                Next i_
                
                '
                ' Apply the transformation as a rank-2 update:
                '    A := A - v * w' - w * v'
                '
                i1_ = (0#) - (1#)
                For i_ = 1# To i + 1# Step 1
                    t(i_) = a(i_ + i1_, i + 1#)
                Next i_
                i1_ = (0#) - (1#)
                For i_ = 1# To i + 1# Step 1
                    T3(i_) = Tau(i_ + i1_)
                Next i_
                Call HermitianRank2Update(a, IsUpper, 0#, i, t, T3, T2, C_Complex(-1#))
            Else
                a(i, i) = C_Complex(a(i, i).x)
            End If
            a(i, i + 1#) = C_Complex(e(i))
            d(i + 1#) = a(i + 1#, i + 1#).x
            Tau(i) = TauI
        Next i
        d(0#) = a(0#, 0#).x
    Else
        
        '
        ' Reduce the lower triangle of A
        '
        a(0#, 0#) = C_Complex(a(0#, 0#).x)
        For i = 0# To N - 2# Step 1
            
            '
            ' Generate elementary reflector H = I - tau * v * v'
            '
            i1_ = (i + 1#) - (1#)
            For i_ = 1# To N - i - 1# Step 1
                t(i_) = a(i_ + i1_, i)
            Next i_
            Call ComplexGenerateReflection(t, N - i - 1#, TauI)
            i1_ = (1#) - (i + 1#)
            For i_ = i + 1# To N - 1# Step 1
                a(i_, i) = t(i_ + i1_)
            Next i_
            e(i) = a(i + 1#, i).x
            If C_NotEqualR(TauI, 0#) Then
                
                '
                ' Apply H(i) from both sides to A(i+1:n,i+1:n)
                '
                a(i + 1#, i) = C_Complex(1#)
                
                '
                ' Compute  x := tau * A * v  storing y in TAU
                '
                i1_ = (i + 1#) - (1#)
                For i_ = 1# To N - i - 1# Step 1
                    t(i_) = a(i_ + i1_, i)
                Next i_
                Call HermitianMatrixVectorMultiply(a, IsUpper, i + 1#, N - 1#, t, TauI, T2)
                i1_ = (1#) - (i)
                For i_ = i To N - 2# Step 1
                    Tau(i_) = T2(i_ + i1_)
                Next i_
                
                '
                ' Compute  w := x - 1/2 * tau * (x'*v) * v
                '
                i1_ = (i + 1#) - (i)
                V = C_Complex(0#)
                For i_ = i To N - 2# Step 1
                    V = C_Add(V, C_Mul(Conj(Tau(i_)), a(i_ + i1_, i)))
                Next i_
                alpha = C_Opposite(C_Mul(C_MulR(TauI, 0.5), V))
                i1_ = (i + 1#) - (i)
                For i_ = i To N - 2# Step 1
                    Tau(i_) = C_Add(Tau(i_), C_Mul(alpha, a(i_ + i1_, i)))
                Next i_
                
                '
                ' Apply the transformation as a rank-2 update:
                ' A := A - v * w' - w * v'
                '
                i1_ = (i + 1#) - (1#)
                For i_ = 1# To N - i - 1# Step 1
                    t(i_) = a(i_ + i1_, i)
                Next i_
                i1_ = (i) - (1#)
                For i_ = 1# To N - i - 1# Step 1
                    T2(i_) = Tau(i_ + i1_)
                Next i_
                Call HermitianRank2Update(a, IsUpper, i + 1#, N - 1#, t, T2, T3, C_Complex(-1#))
            Else
                a(i + 1#, i + 1#) = C_Complex(a(i + 1#, i + 1#).x)
            End If
            a(i + 1#, i) = C_Complex(e(i))
            d(i) = a(i, i).x
            Tau(i) = TauI
        Next i
        d(N - 1#) = a(N - 1#, N - 1#).x
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Unpacking matrix Q which reduces a Hermitian matrix to a real  tridiagonal
'form.
'
'Input parameters:
'    A       -   the result of a HMatrixTD subroutine
'    N       -   size of matrix A.
'    IsUpper -   storage format (a parameter of HMatrixTD subroutine)
'    Tau     -   the result of a HMatrixTD subroutine
'
'Output parameters:
'    Q       -   transformation matrix.
'                array with elements [0..N-1, 0..N-1].
'
'  -- ALGLIB --
'     Copyright 2005-2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub HMatrixTDUnpackQ(ByRef a() As Complex, _
         ByRef N As Long, _
         ByRef IsUpper As Boolean, _
         ByRef Tau() As Complex, _
         ByRef q() As Complex)
    Dim i As Long
    Dim j As Long
    Dim V() As Complex
    Dim WORK() As Complex
    Dim i_ As Long
    Dim i1_ As Long
    If N = 0# Then
        Exit Sub
    End If
    
    '
    ' init
    '
    ReDim q(0# To N - 1#, 0# To N - 1#)
    ReDim V(1# To N)
    ReDim WORK(0# To N - 1#)
    For i = 0# To N - 1# Step 1
        For j = 0# To N - 1# Step 1
            If i = j Then
                q(i, j) = C_Complex(1#)
            Else
                q(i, j) = C_Complex(0#)
            End If
        Next j
    Next i
    
    '
    ' unpack Q
    '
    If IsUpper Then
        For i = 0# To N - 2# Step 1
            
            '
            ' Apply H(i)
            '
            i1_ = (0#) - (1#)
            For i_ = 1# To i + 1# Step 1
                V(i_) = a(i_ + i1_, i + 1#)
            Next i_
            V(i + 1#) = C_Complex(1#)
            Call ComplexApplyReflectionFromTheLeft(q, Tau(i), V, 0#, i, 0#, N - 1#, WORK)
        Next i
    Else
        For i = N - 2# To 0# Step -1
            
            '
            ' Apply H(i)
            '
            i1_ = (i + 1#) - (1#)
            For i_ = 1# To N - i - 1# Step 1
                V(i_) = a(i_ + i1_, i)
            Next i_
            V(1#) = C_Complex(1#)
            Call ComplexApplyReflectionFromTheLeft(q, Tau(i), V, i + 1#, N - 1#, 0#, N - 1#, WORK)
        Next i
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Base case for real QR
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     September 30, 1994.
'     Sergey Bochkanov, ALGLIB project, translation from FORTRAN to
'     pseudocode, 2007-2010.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub RMatrixQRBaseCase(ByRef a() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef WORK() As Double, _
         ByRef t() As Double, _
         ByRef Tau() As Double)
    Dim i As Long
    Dim K As Long
    Dim MinMN As Long
    Dim tmp As Double
    Dim i_ As Long
    Dim i1_ As Long
    MinMN = MinInt(M, N)
    
    '
    ' Test the input arguments
    '
    K = MinMN
    For i = 0# To K - 1# Step 1
        
        '
        ' Generate elementary reflector H(i) to annihilate A(i+1:m,i)
        '
        i1_ = (i) - (1#)
        For i_ = 1# To M - i Step 1
            t(i_) = a(i_ + i1_, i)
        Next i_
        Call GenerateReflection(t, M - i, tmp)
        Tau(i) = tmp
        i1_ = (1#) - (i)
        For i_ = i To M - 1# Step 1
            a(i_, i) = t(i_ + i1_)
        Next i_
        t(1#) = 1#
        If i < N Then
            
            '
            ' Apply H(i) to A(i:m-1,i+1:n-1) from the left
            '
            Call ApplyReflectionFromTheLeft(a, Tau(i), t, i, M - 1#, i + 1#, N - 1#, WORK)
        End If
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Base case for real LQ
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     September 30, 1994.
'     Sergey Bochkanov, ALGLIB project, translation from FORTRAN to
'     pseudocode, 2007-2010.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub RMatrixLQBaseCase(ByRef a() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef WORK() As Double, _
         ByRef t() As Double, _
         ByRef Tau() As Double)
    Dim i As Long
    Dim K As Long
    Dim MinMN As Long
    Dim tmp As Double
    Dim i_ As Long
    Dim i1_ As Long
    MinMN = MinInt(M, N)
    K = MinInt(M, N)
    For i = 0# To K - 1# Step 1
        
        '
        ' Generate elementary reflector H(i) to annihilate A(i,i+1:n-1)
        '
        i1_ = (i) - (1#)
        For i_ = 1# To N - i Step 1
            t(i_) = a(i, i_ + i1_)
        Next i_
        Call GenerateReflection(t, N - i, tmp)
        Tau(i) = tmp
        i1_ = (1#) - (i)
        For i_ = i To N - 1# Step 1
            a(i, i_) = t(i_ + i1_)
        Next i_
        t(1#) = 1#
        If i < N Then
            
            '
            ' Apply H(i) to A(i+1:m,i:n) from the right
            '
            Call ApplyReflectionFromTheRight(a, Tau(i), t, i + 1#, M - 1#, i, N - 1#, WORK)
        End If
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Base case for complex QR
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     September 30, 1994.
'     Sergey Bochkanov, ALGLIB project, translation from FORTRAN to
'     pseudocode, 2007-2010.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub CMatrixQRBaseCase(ByRef a() As Complex, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef WORK() As Complex, _
         ByRef t() As Complex, _
         ByRef Tau() As Complex)
    Dim i As Long
    Dim K As Long
    Dim MMI As Long
    Dim MinMN As Long
    Dim tmp As Complex
    Dim i_ As Long
    Dim i1_ As Long
    MinMN = MinInt(M, N)
    If MinMN <= 0# Then
        Exit Sub
    End If
    
    '
    ' Test the input arguments
    '
    K = MinInt(M, N)
    For i = 0# To K - 1# Step 1
        
        '
        ' Generate elementary reflector H(i) to annihilate A(i+1:m,i)
        '
        MMI = M - i
        i1_ = (i) - (1#)
        For i_ = 1# To MMI Step 1
            t(i_) = a(i_ + i1_, i)
        Next i_
        Call ComplexGenerateReflection(t, MMI, tmp)
        Tau(i) = tmp
        i1_ = (1#) - (i)
        For i_ = i To M - 1# Step 1
            a(i_, i) = t(i_ + i1_)
        Next i_
        t(1#) = C_Complex(1#)
        If i < N - 1# Then
            
            '
            ' Apply H'(i) to A(i:m,i+1:n) from the left
            '
            Call ComplexApplyReflectionFromTheLeft(a, Conj(Tau(i)), t, i, M - 1#, i + 1#, N - 1#, WORK)
        End If
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Base case for complex LQ
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     September 30, 1994.
'     Sergey Bochkanov, ALGLIB project, translation from FORTRAN to
'     pseudocode, 2007-2010.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub CMatrixLQBaseCase(ByRef a() As Complex, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef WORK() As Complex, _
         ByRef t() As Complex, _
         ByRef Tau() As Complex)
    Dim i As Long
    Dim MinMN As Long
    Dim tmp As Complex
    Dim i_ As Long
    Dim i1_ As Long
    MinMN = MinInt(M, N)
    If MinMN <= 0# Then
        Exit Sub
    End If
    
    '
    ' Test the input arguments
    '
    For i = 0# To MinMN - 1# Step 1
        
        '
        ' Generate elementary reflector H(i)
        '
        ' NOTE: ComplexGenerateReflection() generates left reflector,
        ' i.e. H which reduces x by applyiong from the left, but we
        ' need RIGHT reflector. So we replace H=E-tau*v*v' by H^H,
        ' which changes v to conj(v).
        '
        i1_ = (i) - (1#)
        For i_ = 1# To N - i Step 1
            t(i_) = Conj(a(i, i_ + i1_))
        Next i_
        Call ComplexGenerateReflection(t, N - i, tmp)
        Tau(i) = tmp
        i1_ = (1#) - (i)
        For i_ = i To N - 1# Step 1
            a(i, i_) = Conj(t(i_ + i1_))
        Next i_
        t(1#) = C_Complex(1#)
        If i < M - 1# Then
            
            '
            ' Apply H'(i)
            '
            Call ComplexApplyReflectionFromTheRight(a, Tau(i), t, i + 1#, M - 1#, i, N - 1#, WORK)
        End If
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Generate block reflector:
'* fill unused parts of reflectors matrix by zeros
'* fill diagonal of reflectors matrix by ones
'* generate triangular factor T
'
'PARAMETERS:
'    A           -   either LengthA*BlockSize (if ColumnwiseA) or
'                    BlockSize*LengthA (if not ColumnwiseA) matrix of
'                    elementary reflectors.
'                    Modified on exit.
'    Tau         -   scalar factors
'    ColumnwiseA -   reflectors are stored in rows or in columns
'    LengthA     -   length of largest reflector
'    BlockSize   -   number of reflectors
'    T           -   array[BlockSize,2*BlockSize]. Left BlockSize*BlockSize
'                    submatrix stores triangular factor on exit.
'    WORK        -   array[BlockSize]
'
'  -- ALGLIB routine --
'     17.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub RMatrixBlockReflector(ByRef a() As Double, _
         ByRef Tau() As Double, _
         ByVal ColumnwiseA As Boolean, _
         ByVal LengthA As Long, _
         ByVal BlockSize As Long, _
         ByRef t() As Double, _
         ByRef WORK() As Double)
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim V As Double
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' fill beginning of new column with zeros,
    ' load 1.0 in the first non-zero element
    '
    For K = 0# To BlockSize - 1# Step 1
        If ColumnwiseA Then
            For i = 0# To K - 1# Step 1
                a(i, K) = 0#
            Next i
        Else
            For i = 0# To K - 1# Step 1
                a(K, i) = 0#
            Next i
        End If
        a(K, K) = 1#
    Next K
    
    '
    ' Calculate Gram matrix of A
    '
    For i = 0# To BlockSize - 1# Step 1
        For j = 0# To BlockSize - 1# Step 1
            t(i, BlockSize + j) = 0#
        Next j
    Next i
    For K = 0# To LengthA - 1# Step 1
        For j = 1# To BlockSize - 1# Step 1
            If ColumnwiseA Then
                V = a(K, j)
                If V <> 0# Then
                    i1_ = (0#) - (BlockSize)
                    For i_ = BlockSize To BlockSize + j - 1# Step 1
                        t(j, i_) = t(j, i_) + V * a(K, i_ + i1_)
                    Next i_
                End If
            Else
                V = a(j, K)
                If V <> 0# Then
                    i1_ = (0#) - (BlockSize)
                    For i_ = BlockSize To BlockSize + j - 1# Step 1
                        t(j, i_) = t(j, i_) + V * a(i_ + i1_, K)
                    Next i_
                End If
            End If
        Next j
    Next K
    
    '
    ' Prepare Y (stored in TmpA) and T (stored in TmpT)
    '
    For K = 0# To BlockSize - 1# Step 1
        
        '
        ' fill non-zero part of T, use pre-calculated Gram matrix
        '
        i1_ = (BlockSize) - (0#)
        For i_ = 0# To K - 1# Step 1
            WORK(i_) = t(K, i_ + i1_)
        Next i_
        For i = 0# To K - 1# Step 1
            V = 0#
            For i_ = i To K - 1# Step 1
                V = V + t(i, i_) * WORK(i_)
            Next i_
            t(i, K) = -(Tau(K) * V)
        Next i
        t(K, K) = -Tau(K)
        
        '
        ' Rest of T is filled by zeros
        '
        For i = K + 1# To BlockSize - 1# Step 1
            t(i, K) = 0#
        Next i
    Next K
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Generate block reflector (complex):
'* fill unused parts of reflectors matrix by zeros
'* fill diagonal of reflectors matrix by ones
'* generate triangular factor T
'
'
'  -- ALGLIB routine --
'     17.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub CMatrixBlockReflector(ByRef a() As Complex, _
         ByRef Tau() As Complex, _
         ByVal ColumnwiseA As Boolean, _
         ByVal LengthA As Long, _
         ByVal BlockSize As Long, _
         ByRef t() As Complex, _
         ByRef WORK() As Complex)
    Dim i As Long
    Dim K As Long
    Dim V As Complex
    Dim i_ As Long
    
    '
    ' Prepare Y (stored in TmpA) and T (stored in TmpT)
    '
    For K = 0# To BlockSize - 1# Step 1
        
        '
        ' fill beginning of new column with zeros,
        ' load 1.0 in the first non-zero element
        '
        If ColumnwiseA Then
            For i = 0# To K - 1# Step 1
                a(i, K) = C_Complex(0#)
            Next i
        Else
            For i = 0# To K - 1# Step 1
                a(K, i) = C_Complex(0#)
            Next i
        End If
        a(K, K) = C_Complex(1#)
        
        '
        ' fill non-zero part of T,
        '
        For i = 0# To K - 1# Step 1
            If ColumnwiseA Then
                V = C_Complex(0#)
                For i_ = K To LengthA - 1# Step 1
                    V = C_Add(V, C_Mul(Conj(a(i_, i)), a(i_, K)))
                Next i_
            Else
                V = C_Complex(0#)
                For i_ = K To LengthA - 1# Step 1
                    V = C_Add(V, C_Mul(a(i, i_), Conj(a(K, i_))))
                Next i_
            End If
            WORK(i) = V
        Next i
        For i = 0# To K - 1# Step 1
            V = C_Complex(0#)
            For i_ = i To K - 1# Step 1
                V = C_Add(V, C_Mul(t(i, i_), WORK(i_)))
            Next i_
            t(i, K) = C_Opposite(C_Mul(Tau(K), V))
        Next i
        t(K, K) = C_Opposite(Tau(K))
        
        '
        ' Rest of T is filled by zeros
        '
        For i = K + 1# To BlockSize - 1# Step 1
            t(i, K) = C_Complex(0#)
        Next i
    Next K
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 1992-2007 The University of Tennessee. All rights reserved.
'
'Contributors:
'    * Sergey Bochkanov (ALGLIB project). Translation from FORTRAN to
'      pseudocode.
'
'See subroutines comments for additional copyrights.
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Inversion of a matrix given by its LU decomposition.
'
'INPUT PARAMETERS:
'    A       -   LU decomposition of the matrix (output of RMatrixLU subroutine).
'    Pivots  -   table of permutations which were made during the LU decomposition
'                (the output of RMatrixLU subroutine).
'    N       -   size of matrix A.
'
'OUTPUT PARAMETERS:
'    Info    -   return code:
'                * -3    A is singular, or VERY close to singular.
'                        it is filled by zeros in such cases.
'                * -1    N<=0 was passed, or incorrect Pivots was passed
'                *  1    task is solved (but matrix A may be ill-conditioned,
'                        check R1/RInf parameters for condition numbers).
'    Rep     -   solver report, see below for more info
'    A       -   inverse of matrix A.
'                Array whose indexes range within [0..N-1, 0..N-1].
'
'SOLVER REPORT
'
'Subroutine sets following fields of the Rep structure:
'* R1        reciprocal of condition number: 1/cond(A), 1-norm.
'* RInf      reciprocal of condition number: 1/cond(A), inf-norm.
'
'  -- ALGLIB routine --
'     05.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixLUInverse(ByRef a() As Double, _
         ByRef Pivots() As Long, _
         ByVal N As Long, _
         ByRef Info As Long, _
         ByRef Rep As MatInvReport)
    Dim WORK() As Double
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim V As Double
    Info = 1#
    
    '
    ' Quick return if possible
    '
    If N = 0# Then
        Info = -1#
        Exit Sub
    End If
    For i = 0# To N - 1# Step 1
        If Pivots(i) > N - 1# Or Pivots(i) < i Then
            Info = -1#
            Exit Sub
        End If
    Next i
    
    '
    ' calculate condition numbers
    '
    Rep.R1 = RMatrixLURCond1(a, N)
    Rep.RInf = RMatrixLURCondInf(a, N)
    If Rep.R1 < RCondThreshold() Or Rep.RInf < RCondThreshold() Then
        For i = 0# To N - 1# Step 1
            For j = 0# To N - 1# Step 1
                a(i, j) = 0#
            Next j
        Next i
        Rep.R1 = 0#
        Rep.RInf = 0#
        Info = -3#
        Exit Sub
    End If
    
    '
    ' Call cache-oblivious code
    '
    ReDim WORK(0 To N - 1)
    Call RMatrixLUInverseRec(a, 0#, N, WORK, Info, Rep)
    
    '
    ' apply permutations
    '
    For i = 0# To N - 1# Step 1
        For j = N - 2# To 0# Step -1
            K = Pivots(j)
            V = a(i, j)
            a(i, j) = a(i, K)
            a(i, K) = V
        Next j
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Inversion of a general matrix.
'
'Input parameters:
'    A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
'    N   -   size of matrix A.
'
'Output parameters:
'    Info    -   return code, same as in RMatrixLUInverse
'    Rep     -   solver report, same as in RMatrixLUInverse
'    A       -   inverse of matrix A, same as in RMatrixLUInverse
'
'Result:
'    True, if the matrix is not singular.
'    False, if the matrix is singular.
'
'  -- ALGLIB --
'     Copyright 2005 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixInverse(ByRef a() As Double, _
         ByVal N As Long, _
         ByRef Info As Long, _
         ByRef Rep As MatInvReport)
    Dim Pivots() As Long
    Call RMatrixLU(a, N, N, Pivots)
    Call RMatrixLUInverse(a, Pivots, N, Info, Rep)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Inversion of a matrix given by its LU decomposition.
'
'INPUT PARAMETERS:
'    A       -   LU decomposition of the matrix (output of CMatrixLU subroutine).
'    Pivots  -   table of permutations which were made during the LU decomposition
'                (the output of CMatrixLU subroutine).
'    N       -   size of matrix A.
'
'OUTPUT PARAMETERS:
'    Info    -   return code, same as in RMatrixLUInverse
'    Rep     -   solver report, same as in RMatrixLUInverse
'    A       -   inverse of matrix A, same as in RMatrixLUInverse
'
'  -- ALGLIB routine --
'     05.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixLUInverse(ByRef a() As Complex, _
         ByRef Pivots() As Long, _
         ByVal N As Long, _
         ByRef Info As Long, _
         ByRef Rep As MatInvReport)
    Dim WORK() As Complex
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim V As Complex
    Info = 1#
    
    '
    ' Quick return if possible
    '
    If N = 0# Then
        Info = -1#
        Exit Sub
    End If
    For i = 0# To N - 1# Step 1
        If Pivots(i) > N - 1# Or Pivots(i) < i Then
            Info = -1#
            Exit Sub
        End If
    Next i
    
    '
    ' calculate condition numbers
    '
    Rep.R1 = CMatrixLURCond1(a, N)
    Rep.RInf = CMatrixLURCondInf(a, N)
    If Rep.R1 < RCondThreshold() Or Rep.RInf < RCondThreshold() Then
        For i = 0# To N - 1# Step 1
            For j = 0# To N - 1# Step 1
                a(i, j) = C_Complex(0#)
            Next j
        Next i
        Rep.R1 = 0#
        Rep.RInf = 0#
        Info = -3#
        Exit Sub
    End If
    
    '
    ' Call cache-oblivious code
    '
    ReDim WORK(0 To N - 1)
    Call CMatrixLUInverseRec(a, 0#, N, WORK, Info, Rep)
    
    '
    ' apply permutations
    '
    For i = 0# To N - 1# Step 1
        For j = N - 2# To 0# Step -1
            K = Pivots(j)
            V = a(i, j)
            a(i, j) = a(i, K)
            a(i, K) = V
        Next j
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Inversion of a general matrix.
'
'Input parameters:
'    A   -   matrix, array[0..N-1,0..N-1].
'    N   -   size of A.
'
'Output parameters:
'    Info    -   return code, same as in RMatrixLUInverse
'    Rep     -   solver report, same as in RMatrixLUInverse
'    A       -   inverse of matrix A, same as in RMatrixLUInverse
'
'  -- ALGLIB --
'     Copyright 2005 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixInverse(ByRef a() As Complex, _
         ByVal N As Long, _
         ByRef Info As Long, _
         ByRef Rep As MatInvReport)
    Dim Pivots() As Long
    Call CMatrixLU(a, N, N, Pivots)
    Call CMatrixLUInverse(a, Pivots, N, Info, Rep)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Inversion of a symmetric positive definite matrix which is given
'by Cholesky decomposition.
'
'Input parameters:
'    A       -   Cholesky decomposition of the matrix to be inverted:
'                A=U*U or A = L*L'.
'                Output of  SPDMatrixCholesky subroutine.
'    N       -   size of matrix A.
'    IsUpper    storage format.
'                If IsUpper = True, then matrix A is given as A = U'*U
'                (matrix contains upper triangle).
'                Similarly, if IsUpper = False, then A = L*L'.
'
'Output parameters:
'    Info    -   return code, same as in RMatrixLUInverse
'    Rep     -   solver report, same as in RMatrixLUInverse
'    A       -   inverse of matrix A, same as in RMatrixLUInverse
'
'  -- ALGLIB routine --
'     10.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub SPDMatrixCholeskyInverse(ByRef a() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef Info As Long, _
         ByRef Rep As MatInvReport)
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim V As Double
    Dim AJJ As Double
    Dim AII As Double
    Dim tmp() As Double
    Dim Info2 As Long
    Dim Rep2 As MatInvReport
    If N < 1# Then
        Info = -1#
        Exit Sub
    End If
    Info = 1#
    
    '
    ' calculate condition numbers
    '
    Rep.R1 = SPDMatrixCholeskyRCond(a, N, IsUpper)
    Rep.RInf = Rep.R1
    If Rep.R1 < RCondThreshold() Or Rep.RInf < RCondThreshold() Then
        If IsUpper Then
            For i = 0# To N - 1# Step 1
                For j = i To N - 1# Step 1
                    a(i, j) = 0#
                Next j
            Next i
        Else
            For i = 0# To N - 1# Step 1
                For j = 0# To i Step 1
                    a(i, j) = 0#
                Next j
            Next i
        End If
        Rep.R1 = 0#
        Rep.RInf = 0#
        Info = -3#
        Exit Sub
    End If
    
    '
    ' Inverse
    '
    ReDim tmp(0 To N - 1)
    Call SPDMatrixCholeskyInverseRec(a, 0#, N, IsUpper, tmp)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Inversion of a symmetric positive definite matrix.
'
'Given an upper or lower triangle of a symmetric positive definite matrix,
'the algorithm generates matrix A^-1 and saves the upper or lower triangle
'depending on the input.
'
'Input parameters:
'    A       -   matrix to be inverted (upper or lower triangle).
'                Array with elements [0..N-1,0..N-1].
'    N       -   size of matrix A.
'    IsUpper -   storage format.
'                If IsUpper = True, then the upper triangle of matrix A is
'                given, otherwise the lower triangle is given.
'
'Output parameters:
'    Info    -   return code, same as in RMatrixLUInverse
'    Rep     -   solver report, same as in RMatrixLUInverse
'    A       -   inverse of matrix A, same as in RMatrixLUInverse
'
'  -- ALGLIB routine --
'     10.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub SPDMatrixInverse(ByRef a() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef Info As Long, _
         ByRef Rep As MatInvReport)
    If N < 1# Then
        Info = -1#
        Exit Sub
    End If
    Info = 1#
    If SPDMatrixCholesky(a, N, IsUpper) Then
        Call SPDMatrixCholeskyInverse(a, N, IsUpper, Info, Rep)
    Else
        Info = -3#
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Inversion of a Hermitian positive definite matrix which is given
'by Cholesky decomposition.
'
'Input parameters:
'    A       -   Cholesky decomposition of the matrix to be inverted:
'                A=U*U or A = L*L'.
'                Output of  HPDMatrixCholesky subroutine.
'    N       -   size of matrix A.
'    IsUpper    storage format.
'                If IsUpper = True, then matrix A is given as A = U'*U
'                (matrix contains upper triangle).
'                Similarly, if IsUpper = False, then A = L*L'.
'
'Output parameters:
'    Info    -   return code, same as in RMatrixLUInverse
'    Rep     -   solver report, same as in RMatrixLUInverse
'    A       -   inverse of matrix A, same as in RMatrixLUInverse
'
'  -- ALGLIB routine --
'     10.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub HPDMatrixCholeskyInverse(ByRef a() As Complex, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef Info As Long, _
         ByRef Rep As MatInvReport)
    Dim i As Long
    Dim j As Long
    Dim Info2 As Long
    Dim Rep2 As MatInvReport
    Dim tmp() As Complex
    Dim V As Complex
    If N < 1# Then
        Info = -1#
        Exit Sub
    End If
    Info = 1#
    
    '
    ' calculate condition numbers
    '
    Rep.R1 = HPDMatrixCholeskyRCond(a, N, IsUpper)
    Rep.RInf = Rep.R1
    If Rep.R1 < RCondThreshold() Or Rep.RInf < RCondThreshold() Then
        If IsUpper Then
            For i = 0# To N - 1# Step 1
                For j = i To N - 1# Step 1
                    a(i, j) = C_Complex(0#)
                Next j
            Next i
        Else
            For i = 0# To N - 1# Step 1
                For j = 0# To i Step 1
                    a(i, j) = C_Complex(0#)
                Next j
            Next i
        End If
        Rep.R1 = 0#
        Rep.RInf = 0#
        Info = -3#
        Exit Sub
    End If
    
    '
    ' Inverse
    '
    ReDim tmp(0 To N - 1)
    Call HPDMatrixCholeskyInverseRec(a, 0#, N, IsUpper, tmp)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Inversion of a Hermitian positive definite matrix.
'
'Given an upper or lower triangle of a Hermitian positive definite matrix,
'the algorithm generates matrix A^-1 and saves the upper or lower triangle
'depending on the input.
'
'Input parameters:
'    A       -   matrix to be inverted (upper or lower triangle).
'                Array with elements [0..N-1,0..N-1].
'    N       -   size of matrix A.
'    IsUpper -   storage format.
'                If IsUpper = True, then the upper triangle of matrix A is
'                given, otherwise the lower triangle is given.
'
'Output parameters:
'    Info    -   return code, same as in RMatrixLUInverse
'    Rep     -   solver report, same as in RMatrixLUInverse
'    A       -   inverse of matrix A, same as in RMatrixLUInverse
'
'  -- ALGLIB routine --
'     10.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub HPDMatrixInverse(ByRef a() As Complex, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef Info As Long, _
         ByRef Rep As MatInvReport)
    If N < 1# Then
        Info = -1#
        Exit Sub
    End If
    Info = 1#
    If HPDMatrixCholesky(a, N, IsUpper) Then
        Call HPDMatrixCholeskyInverse(a, N, IsUpper, Info, Rep)
    Else
        Info = -3#
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Triangular matrix inverse (real)
'
'The subroutine inverts the following types of matrices:
'    * upper triangular
'    * upper triangular with unit diagonal
'    * lower triangular
'    * lower triangular with unit diagonal
'
'In case of an upper (lower) triangular matrix,  the  inverse  matrix  will
'also be upper (lower) triangular, and after the end of the algorithm,  the
'inverse matrix replaces the source matrix. The elements  below (above) the
'main diagonal are not changed by the algorithm.
'
'If  the matrix  has a unit diagonal, the inverse matrix also  has  a  unit
'diagonal, and the diagonal elements are not passed to the algorithm.
'
'Input parameters:
'    A       -   matrix, array[0..N-1, 0..N-1].
'    N       -   size of A.
'    IsUpper -   True, if the matrix is upper triangular.
'    IsUnit  -   True, if the matrix has a unit diagonal.
'
'Output parameters:
'    Info    -   same as for RMatrixLUInverse
'    Rep     -   same as for RMatrixLUInverse
'    A       -   same as for RMatrixLUInverse.
'
'  -- ALGLIB --
'     Copyright 05.02.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixTRInverse(ByRef a() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByVal Isunit As Boolean, _
         ByRef Info As Long, _
         ByRef Rep As MatInvReport)
    Dim i As Long
    Dim j As Long
    Dim tmp() As Double
    If N < 1# Then
        Info = -1#
        Exit Sub
    End If
    Info = 1#
    
    '
    ' calculate condition numbers
    '
    Rep.R1 = RMatrixTRRCond1(a, N, IsUpper, Isunit)
    Rep.RInf = RMatrixTRRCondInf(a, N, IsUpper, Isunit)
    If Rep.R1 < RCondThreshold() Or Rep.RInf < RCondThreshold() Then
        For i = 0# To N - 1# Step 1
            For j = 0# To N - 1# Step 1
                a(i, j) = 0#
            Next j
        Next i
        Rep.R1 = 0#
        Rep.RInf = 0#
        Info = -3#
        Exit Sub
    End If
    
    '
    ' Invert
    '
    ReDim tmp(0 To N - 1)
    Call RMatrixTRInverseRec(a, 0#, N, IsUpper, Isunit, tmp, Info, Rep)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Triangular matrix inverse (complex)
'
'The subroutine inverts the following types of matrices:
'    * upper triangular
'    * upper triangular with unit diagonal
'    * lower triangular
'    * lower triangular with unit diagonal
'
'In case of an upper (lower) triangular matrix,  the  inverse  matrix  will
'also be upper (lower) triangular, and after the end of the algorithm,  the
'inverse matrix replaces the source matrix. The elements  below (above) the
'main diagonal are not changed by the algorithm.
'
'If  the matrix  has a unit diagonal, the inverse matrix also  has  a  unit
'diagonal, and the diagonal elements are not passed to the algorithm.
'
'Input parameters:
'    A       -   matrix, array[0..N-1, 0..N-1].
'    N       -   size of A.
'    IsUpper -   True, if the matrix is upper triangular.
'    IsUnit  -   True, if the matrix has a unit diagonal.
'
'Output parameters:
'    Info    -   same as for RMatrixLUInverse
'    Rep     -   same as for RMatrixLUInverse
'    A       -   same as for RMatrixLUInverse.
'
'  -- ALGLIB --
'     Copyright 05.02.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixTRInverse(ByRef a() As Complex, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByVal Isunit As Boolean, _
         ByRef Info As Long, _
         ByRef Rep As MatInvReport)
    Dim i As Long
    Dim j As Long
    Dim tmp() As Complex
    If N < 1# Then
        Info = -1#
        Exit Sub
    End If
    Info = 1#
    
    '
    ' calculate condition numbers
    '
    Rep.R1 = CMatrixTRRCond1(a, N, IsUpper, Isunit)
    Rep.RInf = CMatrixTRRCondInf(a, N, IsUpper, Isunit)
    If Rep.R1 < RCondThreshold() Or Rep.RInf < RCondThreshold() Then
        For i = 0# To N - 1# Step 1
            For j = 0# To N - 1# Step 1
                a(i, j) = C_Complex(0#)
            Next j
        Next i
        Rep.R1 = 0#
        Rep.RInf = 0#
        Info = -3#
        Exit Sub
    End If
    
    '
    ' Invert
    '
    ReDim tmp(0 To N - 1)
    Call CMatrixTRInverseRec(a, 0#, N, IsUpper, Isunit, tmp, Info, Rep)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Triangular matrix inversion, recursive subroutine
'
'  -- ALGLIB --
'     05.02.2010, Bochkanov Sergey.
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     February 29, 1992.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub RMatrixTRInverseRec(ByRef a() As Double, _
         ByVal Offs As Long, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByVal Isunit As Boolean, _
         ByRef tmp() As Double, _
         ByRef Info As Long, _
         ByRef Rep As MatInvReport)
    Dim N1 As Long
    Dim N2 As Long
    Dim i As Long
    Dim j As Long
    Dim V As Double
    Dim AJJ As Double
    Dim i_ As Long
    Dim i1_ As Long
    If N < 1# Then
        Info = -1#
        Exit Sub
    End If
    
    '
    ' Base case
    '
    If N <= ABLASBlockSize(a) Then
        If IsUpper Then
            
            '
            ' Compute inverse of upper triangular matrix.
            '
            For j = 0# To N - 1# Step 1
                If Not Isunit Then
                    If a(Offs + j, Offs + j) = 0# Then
                        Info = -3#
                        Exit Sub
                    End If
                    a(Offs + j, Offs + j) = 1# / a(Offs + j, Offs + j)
                    AJJ = -a(Offs + j, Offs + j)
                Else
                    AJJ = -1#
                End If
                
                '
                ' Compute elements 1:j-1 of j-th column.
                '
                If j > 0# Then
                    i1_ = (Offs + 0#) - (0#)
                    For i_ = 0# To j - 1# Step 1
                        tmp(i_) = a(i_ + i1_, Offs + j)
                    Next i_
                    For i = 0# To j - 1# Step 1
                        If i < j - 1# Then
                            i1_ = (i + 1#) - (Offs + i + 1#)
                            V = 0#
                            For i_ = Offs + i + 1# To Offs + j - 1# Step 1
                                V = V + a(Offs + i, i_) * tmp(i_ + i1_)
                            Next i_
                        Else
                            V = 0#
                        End If
                        If Not Isunit Then
                            a(Offs + i, Offs + j) = V + a(Offs + i, Offs + i) * tmp(i)
                        Else
                            a(Offs + i, Offs + j) = V + tmp(i)
                        End If
                    Next i
                    For i_ = Offs + 0# To Offs + j - 1# Step 1
                        a(i_, Offs + j) = AJJ * a(i_, Offs + j)
                    Next i_
                End If
            Next j
        Else
            
            '
            ' Compute inverse of lower triangular matrix.
            '
            For j = N - 1# To 0# Step -1
                If Not Isunit Then
                    If a(Offs + j, Offs + j) = 0# Then
                        Info = -3#
                        Exit Sub
                    End If
                    a(Offs + j, Offs + j) = 1# / a(Offs + j, Offs + j)
                    AJJ = -a(Offs + j, Offs + j)
                Else
                    AJJ = -1#
                End If
                If j < N - 1# Then
                    
                    '
                    ' Compute elements j+1:n of j-th column.
                    '
                    i1_ = (Offs + j + 1#) - (j + 1#)
                    For i_ = j + 1# To N - 1# Step 1
                        tmp(i_) = a(i_ + i1_, Offs + j)
                    Next i_
                    For i = j + 1# To N - 1# Step 1
                        If i > j + 1# Then
                            i1_ = (j + 1#) - (Offs + j + 1#)
                            V = 0#
                            For i_ = Offs + j + 1# To Offs + i - 1# Step 1
                                V = V + a(Offs + i, i_) * tmp(i_ + i1_)
                            Next i_
                        Else
                            V = 0#
                        End If
                        If Not Isunit Then
                            a(Offs + i, Offs + j) = V + a(Offs + i, Offs + i) * tmp(i)
                        Else
                            a(Offs + i, Offs + j) = V + tmp(i)
                        End If
                    Next i
                    For i_ = Offs + j + 1# To Offs + N - 1# Step 1
                        a(i_, Offs + j) = AJJ * a(i_, Offs + j)
                    Next i_
                End If
            Next j
        End If
        Exit Sub
    End If
    
    '
    ' Recursive case
    '
    Call ABLASSplitLength(a, N, N1, N2)
    If N2 > 0# Then
        If IsUpper Then
            For i = 0# To N1 - 1# Step 1
                For i_ = Offs + N1 To Offs + N - 1# Step 1
                    a(Offs + i, i_) = -1 * a(Offs + i, i_)
                Next i_
            Next i
            Call RMatrixLeftTRSM(N1, N2, a, Offs, Offs, IsUpper, Isunit, 0#, a, Offs, Offs + N1)
            Call RMatrixRightTRSM(N1, N2, a, Offs + N1, Offs + N1, IsUpper, Isunit, 0#, a, Offs, Offs + N1)
        Else
            For i = 0# To N2 - 1# Step 1
                For i_ = Offs To Offs + N1 - 1# Step 1
                    a(Offs + N1 + i, i_) = -1 * a(Offs + N1 + i, i_)
                Next i_
            Next i
            Call RMatrixRightTRSM(N2, N1, a, Offs, Offs, IsUpper, Isunit, 0#, a, Offs + N1, Offs)
            Call RMatrixLeftTRSM(N2, N1, a, Offs + N1, Offs + N1, IsUpper, Isunit, 0#, a, Offs + N1, Offs)
        End If
        Call RMatrixTRInverseRec(a, Offs + N1, N2, IsUpper, Isunit, tmp, Info, Rep)
    End If
    Call RMatrixTRInverseRec(a, Offs, N1, IsUpper, Isunit, tmp, Info, Rep)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Triangular matrix inversion, recursive subroutine
'
'  -- ALGLIB --
'     05.02.2010, Bochkanov Sergey.
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     February 29, 1992.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub CMatrixTRInverseRec(ByRef a() As Complex, _
         ByVal Offs As Long, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByVal Isunit As Boolean, _
         ByRef tmp() As Complex, _
         ByRef Info As Long, _
         ByRef Rep As MatInvReport)
    Dim N1 As Long
    Dim N2 As Long
    Dim i As Long
    Dim j As Long
    Dim V As Complex
    Dim AJJ As Complex
    Dim i_ As Long
    Dim i1_ As Long
    If N < 1# Then
        Info = -1#
        Exit Sub
    End If
    
    '
    ' Base case
    '
    If N <= ABLASComplexBlockSize(a) Then
        If IsUpper Then
            
            '
            ' Compute inverse of upper triangular matrix.
            '
            For j = 0# To N - 1# Step 1
                If Not Isunit Then
                    If C_EqualR(a(Offs + j, Offs + j), 0#) Then
                        Info = -3#
                        Exit Sub
                    End If
                    a(Offs + j, Offs + j) = C_RDiv(1#, a(Offs + j, Offs + j))
                    AJJ = C_Opposite(a(Offs + j, Offs + j))
                Else
                    AJJ = C_Complex(-1#)
                End If
                
                '
                ' Compute elements 1:j-1 of j-th column.
                '
                If j > 0# Then
                    i1_ = (Offs + 0#) - (0#)
                    For i_ = 0# To j - 1# Step 1
                        tmp(i_) = a(i_ + i1_, Offs + j)
                    Next i_
                    For i = 0# To j - 1# Step 1
                        If i < j - 1# Then
                            i1_ = (i + 1#) - (Offs + i + 1#)
                            V = C_Complex(0#)
                            For i_ = Offs + i + 1# To Offs + j - 1# Step 1
                                V = C_Add(V, C_Mul(a(Offs + i, i_), tmp(i_ + i1_)))
                            Next i_
                        Else
                            V = C_Complex(0#)
                        End If
                        If Not Isunit Then
                            a(Offs + i, Offs + j) = C_Add(V, C_Mul(a(Offs + i, Offs + i), tmp(i)))
                        Else
                            a(Offs + i, Offs + j) = C_Add(V, tmp(i))
                        End If
                    Next i
                    For i_ = Offs + 0# To Offs + j - 1# Step 1
                        a(i_, Offs + j) = C_Mul(AJJ, a(i_, Offs + j))
                    Next i_
                End If
            Next j
        Else
            
            '
            ' Compute inverse of lower triangular matrix.
            '
            For j = N - 1# To 0# Step -1
                If Not Isunit Then
                    If C_EqualR(a(Offs + j, Offs + j), 0#) Then
                        Info = -3#
                        Exit Sub
                    End If
                    a(Offs + j, Offs + j) = C_RDiv(1#, a(Offs + j, Offs + j))
                    AJJ = C_Opposite(a(Offs + j, Offs + j))
                Else
                    AJJ = C_Complex(-1#)
                End If
                If j < N - 1# Then
                    
                    '
                    ' Compute elements j+1:n of j-th column.
                    '
                    i1_ = (Offs + j + 1#) - (j + 1#)
                    For i_ = j + 1# To N - 1# Step 1
                        tmp(i_) = a(i_ + i1_, Offs + j)
                    Next i_
                    For i = j + 1# To N - 1# Step 1
                        If i > j + 1# Then
                            i1_ = (j + 1#) - (Offs + j + 1#)
                            V = C_Complex(0#)
                            For i_ = Offs + j + 1# To Offs + i - 1# Step 1
                                V = C_Add(V, C_Mul(a(Offs + i, i_), tmp(i_ + i1_)))
                            Next i_
                        Else
                            V = C_Complex(0#)
                        End If
                        If Not Isunit Then
                            a(Offs + i, Offs + j) = C_Add(V, C_Mul(a(Offs + i, Offs + i), tmp(i)))
                        Else
                            a(Offs + i, Offs + j) = C_Add(V, tmp(i))
                        End If
                    Next i
                    For i_ = Offs + j + 1# To Offs + N - 1# Step 1
                        a(i_, Offs + j) = C_Mul(AJJ, a(i_, Offs + j))
                    Next i_
                End If
            Next j
        End If
        Exit Sub
    End If
    
    '
    ' Recursive case
    '
    Call ABLASComplexSplitLength(a, N, N1, N2)
    If N2 > 0# Then
        If IsUpper Then
            For i = 0# To N1 - 1# Step 1
                For i_ = Offs + N1 To Offs + N - 1# Step 1
                    a(Offs + i, i_) = C_MulR(a(Offs + i, i_), -1)
                Next i_
            Next i
            Call CMatrixLeftTRSM(N1, N2, a, Offs, Offs, IsUpper, Isunit, 0#, a, Offs, Offs + N1)
            Call CMatrixRightTRSM(N1, N2, a, Offs + N1, Offs + N1, IsUpper, Isunit, 0#, a, Offs, Offs + N1)
        Else
            For i = 0# To N2 - 1# Step 1
                For i_ = Offs To Offs + N1 - 1# Step 1
                    a(Offs + N1 + i, i_) = C_MulR(a(Offs + N1 + i, i_), -1)
                Next i_
            Next i
            Call CMatrixRightTRSM(N2, N1, a, Offs, Offs, IsUpper, Isunit, 0#, a, Offs + N1, Offs)
            Call CMatrixLeftTRSM(N2, N1, a, Offs + N1, Offs + N1, IsUpper, Isunit, 0#, a, Offs + N1, Offs)
        End If
        Call CMatrixTRInverseRec(a, Offs + N1, N2, IsUpper, Isunit, tmp, Info, Rep)
    End If
    Call CMatrixTRInverseRec(a, Offs, N1, IsUpper, Isunit, tmp, Info, Rep)
End Sub
Private Sub RMatrixLUInverseRec(ByRef a() As Double, _
         ByVal Offs As Long, _
         ByVal N As Long, _
         ByRef WORK() As Double, _
         ByRef Info As Long, _
         ByRef Rep As MatInvReport)
    Dim i As Long
    Dim IWS As Long
    Dim j As Long
    Dim JB As Long
    Dim JJ As Long
    Dim JP As Long
    Dim K As Long
    Dim V As Double
    Dim N1 As Long
    Dim N2 As Long
    Dim i_ As Long
    Dim i1_ As Long
    If N < 1# Then
        Info = -1#
        Exit Sub
    End If
    
    '
    ' Base case
    '
    If N <= ABLASBlockSize(a) Then
        
        '
        ' Form inv(U)
        '
        Call RMatrixTRInverseRec(a, Offs, N, True, False, WORK, Info, Rep)
        If Info <= 0# Then
            Exit Sub
        End If
        
        '
        ' Solve the equation inv(A)*L = inv(U) for inv(A).
        '
        For j = N - 1# To 0# Step -1
            
            '
            ' Copy current column of L to WORK and replace with zeros.
            '
            For i = j + 1# To N - 1# Step 1
                WORK(i) = a(Offs + i, Offs + j)
                a(Offs + i, Offs + j) = 0#
            Next i
            
            '
            ' Compute current column of inv(A).
            '
            If j < N - 1# Then
                For i = 0# To N - 1# Step 1
                    i1_ = (j + 1#) - (Offs + j + 1#)
                    V = 0#
                    For i_ = Offs + j + 1# To Offs + N - 1# Step 1
                        V = V + a(Offs + i, i_) * WORK(i_ + i1_)
                    Next i_
                    a(Offs + i, Offs + j) = a(Offs + i, Offs + j) - V
                Next i
            End If
        Next j
        Exit Sub
    End If
    
    '
    ' Recursive code:
    '
    '         ( L1      )   ( U1  U12 )
    ' A    =  (         ) * (         )
    '         ( L12  L2 )   (     U2  )
    '
    '         ( W   X )
    ' A^-1 =  (       )
    '         ( Y   Z )
    '
    Call ABLASSplitLength(a, N, N1, N2)
    
    '
    ' X := inv(U1)*U12*inv(U2)
    '
    Call RMatrixLeftTRSM(N1, N2, a, Offs, Offs, True, False, 0#, a, Offs, Offs + N1)
    Call RMatrixRightTRSM(N1, N2, a, Offs + N1, Offs + N1, True, False, 0#, a, Offs, Offs + N1)
    
    '
    ' Y := inv(L2)*L12*inv(L1)
    '
    Call RMatrixLeftTRSM(N2, N1, a, Offs + N1, Offs + N1, False, True, 0#, a, Offs + N1, Offs)
    Call RMatrixRightTRSM(N2, N1, a, Offs, Offs, False, True, 0#, a, Offs + N1, Offs)
    
    '
    ' W := inv(L1*U1)+X*Y
    '
    Call RMatrixLUInverseRec(a, Offs, N1, WORK, Info, Rep)
    If Info <= 0# Then
        Exit Sub
    End If
    Call RMatrixGEMM(N1, N1, N2, 1#, a, Offs, Offs + N1, 0#, a, Offs + N1, Offs, 0#, 1#, a, Offs, Offs)
    
    '
    ' X := -X*inv(L2)
    ' Y := -inv(U2)*Y
    '
    Call RMatrixRightTRSM(N1, N2, a, Offs + N1, Offs + N1, False, True, 0#, a, Offs, Offs + N1)
    For i = 0# To N1 - 1# Step 1
        For i_ = Offs + N1 To Offs + N - 1# Step 1
            a(Offs + i, i_) = -1 * a(Offs + i, i_)
        Next i_
    Next i
    Call RMatrixLeftTRSM(N2, N1, a, Offs + N1, Offs + N1, True, False, 0#, a, Offs + N1, Offs)
    For i = 0# To N2 - 1# Step 1
        For i_ = Offs To Offs + N1 - 1# Step 1
            a(Offs + N1 + i, i_) = -1 * a(Offs + N1 + i, i_)
        Next i_
    Next i
    
    '
    ' Z := inv(L2*U2)
    '
    Call RMatrixLUInverseRec(a, Offs + N1, N2, WORK, Info, Rep)
End Sub
Private Sub CMatrixLUInverseRec(ByRef a() As Complex, _
         ByVal Offs As Long, _
         ByVal N As Long, _
         ByRef WORK() As Complex, _
         ByRef Info As Long, _
         ByRef Rep As MatInvReport)
    Dim i As Long
    Dim IWS As Long
    Dim j As Long
    Dim JB As Long
    Dim JJ As Long
    Dim JP As Long
    Dim K As Long
    Dim V As Complex
    Dim N1 As Long
    Dim N2 As Long
    Dim i_ As Long
    Dim i1_ As Long
    If N < 1# Then
        Info = -1#
        Exit Sub
    End If
    
    '
    ' Base case
    '
    If N <= ABLASComplexBlockSize(a) Then
        
        '
        ' Form inv(U)
        '
        Call CMatrixTRInverseRec(a, Offs, N, True, False, WORK, Info, Rep)
        If Info <= 0# Then
            Exit Sub
        End If
        
        '
        ' Solve the equation inv(A)*L = inv(U) for inv(A).
        '
        For j = N - 1# To 0# Step -1
            
            '
            ' Copy current column of L to WORK and replace with zeros.
            '
            For i = j + 1# To N - 1# Step 1
                WORK(i) = a(Offs + i, Offs + j)
                a(Offs + i, Offs + j) = C_Complex(0#)
            Next i
            
            '
            ' Compute current column of inv(A).
            '
            If j < N - 1# Then
                For i = 0# To N - 1# Step 1
                    i1_ = (j + 1#) - (Offs + j + 1#)
                    V = C_Complex(0#)
                    For i_ = Offs + j + 1# To Offs + N - 1# Step 1
                        V = C_Add(V, C_Mul(a(Offs + i, i_), WORK(i_ + i1_)))
                    Next i_
                    a(Offs + i, Offs + j) = C_Sub(a(Offs + i, Offs + j), V)
                Next i
            End If
        Next j
        Exit Sub
    End If
    
    '
    ' Recursive code:
    '
    '         ( L1      )   ( U1  U12 )
    ' A    =  (         ) * (         )
    '         ( L12  L2 )   (     U2  )
    '
    '         ( W   X )
    ' A^-1 =  (       )
    '         ( Y   Z )
    '
    Call ABLASComplexSplitLength(a, N, N1, N2)
    
    '
    ' X := inv(U1)*U12*inv(U2)
    '
    Call CMatrixLeftTRSM(N1, N2, a, Offs, Offs, True, False, 0#, a, Offs, Offs + N1)
    Call CMatrixRightTRSM(N1, N2, a, Offs + N1, Offs + N1, True, False, 0#, a, Offs, Offs + N1)
    
    '
    ' Y := inv(L2)*L12*inv(L1)
    '
    Call CMatrixLeftTRSM(N2, N1, a, Offs + N1, Offs + N1, False, True, 0#, a, Offs + N1, Offs)
    Call CMatrixRightTRSM(N2, N1, a, Offs, Offs, False, True, 0#, a, Offs + N1, Offs)
    
    '
    ' W := inv(L1*U1)+X*Y
    '
    Call CMatrixLUInverseRec(a, Offs, N1, WORK, Info, Rep)
    If Info <= 0# Then
        Exit Sub
    End If
    Call CMatrixGEMM(N1, N1, N2, C_Complex(1#), a, Offs, Offs + N1, 0#, a, Offs + N1, Offs, 0#, C_Complex(1#), a, Offs, Offs)
    
    '
    ' X := -X*inv(L2)
    ' Y := -inv(U2)*Y
    '
    Call CMatrixRightTRSM(N1, N2, a, Offs + N1, Offs + N1, False, True, 0#, a, Offs, Offs + N1)
    For i = 0# To N1 - 1# Step 1
        For i_ = Offs + N1 To Offs + N - 1# Step 1
            a(Offs + i, i_) = C_MulR(a(Offs + i, i_), -1)
        Next i_
    Next i
    Call CMatrixLeftTRSM(N2, N1, a, Offs + N1, Offs + N1, True, False, 0#, a, Offs + N1, Offs)
    For i = 0# To N2 - 1# Step 1
        For i_ = Offs To Offs + N1 - 1# Step 1
            a(Offs + N1 + i, i_) = C_MulR(a(Offs + N1 + i, i_), -1)
        Next i_
    Next i
    
    '
    ' Z := inv(L2*U2)
    '
    Call CMatrixLUInverseRec(a, Offs + N1, N2, WORK, Info, Rep)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Recursive subroutine for SPD inversion.
'
'  -- ALGLIB routine --
'     10.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub SPDMatrixCholeskyInverseRec(ByRef a() As Double, _
         ByVal Offs As Long, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef tmp() As Double)
    Dim i As Long
    Dim j As Long
    Dim V As Double
    Dim N1 As Long
    Dim N2 As Long
    Dim Info2 As Long
    Dim Rep2 As MatInvReport
    Dim i_ As Long
    Dim i1_ As Long
    If N < 1# Then
        Exit Sub
    End If
    
    '
    ' Base case
    '
    If N <= ABLASBlockSize(a) Then
        Call RMatrixTRInverseRec(a, Offs, N, IsUpper, False, tmp, Info2, Rep2)
        If IsUpper Then
            
            '
            ' Compute the product U * U'.
            ' NOTE: we never assume that diagonal of U is real
            '
            For i = 0# To N - 1# Step 1
                If i = 0# Then
                    
                    '
                    ' 1x1 matrix
                    '
                    a(Offs + i, Offs + i) = Square(a(Offs + i, Offs + i))
                Else
                    
                    '
                    ' (I+1)x(I+1) matrix,
                    '
                    ' ( A11  A12 )   ( A11^H        )   ( A11*A11^H+A12*A12^H  A12*A22^H )
                    ' (          ) * (              ) = (                                )
                    ' (      A22 )   ( A12^H  A22^H )   ( A22*A12^H            A22*A22^H )
                    '
                    ' A11 is IxI, A22 is 1x1.
                    '
                    i1_ = (Offs) - (0#)
                    For i_ = 0# To i - 1# Step 1
                        tmp(i_) = a(i_ + i1_, Offs + i)
                    Next i_
                    For j = 0# To i - 1# Step 1
                        V = a(Offs + j, Offs + i)
                        i1_ = (j) - (Offs + j)
                        For i_ = Offs + j To Offs + i - 1# Step 1
                            a(Offs + j, i_) = a(Offs + j, i_) + V * tmp(i_ + i1_)
                        Next i_
                    Next j
                    V = a(Offs + i, Offs + i)
                    For i_ = Offs To Offs + i - 1# Step 1
                        a(i_, Offs + i) = V * a(i_, Offs + i)
                    Next i_
                    a(Offs + i, Offs + i) = Square(a(Offs + i, Offs + i))
                End If
            Next i
        Else
            
            '
            ' Compute the product L' * L
            ' NOTE: we never assume that diagonal of L is real
            '
            For i = 0# To N - 1# Step 1
                If i = 0# Then
                    
                    '
                    ' 1x1 matrix
                    '
                    a(Offs + i, Offs + i) = Square(a(Offs + i, Offs + i))
                Else
                    
                    '
                    ' (I+1)x(I+1) matrix,
                    '
                    ' ( A11^H  A21^H )   ( A11      )   ( A11^H*A11+A21^H*A21  A21^H*A22 )
                    ' (              ) * (          ) = (                                )
                    ' (        A22^H )   ( A21  A22 )   ( A22^H*A21            A22^H*A22 )
                    '
                    ' A11 is IxI, A22 is 1x1.
                    '
                    i1_ = (Offs) - (0#)
                    For i_ = 0# To i - 1# Step 1
                        tmp(i_) = a(Offs + i, i_ + i1_)
                    Next i_
                    For j = 0# To i - 1# Step 1
                        V = a(Offs + i, Offs + j)
                        i1_ = (0#) - (Offs)
                        For i_ = Offs To Offs + j Step 1
                            a(Offs + j, i_) = a(Offs + j, i_) + V * tmp(i_ + i1_)
                        Next i_
                    Next j
                    V = a(Offs + i, Offs + i)
                    For i_ = Offs To Offs + i - 1# Step 1
                        a(Offs + i, i_) = V * a(Offs + i, i_)
                    Next i_
                    a(Offs + i, Offs + i) = Square(a(Offs + i, Offs + i))
                End If
            Next i
        End If
        Exit Sub
    End If
    
    '
    ' Recursive code: triangular factor inversion merged with
    ' UU' or L'L multiplication
    '
    Call ABLASSplitLength(a, N, N1, N2)
    
    '
    ' form off-diagonal block of trangular inverse
    '
    If IsUpper Then
        For i = 0# To N1 - 1# Step 1
            For i_ = Offs + N1 To Offs + N - 1# Step 1
                a(Offs + i, i_) = -1 * a(Offs + i, i_)
            Next i_
        Next i
        Call RMatrixLeftTRSM(N1, N2, a, Offs, Offs, IsUpper, False, 0#, a, Offs, Offs + N1)
        Call RMatrixRightTRSM(N1, N2, a, Offs + N1, Offs + N1, IsUpper, False, 0#, a, Offs, Offs + N1)
    Else
        For i = 0# To N2 - 1# Step 1
            For i_ = Offs To Offs + N1 - 1# Step 1
                a(Offs + N1 + i, i_) = -1 * a(Offs + N1 + i, i_)
            Next i_
        Next i
        Call RMatrixRightTRSM(N2, N1, a, Offs, Offs, IsUpper, False, 0#, a, Offs + N1, Offs)
        Call RMatrixLeftTRSM(N2, N1, a, Offs + N1, Offs + N1, IsUpper, False, 0#, a, Offs + N1, Offs)
    End If
    
    '
    ' invert first diagonal block
    '
    Call SPDMatrixCholeskyInverseRec(a, Offs, N1, IsUpper, tmp)
    
    '
    ' update first diagonal block with off-diagonal block,
    ' update off-diagonal block
    '
    If IsUpper Then
        Call RMatrixSYRK(N1, N2, 1#, a, Offs, Offs + N1, 0#, 1#, a, Offs, Offs, IsUpper)
        Call RMatrixRightTRSM(N1, N2, a, Offs + N1, Offs + N1, IsUpper, False, 1#, a, Offs, Offs + N1)
    Else
        Call RMatrixSYRK(N1, N2, 1#, a, Offs + N1, Offs, 1#, 1#, a, Offs, Offs, IsUpper)
        Call RMatrixLeftTRSM(N2, N1, a, Offs + N1, Offs + N1, IsUpper, False, 1#, a, Offs + N1, Offs)
    End If
    
    '
    ' invert second diagonal block
    '
    Call SPDMatrixCholeskyInverseRec(a, Offs + N1, N2, IsUpper, tmp)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Recursive subroutine for HPD inversion.
'
'  -- ALGLIB routine --
'     10.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub HPDMatrixCholeskyInverseRec(ByRef a() As Complex, _
         ByVal Offs As Long, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef tmp() As Complex)
    Dim i As Long
    Dim j As Long
    Dim V As Complex
    Dim N1 As Long
    Dim N2 As Long
    Dim Info2 As Long
    Dim Rep2 As MatInvReport
    Dim i_ As Long
    Dim i1_ As Long
    If N < 1# Then
        Exit Sub
    End If
    
    '
    ' Base case
    '
    If N <= ABLASComplexBlockSize(a) Then
        Call CMatrixTRInverseRec(a, Offs, N, IsUpper, False, tmp, Info2, Rep2)
        If IsUpper Then
            
            '
            ' Compute the product U * U'.
            ' NOTE: we never assume that diagonal of U is real
            '
            For i = 0# To N - 1# Step 1
                If i = 0# Then
                    
                    '
                    ' 1x1 matrix
                    '
                    a(Offs + i, Offs + i) = C_Complex(Square(a(Offs + i, Offs + i).x) + Square(a(Offs + i, Offs + i).y))
                Else
                    
                    '
                    ' (I+1)x(I+1) matrix,
                    '
                    ' ( A11  A12 )   ( A11^H        )   ( A11*A11^H+A12*A12^H  A12*A22^H )
                    ' (          ) * (              ) = (                                )
                    ' (      A22 )   ( A12^H  A22^H )   ( A22*A12^H            A22*A22^H )
                    '
                    ' A11 is IxI, A22 is 1x1.
                    '
                    i1_ = (Offs) - (0#)
                    For i_ = 0# To i - 1# Step 1
                        tmp(i_) = Conj(a(i_ + i1_, Offs + i))
                    Next i_
                    For j = 0# To i - 1# Step 1
                        V = a(Offs + j, Offs + i)
                        i1_ = (j) - (Offs + j)
                        For i_ = Offs + j To Offs + i - 1# Step 1
                            a(Offs + j, i_) = C_Add(a(Offs + j, i_), C_Mul(V, tmp(i_ + i1_)))
                        Next i_
                    Next j
                    V = Conj(a(Offs + i, Offs + i))
                    For i_ = Offs To Offs + i - 1# Step 1
                        a(i_, Offs + i) = C_Mul(V, a(i_, Offs + i))
                    Next i_
                    a(Offs + i, Offs + i) = C_Complex(Square(a(Offs + i, Offs + i).x) + Square(a(Offs + i, Offs + i).y))
                End If
            Next i
        Else
            
            '
            ' Compute the product L' * L
            ' NOTE: we never assume that diagonal of L is real
            '
            For i = 0# To N - 1# Step 1
                If i = 0# Then
                    
                    '
                    ' 1x1 matrix
                    '
                    a(Offs + i, Offs + i) = C_Complex(Square(a(Offs + i, Offs + i).x) + Square(a(Offs + i, Offs + i).y))
                Else
                    
                    '
                    ' (I+1)x(I+1) matrix,
                    '
                    ' ( A11^H  A21^H )   ( A11      )   ( A11^H*A11+A21^H*A21  A21^H*A22 )
                    ' (              ) * (          ) = (                                )
                    ' (        A22^H )   ( A21  A22 )   ( A22^H*A21            A22^H*A22 )
                    '
                    ' A11 is IxI, A22 is 1x1.
                    '
                    i1_ = (Offs) - (0#)
                    For i_ = 0# To i - 1# Step 1
                        tmp(i_) = a(Offs + i, i_ + i1_)
                    Next i_
                    For j = 0# To i - 1# Step 1
                        V = Conj(a(Offs + i, Offs + j))
                        i1_ = (0#) - (Offs)
                        For i_ = Offs To Offs + j Step 1
                            a(Offs + j, i_) = C_Add(a(Offs + j, i_), C_Mul(V, tmp(i_ + i1_)))
                        Next i_
                    Next j
                    V = Conj(a(Offs + i, Offs + i))
                    For i_ = Offs To Offs + i - 1# Step 1
                        a(Offs + i, i_) = C_Mul(V, a(Offs + i, i_))
                    Next i_
                    a(Offs + i, Offs + i) = C_Complex(Square(a(Offs + i, Offs + i).x) + Square(a(Offs + i, Offs + i).y))
                End If
            Next i
        End If
        Exit Sub
    End If
    
    '
    ' Recursive code: triangular factor inversion merged with
    ' UU' or L'L multiplication
    '
    Call ABLASComplexSplitLength(a, N, N1, N2)
    
    '
    ' form off-diagonal block of trangular inverse
    '
    If IsUpper Then
        For i = 0# To N1 - 1# Step 1
            For i_ = Offs + N1 To Offs + N - 1# Step 1
                a(Offs + i, i_) = C_MulR(a(Offs + i, i_), -1)
            Next i_
        Next i
        Call CMatrixLeftTRSM(N1, N2, a, Offs, Offs, IsUpper, False, 0#, a, Offs, Offs + N1)
        Call CMatrixRightTRSM(N1, N2, a, Offs + N1, Offs + N1, IsUpper, False, 0#, a, Offs, Offs + N1)
    Else
        For i = 0# To N2 - 1# Step 1
            For i_ = Offs To Offs + N1 - 1# Step 1
                a(Offs + N1 + i, i_) = C_MulR(a(Offs + N1 + i, i_), -1)
            Next i_
        Next i
        Call CMatrixRightTRSM(N2, N1, a, Offs, Offs, IsUpper, False, 0#, a, Offs + N1, Offs)
        Call CMatrixLeftTRSM(N2, N1, a, Offs + N1, Offs + N1, IsUpper, False, 0#, a, Offs + N1, Offs)
    End If
    
    '
    ' invert first diagonal block
    '
    Call HPDMatrixCholeskyInverseRec(a, Offs, N1, IsUpper, tmp)
    
    '
    ' update first diagonal block with off-diagonal block,
    ' update off-diagonal block
    '
    If IsUpper Then
        Call CMatrixSYRK(N1, N2, 1#, a, Offs, Offs + N1, 0#, 1#, a, Offs, Offs, IsUpper)
        Call CMatrixRightTRSM(N1, N2, a, Offs + N1, Offs + N1, IsUpper, False, 2#, a, Offs, Offs + N1)
    Else
        Call CMatrixSYRK(N1, N2, 1#, a, Offs + N1, Offs, 2#, 1#, a, Offs, Offs, IsUpper)
        Call CMatrixLeftTRSM(N2, N1, a, Offs + N1, Offs + N1, IsUpper, False, 2#, a, Offs + N1, Offs)
    End If
    
    '
    ' invert second diagonal block
    '
    Call HPDMatrixCholeskyInverseRec(a, Offs + N1, N2, IsUpper, tmp)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2007, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Generation of a random uniformly distributed (Haar) orthogonal matrix
'
'INPUT PARAMETERS:
'    N   -   matrix size, N>=1
'
'OUTPUT PARAMETERS:
'    A   -   orthogonal NxN matrix, array[0..N-1,0..N-1]
'
'  -- ALGLIB routine --
'     04.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixRndOrthogonal(ByVal N As Long, ByRef a() As Double)
    Dim i As Long
    Dim j As Long
    ReDim a(0# To N - 1#, 0# To N - 1#)
    For i = 0# To N - 1# Step 1
        For j = 0# To N - 1# Step 1
            If i = j Then
                a(i, j) = 1#
            Else
                a(i, j) = 0#
            End If
        Next j
    Next i
    Call RMatrixRndOrthogonalFromTheRight(a, N, N)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Generation of random NxN matrix with given condition number and norm2(A)=1
'
'INPUT PARAMETERS:
'    N   -   matrix size
'    C   -   condition number (in 2-norm)
'
'OUTPUT PARAMETERS:
'    A   -   random matrix with norm2(A)=1 and cond(A)=C
'
'  -- ALGLIB routine --
'     04.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixRndCond(ByVal N As Long, _
         ByVal C As Double, _
         ByRef a() As Double)
    Dim i As Long
    Dim j As Long
    Dim L1 As Double
    Dim L2 As Double
    ReDim a(0# To N - 1#, 0# To N - 1#)
    If N = 1# Then
        
        '
        ' special case
        '
        a(0#, 0#) = 2# * RandomInteger(2#) - 1#
        Exit Sub
    End If
    L1 = 0#
    L2 = Log(1# / C)
    For i = 0# To N - 1# Step 1
        For j = 0# To N - 1# Step 1
            a(i, j) = 0#
        Next j
    Next i
    a(0#, 0#) = Exp(L1)
    For i = 1# To N - 2# Step 1
        a(i, i) = Exp(Rnd() * (L2 - L1) + L1)
    Next i
    a(N - 1#, N - 1#) = Exp(L2)
    Call RMatrixRndOrthogonalFromTheLeft(a, N, N)
    Call RMatrixRndOrthogonalFromTheRight(a, N, N)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Generation of a random Haar distributed orthogonal complex matrix
'
'INPUT PARAMETERS:
'    N   -   matrix size, N>=1
'
'OUTPUT PARAMETERS:
'    A   -   orthogonal NxN matrix, array[0..N-1,0..N-1]
'
'  -- ALGLIB routine --
'     04.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixRndOrthogonal(ByVal N As Long, ByRef a() As Complex)
    Dim i As Long
    Dim j As Long
    ReDim a(0# To N - 1#, 0# To N - 1#)
    For i = 0# To N - 1# Step 1
        For j = 0# To N - 1# Step 1
            If i = j Then
                a(i, j) = C_Complex(1#)
            Else
                a(i, j) = C_Complex(0#)
            End If
        Next j
    Next i
    Call CMatrixRndOrthogonalFromTheRight(a, N, N)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Generation of random NxN complex matrix with given condition number C and
'norm2(A)=1
'
'INPUT PARAMETERS:
'    N   -   matrix size
'    C   -   condition number (in 2-norm)
'
'OUTPUT PARAMETERS:
'    A   -   random matrix with norm2(A)=1 and cond(A)=C
'
'  -- ALGLIB routine --
'     04.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixRndCond(ByVal N As Long, _
         ByVal C As Double, _
         ByRef a() As Complex)
    Dim i As Long
    Dim j As Long
    Dim L1 As Double
    Dim L2 As Double
    Dim State As HQRNDState
    Dim V As Complex
    ReDim a(0# To N - 1#, 0# To N - 1#)
    If N = 1# Then
        
        '
        ' special case
        '
        Call HQRNDRandomize(State)
        Call HQRNDUnit2(State, V.x, V.y)
        a(0#, 0#) = V
        Exit Sub
    End If
    L1 = 0#
    L2 = Log(1# / C)
    For i = 0# To N - 1# Step 1
        For j = 0# To N - 1# Step 1
            a(i, j) = C_Complex(0#)
        Next j
    Next i
    a(0#, 0#) = C_Complex(Exp(L1))
    For i = 1# To N - 2# Step 1
        a(i, i) = C_Complex(Exp(Rnd() * (L2 - L1) + L1))
    Next i
    a(N - 1#, N - 1#) = C_Complex(Exp(L2))
    Call CMatrixRndOrthogonalFromTheLeft(a, N, N)
    Call CMatrixRndOrthogonalFromTheRight(a, N, N)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Generation of random NxN symmetric matrix with given condition number  and
'norm2(A)=1
'
'INPUT PARAMETERS:
'    N   -   matrix size
'    C   -   condition number (in 2-norm)
'
'OUTPUT PARAMETERS:
'    A   -   random matrix with norm2(A)=1 and cond(A)=C
'
'  -- ALGLIB routine --
'     04.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub SMatrixRndCond(ByVal N As Long, _
         ByVal C As Double, _
         ByRef a() As Double)
    Dim i As Long
    Dim j As Long
    Dim L1 As Double
    Dim L2 As Double
    ReDim a(0# To N - 1#, 0# To N - 1#)
    If N = 1# Then
        
        '
        ' special case
        '
        a(0#, 0#) = 2# * RandomInteger(2#) - 1#
        Exit Sub
    End If
    
    '
    ' Prepare matrix
    '
    L1 = 0#
    L2 = Log(1# / C)
    For i = 0# To N - 1# Step 1
        For j = 0# To N - 1# Step 1
            a(i, j) = 0#
        Next j
    Next i
    a(0#, 0#) = Exp(L1)
    For i = 1# To N - 2# Step 1
        a(i, i) = (2# * RandomInteger(2#) - 1#) * Exp(Rnd() * (L2 - L1) + L1)
    Next i
    a(N - 1#, N - 1#) = Exp(L2)
    
    '
    ' Multiply
    '
    Call SMatrixRndMultiply(a, N)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Generation of random NxN symmetric positive definite matrix with given
'condition number and norm2(A)=1
'
'INPUT PARAMETERS:
'    N   -   matrix size
'    C   -   condition number (in 2-norm)
'
'OUTPUT PARAMETERS:
'    A   -   random SPD matrix with norm2(A)=1 and cond(A)=C
'
'  -- ALGLIB routine --
'     04.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub SPDMatrixRndCond(ByVal N As Long, _
         ByVal C As Double, _
         ByRef a() As Double)
    Dim i As Long
    Dim j As Long
    Dim L1 As Double
    Dim L2 As Double
    
    '
    ' Special cases
    '
    If N <= 0# Or C < 1# Then
        Exit Sub
    End If
    ReDim a(0# To N - 1#, 0# To N - 1#)
    If N = 1# Then
        a(0#, 0#) = 1#
        Exit Sub
    End If
    
    '
    ' Prepare matrix
    '
    L1 = 0#
    L2 = Log(1# / C)
    For i = 0# To N - 1# Step 1
        For j = 0# To N - 1# Step 1
            a(i, j) = 0#
        Next j
    Next i
    a(0#, 0#) = Exp(L1)
    For i = 1# To N - 2# Step 1
        a(i, i) = Exp(Rnd() * (L2 - L1) + L1)
    Next i
    a(N - 1#, N - 1#) = Exp(L2)
    
    '
    ' Multiply
    '
    Call SMatrixRndMultiply(a, N)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Generation of random NxN Hermitian matrix with given condition number  and
'norm2(A)=1
'
'INPUT PARAMETERS:
'    N   -   matrix size
'    C   -   condition number (in 2-norm)
'
'OUTPUT PARAMETERS:
'    A   -   random matrix with norm2(A)=1 and cond(A)=C
'
'  -- ALGLIB routine --
'     04.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub HMatrixRndCond(ByVal N As Long, _
         ByVal C As Double, _
         ByRef a() As Complex)
    Dim i As Long
    Dim j As Long
    Dim L1 As Double
    Dim L2 As Double
    ReDim a(0# To N - 1#, 0# To N - 1#)
    If N = 1# Then
        
        '
        ' special case
        '
        a(0#, 0#) = C_Complex(2# * RandomInteger(2#) - 1#)
        Exit Sub
    End If
    
    '
    ' Prepare matrix
    '
    L1 = 0#
    L2 = Log(1# / C)
    For i = 0# To N - 1# Step 1
        For j = 0# To N - 1# Step 1
            a(i, j) = C_Complex(0#)
        Next j
    Next i
    a(0#, 0#) = C_Complex(Exp(L1))
    For i = 1# To N - 2# Step 1
        a(i, i) = C_Complex((2# * RandomInteger(2#) - 1#) * Exp(Rnd() * (L2 - L1) + L1))
    Next i
    a(N - 1#, N - 1#) = C_Complex(Exp(L2))
    
    '
    ' Multiply
    '
    Call HMatrixRndMultiply(a, N)
    
    '
    ' post-process to ensure that matrix diagonal is real
    '
    For i = 0# To N - 1# Step 1
        a(i, i).y = 0#
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Generation of random NxN Hermitian positive definite matrix with given
'condition number and norm2(A)=1
'
'INPUT PARAMETERS:
'    N   -   matrix size
'    C   -   condition number (in 2-norm)
'
'OUTPUT PARAMETERS:
'    A   -   random HPD matrix with norm2(A)=1 and cond(A)=C
'
'  -- ALGLIB routine --
'     04.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub HPDMatrixRndCond(ByVal N As Long, _
         ByVal C As Double, _
         ByRef a() As Complex)
    Dim i As Long
    Dim j As Long
    Dim L1 As Double
    Dim L2 As Double
    
    '
    ' Special cases
    '
    If N <= 0# Or C < 1# Then
        Exit Sub
    End If
    ReDim a(0# To N - 1#, 0# To N - 1#)
    If N = 1# Then
        a(0#, 0#) = C_Complex(1#)
        Exit Sub
    End If
    
    '
    ' Prepare matrix
    '
    L1 = 0#
    L2 = Log(1# / C)
    For i = 0# To N - 1# Step 1
        For j = 0# To N - 1# Step 1
            a(i, j) = C_Complex(0#)
        Next j
    Next i
    a(0#, 0#) = C_Complex(Exp(L1))
    For i = 1# To N - 2# Step 1
        a(i, i) = C_Complex(Exp(Rnd() * (L2 - L1) + L1))
    Next i
    a(N - 1#, N - 1#) = C_Complex(Exp(L2))
    
    '
    ' Multiply
    '
    Call HMatrixRndMultiply(a, N)
    
    '
    ' post-process to ensure that matrix diagonal is real
    '
    For i = 0# To N - 1# Step 1
        a(i, i).y = 0#
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Multiplication of MxN matrix by NxN random Haar distributed orthogonal matrix
'
'INPUT PARAMETERS:
'    A   -   matrix, array[0..M-1, 0..N-1]
'    M, N-   matrix size
'
'OUTPUT PARAMETERS:
'    A   -   A*Q, where Q is random NxN orthogonal matrix
'
'  -- ALGLIB routine --
'     04.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixRndOrthogonalFromTheRight(ByRef a() As Double, _
         ByVal M As Long, _
         ByVal N As Long)
    Dim Tau As Double
    Dim lambda As Double
    Dim s As Long
    Dim i As Long
    Dim U1 As Double
    Dim U2 As Double
    Dim w() As Double
    Dim V() As Double
    Dim State As HQRNDState
    Dim i_ As Long
    If N = 1# Then
        
        '
        ' Special case
        '
        Tau = 2# * RandomInteger(2#) - 1#
        For i = 0# To M - 1# Step 1
            a(i, 0#) = a(i, 0#) * Tau
        Next i
        Exit Sub
    End If
    
    '
    ' General case.
    ' First pass.
    '
    ReDim w(0# To M - 1#)
    ReDim V(1# To N)
    Call HQRNDRandomize(State)
    For s = 2# To N Step 1
        
        '
        ' Prepare random normal v
        '
        Do
            i = 1#
            Do While i <= s
                Call HQRNDNormal2(State, U1, U2)
                V(i) = U1
                If i + 1# <= s Then
                    V(i + 1#) = U2
                End If
                i = i + 2#
            Loop
            lambda = 0#
            For i_ = 1# To s Step 1
                lambda = lambda + V(i_) * V(i_)
            Next i_
        Loop Until lambda <> 0#
        
        '
        ' Prepare and apply reflection
        '
        Call GenerateReflection(V, s, Tau)
        V(1#) = 1#
        Call ApplyReflectionFromTheRight(a, Tau, V, 0#, M - 1#, N - s, N - 1#, w)
    Next s
    
    '
    ' Second pass.
    '
    For i = 0# To N - 1# Step 1
        Tau = 2# * RandomInteger(2#) - 1#
        For i_ = 0# To M - 1# Step 1
            a(i_, i) = Tau * a(i_, i)
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Multiplication of MxN matrix by MxM random Haar distributed orthogonal matrix
'
'INPUT PARAMETERS:
'    A   -   matrix, array[0..M-1, 0..N-1]
'    M, N-   matrix size
'
'OUTPUT PARAMETERS:
'    A   -   Q*A, where Q is random MxM orthogonal matrix
'
'  -- ALGLIB routine --
'     04.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixRndOrthogonalFromTheLeft(ByRef a() As Double, _
         ByVal M As Long, _
         ByVal N As Long)
    Dim Tau As Double
    Dim lambda As Double
    Dim s As Long
    Dim i As Long
    Dim j As Long
    Dim U1 As Double
    Dim U2 As Double
    Dim w() As Double
    Dim V() As Double
    Dim State As HQRNDState
    Dim i_ As Long
    If M = 1# Then
        
        '
        ' special case
        '
        Tau = 2# * RandomInteger(2#) - 1#
        For j = 0# To N - 1# Step 1
            a(0#, j) = a(0#, j) * Tau
        Next j
        Exit Sub
    End If
    
    '
    ' General case.
    ' First pass.
    '
    ReDim w(0# To N - 1#)
    ReDim V(1# To M)
    Call HQRNDRandomize(State)
    For s = 2# To M Step 1
        
        '
        ' Prepare random normal v
        '
        Do
            i = 1#
            Do While i <= s
                Call HQRNDNormal2(State, U1, U2)
                V(i) = U1
                If i + 1# <= s Then
                    V(i + 1#) = U2
                End If
                i = i + 2#
            Loop
            lambda = 0#
            For i_ = 1# To s Step 1
                lambda = lambda + V(i_) * V(i_)
            Next i_
        Loop Until lambda <> 0#
        
        '
        ' Prepare and apply reflection
        '
        Call GenerateReflection(V, s, Tau)
        V(1#) = 1#
        Call ApplyReflectionFromTheLeft(a, Tau, V, M - s, M - 1#, 0#, N - 1#, w)
    Next s
    
    '
    ' Second pass.
    '
    For i = 0# To M - 1# Step 1
        Tau = 2# * RandomInteger(2#) - 1#
        For i_ = 0# To N - 1# Step 1
            a(i, i_) = Tau * a(i, i_)
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Multiplication of MxN complex matrix by NxN random Haar distributed
'complex orthogonal matrix
'
'INPUT PARAMETERS:
'    A   -   matrix, array[0..M-1, 0..N-1]
'    M, N-   matrix size
'
'OUTPUT PARAMETERS:
'    A   -   A*Q, where Q is random NxN orthogonal matrix
'
'  -- ALGLIB routine --
'     04.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixRndOrthogonalFromTheRight(ByRef a() As Complex, _
         ByVal M As Long, _
         ByVal N As Long)
    Dim lambda As Complex
    Dim Tau As Complex
    Dim s As Long
    Dim i As Long
    Dim w() As Complex
    Dim V() As Complex
    Dim State As HQRNDState
    Dim i_ As Long
    If N = 1# Then
        
        '
        ' Special case
        '
        Call HQRNDRandomize(State)
        Call HQRNDUnit2(State, Tau.x, Tau.y)
        For i = 0# To M - 1# Step 1
            a(i, 0#) = C_Mul(a(i, 0#), Tau)
        Next i
        Exit Sub
    End If
    
    '
    ' General case.
    ' First pass.
    '
    ReDim w(0# To M - 1#)
    ReDim V(1# To N)
    Call HQRNDRandomize(State)
    For s = 2# To N Step 1
        
        '
        ' Prepare random normal v
        '
        Do
            For i = 1# To s Step 1
                Call HQRNDNormal2(State, Tau.x, Tau.y)
                V(i) = Tau
            Next i
            lambda = C_Complex(0#)
            For i_ = 1# To s Step 1
                lambda = C_Add(lambda, C_Mul(V(i_), Conj(V(i_))))
            Next i_
        Loop Until C_NotEqualR(lambda, 0#)
        
        '
        ' Prepare and apply reflection
        '
        Call ComplexGenerateReflection(V, s, Tau)
        V(1#) = C_Complex(1#)
        Call ComplexApplyReflectionFromTheRight(a, Tau, V, 0#, M - 1#, N - s, N - 1#, w)
    Next s
    
    '
    ' Second pass.
    '
    For i = 0# To N - 1# Step 1
        Call HQRNDUnit2(State, Tau.x, Tau.y)
        For i_ = 0# To M - 1# Step 1
            a(i_, i) = C_Mul(Tau, a(i_, i))
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Multiplication of MxN complex matrix by MxM random Haar distributed
'complex orthogonal matrix
'
'INPUT PARAMETERS:
'    A   -   matrix, array[0..M-1, 0..N-1]
'    M, N-   matrix size
'
'OUTPUT PARAMETERS:
'    A   -   Q*A, where Q is random MxM orthogonal matrix
'
'  -- ALGLIB routine --
'     04.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixRndOrthogonalFromTheLeft(ByRef a() As Complex, _
         ByVal M As Long, _
         ByVal N As Long)
    Dim Tau As Complex
    Dim lambda As Complex
    Dim s As Long
    Dim i As Long
    Dim j As Long
    Dim w() As Complex
    Dim V() As Complex
    Dim State As HQRNDState
    Dim i_ As Long
    If M = 1# Then
        
        '
        ' special case
        '
        Call HQRNDRandomize(State)
        Call HQRNDUnit2(State, Tau.x, Tau.y)
        For j = 0# To N - 1# Step 1
            a(0#, j) = C_Mul(a(0#, j), Tau)
        Next j
        Exit Sub
    End If
    
    '
    ' General case.
    ' First pass.
    '
    ReDim w(0# To N - 1#)
    ReDim V(1# To M)
    Call HQRNDRandomize(State)
    For s = 2# To M Step 1
        
        '
        ' Prepare random normal v
        '
        Do
            For i = 1# To s Step 1
                Call HQRNDNormal2(State, Tau.x, Tau.y)
                V(i) = Tau
            Next i
            lambda = C_Complex(0#)
            For i_ = 1# To s Step 1
                lambda = C_Add(lambda, C_Mul(V(i_), Conj(V(i_))))
            Next i_
        Loop Until C_NotEqualR(lambda, 0#)
        
        '
        ' Prepare and apply reflection
        '
        Call ComplexGenerateReflection(V, s, Tau)
        V(1#) = C_Complex(1#)
        Call ComplexApplyReflectionFromTheLeft(a, Tau, V, M - s, M - 1#, 0#, N - 1#, w)
    Next s
    
    '
    ' Second pass.
    '
    For i = 0# To M - 1# Step 1
        Call HQRNDUnit2(State, Tau.x, Tau.y)
        For i_ = 0# To N - 1# Step 1
            a(i, i_) = C_Mul(Tau, a(i, i_))
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Symmetric multiplication of NxN matrix by random Haar distributed
'orthogonal  matrix
'
'INPUT PARAMETERS:
'    A   -   matrix, array[0..N-1, 0..N-1]
'    N   -   matrix size
'
'OUTPUT PARAMETERS:
'    A   -   Q'*A*Q, where Q is random NxN orthogonal matrix
'
'  -- ALGLIB routine --
'     04.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub SMatrixRndMultiply(ByRef a() As Double, ByVal N As Long)
    Dim Tau As Double
    Dim lambda As Double
    Dim s As Long
    Dim i As Long
    Dim U1 As Double
    Dim U2 As Double
    Dim w() As Double
    Dim V() As Double
    Dim State As HQRNDState
    Dim i_ As Long
    
    '
    ' General case.
    '
    ReDim w(0# To N - 1#)
    ReDim V(1# To N)
    Call HQRNDRandomize(State)
    For s = 2# To N Step 1
        
        '
        ' Prepare random normal v
        '
        Do
            i = 1#
            Do While i <= s
                Call HQRNDNormal2(State, U1, U2)
                V(i) = U1
                If i + 1# <= s Then
                    V(i + 1#) = U2
                End If
                i = i + 2#
            Loop
            lambda = 0#
            For i_ = 1# To s Step 1
                lambda = lambda + V(i_) * V(i_)
            Next i_
        Loop Until lambda <> 0#
        
        '
        ' Prepare and apply reflection
        '
        Call GenerateReflection(V, s, Tau)
        V(1#) = 1#
        Call ApplyReflectionFromTheRight(a, Tau, V, 0#, N - 1#, N - s, N - 1#, w)
        Call ApplyReflectionFromTheLeft(a, Tau, V, N - s, N - 1#, 0#, N - 1#, w)
    Next s
    
    '
    ' Second pass.
    '
    For i = 0# To N - 1# Step 1
        Tau = 2# * RandomInteger(2#) - 1#
        For i_ = 0# To N - 1# Step 1
            a(i_, i) = Tau * a(i_, i)
        Next i_
        For i_ = 0# To N - 1# Step 1
            a(i, i_) = Tau * a(i, i_)
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Hermitian multiplication of NxN matrix by random Haar distributed
'complex orthogonal matrix
'
'INPUT PARAMETERS:
'    A   -   matrix, array[0..N-1, 0..N-1]
'    N   -   matrix size
'
'OUTPUT PARAMETERS:
'    A   -   Q^H*A*Q, where Q is random NxN orthogonal matrix
'
'  -- ALGLIB routine --
'     04.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub HMatrixRndMultiply(ByRef a() As Complex, ByVal N As Long)
    Dim Tau As Complex
    Dim lambda As Complex
    Dim s As Long
    Dim i As Long
    Dim w() As Complex
    Dim V() As Complex
    Dim State As HQRNDState
    Dim i_ As Long
    
    '
    ' General case.
    '
    ReDim w(0# To N - 1#)
    ReDim V(1# To N)
    Call HQRNDRandomize(State)
    For s = 2# To N Step 1
        
        '
        ' Prepare random normal v
        '
        Do
            For i = 1# To s Step 1
                Call HQRNDNormal2(State, Tau.x, Tau.y)
                V(i) = Tau
            Next i
            lambda = C_Complex(0#)
            For i_ = 1# To s Step 1
                lambda = C_Add(lambda, C_Mul(V(i_), Conj(V(i_))))
            Next i_
        Loop Until C_NotEqualR(lambda, 0#)
        
        '
        ' Prepare and apply reflection
        '
        Call ComplexGenerateReflection(V, s, Tau)
        V(1#) = C_Complex(1#)
        Call ComplexApplyReflectionFromTheRight(a, Tau, V, 0#, N - 1#, N - s, N - 1#, w)
        Call ComplexApplyReflectionFromTheLeft(a, Conj(Tau), V, N - s, N - 1#, 0#, N - 1#, w)
    Next s
    
    '
    ' Second pass.
    '
    For i = 0# To N - 1# Step 1
        Call HQRNDUnit2(State, Tau.x, Tau.y)
        For i_ = 0# To N - 1# Step 1
            a(i_, i) = C_Mul(Tau, a(i_, i))
        Next i_
        Tau = Conj(Tau)
        For i_ = 0# To N - 1# Step 1
            a(i, i_) = C_Mul(Tau, a(i, i_))
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2005-2007, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Determinant calculation of the matrix given by its LU decomposition.
'
'Input parameters:
'    A       -   LU decomposition of the matrix (output of
'                RMatrixLU subroutine).
'    Pivots  -   table of permutations which were made during
'                the LU decomposition.
'                Output of RMatrixLU subroutine.
'    N       -   size of matrix A.
'
'Result: matrix determinant.
'
'  -- ALGLIB --
'     Copyright 2005 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function RMatrixLUDet(ByRef a() As Double, _
         ByRef Pivots() As Long, _
         ByVal N As Long) As Double
    Dim Result As Double
    Dim i As Long
    Dim s As Long
    Result = 1#
    s = 1#
    For i = 0# To N - 1# Step 1
        Result = Result * a(i, i)
        If Pivots(i) <> i Then
            s = -s
        End If
    Next i
    Result = Result * s
    RMatrixLUDet = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Calculation of the determinant of a general matrix
'
'Input parameters:
'    A       -   matrix, array[0..N-1, 0..N-1]
'    N       -   size of matrix A.
'
'Result: determinant of matrix A.
'
'  -- ALGLIB --
'     Copyright 2005 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function RMatrixDet(ByRef A_() As Double, ByVal N As Long) As Double
    Dim Result As Double
    Dim a() As Double
    Dim Pivots() As Long
    a = A_
    Call RMatrixLU(a, N, N, Pivots)
    Result = RMatrixLUDet(a, Pivots, N)
    RMatrixDet = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Determinant calculation of the matrix given by its LU decomposition.
'
'Input parameters:
'    A       -   LU decomposition of the matrix (output of
'                RMatrixLU subroutine).
'    Pivots  -   table of permutations which were made during
'                the LU decomposition.
'                Output of RMatrixLU subroutine.
'    N       -   size of matrix A.
'
'Result: matrix determinant.
'
'  -- ALGLIB --
'     Copyright 2005 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function CMatrixLUDet(ByRef a() As Complex, _
         ByRef Pivots() As Long, _
         ByVal N As Long) As Complex
    Dim Result As Complex
    Dim i As Long
    Dim s As Long
    Result = C_Complex(1#)
    s = 1#
    For i = 0# To N - 1# Step 1
        Result = C_Mul(Result, a(i, i))
        If Pivots(i) <> i Then
            s = -s
        End If
    Next i
    Result = C_MulR(Result, s)
    CMatrixLUDet = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Calculation of the determinant of a general matrix
'
'Input parameters:
'    A       -   matrix, array[0..N-1, 0..N-1]
'    N       -   size of matrix A.
'
'Result: determinant of matrix A.
'
'  -- ALGLIB --
'     Copyright 2005 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function CMatrixDet(ByRef A_() As Complex, ByVal N As Long) As Complex
    Dim Result As Complex
    Dim a() As Complex
    Dim Pivots() As Long
    a = A_
    Call CMatrixLU(a, N, N, Pivots)
    Result = CMatrixLUDet(a, Pivots, N)
    CMatrixDet = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Determinant calculation of the matrix given by the Cholesky decomposition.
'
'Input parameters:
'    A   -   Cholesky decomposition,
'            output of SMatrixCholesky subroutine.
'    N   -   size of matrix A.
'
'As the determinant is equal to the product of squares of diagonal elements,
'its not necessary to specify which triangle - lower or upper - the matrix
'is stored in.
'
'Result:
'    matrix determinant.
'
'  -- ALGLIB --
'     Copyright 2005-2008 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function SPDMatrixCholeskyDet(ByRef a() As Double, _
         ByVal N As Long) As Double
    Dim Result As Double
    Dim i As Long
    Result = 1#
    For i = 0# To N - 1# Step 1
        Result = Result * Square(a(i, i))
    Next i
    SPDMatrixCholeskyDet = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Determinant calculation of the symmetric positive definite matrix.
'
'Input parameters:
'    A       -   matrix. Array with elements [0..N-1, 0..N-1].
'    N       -   size of matrix A.
'    IsUpper -   if IsUpper = True, then the symmetric matrix A is given by
'                its upper triangle, and the lower triangle isnt used by
'                subroutine. Similarly, if IsUpper = False, then A is given
'                by its lower triangle.
'
'Result:
'    determinant of matrix A.
'    If matrix A is not positive definite, then subroutine returns -1.
'
'  -- ALGLIB --
'     Copyright 2005-2008 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function SPDMatrixDet(ByRef A_() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean) As Double
    Dim Result As Double
    Dim a() As Double
    a = A_
    If Not SPDMatrixCholesky(a, N, IsUpper) Then
        Result = -1#
    Else
        Result = SPDMatrixCholeskyDet(a, N)
    End If
    SPDMatrixDet = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 1992-2007 The University of Tennessee.  All rights reserved.
'
'Contributors:
'    * Sergey Bochkanov (ALGLIB project). Translation from FORTRAN to
'      pseudocode.
'
'See subroutines comments for additional copyrights.
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'LDLTDecomposition of a symmetric matrix
'
'The algorithm represents a symmetric matrix (which is not necessarily
'positive definite) as A=L*D*L' or A = U*D*U', where D is a block-diagonal
'matrix with blocks 1x1 or 2x2, matrix L (matrix U) is a product of lower
'(upper) triangular matrices with unit diagonal and permutation matrices.
'
'Input parameters:
'    A       -   factorized matrix, array with elements [0..N-1, 0..N-1].
'                If IsUpper  True, then the upper triangle contains
'                elements of symmetric matrix A, and the lower triangle is
'                not used.
'                The same applies if IsUpper = False.
'    N       -   size of factorized matrix.
'    IsUpper -   parameter which shows a method of matrix definition (lower
'                or upper triangle).
'
'Output parameters:
'    A       -   matrices D and U, if IsUpper = True, or L, if IsUpper = False,
'                in compact form, replacing the upper (lower) triangle of
'                matrix A. In that case, the elements under (over) the main
'                diagonal are not used nor modified.
'    Pivots  -   tables of performed permutations (see below).
'
'If IsUpper = True, then A = U*D*U', U = P(n)*U(n)*...*P(k)*U(k), where
'P(k) is the permutation matrix, U(k) - upper triangular matrix with its
'unit main diagonal and k decreases from n with step s which is equal to
'1 or 2 (according to the size of the blocks of matrix D).
'
'        (   I    v    0   )   k-s+1
'U(k) =  (   0    I    0   )   s
'        (   0    0    I   )   n-k-1
'           k-s+1 s   n-k-1
'
'If Pivots[k]>=0, then s=1, P(k) - permutation of rows k and Pivots[k], the
'vectorv forming matrix U(k) is stored in elements A(0:k-1,k), D(k) replaces
'A(k,k). If Pivots[k]=Pivots[k-1]<0 then s=2, P(k) - permutation of rows k-1
'and N+Pivots[k-1], the vector v forming matrix U(k) is stored in elements
'A(0:k-1,k:k+1), the upper triangle of block D(k) is stored in A(k,k),
'A(k,k+1) and A(k+1,k+1).
'
'If IsUpper = False, then A = L*D*L', L=P(0)*L(0)*...*P(k)*L(k), where P(k)
'is the permutation matrix, L(k)  lower triangular matrix with unit main
'diagonal and k decreases from 1 with step s which is equal to 1 or 2
'(according to the size of the blocks of matrix D).
'
'        (   I    0     0   )  k-1
'L(k) =  (   0    I     0   )  s
'        (   0    v     I   )  n-k-s+1
'           k-1   s  n-k-s+1
'
'If Pivots[k]>=0 then s=1, P(k)  permutation of rows k and Pivots[k], the
'vector v forming matrix L(k) is stored in elements A(k+1:n-1,k), D(k)
'replaces A(k,k). If Pivots[k]=Pivots[k+1]<0 then s=2, P(k) - permutation
'of rows k+1 and N+Pivots[k+1], the vector v forming matrix L(k) is stored
'in elements A(k+2:n-1,k:k+1), the lower triangle of block D(k) is stored in
'A(k,k), A(k+1,k) and A(k+1,k+1).
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     June 30, 1999
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub SMatrixLDLT(ByRef a() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef Pivots() As Long)
    Dim i As Long
    Dim IMAX As Long
    Dim j As Long
    Dim JMax As Long
    Dim K As Long
    Dim KK As Long
    Dim KP As Long
    Dim KSTEP As Long
    Dim ABSAKK As Double
    Dim alpha As Double
    Dim COLMAX As Double
    Dim D11 As Double
    Dim D12 As Double
    Dim D21 As Double
    Dim D22 As Double
    Dim R1 As Double
    Dim ROWMAX As Double
    Dim t As Double
    Dim WK As Double
    Dim WKM1 As Double
    Dim WKP1 As Double
    Dim II As Long
    Dim I1 As Long
    Dim I2 As Long
    Dim VV As Double
    Dim temp() As Double
    Dim i_ As Long
    ReDim Pivots(0# To N - 1#)
    ReDim temp(0# To N - 1#)
    '
    ' Initialize ALPHA for use in choosing pivot block size.
    '
    alpha = (1# + Sqr(17#)) / 8#
    If IsUpper Then
        '
        ' Factorize A as U*D*U' using the upper triangle of A
        '
        '
        ' K is the main loop index, decreasing from N to 1 in steps of
        ' 1 or 2
        '
        K = N - 1#
        Do While K >= 0#
            KSTEP = 1#
            '
            ' Determine rows and columns to be interchanged and whether
            ' a 1-by-1 or 2-by-2 pivot block will be used
            '
            ABSAKK = Abs(a(K, K))
            '
            ' IMAX is the row-index of the largest off-diagonal element in
            ' column K+1, and COLMAX is its absolute value
            '
            If K > 0# Then
                IMAX = 1#
                For II = 2# To K Step 1
                    If Abs(a(II - 1#, K)) > Abs(a(IMAX - 1#, K)) Then
                        IMAX = II
                    End If
                Next II
                COLMAX = Abs(a(IMAX - 1#, K))
            Else
                COLMAX = 0#
            End If
            If MaxReal(ABSAKK, COLMAX) = 0# Then
                '
                ' Column K is zero
                '
                KP = K
            Else
                If ABSAKK >= alpha * COLMAX Then
                    '
                    ' no interchange, use 1-by-1 pivot block
                    '
                    KP = K
                Else
                    '
                    ' JMAX is the column-index of the largest off-diagonal
                    ' element in row IMAX, and ROWMAX is its absolute value
                    '
                    JMax = IMAX + 1#
                    For II = IMAX + 2# To K + 1# Step 1
                        If Abs(a(IMAX - 1#, II - 1#)) > Abs(a(IMAX - 1#, JMax - 1#)) Then
                            JMax = II
                        End If
                    Next II
                    ROWMAX = Abs(a(IMAX - 1#, JMax - 1#))
                    If IMAX > 1# Then
                        JMax = 1#
                        For II = 2# To IMAX - 1# Step 1
                            If Abs(a(II - 1#, IMAX - 1#)) > Abs(a(JMax - 1#, IMAX - 1#)) Then
                                JMax = II
                            End If
                        Next II
                        ROWMAX = MaxReal(ROWMAX, Abs(a(JMax - 1#, IMAX - 1#)))
                    End If
                    VV = COLMAX / ROWMAX
                    If ABSAKK >= alpha * COLMAX * VV Then
                        '
                        ' no interchange, use 1-by-1 pivot block
                        '
                        KP = K
                    Else
                        If Abs(a(IMAX - 1#, IMAX - 1#)) >= alpha * ROWMAX Then
                            '
                            ' interchange rows and columns K and IMAX, use 1-by-1
                            ' pivot block
                            '
                            KP = IMAX - 1#
                        Else
                            '
                            ' interchange rows and columns K-1 and IMAX, use 2-by-2
                            ' pivot block
                            '
                            KP = IMAX - 1#
                            KSTEP = 2#
                        End If
                    End If
                End If
                KK = K + 1# - KSTEP
                If KP + 1# <> KK + 1# Then
                    '
                    ' Interchange rows and columns KK and KP+1 in the leading
                    ' submatrix A(0:K,0:K)
                    '
                    For i_ = 0# To KP - 1# Step 1
                        temp(i_) = a(i_, KK)
                    Next i_
                    For i_ = 0# To KP - 1# Step 1
                        a(i_, KK) = a(i_, KP)
                    Next i_
                    For i_ = 0# To KP - 1# Step 1
                        a(i_, KP) = temp(i_)
                    Next i_
                    For i_ = KP + 1# To KK - 1# Step 1
                        temp(i_) = a(i_, KK)
                    Next i_
                    For i_ = KP + 1# To KK - 1# Step 1
                        a(i_, KK) = a(KP, i_)
                    Next i_
                    For i_ = KP + 1# To KK - 1# Step 1
                        a(KP, i_) = temp(i_)
                    Next i_
                    t = a(KK, KK)
                    a(KK, KK) = a(KP, KP)
                    a(KP, KP) = t
                    If KSTEP = 2# Then
                        t = a(K - 1#, K)
                        a(K - 1#, K) = a(KP, K)
                        a(KP, K) = t
                    End If
                End If
                '
                ' Update the leading submatrix
                '
                If KSTEP = 1# Then
                    '
                    ' 1-by-1 pivot block D(k): column k now holds
                    '
                    ' W(k) = U(k)*D(k)
                    '
                    ' where U(k) is the k-th column of U
                    '
                    ' Perform a rank-1 update of A(1:k-1,1:k-1) as
                    '
                    ' A := A - U(k)*D(k)*U(k)' = A - W(k)*1/D(k)*W(k)'
                    '
                    R1 = 1# / a(K, K)
                    For i = 0# To K - 1# Step 1
                        VV = -(R1 * a(i, K))
                        For i_ = i To K - 1# Step 1
                            a(i, i_) = a(i, i_) + VV * a(i_, K)
                        Next i_
                    Next i
                    '
                    ' Store U(K+1) in column K+1
                    '
                    For i_ = 0# To K - 1# Step 1
                        a(i_, K) = R1 * a(i_, K)
                    Next i_
                Else
                    '
                    ' 2-by-2 pivot block D(k): columns k and k-1 now hold
                    '
                    ' ( W(k-1) W(k) ) = ( U(k-1) U(k) )*D(k)
                    '
                    ' where U(k) and U(k-1) are the k-th and (k-1)-th columns
                    ' of U
                    '
                    ' Perform a rank-2 update of A(1:k-2,1:k-2) as
                    '
                    ' A := A - ( U(k-1) U(k) )*D(k)*( U(k-1) U(k) )'
                    '    = A - ( W(k-1) W(k) )*inv(D(k))*( W(k-1) W(k) )'
                    '
                    If K > 1# Then
                        D12 = a(K - 1#, K)
                        D22 = a(K - 1#, K - 1#) / D12
                        D11 = a(K, K) / D12
                        t = 1# / (D11 * D22 - 1#)
                        D12 = t / D12
                        For j = K - 2# To 0# Step -1
                            WKM1 = D12 * (D11 * a(j, K - 1#) - a(j, K))
                            WK = D12 * (D22 * a(j, K) - a(j, K - 1#))
                            For i_ = 0# To j Step 1
                                a(i_, j) = a(i_, j) - WK * a(i_, K)
                            Next i_
                            For i_ = 0# To j Step 1
                                a(i_, j) = a(i_, j) - WKM1 * a(i_, K - 1#)
                            Next i_
                            a(j, K) = WK
                            a(j, K - 1#) = WKM1
                        Next j
                    End If
                End If
            End If
            '
            ' Store details of the interchanges in IPIV
            '
            If KSTEP = 1# Then
                Pivots(K) = KP
            Else
                Pivots(K) = KP - N
                Pivots(K - 1#) = KP - N
            End If
            '
            ' Decrease K+1 and return to the start of the main loop
            '
            K = K - KSTEP
        Loop
    Else
        '
        ' Factorize A as L*D*L' using the lower triangle of A
        '
        ' K+1 is the main loop index, increasing from 1 to N in steps of
        ' 1 or 2
        '
        K = 0#
        Do While K <= N - 1#
            KSTEP = 1#
            '
            ' Determine rows and columns to be interchanged and whether
            ' a 1-by-1 or 2-by-2 pivot block will be used
            '
            ABSAKK = Abs(a(K, K))
            '
            ' IMAX is the row-index of the largest off-diagonal element in
            ' column K+1, and COLMAX is its absolute value
            '
            If K < N - 1# Then
                IMAX = K + 1# + 1#
                For II = K + 1# + 2# To N Step 1
                    If Abs(a(II - 1#, K)) > Abs(a(IMAX - 1#, K)) Then
                        IMAX = II
                    End If
                Next II
                COLMAX = Abs(a(IMAX - 1#, K))
            Else
                COLMAX = 0#
            End If
            If MaxReal(ABSAKK, COLMAX) = 0# Then
                '
                ' Column K+1 is zero
                '
                KP = K
            Else
                If ABSAKK >= alpha * COLMAX Then
                    '
                    ' no interchange, use 1-by-1 pivot block
                    '
                    KP = K
                Else
                    '
                    ' JMAX is the column-index of the largest off-diagonal
                    ' element in row IMAX, and ROWMAX is its absolute value
                    '
                    JMax = K + 1#
                    For II = K + 1# + 1# To IMAX - 1# Step 1
                        If Abs(a(IMAX - 1#, II - 1#)) > Abs(a(IMAX - 1#, JMax - 1#)) Then
                            JMax = II
                        End If
                    Next II
                    ROWMAX = Abs(a(IMAX - 1#, JMax - 1#))
                    If IMAX < N Then
                        JMax = IMAX + 1#
                        For II = IMAX + 2# To N Step 1
                            If Abs(a(II - 1#, IMAX - 1#)) > Abs(a(JMax - 1#, IMAX - 1#)) Then
                                JMax = II
                            End If
                        Next II
                        ROWMAX = MaxReal(ROWMAX, Abs(a(JMax - 1#, IMAX - 1#)))
                    End If
                    VV = COLMAX / ROWMAX
                    If ABSAKK >= alpha * COLMAX * VV Then
                        '
                        ' no interchange, use 1-by-1 pivot block
                        '
                        KP = K
                    Else
                        If Abs(a(IMAX - 1#, IMAX - 1#)) >= alpha * ROWMAX Then
                            '
                            ' interchange rows and columns K+1 and IMAX, use 1-by-1
                            ' pivot block
                            '
                            KP = IMAX - 1#
                        Else
                            '
                            ' interchange rows and columns K+1+1 and IMAX, use 2-by-2
                            ' pivot block
                            '
                            KP = IMAX - 1#
                            KSTEP = 2#
                        End If
                    End If
                End If
                KK = K + KSTEP - 1#
                If KP <> KK Then
                    '
                    '              Interchange rows and columns KK+1 and KP+1 in the trailing
                    '              submatrix A(K+1:n,K+1:n)
                    '
                    If KP + 1# < N Then
                        For i_ = KP + 1# To N - 1# Step 1
                            temp(i_) = a(i_, KK)
                        Next i_
                        For i_ = KP + 1# To N - 1# Step 1
                            a(i_, KK) = a(i_, KP)
                        Next i_
                        For i_ = KP + 1# To N - 1# Step 1
                            a(i_, KP) = temp(i_)
                        Next i_
                    End If
                    For i_ = KK + 1# To KP - 1# Step 1
                        temp(i_) = a(i_, KK)
                    Next i_
                    For i_ = KK + 1# To KP - 1# Step 1
                        a(i_, KK) = a(KP, i_)
                    Next i_
                    For i_ = KK + 1# To KP - 1# Step 1
                        a(KP, i_) = temp(i_)
                    Next i_
                    t = a(KK, KK)
                    a(KK, KK) = a(KP, KP)
                    a(KP, KP) = t
                    If KSTEP = 2# Then
                        t = a(K + 1#, K)
                        a(K + 1#, K) = a(KP, K)
                        a(KP, K) = t
                    End If
                End If
                '
                ' Update the trailing submatrix
                '
                If KSTEP = 1# Then
                    '
                    ' 1-by-1 pivot block D(K+1): column K+1 now holds
                    '
                    ' W(K+1) = L(K+1)*D(K+1)
                    '
                    ' where L(K+1) is the K+1-th column of L
                    '
                    If K + 1# < N Then
                        '
                        ' Perform a rank-1 update of A(K+1+1:n,K+1+1:n) as
                        '
                        ' A := A - L(K+1)*D(K+1)*L(K+1)' = A - W(K+1)*(1/D(K+1))*W(K+1)'
                        '
                        D11 = 1# / a(K + 1# - 1#, K + 1# - 1#)
                        For II = K + 1# To N - 1# Step 1
                            VV = -(D11 * a(II, K))
                            For i_ = K + 1# To II Step 1
                                a(II, i_) = a(II, i_) + VV * a(i_, K)
                            Next i_
                        Next II
                        '
                        ' Store L(K+1) in column K+1
                        '
                        For i_ = K + 1# To N - 1# Step 1
                            a(i_, K) = D11 * a(i_, K)
                        Next i_
                    End If
                Else
                    '
                    ' 2-by-2 pivot block D(K+1)
                    '
                    If K < N - 2# Then
                        '
                        ' Perform a rank-2 update of A(K+1+2:n,K+1+2:n) as
                        '
                        ' A := A - ( (A(K+1) A(K+1+1))*D(K+1)**(-1) ) * (A(K+1) A(K+1+1))'
                        '
                        ' where L(K+1) and L(K+1+1) are the K+1-th and (K+1+1)-th
                        ' columns of L
                        '
                        D21 = a(K + 1#, K)
                        D11 = a(K + 1#, K + 1#) / D21
                        D22 = a(K, K) / D21
                        t = 1# / (D11 * D22 - 1#)
                        D21 = t / D21
                        For j = K + 2# To N - 1# Step 1
                            WK = D21 * (D11 * a(j, K) - a(j, K + 1#))
                            WKP1 = D21 * (D22 * a(j, K + 1#) - a(j, K))
                            For i_ = j To N - 1# Step 1
                                a(i_, j) = a(i_, j) - WK * a(i_, K)
                            Next i_
                            For i_ = j To N - 1# Step 1
                                a(i_, j) = a(i_, j) - WKP1 * a(i_, K + 1#)
                            Next i_
                            a(j, K) = WK
                            a(j, K + 1#) = WKP1
                        Next j
                    End If
                End If
            End If
            '
            ' Store details of the interchanges in IPIV
            '
            If KSTEP = 1# Then
                Pivots(K + 1# - 1#) = KP + 1# - 1#
            Else
                Pivots(K + 1# - 1#) = KP + 1# - 1# - N
                Pivots(K + 1# + 1# - 1#) = KP + 1# - 1# - N
            End If
            '
            ' Increase K+1 and return to the start of the main loop
            '
            K = K + KSTEP
        Loop
    End If
End Sub
Public Sub LDLTDecomposition(ByRef a() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef Pivots() As Long)
    Dim i As Long
    Dim IMAX As Long
    Dim j As Long
    Dim JMax As Long
    Dim K As Long
    Dim KK As Long
    Dim KP As Long
    Dim KSTEP As Long
    Dim ABSAKK As Double
    Dim alpha As Double
    Dim COLMAX As Double
    Dim D11 As Double
    Dim D12 As Double
    Dim D21 As Double
    Dim D22 As Double
    Dim R1 As Double
    Dim ROWMAX As Double
    Dim t As Double
    Dim WK As Double
    Dim WKM1 As Double
    Dim WKP1 As Double
    Dim II As Long
    Dim I1 As Long
    Dim I2 As Long
    Dim VV As Double
    Dim temp() As Double
    Dim i_ As Long
    ReDim Pivots(1# To N)
    ReDim temp(1# To N)
    '
    ' Initialize ALPHA for use in choosing pivot block size.
    '
    alpha = (1# + Sqr(17#)) / 8#
    If IsUpper Then
        '
        ' Factorize A as U*D*U' using the upper triangle of A
        '
        '
        ' K is the main loop index, decreasing from N to 1 in steps of
        ' 1 or 2
        '
        K = N
        Do While K >= 1#
            KSTEP = 1#
            '
            ' Determine rows and columns to be interchanged and whether
            ' a 1-by-1 or 2-by-2 pivot block will be used
            '
            ABSAKK = Abs(a(K, K))
            '
            ' IMAX is the row-index of the largest off-diagonal element in
            ' column K, and COLMAX is its absolute value
            '
            If K > 1# Then
                IMAX = 1#
                For II = 2# To K - 1# Step 1
                    If Abs(a(II, K)) > Abs(a(IMAX, K)) Then
                        IMAX = II
                    End If
                Next II
                COLMAX = Abs(a(IMAX, K))
            Else
                COLMAX = 0#
            End If
            If MaxReal(ABSAKK, COLMAX) = 0# Then
                '
                ' Column K is zero
                '
                KP = K
            Else
                If ABSAKK >= alpha * COLMAX Then
                    '
                    ' no interchange, use 1-by-1 pivot block
                    '
                    KP = K
                Else
                    '
                    ' JMAX is the column-index of the largest off-diagonal
                    ' element in row IMAX, and ROWMAX is its absolute value
                    '
                    JMax = IMAX + 1#
                    For II = IMAX + 2# To K Step 1
                        If Abs(a(IMAX, II)) > Abs(a(IMAX, JMax)) Then
                            JMax = II
                        End If
                    Next II
                    ROWMAX = Abs(a(IMAX, JMax))
                    If IMAX > 1# Then
                        JMax = 1#
                        For II = 2# To IMAX - 1# Step 1
                            If Abs(a(II, IMAX)) > Abs(a(JMax, IMAX)) Then
                                JMax = II
                            End If
                        Next II
                        ROWMAX = MaxReal(ROWMAX, Abs(a(JMax, IMAX)))
                    End If
                    VV = COLMAX / ROWMAX
                    If ABSAKK >= alpha * COLMAX * VV Then
                        '
                        ' no interchange, use 1-by-1 pivot block
                        '
                        KP = K
                    Else
                        If Abs(a(IMAX, IMAX)) >= alpha * ROWMAX Then
                            '
                            ' interchange rows and columns K and IMAX, use 1-by-1
                            ' pivot block
                            '
                            KP = IMAX
                        Else
                            '
                            ' interchange rows and columns K-1 and IMAX, use 2-by-2
                            ' pivot block
                            '
                            KP = IMAX
                            KSTEP = 2#
                        End If
                    End If
                End If
                KK = K - KSTEP + 1#
                If KP <> KK Then
                    '
                    ' Interchange rows and columns KK and KP in the leading
                    ' submatrix A(1:k,1:k)
                    '
                    I1 = KP - 1#
                    For i_ = 1# To I1 Step 1
                        temp(i_) = a(i_, KK)
                    Next i_
                    For i_ = 1# To I1 Step 1
                        a(i_, KK) = a(i_, KP)
                    Next i_
                    For i_ = 1# To I1 Step 1
                        a(i_, KP) = temp(i_)
                    Next i_
                    I1 = KP + 1#
                    I2 = KK - 1#
                    For i_ = I1 To I2 Step 1
                        temp(i_) = a(i_, KK)
                    Next i_
                    For i_ = I1 To I2 Step 1
                        a(i_, KK) = a(KP, i_)
                    Next i_
                    For i_ = I1 To I2 Step 1
                        a(KP, i_) = temp(i_)
                    Next i_
                    t = a(KK, KK)
                    a(KK, KK) = a(KP, KP)
                    a(KP, KP) = t
                    If KSTEP = 2# Then
                        t = a(K - 1#, K)
                        a(K - 1#, K) = a(KP, K)
                        a(KP, K) = t
                    End If
                End If
                '
                ' Update the leading submatrix
                '
                If KSTEP = 1# Then
                    '
                    ' 1-by-1 pivot block D(k): column k now holds
                    '
                    ' W(k) = U(k)*D(k)
                    '
                    ' where U(k) is the k-th column of U
                    '
                    ' Perform a rank-1 update of A(1:k-1,1:k-1) as
                    '
                    ' A := A - U(k)*D(k)*U(k)' = A - W(k)*1/D(k)*W(k)'
                    '
                    R1 = 1# / a(K, K)
                    For i = 1# To K - 1# Step 1
                        I2 = K - 1#
                        VV = -(R1 * a(i, K))
                        For i_ = i To I2 Step 1
                            a(i, i_) = a(i, i_) + VV * a(i_, K)
                        Next i_
                    Next i
                    '
                    ' Store U(k) in column k
                    '
                    I2 = K - 1#
                    For i_ = 1# To I2 Step 1
                        a(i_, K) = R1 * a(i_, K)
                    Next i_
                Else
                    '
                    ' 2-by-2 pivot block D(k): columns k and k-1 now hold
                    '
                    ' ( W(k-1) W(k) ) = ( U(k-1) U(k) )*D(k)
                    '
                    ' where U(k) and U(k-1) are the k-th and (k-1)-th columns
                    ' of U
                    '
                    ' Perform a rank-2 update of A(1:k-2,1:k-2) as
                    '
                    ' A := A - ( U(k-1) U(k) )*D(k)*( U(k-1) U(k) )'
                    '    = A - ( W(k-1) W(k) )*inv(D(k))*( W(k-1) W(k) )'
                    '
                    If K > 2# Then
                        D12 = a(K - 1#, K)
                        D22 = a(K - 1#, K - 1#) / D12
                        D11 = a(K, K) / D12
                        t = 1# / (D11 * D22 - 1#)
                        D12 = t / D12
                        For j = K - 2# To 1# Step -1
                            WKM1 = D12 * (D11 * a(j, K - 1#) - a(j, K))
                            WK = D12 * (D22 * a(j, K) - a(j, K - 1#))
                            For i_ = 1# To j Step 1
                                a(i_, j) = a(i_, j) - WK * a(i_, K)
                            Next i_
                            I1 = K - 1#
                            For i_ = 1# To j Step 1
                                a(i_, j) = a(i_, j) - WKM1 * a(i_, I1)
                            Next i_
                            a(j, K) = WK
                            a(j, K - 1#) = WKM1
                        Next j
                    End If
                End If
            End If
            '
            ' Store details of the interchanges in IPIV
            '
            If KSTEP = 1# Then
                Pivots(K) = KP
            Else
                Pivots(K) = -KP
                Pivots(K - 1#) = -KP
            End If
            '
            ' Decrease K and return to the start of the main loop
            '
            K = K - KSTEP
        Loop
    Else
        '
        ' Factorize A as L*D*L' using the lower triangle of A
        '
        ' K is the main loop index, increasing from 1 to N in steps of
        ' 1 or 2
        '
        K = 1#
        Do While K <= N
            KSTEP = 1#
            '
            ' Determine rows and columns to be interchanged and whether
            ' a 1-by-1 or 2-by-2 pivot block will be used
            '
            ABSAKK = Abs(a(K, K))
            '
            ' IMAX is the row-index of the largest off-diagonal element in
            ' column K, and COLMAX is its absolute value
            '
            If K < N Then
                IMAX = K + 1#
                For II = K + 2# To N Step 1
                    If Abs(a(II, K)) > Abs(a(IMAX, K)) Then
                        IMAX = II
                    End If
                Next II
                COLMAX = Abs(a(IMAX, K))
            Else
                COLMAX = 0#
            End If
            If MaxReal(ABSAKK, COLMAX) = 0# Then
                '
                ' Column K is zero
                '
                KP = K
            Else
                If ABSAKK >= alpha * COLMAX Then
                    '
                    ' no interchange, use 1-by-1 pivot block
                    '
                    KP = K
                Else
                    '
                    ' JMAX is the column-index of the largest off-diagonal
                    ' element in row IMAX, and ROWMAX is its absolute value
                    '
                    JMax = K
                    For II = K + 1# To IMAX - 1# Step 1
                        If Abs(a(IMAX, II)) > Abs(a(IMAX, JMax)) Then
                            JMax = II
                        End If
                    Next II
                    ROWMAX = Abs(a(IMAX, JMax))
                    If IMAX < N Then
                        JMax = IMAX + 1#
                        For II = IMAX + 2# To N Step 1
                            If Abs(a(II, IMAX)) > Abs(a(JMax, IMAX)) Then
                                JMax = II
                            End If
                        Next II
                        ROWMAX = MaxReal(ROWMAX, Abs(a(JMax, IMAX)))
                    End If
                    VV = COLMAX / ROWMAX
                    If ABSAKK >= alpha * COLMAX * VV Then
                        '
                        ' no interchange, use 1-by-1 pivot block
                        '
                        KP = K
                    Else
                        If Abs(a(IMAX, IMAX)) >= alpha * ROWMAX Then
                            '
                            ' interchange rows and columns K and IMAX, use 1-by-1
                            ' pivot block
                            '
                            KP = IMAX
                        Else
                            '
                            ' interchange rows and columns K+1 and IMAX, use 2-by-2
                            ' pivot block
                            '
                            KP = IMAX
                            KSTEP = 2#
                        End If
                    End If
                End If
                KK = K + KSTEP - 1#
                If KP <> KK Then
                    '
                    '              Interchange rows and columns KK and KP in the trailing
                    '              submatrix A(k:n,k:n)
                    '
                    If KP < N Then
                        I1 = KP + 1#
                        For i_ = I1 To N Step 1
                            temp(i_) = a(i_, KK)
                        Next i_
                        For i_ = I1 To N Step 1
                            a(i_, KK) = a(i_, KP)
                        Next i_
                        For i_ = I1 To N Step 1
                            a(i_, KP) = temp(i_)
                        Next i_
                    End If
                    I1 = KK + 1#
                    I2 = KP - 1#
                    For i_ = I1 To I2 Step 1
                        temp(i_) = a(i_, KK)
                    Next i_
                    For i_ = I1 To I2 Step 1
                        a(i_, KK) = a(KP, i_)
                    Next i_
                    For i_ = I1 To I2 Step 1
                        a(KP, i_) = temp(i_)
                    Next i_
                    t = a(KK, KK)
                    a(KK, KK) = a(KP, KP)
                    a(KP, KP) = t
                    If KSTEP = 2# Then
                        t = a(K + 1#, K)
                        a(K + 1#, K) = a(KP, K)
                        a(KP, K) = t
                    End If
                End If
                '
                ' Update the trailing submatrix
                '
                If KSTEP = 1# Then
                    '
                    ' 1-by-1 pivot block D(k): column k now holds
                    '
                    ' W(k) = L(k)*D(k)
                    '
                    ' where L(k) is the k-th column of L
                    '
                    If K < N Then
                        '
                        ' Perform a rank-1 update of A(k+1:n,k+1:n) as
                        '
                        ' A := A - L(k)*D(k)*L(k)' = A - W(k)*(1/D(k))*W(k)'
                        '
                        D11 = 1# / a(K, K)
                        For II = K + 1# To N Step 1
                            I1 = K + 1#
                            I2 = II
                            VV = -(D11 * a(II, K))
                            For i_ = I1 To I2 Step 1
                                a(II, i_) = a(II, i_) + VV * a(i_, K)
                            Next i_
                        Next II
                        '
                        ' Store L(k) in column K
                        '
                        I1 = K + 1#
                        For i_ = I1 To N Step 1
                            a(i_, K) = D11 * a(i_, K)
                        Next i_
                    End If
                Else
                    '
                    ' 2-by-2 pivot block D(k)
                    '
                    If K < N - 1# Then
                        '
                        ' Perform a rank-2 update of A(k+2:n,k+2:n) as
                        '
                        ' A := A - ( (A(k) A(k+1))*D(k)**(-1) ) * (A(k) A(k+1))'
                        '
                        ' where L(k) and L(k+1) are the k-th and (k+1)-th
                        ' columns of L
                        '
                        D21 = a(K + 1#, K)
                        D11 = a(K + 1#, K + 1#) / D21
                        D22 = a(K, K) / D21
                        t = 1# / (D11 * D22 - 1#)
                        D21 = t / D21
                        For j = K + 2# To N Step 1
                            WK = D21 * (D11 * a(j, K) - a(j, K + 1#))
                            WKP1 = D21 * (D22 * a(j, K + 1#) - a(j, K))
                            II = K + 1#
                            For i_ = j To N Step 1
                                a(i_, j) = a(i_, j) - WK * a(i_, K)
                            Next i_
                            For i_ = j To N Step 1
                                a(i_, j) = a(i_, j) - WKP1 * a(i_, II)
                            Next i_
                            a(j, K) = WK
                            a(j, K + 1#) = WKP1
                        Next j
                    End If
                End If
            End If
            '
            ' Store details of the interchanges in IPIV
            '
            If KSTEP = 1# Then
                Pivots(K) = KP
            Else
                Pivots(K) = -KP
                Pivots(K + 1#) = -KP
            End If
            '
            ' Increase K and return to the start of the main loop
            '
            K = K + KSTEP
        Loop
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2005-2007, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Inverse matrix update by the Sherman-Morrison formula
'
'The algorithm updates matrix A^-1 when adding a number to an element
'of matrix A.
'
'Input parameters:
'    InvA    -   inverse of matrix A.
'                Array whose indexes range within [0..N-1, 0..N-1].
'    N       -   size of matrix A.
'    UpdRow  -   row where the element to be updated is stored.
'    UpdColumn - column where the element to be updated is stored.
'    UpdVal  -   a number to be added to the element.
'
'
'Output parameters:
'    InvA    -   inverse of modified matrix A.
'
'  -- ALGLIB --
'     Copyright 2005 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixInvUpdateSimple(ByRef InvA() As Double, _
         ByVal N As Long, _
         ByVal UpdRow As Long, _
         ByVal UpdColumn As Long, _
         ByVal UpdVal As Double)
    Dim T1() As Double
    Dim T2() As Double
    Dim i As Long
    Dim lambda As Double
    Dim VT As Double
    Dim i_ As Long
    ReDim T1(0# To N - 1#)
    ReDim T2(0# To N - 1#)
    
    '
    ' T1 = InvA * U
    '
    For i_ = 0# To N - 1# Step 1
        T1(i_) = InvA(i_, UpdRow)
    Next i_
    
    '
    ' T2 = v*InvA
    '
    For i_ = 0# To N - 1# Step 1
        T2(i_) = InvA(UpdColumn, i_)
    Next i_
    
    '
    ' Lambda = v * InvA * U
    '
    lambda = UpdVal * InvA(UpdColumn, UpdRow)
    
    '
    ' InvA = InvA - correction
    '
    For i = 0# To N - 1# Step 1
        VT = UpdVal * T1(i)
        VT = VT / (1# + lambda)
        For i_ = 0# To N - 1# Step 1
            InvA(i, i_) = InvA(i, i_) - VT * T2(i_)
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Inverse matrix update by the Sherman-Morrison formula
'
'The algorithm updates matrix A^-1 when adding a vector to a row
'of matrix A.
'
'Input parameters:
'    InvA    -   inverse of matrix A.
'                Array whose indexes range within [0..N-1, 0..N-1].
'    N       -   size of matrix A.
'    UpdRow  -   the row of A whose vector V was added.
'                0 <= Row <= N-1
'    V       -   the vector to be added to a row.
'                Array whose index ranges within [0..N-1].
'
'Output parameters:
'    InvA    -   inverse of modified matrix A.
'
'  -- ALGLIB --
'     Copyright 2005 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixInvUpdateRow(ByRef InvA() As Double, _
         ByVal N As Long, _
         ByVal UpdRow As Long, _
         ByRef V() As Double)
    Dim T1() As Double
    Dim T2() As Double
    Dim i As Long
    Dim j As Long
    Dim lambda As Double
    Dim VT As Double
    Dim i_ As Long
    ReDim T1(0# To N - 1#)
    ReDim T2(0# To N - 1#)
    
    '
    ' T1 = InvA * U
    '
    For i_ = 0# To N - 1# Step 1
        T1(i_) = InvA(i_, UpdRow)
    Next i_
    
    '
    ' T2 = v*InvA
    ' Lambda = v * InvA * U
    '
    For j = 0# To N - 1# Step 1
        VT = 0#
        For i_ = 0# To N - 1# Step 1
            VT = VT + V(i_) * InvA(i_, j)
        Next i_
        T2(j) = VT
    Next j
    lambda = T2(UpdRow)
    
    '
    ' InvA = InvA - correction
    '
    For i = 0# To N - 1# Step 1
        VT = T1(i) / (1# + lambda)
        For i_ = 0# To N - 1# Step 1
            InvA(i, i_) = InvA(i, i_) - VT * T2(i_)
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Inverse matrix update by the Sherman-Morrison formula
'
'The algorithm updates matrix A^-1 when adding a vector to a column
'of matrix A.
'
'Input parameters:
'    InvA        -   inverse of matrix A.
'                    Array whose indexes range within [0..N-1, 0..N-1].
'    N           -   size of matrix A.
'    UpdColumn   -   the column of A whose vector U was added.
'                    0 <= UpdColumn <= N-1
'    U           -   the vector to be added to a column.
'                    Array whose index ranges within [0..N-1].
'
'Output parameters:
'    InvA        -   inverse of modified matrix A.
'
'  -- ALGLIB --
'     Copyright 2005 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixInvUpdateColumn(ByRef InvA() As Double, _
         ByVal N As Long, _
         ByVal UpdColumn As Long, _
         ByRef U() As Double)
    Dim T1() As Double
    Dim T2() As Double
    Dim i As Long
    Dim lambda As Double
    Dim VT As Double
    Dim i_ As Long
    ReDim T1(0# To N - 1#)
    ReDim T2(0# To N - 1#)
    
    '
    ' T1 = InvA * U
    ' Lambda = v * InvA * U
    '
    For i = 0# To N - 1# Step 1
        VT = 0#
        For i_ = 0# To N - 1# Step 1
            VT = VT + InvA(i, i_) * U(i_)
        Next i_
        T1(i) = VT
    Next i
    lambda = T1(UpdColumn)
    
    '
    ' T2 = v*InvA
    '
    For i_ = 0# To N - 1# Step 1
        T2(i_) = InvA(UpdColumn, i_)
    Next i_
    
    '
    ' InvA = InvA - correction
    '
    For i = 0# To N - 1# Step 1
        VT = T1(i) / (1# + lambda)
        For i_ = 0# To N - 1# Step 1
            InvA(i, i_) = InvA(i, i_) - VT * T2(i_)
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Inverse matrix update by the Sherman-Morrison formula
'
'The algorithm computes the inverse of matrix A+u*v by using the given matrix
'A^-1 and the vectors u and v.
'
'Input parameters:
'    InvA    -   inverse of matrix A.
'                Array whose indexes range within [0..N-1, 0..N-1].
'    N       -   size of matrix A.
'    U       -   the vector modifying the matrix.
'                Array whose index ranges within [0..N-1].
'    V       -   the vector modifying the matrix.
'                Array whose index ranges within [0..N-1].
'
'Output parameters:
'    InvA - inverse of matrix A + u*v'.
'
'  -- ALGLIB --
'     Copyright 2005 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixInvUpdateUV(ByRef InvA() As Double, _
         ByVal N As Long, _
         ByRef U() As Double, _
         ByRef V() As Double)
    Dim T1() As Double
    Dim T2() As Double
    Dim i As Long
    Dim j As Long
    Dim lambda As Double
    Dim VT As Double
    Dim i_ As Long
    ReDim T1(0# To N - 1#)
    ReDim T2(0# To N - 1#)
    
    '
    ' T1 = InvA * U
    ' Lambda = v * T1
    '
    For i = 0# To N - 1# Step 1
        VT = 0#
        For i_ = 0# To N - 1# Step 1
            VT = VT + InvA(i, i_) * U(i_)
        Next i_
        T1(i) = VT
    Next i
    lambda = 0#
    For i_ = 0# To N - 1# Step 1
        lambda = lambda + V(i_) * T1(i_)
    Next i_
    
    '
    ' T2 = v*InvA
    '
    For j = 0# To N - 1# Step 1
        VT = 0#
        For i_ = 0# To N - 1# Step 1
            VT = VT + V(i_) * InvA(i_, j)
        Next i_
        T2(j) = VT
    Next j
    
    '
    ' InvA = InvA - correction
    '
    For i = 0# To N - 1# Step 1
        VT = T1(i) / (1# + lambda)
        For i_ = 0# To N - 1# Step 1
            InvA(i, i_) = InvA(i, i_) - VT * T2(i_)
        Next i_
    Next i
End Sub
Public Sub ShermanMorrisonSimpleUpdate(ByRef InvA() As Double, _
         ByVal N As Long, _
         ByVal UpdRow As Long, _
         ByVal UpdColumn As Long, _
         ByVal UpdVal As Double)
    Dim T1() As Double
    Dim T2() As Double
    Dim i As Long
    Dim lambda As Double
    Dim VT As Double
    Dim i_ As Long
    ReDim T1(1# To N)
    ReDim T2(1# To N)
    
    '
    ' T1 = InvA * U
    '
    For i_ = 1# To N Step 1
        T1(i_) = InvA(i_, UpdRow)
    Next i_
    
    '
    ' T2 = v*InvA
    '
    For i_ = 1# To N Step 1
        T2(i_) = InvA(UpdColumn, i_)
    Next i_
    
    '
    ' Lambda = v * InvA * U
    '
    lambda = UpdVal * InvA(UpdColumn, UpdRow)
    
    '
    ' InvA = InvA - correction
    '
    For i = 1# To N Step 1
        VT = UpdVal * T1(i)
        VT = VT / (1# + lambda)
        For i_ = 1# To N Step 1
            InvA(i, i_) = InvA(i, i_) - VT * T2(i_)
        Next i_
    Next i
End Sub
Public Sub ShermanMorrisonUpdateRow(ByRef InvA() As Double, _
         ByVal N As Long, _
         ByVal UpdRow As Long, _
         ByRef V() As Double)
    Dim T1() As Double
    Dim T2() As Double
    Dim i As Long
    Dim j As Long
    Dim lambda As Double
    Dim VT As Double
    Dim i_ As Long
    ReDim T1(1# To N)
    ReDim T2(1# To N)
    
    '
    ' T1 = InvA * U
    '
    For i_ = 1# To N Step 1
        T1(i_) = InvA(i_, UpdRow)
    Next i_
    
    '
    ' T2 = v*InvA
    ' Lambda = v * InvA * U
    '
    For j = 1# To N Step 1
        VT = 0#
        For i_ = 1# To N Step 1
            VT = VT + V(i_) * InvA(i_, j)
        Next i_
        T2(j) = VT
    Next j
    lambda = T2(UpdRow)
    
    '
    ' InvA = InvA - correction
    '
    For i = 1# To N Step 1
        VT = T1(i) / (1# + lambda)
        For i_ = 1# To N Step 1
            InvA(i, i_) = InvA(i, i_) - VT * T2(i_)
        Next i_
    Next i
End Sub
Public Sub ShermanMorrisonUpdateColumn(ByRef InvA() As Double, _
         ByVal N As Long, _
         ByVal UpdColumn As Long, _
         ByRef U() As Double)
    Dim T1() As Double
    Dim T2() As Double
    Dim i As Long
    Dim lambda As Double
    Dim VT As Double
    Dim i_ As Long
    ReDim T1(1# To N)
    ReDim T2(1# To N)
    
    '
    ' T1 = InvA * U
    ' Lambda = v * InvA * U
    '
    For i = 1# To N Step 1
        VT = 0#
        For i_ = 1# To N Step 1
            VT = VT + InvA(i, i_) * U(i_)
        Next i_
        T1(i) = VT
    Next i
    lambda = T1(UpdColumn)
    
    '
    ' T2 = v*InvA
    '
    For i_ = 1# To N Step 1
        T2(i_) = InvA(UpdColumn, i_)
    Next i_
    
    '
    ' InvA = InvA - correction
    '
    For i = 1# To N Step 1
        VT = T1(i) / (1# + lambda)
        For i_ = 1# To N Step 1
            InvA(i, i_) = InvA(i, i_) - VT * T2(i_)
        Next i_
    Next i
End Sub
Public Sub ShermanMorrisonUpdateUV(ByRef InvA() As Double, _
         ByVal N As Long, _
         ByRef U() As Double, _
         ByRef V() As Double)
    Dim T1() As Double
    Dim T2() As Double
    Dim i As Long
    Dim j As Long
    Dim lambda As Double
    Dim VT As Double
    Dim i_ As Long
    ReDim T1(1# To N)
    ReDim T2(1# To N)
    
    '
    ' T1 = InvA * U
    ' Lambda = v * T1
    '
    For i = 1# To N Step 1
        VT = 0#
        For i_ = 1# To N Step 1
            VT = VT + InvA(i, i_) * U(i_)
        Next i_
        T1(i) = VT
    Next i
    lambda = 0#
    For i_ = 1# To N Step 1
        lambda = lambda + V(i_) * T1(i_)
    Next i_
    
    '
    ' T2 = v*InvA
    '
    For j = 1# To N Step 1
        VT = 0#
        For i_ = 1# To N Step 1
            VT = VT + V(i_) * InvA(i_, j)
        Next i_
        T2(j) = VT
    Next j
    
    '
    ' InvA = InvA - correction
    '
    For i = 1# To N Step 1
        VT = T1(i) / (1# + lambda)
        For i_ = 1# To N Step 1
            InvA(i, i_) = InvA(i, i_) - VT * T2(i_)
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 1992-2007 The University of Tennessee.  All rights reserved.
'
'Contributors:
'    * Sergey Bochkanov (ALGLIB project). Translation from FORTRAN to
'      pseudocode.
'
'See subroutines comments for additional copyrights.
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Matrix norm estimation
'
'The algorithm estimates the 1-norm of square matrix A  on  the  assumption
'that the multiplication of matrix  A  by  the  vector  is  available  (the
'iterative method is used). It is recommended to use this algorithm  if  it
'is hard  to  calculate  matrix  elements  explicitly  (for  example,  when
'estimating the inverse matrix norm).
'
'The algorithm uses back communication for multiplying the  vector  by  the
'matrix.  If  KASE=0  after  returning from a subroutine, its execution was
'completed successfully, otherwise it is required to multiply the  returned
'vector by matrix A and call the subroutine again.
'
'The DemoIterativeEstimateNorm subroutine shows a simple example.
'
'Parameters:
'    N       -   size of matrix A.
'    V       -   vector.   It is initialized by the subroutine on the first
'                call. It is then passed into it on repeated calls.
'    X       -   if KASE<>0, it contains the vector to be replaced by:
'                    A * X,      if KASE=1
'                    A^T * X,    if KASE=2
'                Array whose index ranges within [1..N].
'    ISGN    -   vector. It is initialized by the subroutine on  the  first
'                call. It is then passed into it on repeated calls.
'    EST     -   if KASE=0, it contains the lower boundary of the matrix
'                norm estimate.
'    KASE    -   on the first call, it should be equal to 0. After the last
'                return, it is equal to 0 (EST contains the  matrix  norm),
'                on intermediate returns it can be equal to 1 or 2 depending
'                on the operation to be performed on vector X.
'
'  -- LAPACK auxiliary routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     February 29, 1992
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub IterativeEstimate1Norm(ByVal N As Long, _
         ByRef V() As Double, _
         ByRef x() As Double, _
         ByRef ISGN() As Long, _
         ByRef EST As Double, _
         ByRef KASE As Long)
    Dim ITMAX As Long
    Dim i As Long
    Dim t As Double
    Dim Flg As Boolean
    Dim PosITER As Long
    Dim PosJ As Long
    Dim PosJLAST As Long
    Dim PosJUMP As Long
    Dim PosALTSGN As Long
    Dim PosESTOLD As Long
    Dim PosTEMP As Long
    Dim i_ As Long
    ITMAX = 5#
    PosALTSGN = N + 1#
    PosESTOLD = N + 2#
    PosTEMP = N + 3#
    PosITER = N + 1#
    PosJ = N + 2#
    PosJLAST = N + 3#
    PosJUMP = N + 4#
    If KASE = 0# Then
        ReDim V(1# To N + 3#)
        ReDim x(1# To N)
        ReDim ISGN(1# To N + 4#)
        t = 1# / N
        For i = 1# To N Step 1
            x(i) = t
        Next i
        KASE = 1#
        ISGN(PosJUMP) = 1#
        Exit Sub
    End If
    '
    '     ................ ENTRY   (JUMP = 1)
    '     FIRST ITERATION.  X HAS BEEN OVERWRITTEN BY A*X.
    '
    If ISGN(PosJUMP) = 1# Then
        If N = 1# Then
            V(1#) = x(1#)
            EST = Abs(V(1#))
            KASE = 0#
            Exit Sub
        End If
        EST = 0#
        For i = 1# To N Step 1
            EST = EST + Abs(x(i))
        Next i
        For i = 1# To N Step 1
            If x(i) >= 0# Then
                x(i) = 1#
            Else
                x(i) = -1#
            End If
            ISGN(i) = Sgn(x(i))
        Next i
        KASE = 2#
        ISGN(PosJUMP) = 2#
        Exit Sub
    End If
    '
    '     ................ ENTRY   (JUMP = 2)
    '     FIRST ITERATION.  X HAS BEEN OVERWRITTEN BY TRANDPOSE(A)*X.
    '
    If ISGN(PosJUMP) = 2# Then
        ISGN(PosJ) = 1#
        For i = 2# To N Step 1
            If Abs(x(i)) > Abs(x(ISGN(PosJ))) Then
                ISGN(PosJ) = i
            End If
        Next i
        ISGN(PosITER) = 2#
        '
        ' MAIN LOOP - ITERATIONS 2,3,...,ITMAX.
        '
        For i = 1# To N Step 1
            x(i) = 0#
        Next i
        x(ISGN(PosJ)) = 1#
        KASE = 1#
        ISGN(PosJUMP) = 3#
        Exit Sub
    End If
    '
    '     ................ ENTRY   (JUMP = 3)
    '     X HAS BEEN OVERWRITTEN BY A*X.
    '
    If ISGN(PosJUMP) = 3# Then
        For i_ = 1# To N Step 1
            V(i_) = x(i_)
        Next i_
        V(PosESTOLD) = EST
        EST = 0#
        For i = 1# To N Step 1
            EST = EST + Abs(V(i))
        Next i
        Flg = False
        For i = 1# To N Step 1
            If x(i) >= 0# And ISGN(i) < 0# Or x(i) < 0# And ISGN(i) >= 0# Then
                Flg = True
            End If
        Next i
        '
        ' REPEATED SIGN VECTOR DETECTED, HENCE ALGORITHM HAS CONVERGED.
        ' OR MAY BE CYCLING.
        '
        If Not Flg Or EST <= V(PosESTOLD) Then
            V(PosALTSGN) = 1#
            For i = 1# To N Step 1
                x(i) = V(PosALTSGN) * (1# + (i - 1#) / (N - 1#))
                V(PosALTSGN) = -V(PosALTSGN)
            Next i
            KASE = 1#
            ISGN(PosJUMP) = 5#
            Exit Sub
        End If
        For i = 1# To N Step 1
            If x(i) >= 0# Then
                x(i) = 1#
                ISGN(i) = 1#
            Else
                x(i) = -1#
                ISGN(i) = -1#
            End If
        Next i
        KASE = 2#
        ISGN(PosJUMP) = 4#
        Exit Sub
    End If
    '
    '     ................ ENTRY   (JUMP = 4)
    '     X HAS BEEN OVERWRITTEN BY TRANDPOSE(A)*X.
    '
    If ISGN(PosJUMP) = 4# Then
        ISGN(PosJLAST) = ISGN(PosJ)
        ISGN(PosJ) = 1#
        For i = 2# To N Step 1
            If Abs(x(i)) > Abs(x(ISGN(PosJ))) Then
                ISGN(PosJ) = i
            End If
        Next i
        If x(ISGN(PosJLAST)) <> Abs(x(ISGN(PosJ))) And ISGN(PosITER) < ITMAX Then
            ISGN(PosITER) = ISGN(PosITER) + 1#
            For i = 1# To N Step 1
                x(i) = 0#
            Next i
            x(ISGN(PosJ)) = 1#
            KASE = 1#
            ISGN(PosJUMP) = 3#
            Exit Sub
        End If
        '
        ' ITERATION COMPLETE.  FINAL STAGE.
        '
        V(PosALTSGN) = 1#
        For i = 1# To N Step 1
            x(i) = V(PosALTSGN) * (1# + (i - 1#) / (N - 1#))
            V(PosALTSGN) = -V(PosALTSGN)
        Next i
        KASE = 1#
        ISGN(PosJUMP) = 5#
        Exit Sub
    End If
    '
    '     ................ ENTRY   (JUMP = 5)
    '     X HAS BEEN OVERWRITTEN BY A*X.
    '
    If ISGN(PosJUMP) = 5# Then
        V(PosTEMP) = 0#
        For i = 1# To N Step 1
            V(PosTEMP) = V(PosTEMP) + Abs(x(i))
        Next i
        V(PosTEMP) = 2# * V(PosTEMP) / (3# * N)
        If V(PosTEMP) > EST Then
            For i_ = 1# To N Step 1
                V(i_) = x(i_)
            Next i_
            EST = V(PosTEMP)
        End If
        KASE = 0#
        Exit Sub
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Example of usage of an IterativeEstimateNorm subroutine
'
'Input parameters:
'    A   -   matrix.
'            Array whose indexes range within [1..N, 1..N].
'
'Return:
'    Matrix norm estimated by the subroutine.
'
'  -- ALGLIB --
'     Copyright 2005 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function DemoIterativeEstimate1Norm(ByRef a() As Double, _
         ByVal N As Long) As Double
    Dim Result As Double
    Dim i As Long
    Dim s As Double
    Dim x() As Double
    Dim t() As Double
    Dim V() As Double
    Dim IV() As Long
    Dim KASE As Long
    Dim i_ As Long
    KASE = 0#
    ReDim t(1# To N)
    Call IterativeEstimate1Norm(N, V, x, IV, Result, KASE)
    Do While KASE <> 0#
        If KASE = 1# Then
            For i = 1# To N Step 1
                s = 0#
                For i_ = 1# To N Step 1
                    s = s + a(i, i_) * x(i_)
                Next i_
                t(i) = s
            Next i
        Else
            For i = 1# To N Step 1
                s = 0#
                For i_ = 1# To N Step 1
                    s = s + a(i_, i) * x(i_)
                Next i_
                t(i) = s
            Next i
        End If
        For i_ = 1# To N Step 1
            x(i_) = t(i_)
        Next i_
        Call IterativeEstimate1Norm(N, V, x, IV, Result, KASE)
    Loop
    DemoIterativeEstimate1Norm = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 1992-2007 The University of Tennessee.  All rights reserved.
'
'Contributors:
'    * Sergey Bochkanov (ALGLIB project). Translation from FORTRAN to
'      pseudocode.
'
'See subroutines comments for additional copyrights.
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
Public Sub HermitianMatrixVectorMultiply(ByRef a() As Complex, _
         ByVal IsUpper As Boolean, _
         ByVal I1 As Long, _
         ByVal I2 As Long, _
         ByRef x() As Complex, _
         ByRef Alpha_ As Complex, _
         ByRef y() As Complex)
    Dim alpha As Complex
    Dim i As Long
    Dim BA1 As Long
    Dim Ba2 As Long
    Dim BY1 As Long
    Dim BY2 As Long
    Dim BX1 As Long
    Dim BX2 As Long
    Dim N As Long
    Dim V As Complex
    Dim i_ As Long
    Dim i1_ As Long
    alpha = Alpha_
    N = I2 - I1 + 1#
    If N <= 0# Then
        Exit Sub
    End If
    
    '
    ' Let A = L + D + U, where
    '  L is strictly lower triangular (main diagonal is zero)
    '  D is diagonal
    '  U is strictly upper triangular (main diagonal is zero)
    '
    ' A*x = L*x + D*x + U*x
    '
    ' Calculate D*x first
    '
    For i = I1 To I2 Step 1
        y(i - I1 + 1#) = C_Mul(a(i, i), x(i - I1 + 1#))
    Next i
    
    '
    ' Add L*x + U*x
    '
    If IsUpper Then
        For i = I1 To I2 - 1# Step 1
            
            '
            ' Add L*x to the result
            '
            V = x(i - I1 + 1#)
            BY1 = i - I1 + 2#
            BY2 = N
            BA1 = i + 1#
            Ba2 = I2
            i1_ = (BA1) - (BY1)
            For i_ = BY1 To BY2 Step 1
                y(i_) = C_Add(y(i_), C_Mul(V, Conj(a(i, i_ + i1_))))
            Next i_
            
            '
            ' Add U*x to the result
            '
            BX1 = i - I1 + 2#
            BX2 = N
            BA1 = i + 1#
            Ba2 = I2
            i1_ = (BA1) - (BX1)
            V = C_Complex(0#)
            For i_ = BX1 To BX2 Step 1
                V = C_Add(V, C_Mul(x(i_), a(i, i_ + i1_)))
            Next i_
            y(i - I1 + 1#) = C_Add(y(i - I1 + 1#), V)
        Next i
    Else
        For i = I1 + 1# To I2 Step 1
            
            '
            ' Add L*x to the result
            '
            BX1 = 1#
            BX2 = i - I1
            BA1 = I1
            Ba2 = i - 1#
            i1_ = (BA1) - (BX1)
            V = C_Complex(0#)
            For i_ = BX1 To BX2 Step 1
                V = C_Add(V, C_Mul(x(i_), a(i, i_ + i1_)))
            Next i_
            y(i - I1 + 1#) = C_Add(y(i - I1 + 1#), V)
            
            '
            ' Add U*x to the result
            '
            V = x(i - I1 + 1#)
            BY1 = 1#
            BY2 = i - I1
            BA1 = I1
            Ba2 = i - 1#
            i1_ = (BA1) - (BY1)
            For i_ = BY1 To BY2 Step 1
                y(i_) = C_Add(y(i_), C_Mul(V, Conj(a(i, i_ + i1_))))
            Next i_
        Next i
    End If
    For i_ = 1# To N Step 1
        y(i_) = C_Mul(alpha, y(i_))
    Next i_
End Sub
Public Sub HermitianRank2Update(ByRef a() As Complex, _
         ByVal IsUpper As Boolean, _
         ByVal I1 As Long, _
         ByVal I2 As Long, _
         ByRef x() As Complex, _
         ByRef y() As Complex, _
         ByRef t() As Complex, _
         ByRef Alpha_ As Complex)
    Dim alpha As Complex
    Dim i As Long
    Dim TP1 As Long
    Dim TP2 As Long
    Dim V As Complex
    Dim i_ As Long
    Dim i1_ As Long
    alpha = Alpha_
    If IsUpper Then
        For i = I1 To I2 Step 1
            TP1 = i + 1# - I1
            TP2 = I2 - I1 + 1#
            V = C_Mul(alpha, x(i + 1# - I1))
            For i_ = TP1 To TP2 Step 1
                t(i_) = C_Mul(V, Conj(y(i_)))
            Next i_
            V = C_Mul(Conj(alpha), y(i + 1# - I1))
            For i_ = TP1 To TP2 Step 1
                t(i_) = C_Add(t(i_), C_Mul(V, Conj(x(i_))))
            Next i_
            i1_ = (TP1) - (i)
            For i_ = i To I2 Step 1
                a(i, i_) = C_Add(a(i, i_), t(i_ + i1_))
            Next i_
        Next i
    Else
        For i = I1 To I2 Step 1
            TP1 = 1#
            TP2 = i + 1# - I1
            V = C_Mul(alpha, x(i + 1# - I1))
            For i_ = TP1 To TP2 Step 1
                t(i_) = C_Mul(V, Conj(y(i_)))
            Next i_
            V = C_Mul(Conj(alpha), y(i + 1# - I1))
            For i_ = TP1 To TP2 Step 1
                t(i_) = C_Add(t(i_), C_Mul(V, Conj(x(i_))))
            Next i_
            i1_ = (TP1) - (I1)
            For i_ = I1 To i Step 1
                a(i, i_) = C_Add(a(i, i_), t(i_ + i1_))
            Next i_
        Next i
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2007-2008, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Dense solver.
'
'This  subroutine  solves  a  system  A*x=b,  where A is NxN non-denegerate
'real matrix, x and b are vectors.
'
'Algorithm features:
'* automatic detection of degenerate cases
'* condition number estimation
'* iterative refinement
'* O(N^3) complexity
'
'INPUT PARAMETERS
'    A       -   array[0..N-1,0..N-1], system matrix
'    N       -   size of A
'    B       -   array[0..N-1], right part
'
'OUTPUT PARAMETERS
'    Info    -   return code:
'                * -3    A is singular, or VERY close to singular.
'                        X is filled by zeros in such cases.
'                * -1    N<=0 was passed
'                *  1    task is solved (but matrix A may be ill-conditioned,
'                        check R1/RInf parameters for condition numbers).
'    Rep     -   solver report, see below for more info
'    X       -   array[0..N-1], it contains:
'                * solution of A*x=b if A is non-singular (well-conditioned
'                  or ill-conditioned, but not very close to singular)
'                * zeros,  if  A  is  singular  or  VERY  close to singular
'                  (in this case Info=-3).
'
'SOLVER REPORT
'
'Subroutine sets following fields of the Rep structure:
'* R1        reciprocal of condition number: 1/cond(A), 1-norm.
'* RInf      reciprocal of condition number: 1/cond(A), inf-norm.
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixSolve(ByRef a() As Double, _
         ByVal N As Long, _
         ByRef B() As Double, _
         ByRef Info As Long, _
         ByRef Rep As DenseSolverReport, _
         ByRef x() As Double)
    Dim BM() As Double
    Dim XM() As Double
    Dim i_ As Long
    If N <= 0# Then
        Info = -1#
        Exit Sub
    End If
    ReDim BM(0 To N - 1, 0 To 1# - 1)
    For i_ = 0# To N - 1# Step 1
        BM(i_, 0#) = B(i_)
    Next i_
    Call RMatrixSolveM(a, N, BM, 1#, True, Info, Rep, XM)
    ReDim x(0 To N - 1)
    For i_ = 0# To N - 1# Step 1
        x(i_) = XM(i_, 0#)
    Next i_
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Dense solver.
'
'Similar to RMatrixSolve() but solves task with multiple right parts (where
'b and x are NxM matrices).
'
'Algorithm features:
'* automatic detection of degenerate cases
'* condition number estimation
'* optional iterative refinement
'* O(N^3+M*N^2) complexity
'
'INPUT PARAMETERS
'    A       -   array[0..N-1,0..N-1], system matrix
'    N       -   size of A
'    B       -   array[0..N-1,0..M-1], right part
'    M       -   right part size
'    RFS     -   iterative refinement switch:
'                * True - refinement is used.
'                  Less performance, more precision.
'                * False - refinement is not used.
'                  More performance, less precision.
'
'OUTPUT PARAMETERS
'    Info    -   same as in RMatrixSolve
'    Rep     -   same as in RMatrixSolve
'    X       -   same as in RMatrixSolve
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixSolveM(ByRef a() As Double, _
         ByVal N As Long, _
         ByRef B() As Double, _
         ByVal M As Long, _
         ByVal RFS As Boolean, _
         ByRef Info As Long, _
         ByRef Rep As DenseSolverReport, _
         ByRef x() As Double)
    Dim DA() As Double
    Dim EmptyA() As Double
    Dim p() As Long
    Dim ScaleA As Double
    Dim i As Long
    Dim j As Long
    Dim i_ As Long
    
    '
    ' prepare: check inputs, allocate space...
    '
    If N <= 0# Or M <= 0# Then
        Info = -1#
        Exit Sub
    End If
    ReDim DA(0 To N - 1, 0 To N - 1)
    
    '
    ' 1. scale matrix, max(|A[i,j]|)
    ' 2. factorize scaled matrix
    ' 3. solve
    '
    ScaleA = 0#
    For i = 0# To N - 1# Step 1
        For j = 0# To N - 1# Step 1
            ScaleA = MaxReal(ScaleA, Abs(a(i, j)))
        Next j
    Next i
    If ScaleA = 0# Then
        ScaleA = 1#
    End If
    ScaleA = 1# / ScaleA
    For i = 0# To N - 1# Step 1
        For i_ = 0# To N - 1# Step 1
            DA(i, i_) = a(i, i_)
        Next i_
    Next i
    Call RMatrixLU(DA, N, N, p)
    If RFS Then
        Call RMatrixLUSolveInternal(DA, p, ScaleA, N, a, True, B, M, Info, Rep, x)
    Else
        Call RMatrixLUSolveInternal(DA, p, ScaleA, N, EmptyA, False, B, M, Info, Rep, x)
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Dense solver.
'
'This  subroutine  solves  a  system  A*X=B,  where A is NxN non-denegerate
'real matrix given by its LU decomposition, X and B are NxM real matrices.
'
'Algorithm features:
'* automatic detection of degenerate cases
'* O(N^2) complexity
'* condition number estimation
'
'No iterative refinement  is provided because exact form of original matrix
'is not known to subroutine. Use RMatrixSolve or RMatrixMixedSolve  if  you
'need iterative refinement.
'
'INPUT PARAMETERS
'    LUA     -   array[0..N-1,0..N-1], LU decomposition, RMatrixLU result
'    P       -   array[0..N-1], pivots array, RMatrixLU result
'    N       -   size of A
'    B       -   array[0..N-1], right part
'
'OUTPUT PARAMETERS
'    Info    -   same as in RMatrixSolve
'    Rep     -   same as in RMatrixSolve
'    X       -   same as in RMatrixSolve
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixLUSolve(ByRef LUA() As Double, _
         ByRef p() As Long, _
         ByVal N As Long, _
         ByRef B() As Double, _
         ByRef Info As Long, _
         ByRef Rep As DenseSolverReport, _
         ByRef x() As Double)
    Dim BM() As Double
    Dim XM() As Double
    Dim i_ As Long
    If N <= 0# Then
        Info = -1#
        Exit Sub
    End If
    ReDim BM(0 To N - 1, 0 To 1# - 1)
    For i_ = 0# To N - 1# Step 1
        BM(i_, 0#) = B(i_)
    Next i_
    Call RMatrixLUSolveM(LUA, p, N, BM, 1#, Info, Rep, XM)
    ReDim x(0 To N - 1)
    For i_ = 0# To N - 1# Step 1
        x(i_) = XM(i_, 0#)
    Next i_
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Dense solver.
'
'Similar to RMatrixLUSolve() but solves task with multiple right parts
'(where b and x are NxM matrices).
'
'Algorithm features:
'* automatic detection of degenerate cases
'* O(M*N^2) complexity
'* condition number estimation
'
'No iterative refinement  is provided because exact form of original matrix
'is not known to subroutine. Use RMatrixSolve or RMatrixMixedSolve  if  you
'need iterative refinement.
'
'INPUT PARAMETERS
'    LUA     -   array[0..N-1,0..N-1], LU decomposition, RMatrixLU result
'    P       -   array[0..N-1], pivots array, RMatrixLU result
'    N       -   size of A
'    B       -   array[0..N-1,0..M-1], right part
'    M       -   right part size
'
'OUTPUT PARAMETERS
'    Info    -   same as in RMatrixSolve
'    Rep     -   same as in RMatrixSolve
'    X       -   same as in RMatrixSolve
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixLUSolveM(ByRef LUA() As Double, _
         ByRef p() As Long, _
         ByVal N As Long, _
         ByRef B() As Double, _
         ByVal M As Long, _
         ByRef Info As Long, _
         ByRef Rep As DenseSolverReport, _
         ByRef x() As Double)
    Dim EmptyA() As Double
    Dim i As Long
    Dim j As Long
    Dim ScaleA As Double
    
    '
    ' prepare: check inputs, allocate space...
    '
    If N <= 0# Or M <= 0# Then
        Info = -1#
        Exit Sub
    End If
    
    '
    ' 1. scale matrix, max(|U[i,j]|)
    '    we assume that LU is in its normal form, i.e. |L[i,j]|<=1
    ' 2. solve
    '
    ScaleA = 0#
    For i = 0# To N - 1# Step 1
        For j = i To N - 1# Step 1
            ScaleA = MaxReal(ScaleA, Abs(LUA(i, j)))
        Next j
    Next i
    If ScaleA = 0# Then
        ScaleA = 1#
    End If
    ScaleA = 1# / ScaleA
    Call RMatrixLUSolveInternal(LUA, p, ScaleA, N, EmptyA, False, B, M, Info, Rep, x)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Dense solver.
'
'This  subroutine  solves  a  system  A*x=b,  where BOTH ORIGINAL A AND ITS
'LU DECOMPOSITION ARE KNOWN. You can use it if for some  reasons  you  have
'both A and its LU decomposition.
'
'Algorithm features:
'* automatic detection of degenerate cases
'* condition number estimation
'* iterative refinement
'* O(N^2) complexity
'
'INPUT PARAMETERS
'    A       -   array[0..N-1,0..N-1], system matrix
'    LUA     -   array[0..N-1,0..N-1], LU decomposition, RMatrixLU result
'    P       -   array[0..N-1], pivots array, RMatrixLU result
'    N       -   size of A
'    B       -   array[0..N-1], right part
'
'OUTPUT PARAMETERS
'    Info    -   same as in RMatrixSolveM
'    Rep     -   same as in RMatrixSolveM
'    X       -   same as in RMatrixSolveM
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixMixedSolve(ByRef a() As Double, _
         ByRef LUA() As Double, _
         ByRef p() As Long, _
         ByVal N As Long, _
         ByRef B() As Double, _
         ByRef Info As Long, _
         ByRef Rep As DenseSolverReport, _
         ByRef x() As Double)
    Dim BM() As Double
    Dim XM() As Double
    Dim i_ As Long
    If N <= 0# Then
        Info = -1#
        Exit Sub
    End If
    ReDim BM(0 To N - 1, 0 To 1# - 1)
    For i_ = 0# To N - 1# Step 1
        BM(i_, 0#) = B(i_)
    Next i_
    Call RMatrixMixedSolveM(a, LUA, p, N, BM, 1#, Info, Rep, XM)
    ReDim x(0 To N - 1)
    For i_ = 0# To N - 1# Step 1
        x(i_) = XM(i_, 0#)
    Next i_
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Dense solver.
'
'Similar to RMatrixMixedSolve() but  solves task with multiple right  parts
'(where b and x are NxM matrices).
'
'Algorithm features:
'* automatic detection of degenerate cases
'* condition number estimation
'* iterative refinement
'* O(M*N^2) complexity
'
'INPUT PARAMETERS
'    A       -   array[0..N-1,0..N-1], system matrix
'    LUA     -   array[0..N-1,0..N-1], LU decomposition, RMatrixLU result
'    P       -   array[0..N-1], pivots array, RMatrixLU result
'    N       -   size of A
'    B       -   array[0..N-1,0..M-1], right part
'    M       -   right part size
'
'OUTPUT PARAMETERS
'    Info    -   same as in RMatrixSolveM
'    Rep     -   same as in RMatrixSolveM
'    X       -   same as in RMatrixSolveM
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixMixedSolveM(ByRef a() As Double, _
         ByRef LUA() As Double, _
         ByRef p() As Long, _
         ByVal N As Long, _
         ByRef B() As Double, _
         ByVal M As Long, _
         ByRef Info As Long, _
         ByRef Rep As DenseSolverReport, _
         ByRef x() As Double)
    Dim ScaleA As Double
    Dim i As Long
    Dim j As Long
    
    '
    ' prepare: check inputs, allocate space...
    '
    If N <= 0# Or M <= 0# Then
        Info = -1#
        Exit Sub
    End If
    
    '
    ' 1. scale matrix, max(|A[i,j]|)
    ' 2. factorize scaled matrix
    ' 3. solve
    '
    ScaleA = 0#
    For i = 0# To N - 1# Step 1
        For j = 0# To N - 1# Step 1
            ScaleA = MaxReal(ScaleA, Abs(a(i, j)))
        Next j
    Next i
    If ScaleA = 0# Then
        ScaleA = 1#
    End If
    ScaleA = 1# / ScaleA
    Call RMatrixLUSolveInternal(LUA, p, ScaleA, N, a, True, B, M, Info, Rep, x)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Dense solver. Same as RMatrixSolveM(), but for complex matrices.
'
'Algorithm features:
'* automatic detection of degenerate cases
'* condition number estimation
'* iterative refinement
'* O(N^3+M*N^2) complexity
'
'INPUT PARAMETERS
'    A       -   array[0..N-1,0..N-1], system matrix
'    N       -   size of A
'    B       -   array[0..N-1,0..M-1], right part
'    M       -   right part size
'    RFS     -   iterative refinement switch:
'                * True - refinement is used.
'                  Less performance, more precision.
'                * False - refinement is not used.
'                  More performance, less precision.
'
'OUTPUT PARAMETERS
'    Info    -   same as in RMatrixSolve
'    Rep     -   same as in RMatrixSolve
'    X       -   same as in RMatrixSolve
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixSolveM(ByRef a() As Complex, _
         ByVal N As Long, _
         ByRef B() As Complex, _
         ByVal M As Long, _
         ByVal RFS As Boolean, _
         ByRef Info As Long, _
         ByRef Rep As DenseSolverReport, _
         ByRef x() As Complex)
    Dim DA() As Complex
    Dim EmptyA() As Complex
    Dim p() As Long
    Dim ScaleA As Double
    Dim i As Long
    Dim j As Long
    Dim i_ As Long
    
    '
    ' prepare: check inputs, allocate space...
    '
    If N <= 0# Or M <= 0# Then
        Info = -1#
        Exit Sub
    End If
    ReDim DA(0 To N - 1, 0 To N - 1)
    
    '
    ' 1. scale matrix, max(|A[i,j]|)
    ' 2. factorize scaled matrix
    ' 3. solve
    '
    ScaleA = 0#
    For i = 0# To N - 1# Step 1
        For j = 0# To N - 1# Step 1
            ScaleA = MaxReal(ScaleA, AbsComplex(a(i, j)))
        Next j
    Next i
    If ScaleA = 0# Then
        ScaleA = 1#
    End If
    ScaleA = 1# / ScaleA
    For i = 0# To N - 1# Step 1
        For i_ = 0# To N - 1# Step 1
            DA(i, i_) = a(i, i_)
        Next i_
    Next i
    Call CMatrixLU(DA, N, N, p)
    If RFS Then
        Call CMatrixLUSolveInternal(DA, p, ScaleA, N, a, True, B, M, Info, Rep, x)
    Else
        Call CMatrixLUSolveInternal(DA, p, ScaleA, N, EmptyA, False, B, M, Info, Rep, x)
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Dense solver. Same as RMatrixSolve(), but for complex matrices.
'
'Algorithm features:
'* automatic detection of degenerate cases
'* condition number estimation
'* iterative refinement
'* O(N^3) complexity
'
'INPUT PARAMETERS
'    A       -   array[0..N-1,0..N-1], system matrix
'    N       -   size of A
'    B       -   array[0..N-1], right part
'
'OUTPUT PARAMETERS
'    Info    -   same as in RMatrixSolve
'    Rep     -   same as in RMatrixSolve
'    X       -   same as in RMatrixSolve
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixSolve(ByRef a() As Complex, _
         ByVal N As Long, _
         ByRef B() As Complex, _
         ByRef Info As Long, _
         ByRef Rep As DenseSolverReport, _
         ByRef x() As Complex)
    Dim BM() As Complex
    Dim XM() As Complex
    Dim i_ As Long
    If N <= 0# Then
        Info = -1#
        Exit Sub
    End If
    ReDim BM(0 To N - 1, 0 To 1# - 1)
    For i_ = 0# To N - 1# Step 1
        BM(i_, 0#) = B(i_)
    Next i_
    Call CMatrixSolveM(a, N, BM, 1#, True, Info, Rep, XM)
    ReDim x(0 To N - 1)
    For i_ = 0# To N - 1# Step 1
        x(i_) = XM(i_, 0#)
    Next i_
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Dense solver. Same as RMatrixLUSolveM(), but for complex matrices.
'
'Algorithm features:
'* automatic detection of degenerate cases
'* O(M*N^2) complexity
'* condition number estimation
'
'No iterative refinement  is provided because exact form of original matrix
'is not known to subroutine. Use CMatrixSolve or CMatrixMixedSolve  if  you
'need iterative refinement.
'
'INPUT PARAMETERS
'    LUA     -   array[0..N-1,0..N-1], LU decomposition, RMatrixLU result
'    P       -   array[0..N-1], pivots array, RMatrixLU result
'    N       -   size of A
'    B       -   array[0..N-1,0..M-1], right part
'    M       -   right part size
'
'OUTPUT PARAMETERS
'    Info    -   same as in RMatrixSolve
'    Rep     -   same as in RMatrixSolve
'    X       -   same as in RMatrixSolve
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixLUSolveM(ByRef LUA() As Complex, _
         ByRef p() As Long, _
         ByVal N As Long, _
         ByRef B() As Complex, _
         ByVal M As Long, _
         ByRef Info As Long, _
         ByRef Rep As DenseSolverReport, _
         ByRef x() As Complex)
    Dim EmptyA() As Complex
    Dim i As Long
    Dim j As Long
    Dim ScaleA As Double
    
    '
    ' prepare: check inputs, allocate space...
    '
    If N <= 0# Or M <= 0# Then
        Info = -1#
        Exit Sub
    End If
    
    '
    ' 1. scale matrix, max(|U[i,j]|)
    '    we assume that LU is in its normal form, i.e. |L[i,j]|<=1
    ' 2. solve
    '
    ScaleA = 0#
    For i = 0# To N - 1# Step 1
        For j = i To N - 1# Step 1
            ScaleA = MaxReal(ScaleA, AbsComplex(LUA(i, j)))
        Next j
    Next i
    If ScaleA = 0# Then
        ScaleA = 1#
    End If
    ScaleA = 1# / ScaleA
    Call CMatrixLUSolveInternal(LUA, p, ScaleA, N, EmptyA, False, B, M, Info, Rep, x)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Dense solver. Same as RMatrixLUSolve(), but for complex matrices.
'
'Algorithm features:
'* automatic detection of degenerate cases
'* O(N^2) complexity
'* condition number estimation
'
'No iterative refinement is provided because exact form of original matrix
'is not known to subroutine. Use CMatrixSolve or CMatrixMixedSolve  if  you
'need iterative refinement.
'
'INPUT PARAMETERS
'    LUA     -   array[0..N-1,0..N-1], LU decomposition, CMatrixLU result
'    P       -   array[0..N-1], pivots array, CMatrixLU result
'    N       -   size of A
'    B       -   array[0..N-1], right part
'
'OUTPUT PARAMETERS
'    Info    -   same as in RMatrixSolve
'    Rep     -   same as in RMatrixSolve
'    X       -   same as in RMatrixSolve
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixLUSolve(ByRef LUA() As Complex, _
         ByRef p() As Long, _
         ByVal N As Long, _
         ByRef B() As Complex, _
         ByRef Info As Long, _
         ByRef Rep As DenseSolverReport, _
         ByRef x() As Complex)
    Dim BM() As Complex
    Dim XM() As Complex
    Dim i_ As Long
    If N <= 0# Then
        Info = -1#
        Exit Sub
    End If
    ReDim BM(0 To N - 1, 0 To 1# - 1)
    For i_ = 0# To N - 1# Step 1
        BM(i_, 0#) = B(i_)
    Next i_
    Call CMatrixLUSolveM(LUA, p, N, BM, 1#, Info, Rep, XM)
    ReDim x(0 To N - 1)
    For i_ = 0# To N - 1# Step 1
        x(i_) = XM(i_, 0#)
    Next i_
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Dense solver. Same as RMatrixMixedSolveM(), but for complex matrices.
'
'Algorithm features:
'* automatic detection of degenerate cases
'* condition number estimation
'* iterative refinement
'* O(M*N^2) complexity
'
'INPUT PARAMETERS
'    A       -   array[0..N-1,0..N-1], system matrix
'    LUA     -   array[0..N-1,0..N-1], LU decomposition, CMatrixLU result
'    P       -   array[0..N-1], pivots array, CMatrixLU result
'    N       -   size of A
'    B       -   array[0..N-1,0..M-1], right part
'    M       -   right part size
'
'OUTPUT PARAMETERS
'    Info    -   same as in RMatrixSolveM
'    Rep     -   same as in RMatrixSolveM
'    X       -   same as in RMatrixSolveM
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixMixedSolveM(ByRef a() As Complex, _
         ByRef LUA() As Complex, _
         ByRef p() As Long, _
         ByVal N As Long, _
         ByRef B() As Complex, _
         ByVal M As Long, _
         ByRef Info As Long, _
         ByRef Rep As DenseSolverReport, _
         ByRef x() As Complex)
    Dim ScaleA As Double
    Dim i As Long
    Dim j As Long
    
    '
    ' prepare: check inputs, allocate space...
    '
    If N <= 0# Or M <= 0# Then
        Info = -1#
        Exit Sub
    End If
    
    '
    ' 1. scale matrix, max(|A[i,j]|)
    ' 2. factorize scaled matrix
    ' 3. solve
    '
    ScaleA = 0#
    For i = 0# To N - 1# Step 1
        For j = 0# To N - 1# Step 1
            ScaleA = MaxReal(ScaleA, AbsComplex(a(i, j)))
        Next j
    Next i
    If ScaleA = 0# Then
        ScaleA = 1#
    End If
    ScaleA = 1# / ScaleA
    Call CMatrixLUSolveInternal(LUA, p, ScaleA, N, a, True, B, M, Info, Rep, x)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Dense solver. Same as RMatrixMixedSolve(), but for complex matrices.
'
'Algorithm features:
'* automatic detection of degenerate cases
'* condition number estimation
'* iterative refinement
'* O(N^2) complexity
'
'INPUT PARAMETERS
'    A       -   array[0..N-1,0..N-1], system matrix
'    LUA     -   array[0..N-1,0..N-1], LU decomposition, CMatrixLU result
'    P       -   array[0..N-1], pivots array, CMatrixLU result
'    N       -   size of A
'    B       -   array[0..N-1], right part
'
'OUTPUT PARAMETERS
'    Info    -   same as in RMatrixSolveM
'    Rep     -   same as in RMatrixSolveM
'    X       -   same as in RMatrixSolveM
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixMixedSolve(ByRef a() As Complex, _
         ByRef LUA() As Complex, _
         ByRef p() As Long, _
         ByVal N As Long, _
         ByRef B() As Complex, _
         ByRef Info As Long, _
         ByRef Rep As DenseSolverReport, _
         ByRef x() As Complex)
    Dim BM() As Complex
    Dim XM() As Complex
    Dim i_ As Long
    If N <= 0# Then
        Info = -1#
        Exit Sub
    End If
    ReDim BM(0 To N - 1, 0 To 1# - 1)
    For i_ = 0# To N - 1# Step 1
        BM(i_, 0#) = B(i_)
    Next i_
    Call CMatrixMixedSolveM(a, LUA, p, N, BM, 1#, Info, Rep, XM)
    ReDim x(0 To N - 1)
    For i_ = 0# To N - 1# Step 1
        x(i_) = XM(i_, 0#)
    Next i_
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Dense solver. Same as RMatrixSolveM(), but for symmetric positive definite
'matrices.
'
'Algorithm features:
'* automatic detection of degenerate cases
'* condition number estimation
'* O(N^3+M*N^2) complexity
'* matrix is represented by its upper or lower triangle
'
'No iterative refinement is provided because such partial representation of
'matrix does not allow efficient calculation of extra-precise  matrix-vector
'products for large matrices. Use RMatrixSolve or RMatrixMixedSolve  if  you
'need iterative refinement.
'
'INPUT PARAMETERS
'    A       -   array[0..N-1,0..N-1], system matrix
'    N       -   size of A
'    IsUpper -   what half of A is provided
'    B       -   array[0..N-1,0..M-1], right part
'    M       -   right part size
'
'OUTPUT PARAMETERS
'    Info    -   same as in RMatrixSolve.
'                Returns -3 for non-SPD matrices.
'    Rep     -   same as in RMatrixSolve
'    X       -   same as in RMatrixSolve
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub SPDMatrixSolveM(ByRef a() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef B() As Double, _
         ByVal M As Long, _
         ByRef Info As Long, _
         ByRef Rep As DenseSolverReport, _
         ByRef x() As Double)
    Dim DA() As Double
    Dim SqrtScaleA As Double
    Dim i As Long
    Dim j As Long
    Dim J1 As Long
    Dim J2 As Long
    Dim i_ As Long
    
    '
    ' prepare: check inputs, allocate space...
    '
    If N <= 0# Or M <= 0# Then
        Info = -1#
        Exit Sub
    End If
    ReDim DA(0 To N - 1, 0 To N - 1)
    
    '
    ' 1. scale matrix, max(|A[i,j]|)
    ' 2. factorize scaled matrix
    ' 3. solve
    '
    SqrtScaleA = 0#
    For i = 0# To N - 1# Step 1
        If IsUpper Then
            J1 = i
            J2 = N - 1#
        Else
            J1 = 0#
            J2 = i
        End If
        For j = J1 To J2 Step 1
            SqrtScaleA = MaxReal(SqrtScaleA, Abs(a(i, j)))
        Next j
    Next i
    If SqrtScaleA = 0# Then
        SqrtScaleA = 1#
    End If
    SqrtScaleA = 1# / SqrtScaleA
    SqrtScaleA = Sqr(SqrtScaleA)
    For i = 0# To N - 1# Step 1
        If IsUpper Then
            J1 = i
            J2 = N - 1#
        Else
            J1 = 0#
            J2 = i
        End If
        For i_ = J1 To J2 Step 1
            DA(i, i_) = a(i, i_)
        Next i_
    Next i
    If Not SPDMatrixCholesky(DA, N, IsUpper) Then
        ReDim x(0 To N - 1, 0 To M - 1)
        For i = 0# To N - 1# Step 1
            For j = 0# To M - 1# Step 1
                x(i, j) = 0#
            Next j
        Next i
        Rep.R1 = 0#
        Rep.RInf = 0#
        Info = -3#
        Exit Sub
    End If
    Info = 1#
    Call SPDMatrixCholeskySolveInternal(DA, SqrtScaleA, N, IsUpper, a, True, B, M, Info, Rep, x)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Dense solver. Same as RMatrixSolve(), but for SPD matrices.
'
'Algorithm features:
'* automatic detection of degenerate cases
'* condition number estimation
'* O(N^3) complexity
'* matrix is represented by its upper or lower triangle
'
'No iterative refinement is provided because such partial representation of
'matrix does not allow efficient calculation of extra-precise  matrix-vector
'products for large matrices. Use RMatrixSolve or RMatrixMixedSolve  if  you
'need iterative refinement.
'
'INPUT PARAMETERS
'    A       -   array[0..N-1,0..N-1], system matrix
'    N       -   size of A
'    IsUpper -   what half of A is provided
'    B       -   array[0..N-1], right part
'
'OUTPUT PARAMETERS
'    Info    -   same as in RMatrixSolve
'                Returns -3 for non-SPD matrices.
'    Rep     -   same as in RMatrixSolve
'    X       -   same as in RMatrixSolve
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub SPDMatrixSolve(ByRef a() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef B() As Double, _
         ByRef Info As Long, _
         ByRef Rep As DenseSolverReport, _
         ByRef x() As Double)
    Dim BM() As Double
    Dim XM() As Double
    Dim i_ As Long
    If N <= 0# Then
        Info = -1#
        Exit Sub
    End If
    ReDim BM(0 To N - 1, 0 To 1# - 1)
    For i_ = 0# To N - 1# Step 1
        BM(i_, 0#) = B(i_)
    Next i_
    Call SPDMatrixSolveM(a, N, IsUpper, BM, 1#, Info, Rep, XM)
    ReDim x(0 To N - 1)
    For i_ = 0# To N - 1# Step 1
        x(i_) = XM(i_, 0#)
    Next i_
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Dense solver. Same as RMatrixLUSolveM(), but for SPD matrices  represented
'by their Cholesky decomposition.
'
'Algorithm features:
'* automatic detection of degenerate cases
'* O(M*N^2) complexity
'* condition number estimation
'* matrix is represented by its upper or lower triangle
'
'No iterative refinement is provided because such partial representation of
'matrix does not allow efficient calculation of extra-precise  matrix-vector
'products for large matrices. Use RMatrixSolve or RMatrixMixedSolve  if  you
'need iterative refinement.
'
'INPUT PARAMETERS
'    CHA     -   array[0..N-1,0..N-1], Cholesky decomposition,
'                SPDMatrixCholesky result
'    N       -   size of CHA
'    IsUpper -   what half of CHA is provided
'    B       -   array[0..N-1,0..M-1], right part
'    M       -   right part size
'
'OUTPUT PARAMETERS
'    Info    -   same as in RMatrixSolve
'    Rep     -   same as in RMatrixSolve
'    X       -   same as in RMatrixSolve
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub SPDMatrixCholeskySolveM(ByRef CHA() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef B() As Double, _
         ByVal M As Long, _
         ByRef Info As Long, _
         ByRef Rep As DenseSolverReport, _
         ByRef x() As Double)
    Dim EmptyA() As Double
    Dim SqrtScaleA As Double
    Dim i As Long
    Dim j As Long
    Dim J1 As Long
    Dim J2 As Long
    
    '
    ' prepare: check inputs, allocate space...
    '
    If N <= 0# Or M <= 0# Then
        Info = -1#
        Exit Sub
    End If
    
    '
    ' 1. scale matrix, max(|U[i,j]|)
    ' 2. factorize scaled matrix
    ' 3. solve
    '
    SqrtScaleA = 0#
    For i = 0# To N - 1# Step 1
        If IsUpper Then
            J1 = i
            J2 = N - 1#
        Else
            J1 = 0#
            J2 = i
        End If
        For j = J1 To J2 Step 1
            SqrtScaleA = MaxReal(SqrtScaleA, Abs(CHA(i, j)))
        Next j
    Next i
    If SqrtScaleA = 0# Then
        SqrtScaleA = 1#
    End If
    SqrtScaleA = 1# / SqrtScaleA
    Call SPDMatrixCholeskySolveInternal(CHA, SqrtScaleA, N, IsUpper, EmptyA, False, B, M, Info, Rep, x)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Dense solver. Same as RMatrixLUSolve(), but for  SPD matrices  represented
'by their Cholesky decomposition.
'
'Algorithm features:
'* automatic detection of degenerate cases
'* O(N^2) complexity
'* condition number estimation
'* matrix is represented by its upper or lower triangle
'
'No iterative refinement is provided because such partial representation of
'matrix does not allow efficient calculation of extra-precise  matrix-vector
'products for large matrices. Use RMatrixSolve or RMatrixMixedSolve  if  you
'need iterative refinement.
'
'INPUT PARAMETERS
'    CHA     -   array[0..N-1,0..N-1], Cholesky decomposition,
'                SPDMatrixCholesky result
'    N       -   size of A
'    IsUpper -   what half of CHA is provided
'    B       -   array[0..N-1], right part
'
'OUTPUT PARAMETERS
'    Info    -   same as in RMatrixSolve
'    Rep     -   same as in RMatrixSolve
'    X       -   same as in RMatrixSolve
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub SPDMatrixCholeskySolve(ByRef CHA() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef B() As Double, _
         ByRef Info As Long, _
         ByRef Rep As DenseSolverReport, _
         ByRef x() As Double)
    Dim BM() As Double
    Dim XM() As Double
    Dim i_ As Long
    If N <= 0# Then
        Info = -1#
        Exit Sub
    End If
    ReDim BM(0 To N - 1, 0 To 1# - 1)
    For i_ = 0# To N - 1# Step 1
        BM(i_, 0#) = B(i_)
    Next i_
    Call SPDMatrixCholeskySolveM(CHA, N, IsUpper, BM, 1#, Info, Rep, XM)
    ReDim x(0 To N - 1)
    For i_ = 0# To N - 1# Step 1
        x(i_) = XM(i_, 0#)
    Next i_
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Dense solver. Same as RMatrixSolveM(), but for Hermitian positive definite
'matrices.
'
'Algorithm features:
'* automatic detection of degenerate cases
'* condition number estimation
'* O(N^3+M*N^2) complexity
'* matrix is represented by its upper or lower triangle
'
'No iterative refinement is provided because such partial representation of
'matrix does not allow efficient calculation of extra-precise  matrix-vector
'products for large matrices. Use RMatrixSolve or RMatrixMixedSolve  if  you
'need iterative refinement.
'
'INPUT PARAMETERS
'    A       -   array[0..N-1,0..N-1], system matrix
'    N       -   size of A
'    IsUpper -   what half of A is provided
'    B       -   array[0..N-1,0..M-1], right part
'    M       -   right part size
'
'OUTPUT PARAMETERS
'    Info    -   same as in RMatrixSolve.
'                Returns -3 for non-HPD matrices.
'    Rep     -   same as in RMatrixSolve
'    X       -   same as in RMatrixSolve
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub HPDMatrixSolveM(ByRef a() As Complex, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef B() As Complex, _
         ByVal M As Long, _
         ByRef Info As Long, _
         ByRef Rep As DenseSolverReport, _
         ByRef x() As Complex)
    Dim DA() As Complex
    Dim SqrtScaleA As Double
    Dim i As Long
    Dim j As Long
    Dim J1 As Long
    Dim J2 As Long
    Dim i_ As Long
    
    '
    ' prepare: check inputs, allocate space...
    '
    If N <= 0# Or M <= 0# Then
        Info = -1#
        Exit Sub
    End If
    ReDim DA(0 To N - 1, 0 To N - 1)
    
    '
    ' 1. scale matrix, max(|A[i,j]|)
    ' 2. factorize scaled matrix
    ' 3. solve
    '
    SqrtScaleA = 0#
    For i = 0# To N - 1# Step 1
        If IsUpper Then
            J1 = i
            J2 = N - 1#
        Else
            J1 = 0#
            J2 = i
        End If
        For j = J1 To J2 Step 1
            SqrtScaleA = MaxReal(SqrtScaleA, AbsComplex(a(i, j)))
        Next j
    Next i
    If SqrtScaleA = 0# Then
        SqrtScaleA = 1#
    End If
    SqrtScaleA = 1# / SqrtScaleA
    SqrtScaleA = Sqr(SqrtScaleA)
    For i = 0# To N - 1# Step 1
        If IsUpper Then
            J1 = i
            J2 = N - 1#
        Else
            J1 = 0#
            J2 = i
        End If
        For i_ = J1 To J2 Step 1
            DA(i, i_) = a(i, i_)
        Next i_
    Next i
    If Not HPDMatrixCholesky(DA, N, IsUpper) Then
        ReDim x(0 To N - 1, 0 To M - 1)
        For i = 0# To N - 1# Step 1
            For j = 0# To M - 1# Step 1
                x(i, j) = C_Complex(0#)
            Next j
        Next i
        Rep.R1 = 0#
        Rep.RInf = 0#
        Info = -3#
        Exit Sub
    End If
    Info = 1#
    Call HPDMatrixCholeskySolveInternal(DA, SqrtScaleA, N, IsUpper, a, True, B, M, Info, Rep, x)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Dense solver. Same as RMatrixSolve(),  but for Hermitian positive definite
'matrices.
'
'Algorithm features:
'* automatic detection of degenerate cases
'* condition number estimation
'* O(N^3) complexity
'* matrix is represented by its upper or lower triangle
'
'No iterative refinement is provided because such partial representation of
'matrix does not allow efficient calculation of extra-precise  matrix-vector
'products for large matrices. Use RMatrixSolve or RMatrixMixedSolve  if  you
'need iterative refinement.
'
'INPUT PARAMETERS
'    A       -   array[0..N-1,0..N-1], system matrix
'    N       -   size of A
'    IsUpper -   what half of A is provided
'    B       -   array[0..N-1], right part
'
'OUTPUT PARAMETERS
'    Info    -   same as in RMatrixSolve
'                Returns -3 for non-HPD matrices.
'    Rep     -   same as in RMatrixSolve
'    X       -   same as in RMatrixSolve
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub HPDMatrixSolve(ByRef a() As Complex, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef B() As Complex, _
         ByRef Info As Long, _
         ByRef Rep As DenseSolverReport, _
         ByRef x() As Complex)
    Dim BM() As Complex
    Dim XM() As Complex
    Dim i_ As Long
    If N <= 0# Then
        Info = -1#
        Exit Sub
    End If
    ReDim BM(0 To N - 1, 0 To 1# - 1)
    For i_ = 0# To N - 1# Step 1
        BM(i_, 0#) = B(i_)
    Next i_
    Call HPDMatrixSolveM(a, N, IsUpper, BM, 1#, Info, Rep, XM)
    ReDim x(0 To N - 1)
    For i_ = 0# To N - 1# Step 1
        x(i_) = XM(i_, 0#)
    Next i_
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Dense solver. Same as RMatrixLUSolveM(), but for HPD matrices  represented
'by their Cholesky decomposition.
'
'Algorithm features:
'* automatic detection of degenerate cases
'* O(M*N^2) complexity
'* condition number estimation
'* matrix is represented by its upper or lower triangle
'
'No iterative refinement is provided because such partial representation of
'matrix does not allow efficient calculation of extra-precise  matrix-vector
'products for large matrices. Use RMatrixSolve or RMatrixMixedSolve  if  you
'need iterative refinement.
'
'INPUT PARAMETERS
'    CHA     -   array[0..N-1,0..N-1], Cholesky decomposition,
'                HPDMatrixCholesky result
'    N       -   size of CHA
'    IsUpper -   what half of CHA is provided
'    B       -   array[0..N-1,0..M-1], right part
'    M       -   right part size
'
'OUTPUT PARAMETERS
'    Info    -   same as in RMatrixSolve
'    Rep     -   same as in RMatrixSolve
'    X       -   same as in RMatrixSolve
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub HPDMatrixCholeskySolveM(ByRef CHA() As Complex, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef B() As Complex, _
         ByVal M As Long, _
         ByRef Info As Long, _
         ByRef Rep As DenseSolverReport, _
         ByRef x() As Complex)
    Dim EmptyA() As Complex
    Dim SqrtScaleA As Double
    Dim i As Long
    Dim j As Long
    Dim J1 As Long
    Dim J2 As Long
    
    '
    ' prepare: check inputs, allocate space...
    '
    If N <= 0# Or M <= 0# Then
        Info = -1#
        Exit Sub
    End If
    
    '
    ' 1. scale matrix, max(|U[i,j]|)
    ' 2. factorize scaled matrix
    ' 3. solve
    '
    SqrtScaleA = 0#
    For i = 0# To N - 1# Step 1
        If IsUpper Then
            J1 = i
            J2 = N - 1#
        Else
            J1 = 0#
            J2 = i
        End If
        For j = J1 To J2 Step 1
            SqrtScaleA = MaxReal(SqrtScaleA, AbsComplex(CHA(i, j)))
        Next j
    Next i
    If SqrtScaleA = 0# Then
        SqrtScaleA = 1#
    End If
    SqrtScaleA = 1# / SqrtScaleA
    Call HPDMatrixCholeskySolveInternal(CHA, SqrtScaleA, N, IsUpper, EmptyA, False, B, M, Info, Rep, x)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Dense solver. Same as RMatrixLUSolve(), but for  HPD matrices  represented
'by their Cholesky decomposition.
'
'Algorithm features:
'* automatic detection of degenerate cases
'* O(N^2) complexity
'* condition number estimation
'* matrix is represented by its upper or lower triangle
'
'No iterative refinement is provided because such partial representation of
'matrix does not allow efficient calculation of extra-precise  matrix-vector
'products for large matrices. Use RMatrixSolve or RMatrixMixedSolve  if  you
'need iterative refinement.
'
'INPUT PARAMETERS
'    CHA     -   array[0..N-1,0..N-1], Cholesky decomposition,
'                SPDMatrixCholesky result
'    N       -   size of A
'    IsUpper -   what half of CHA is provided
'    B       -   array[0..N-1], right part
'
'OUTPUT PARAMETERS
'    Info    -   same as in RMatrixSolve
'    Rep     -   same as in RMatrixSolve
'    X       -   same as in RMatrixSolve
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub HPDMatrixCholeskySolve(ByRef CHA() As Complex, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef B() As Complex, _
         ByRef Info As Long, _
         ByRef Rep As DenseSolverReport, _
         ByRef x() As Complex)
    Dim BM() As Complex
    Dim XM() As Complex
    Dim i_ As Long
    If N <= 0# Then
        Info = -1#
        Exit Sub
    End If
    ReDim BM(0 To N - 1, 0 To 1# - 1)
    For i_ = 0# To N - 1# Step 1
        BM(i_, 0#) = B(i_)
    Next i_
    Call HPDMatrixCholeskySolveM(CHA, N, IsUpper, BM, 1#, Info, Rep, XM)
    ReDim x(0 To N - 1)
    For i_ = 0# To N - 1# Step 1
        x(i_) = XM(i_, 0#)
    Next i_
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Dense solver.
'
'This subroutine finds solution of the linear system A*X=B with non-square,
'possibly degenerate A.  System  is  solved in the least squares sense, and
'general least squares solution  X = X0 + CX*y  which  minimizes |A*X-B| is
'returned. If A is non-degenerate, solution in the  usual sense is returned
'
'Algorithm features:
'* automatic detection of degenerate cases
'* iterative refinement
'* O(N^3) complexity
'
'INPUT PARAMETERS
'    A       -   array[0..NRows-1,0..NCols-1], system matrix
'    NRows   -   vertical size of A
'    NCols   -   horizontal size of A
'    B       -   array[0..NCols-1], right part
'    Threshold-  a number in [0,1]. Singular values  beyond  Threshold  are
'                considered  zero.  Set  it to 0.0, if you don't understand
'                what it means, so the solver will choose good value on its
'                own.
'
'OUTPUT PARAMETERS
'    Info    -   return code:
'                * -4    SVD subroutine failed
'                * -1    if NRows<=0 or NCols<=0 or Threshold<0 was passed
'                *  1    if task is solved
'    Rep     -   solver report, see below for more info
'    X       -   array[0..N-1,0..M-1], it contains:
'                * solution of A*X=B if A is non-singular (well-conditioned
'                  or ill-conditioned, but not very close to singular)
'                * zeros,  if  A  is  singular  or  VERY  close to singular
'                  (in this case Info=-3).
'
'SOLVER REPORT
'
'Subroutine sets following fields of the Rep structure:
'* R2        reciprocal of condition number: 1/cond(A), 2-norm.
'* N         = NCols
'* K         dim(Null(A))
'* CX        array[0..N-1,0..K-1], kernel of A.
'            Columns of CX store such vectors that A*CX[i]=0.
'
'  -- ALGLIB --
'     Copyright 24.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixSolveLS(ByRef a() As Double, _
         ByVal nrows As Long, _
         ByVal NCols As Long, _
         ByRef B() As Double, _
         ByVal Threshold As Double, _
         ByRef Info As Long, _
         ByRef Rep As DenseSolverLSReport, _
         ByRef x() As Double)
    Dim SV() As Double
    Dim U() As Double
    Dim VT() As Double
    Dim RP() As Double
    Dim UTB() As Double
    Dim SUTB() As Double
    Dim tmp() As Double
    Dim TA() As Double
    Dim TX() As Double
    Dim Buf() As Double
    Dim w() As Double
    Dim i As Long
    Dim j As Long
    Dim NSV As Long
    Dim KernelIdx As Long
    Dim V As Double
    Dim VErr As Double
    Dim SVDFailed As Boolean
    Dim ZeroA As Boolean
    Dim RFS As Long
    Dim NRFS As Long
    Dim TerminateNextTime As Boolean
    Dim SmallErr As Boolean
    Dim i_ As Long
    If nrows <= 0# Or NCols <= 0# Or Threshold < 0# Then
        Info = -1#
        Exit Sub
    End If
    If Threshold = 0# Then
        Threshold = 1000# * MachineEpsilon
    End If
    
    '
    ' Factorize A first
    '
    SVDFailed = Not RMatrixSVD(a, nrows, NCols, 1#, 2#, 2#, SV, U, VT)
    ZeroA = SV(0#) = 0#
    If SVDFailed Or ZeroA Then
        If SVDFailed Then
            Info = -4#
        Else
            Info = 1#
        End If
        ReDim x(0 To NCols - 1)
        For i = 0# To NCols - 1# Step 1
            x(i) = 0#
        Next i
        Rep.N = NCols
        Rep.K = NCols
        ReDim Rep.cx(0 To NCols - 1, 0 To NCols - 1)
        For i = 0# To NCols - 1# Step 1
            For j = 0# To NCols - 1# Step 1
                If i = j Then
                    Rep.cx(i, j) = 1#
                Else
                    Rep.cx(i, j) = 0#
                End If
            Next j
        Next i
        Rep.R2 = 0#
        Exit Sub
    End If
    NSV = MinInt(NCols, nrows)
    If NSV = NCols Then
        Rep.R2 = SV(NSV - 1#) / SV(0#)
    Else
        Rep.R2 = 0#
    End If
    Rep.N = NCols
    Info = 1#
    
    '
    ' Iterative refinement of xc combined with solution:
    ' 1. xc = 0
    ' 2. calculate r = bc-A*xc using extra-precise dot product
    ' 3. solve A*y = r
    ' 4. update x:=x+r
    ' 5. goto 2
    '
    ' This cycle is executed until one of two things happens:
    ' 1. maximum number of iterations reached
    ' 2. last iteration decreased error to the lower limit
    '
    ReDim UTB(0 To NSV - 1)
    ReDim SUTB(0 To NSV - 1)
    ReDim x(0 To NCols - 1)
    ReDim tmp(0 To NCols - 1)
    ReDim TA(0 To NCols + 1# - 1)
    ReDim TX(0 To NCols + 1# - 1)
    ReDim Buf(0 To NCols + 1# - 1)
    For i = 0# To NCols - 1# Step 1
        x(i) = 0#
    Next i
    KernelIdx = NSV
    For i = 0# To NSV - 1# Step 1
        If SV(i) <= Threshold * SV(0#) Then
            KernelIdx = i
            Exit For
        End If
    Next i
    Rep.K = NCols - KernelIdx
    NRFS = DenseSolverRFSMaxV2(NCols, Rep.R2)
    TerminateNextTime = False
    ReDim RP(0 To nrows - 1)
    For RFS = 0# To NRFS Step 1
        If TerminateNextTime Then
            Exit For
        End If
        
        '
        ' calculate right part
        '
        If RFS = 0# Then
            For i_ = 0# To nrows - 1# Step 1
                RP(i_) = B(i_)
            Next i_
        Else
            SmallErr = True
            For i = 0# To nrows - 1# Step 1
                For i_ = 0# To NCols - 1# Step 1
                    TA(i_) = a(i, i_)
                Next i_
                TA(NCols) = -1#
                For i_ = 0# To NCols - 1# Step 1
                    TX(i_) = x(i_)
                Next i_
                TX(NCols) = B(i)
                Call XDot(TA, TX, NCols + 1#, Buf, V, VErr)
                RP(i) = -V
                SmallErr = SmallErr And Abs(V) < 4# * VErr
            Next i
            If SmallErr Then
                TerminateNextTime = True
            End If
        End If
        
        '
        ' solve A*dx = rp
        '
        For i = 0# To NCols - 1# Step 1
            tmp(i) = 0#
        Next i
        For i = 0# To NSV - 1# Step 1
            UTB(i) = 0#
        Next i
        For i = 0# To nrows - 1# Step 1
            V = RP(i)
            For i_ = 0# To NSV - 1# Step 1
                UTB(i_) = UTB(i_) + V * U(i, i_)
            Next i_
        Next i
        For i = 0# To NSV - 1# Step 1
            If i < KernelIdx Then
                SUTB(i) = UTB(i) / SV(i)
            Else
                SUTB(i) = 0#
            End If
        Next i
        For i = 0# To NSV - 1# Step 1
            V = SUTB(i)
            For i_ = 0# To NCols - 1# Step 1
                tmp(i_) = tmp(i_) + V * VT(i, i_)
            Next i_
        Next i
        
        '
        ' update x:  x:=x+dx
        '
        For i_ = 0# To NCols - 1# Step 1
            x(i_) = x(i_) + tmp(i_)
        Next i_
    Next RFS
    
    '
    ' fill CX
    '
    If Rep.K > 0# Then
        ReDim Rep.cx(0 To NCols - 1, 0 To Rep.K - 1)
        For i = 0# To Rep.K - 1# Step 1
            For i_ = 0# To NCols - 1# Step 1
                Rep.cx(i_, i) = VT(KernelIdx + i, i_)
            Next i_
        Next i
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal LU solver
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub RMatrixLUSolveInternal(ByRef LUA() As Double, _
         ByRef p() As Long, _
         ByRef ScaleA As Double, _
         ByVal N As Long, _
         ByRef a() As Double, _
         ByVal HaveA As Boolean, _
         ByRef B() As Double, _
         ByVal M As Long, _
         ByRef Info As Long, _
         ByRef Rep As DenseSolverReport, _
         ByRef x() As Double)
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim RFS As Long
    Dim NRFS As Long
    Dim XC() As Double
    Dim y() As Double
    Dim BC() As Double
    Dim XA() As Double
    Dim XB() As Double
    Dim TX() As Double
    Dim V As Double
    Dim VErr As Double
    Dim MXB As Double
    Dim ScaleRight As Double
    Dim SmallErr As Boolean
    Dim TerminateNextTime As Boolean
    Dim i_ As Long
    
    '
    ' prepare: check inputs, allocate space...
    '
    If N <= 0# Or M <= 0# Then
        Info = -1#
        Exit Sub
    End If
    For i = 0# To N - 1# Step 1
        If p(i) > N - 1# Or p(i) < i Then
            Info = -1#
            Exit Sub
        End If
    Next i
    ReDim x(0 To N - 1, 0 To M - 1)
    ReDim y(0 To N - 1)
    ReDim XC(0 To N - 1)
    ReDim BC(0 To N - 1)
    ReDim TX(0 To N + 1# - 1)
    ReDim XA(0 To N + 1# - 1)
    ReDim XB(0 To N + 1# - 1)
    
    '
    ' estimate condition number, test for near singularity
    '
    Rep.R1 = RMatrixLURCond1(LUA, N)
    Rep.RInf = RMatrixLURCondInf(LUA, N)
    If Rep.R1 < RCondThreshold() Or Rep.RInf < RCondThreshold() Then
        For i = 0# To N - 1# Step 1
            For j = 0# To M - 1# Step 1
                x(i, j) = 0#
            Next j
        Next i
        Rep.R1 = 0#
        Rep.RInf = 0#
        Info = -3#
        Exit Sub
    End If
    Info = 1#
    
    '
    ' solve
    '
    For K = 0# To M - 1# Step 1
        
        '
        ' copy B to contiguous storage
        '
        For i_ = 0# To N - 1# Step 1
            BC(i_) = B(i_, K)
        Next i_
        
        '
        ' Scale right part:
        ' * MX stores max(|Bi|)
        ' * ScaleRight stores actual scaling applied to B when solving systems
        '   it is chosen to make |scaleRight*b| close to 1.
        '
        MXB = 0#
        For i = 0# To N - 1# Step 1
            MXB = MaxReal(MXB, Abs(BC(i)))
        Next i
        If MXB = 0# Then
            MXB = 1#
        End If
        ScaleRight = 1# / MXB
        
        '
        ' First, non-iterative part of solution process.
        ' We use separate code for this task because
        ' XDot is quite slow and we want to save time.
        '
        For i_ = 0# To N - 1# Step 1
            XC(i_) = ScaleRight * BC(i_)
        Next i_
        Call RBasicLUSolve(LUA, p, ScaleA, N, XC, TX)
        
        '
        ' Iterative refinement of xc:
        ' * calculate r = bc-A*xc using extra-precise dot product
        ' * solve A*y = r
        ' * update x:=x+r
        '
        ' This cycle is executed until one of two things happens:
        ' 1. maximum number of iterations reached
        ' 2. last iteration decreased error to the lower limit
        '
        If HaveA Then
            NRFS = DenseSolverRFSMax(N, Rep.R1, Rep.RInf)
            TerminateNextTime = False
            For RFS = 0# To NRFS - 1# Step 1
                If TerminateNextTime Then
                    Exit For
                End If
                
                '
                ' generate right part
                '
                SmallErr = True
                For i_ = 0# To N - 1# Step 1
                    XB(i_) = XC(i_)
                Next i_
                For i = 0# To N - 1# Step 1
                    For i_ = 0# To N - 1# Step 1
                        XA(i_) = ScaleA * a(i, i_)
                    Next i_
                    XA(N) = -1#
                    XB(N) = ScaleRight * BC(i)
                    Call XDot(XA, XB, N + 1#, TX, V, VErr)
                    y(i) = -V
                    SmallErr = SmallErr And Abs(V) < 4# * VErr
                Next i
                If SmallErr Then
                    TerminateNextTime = True
                End If
                
                '
                ' solve and update
                '
                Call RBasicLUSolve(LUA, p, ScaleA, N, y, TX)
                For i_ = 0# To N - 1# Step 1
                    XC(i_) = XC(i_) + y(i_)
                Next i_
            Next RFS
        End If
        
        '
        ' Store xc.
        ' Post-scale result.
        '
        V = ScaleA * MXB
        For i_ = 0# To N - 1# Step 1
            x(i_, K) = V * XC(i_)
        Next i_
    Next K
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal Cholesky solver
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub SPDMatrixCholeskySolveInternal(ByRef CHA() As Double, _
         ByRef SqrtScaleA As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef a() As Double, _
         ByVal HaveA As Boolean, _
         ByRef B() As Double, _
         ByVal M As Long, _
         ByRef Info As Long, _
         ByRef Rep As DenseSolverReport, _
         ByRef x() As Double)
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim RFS As Long
    Dim NRFS As Long
    Dim XC() As Double
    Dim y() As Double
    Dim BC() As Double
    Dim XA() As Double
    Dim XB() As Double
    Dim TX() As Double
    Dim V As Double
    Dim VErr As Double
    Dim MXB As Double
    Dim ScaleRight As Double
    Dim SmallErr As Boolean
    Dim TerminateNextTime As Boolean
    Dim i_ As Long
    
    '
    ' prepare: check inputs, allocate space...
    '
    If N <= 0# Or M <= 0# Then
        Info = -1#
        Exit Sub
    End If
    ReDim x(0 To N - 1, 0 To M - 1)
    ReDim y(0 To N - 1)
    ReDim XC(0 To N - 1)
    ReDim BC(0 To N - 1)
    ReDim TX(0 To N + 1# - 1)
    ReDim XA(0 To N + 1# - 1)
    ReDim XB(0 To N + 1# - 1)
    
    '
    ' estimate condition number, test for near singularity
    '
    Rep.R1 = SPDMatrixCholeskyRCond(CHA, N, IsUpper)
    Rep.RInf = Rep.R1
    If Rep.R1 < RCondThreshold() Then
        For i = 0# To N - 1# Step 1
            For j = 0# To M - 1# Step 1
                x(i, j) = 0#
            Next j
        Next i
        Rep.R1 = 0#
        Rep.RInf = 0#
        Info = -3#
        Exit Sub
    End If
    Info = 1#
    
    '
    ' solve
    '
    For K = 0# To M - 1# Step 1
        
        '
        ' copy B to contiguous storage
        '
        For i_ = 0# To N - 1# Step 1
            BC(i_) = B(i_, K)
        Next i_
        
        '
        ' Scale right part:
        ' * MX stores max(|Bi|)
        ' * ScaleRight stores actual scaling applied to B when solving systems
        '   it is chosen to make |scaleRight*b| close to 1.
        '
        MXB = 0#
        For i = 0# To N - 1# Step 1
            MXB = MaxReal(MXB, Abs(BC(i)))
        Next i
        If MXB = 0# Then
            MXB = 1#
        End If
        ScaleRight = 1# / MXB
        
        '
        ' First, non-iterative part of solution process.
        ' We use separate code for this task because
        ' XDot is quite slow and we want to save time.
        '
        For i_ = 0# To N - 1# Step 1
            XC(i_) = ScaleRight * BC(i_)
        Next i_
        Call SPDBasicCholeskySolve(CHA, SqrtScaleA, N, IsUpper, XC, TX)
        
        '
        ' Store xc.
        ' Post-scale result.
        '
        V = Square(SqrtScaleA) * MXB
        For i_ = 0# To N - 1# Step 1
            x(i_, K) = V * XC(i_)
        Next i_
    Next K
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal LU solver
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub CMatrixLUSolveInternal(ByRef LUA() As Complex, _
         ByRef p() As Long, _
         ByRef ScaleA As Double, _
         ByVal N As Long, _
         ByRef a() As Complex, _
         ByVal HaveA As Boolean, _
         ByRef B() As Complex, _
         ByVal M As Long, _
         ByRef Info As Long, _
         ByRef Rep As DenseSolverReport, _
         ByRef x() As Complex)
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim RFS As Long
    Dim NRFS As Long
    Dim XC() As Complex
    Dim y() As Complex
    Dim BC() As Complex
    Dim XA() As Complex
    Dim XB() As Complex
    Dim TX() As Complex
    Dim TmpBuf() As Double
    Dim V As Complex
    Dim VErr As Double
    Dim MXB As Double
    Dim ScaleRight As Double
    Dim SmallErr As Boolean
    Dim TerminateNextTime As Boolean
    Dim i_ As Long
    
    '
    ' prepare: check inputs, allocate space...
    '
    If N <= 0# Or M <= 0# Then
        Info = -1#
        Exit Sub
    End If
    For i = 0# To N - 1# Step 1
        If p(i) > N - 1# Or p(i) < i Then
            Info = -1#
            Exit Sub
        End If
    Next i
    ReDim x(0 To N - 1, 0 To M - 1)
    ReDim y(0 To N - 1)
    ReDim XC(0 To N - 1)
    ReDim BC(0 To N - 1)
    ReDim TX(0 To N - 1)
    ReDim XA(0 To N + 1# - 1)
    ReDim XB(0 To N + 1# - 1)
    ReDim TmpBuf(0 To 2# * N + 2# - 1)
    
    '
    ' estimate condition number, test for near singularity
    '
    Rep.R1 = CMatrixLURCond1(LUA, N)
    Rep.RInf = CMatrixLURCondInf(LUA, N)
    If Rep.R1 < RCondThreshold() Or Rep.RInf < RCondThreshold() Then
        For i = 0# To N - 1# Step 1
            For j = 0# To M - 1# Step 1
                x(i, j) = C_Complex(0#)
            Next j
        Next i
        Rep.R1 = 0#
        Rep.RInf = 0#
        Info = -3#
        Exit Sub
    End If
    Info = 1#
    
    '
    ' solve
    '
    For K = 0# To M - 1# Step 1
        
        '
        ' copy B to contiguous storage
        '
        For i_ = 0# To N - 1# Step 1
            BC(i_) = B(i_, K)
        Next i_
        
        '
        ' Scale right part:
        ' * MX stores max(|Bi|)
        ' * ScaleRight stores actual scaling applied to B when solving systems
        '   it is chosen to make |scaleRight*b| close to 1.
        '
        MXB = 0#
        For i = 0# To N - 1# Step 1
            MXB = MaxReal(MXB, AbsComplex(BC(i)))
        Next i
        If MXB = 0# Then
            MXB = 1#
        End If
        ScaleRight = 1# / MXB
        
        '
        ' First, non-iterative part of solution process.
        ' We use separate code for this task because
        ' XDot is quite slow and we want to save time.
        '
        For i_ = 0# To N - 1# Step 1
            XC(i_) = C_MulR(BC(i_), ScaleRight)
        Next i_
        Call CBasicLUSolve(LUA, p, ScaleA, N, XC, TX)
        
        '
        ' Iterative refinement of xc:
        ' * calculate r = bc-A*xc using extra-precise dot product
        ' * solve A*y = r
        ' * update x:=x+r
        '
        ' This cycle is executed until one of two things happens:
        ' 1. maximum number of iterations reached
        ' 2. last iteration decreased error to the lower limit
        '
        If HaveA Then
            NRFS = DenseSolverRFSMax(N, Rep.R1, Rep.RInf)
            TerminateNextTime = False
            For RFS = 0# To NRFS - 1# Step 1
                If TerminateNextTime Then
                    Exit For
                End If
                
                '
                ' generate right part
                '
                SmallErr = True
                For i_ = 0# To N - 1# Step 1
                    XB(i_) = XC(i_)
                Next i_
                For i = 0# To N - 1# Step 1
                    For i_ = 0# To N - 1# Step 1
                        XA(i_) = C_MulR(a(i, i_), ScaleA)
                    Next i_
                    XA(N) = C_Complex(-1#)
                    XB(N) = C_MulR(BC(i), ScaleRight)
                    Call XCDot(XA, XB, N + 1#, TmpBuf, V, VErr)
                    y(i) = C_Opposite(V)
                    SmallErr = SmallErr And AbsComplex(V) < 4# * VErr
                Next i
                If SmallErr Then
                    TerminateNextTime = True
                End If
                
                '
                ' solve and update
                '
                Call CBasicLUSolve(LUA, p, ScaleA, N, y, TX)
                For i_ = 0# To N - 1# Step 1
                    XC(i_) = C_Add(XC(i_), y(i_))
                Next i_
            Next RFS
        End If
        
        '
        ' Store xc.
        ' Post-scale result.
        '
        V = C_Complex(ScaleA * MXB)
        For i_ = 0# To N - 1# Step 1
            x(i_, K) = C_Mul(V, XC(i_))
        Next i_
    Next K
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal Cholesky solver
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub HPDMatrixCholeskySolveInternal(ByRef CHA() As Complex, _
         ByRef SqrtScaleA As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef a() As Complex, _
         ByVal HaveA As Boolean, _
         ByRef B() As Complex, _
         ByVal M As Long, _
         ByRef Info As Long, _
         ByRef Rep As DenseSolverReport, _
         ByRef x() As Complex)
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim RFS As Long
    Dim NRFS As Long
    Dim XC() As Complex
    Dim y() As Complex
    Dim BC() As Complex
    Dim XA() As Complex
    Dim XB() As Complex
    Dim TX() As Complex
    Dim V As Double
    Dim VErr As Double
    Dim MXB As Double
    Dim ScaleRight As Double
    Dim SmallErr As Boolean
    Dim TerminateNextTime As Boolean
    Dim i_ As Long
    
    '
    ' prepare: check inputs, allocate space...
    '
    If N <= 0# Or M <= 0# Then
        Info = -1#
        Exit Sub
    End If
    ReDim x(0 To N - 1, 0 To M - 1)
    ReDim y(0 To N - 1)
    ReDim XC(0 To N - 1)
    ReDim BC(0 To N - 1)
    ReDim TX(0 To N + 1# - 1)
    ReDim XA(0 To N + 1# - 1)
    ReDim XB(0 To N + 1# - 1)
    
    '
    ' estimate condition number, test for near singularity
    '
    Rep.R1 = HPDMatrixCholeskyRCond(CHA, N, IsUpper)
    Rep.RInf = Rep.R1
    If Rep.R1 < RCondThreshold() Then
        For i = 0# To N - 1# Step 1
            For j = 0# To M - 1# Step 1
                x(i, j) = C_Complex(0#)
            Next j
        Next i
        Rep.R1 = 0#
        Rep.RInf = 0#
        Info = -3#
        Exit Sub
    End If
    Info = 1#
    
    '
    ' solve
    '
    For K = 0# To M - 1# Step 1
        
        '
        ' copy B to contiguous storage
        '
        For i_ = 0# To N - 1# Step 1
            BC(i_) = B(i_, K)
        Next i_
        
        '
        ' Scale right part:
        ' * MX stores max(|Bi|)
        ' * ScaleRight stores actual scaling applied to B when solving systems
        '   it is chosen to make |scaleRight*b| close to 1.
        '
        MXB = 0#
        For i = 0# To N - 1# Step 1
            MXB = MaxReal(MXB, AbsComplex(BC(i)))
        Next i
        If MXB = 0# Then
            MXB = 1#
        End If
        ScaleRight = 1# / MXB
        
        '
        ' First, non-iterative part of solution process.
        ' We use separate code for this task because
        ' XDot is quite slow and we want to save time.
        '
        For i_ = 0# To N - 1# Step 1
            XC(i_) = C_MulR(BC(i_), ScaleRight)
        Next i_
        Call HPDBasicCholeskySolve(CHA, SqrtScaleA, N, IsUpper, XC, TX)
        
        '
        ' Store xc.
        ' Post-scale result.
        '
        V = Square(SqrtScaleA) * MXB
        For i_ = 0# To N - 1# Step 1
            x(i_, K) = C_MulR(XC(i_), V)
        Next i_
    Next K
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal subroutine.
'Returns maximum count of RFS iterations as function of:
'1. machine epsilon
'2. task size.
'3. condition number
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Function DenseSolverRFSMax(ByVal N As Long, _
         ByVal R1 As Double, _
         ByVal RInf As Double) As Long
    Dim Result As Long
    Result = 5#
    DenseSolverRFSMax = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal subroutine.
'Returns maximum count of RFS iterations as function of:
'1. machine epsilon
'2. task size.
'3. norm-2 condition number
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Function DenseSolverRFSMaxV2(ByVal N As Long, _
         ByVal R2 As Double) As Long
    Dim Result As Long
    Result = DenseSolverRFSMax(N, 0#, 0#)
    DenseSolverRFSMaxV2 = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Basic LU solver for ScaleA*PLU*x = y.
'
'This subroutine assumes that:
'* L is well-scaled, and it is U which needs scaling by ScaleA.
'* A=PLU is well-conditioned, so no zero divisions or overflow may occur
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub RBasicLUSolve(ByRef LUA() As Double, _
         ByRef p() As Long, _
         ByVal ScaleA As Double, _
         ByVal N As Long, _
         ByRef XB() As Double, _
         ByRef tmp() As Double)
    Dim i As Long
    Dim V As Double
    Dim i_ As Long
    For i = 0# To N - 1# Step 1
        If p(i) <> i Then
            V = XB(i)
            XB(i) = XB(p(i))
            XB(p(i)) = V
        End If
    Next i
    For i = 1# To N - 1# Step 1
        V = 0#
        For i_ = 0# To i - 1# Step 1
            V = V + LUA(i, i_) * XB(i_)
        Next i_
        XB(i) = XB(i) - V
    Next i
    XB(N - 1#) = XB(N - 1#) / (ScaleA * LUA(N - 1#, N - 1#))
    For i = N - 2# To 0# Step -1
        For i_ = i + 1# To N - 1# Step 1
            tmp(i_) = ScaleA * LUA(i, i_)
        Next i_
        V = 0#
        For i_ = i + 1# To N - 1# Step 1
            V = V + tmp(i_) * XB(i_)
        Next i_
        XB(i) = (XB(i) - V) / (ScaleA * LUA(i, i))
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Basic Cholesky solver for ScaleA*Cholesky(A)'*x = y.
'
'This subroutine assumes that:
'* A*ScaleA is well scaled
'* A is well-conditioned, so no zero divisions or overflow may occur
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub SPDBasicCholeskySolve(ByRef CHA() As Double, _
         ByVal SqrtScaleA As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef XB() As Double, _
         ByRef tmp() As Double)
    Dim i As Long
    Dim V As Double
    Dim i_ As Long
    
    '
    ' A = L*L' or A=U'*U
    '
    If IsUpper Then
        
        '
        ' Solve U'*y=b first.
        '
        For i = 0# To N - 1# Step 1
            XB(i) = XB(i) / (SqrtScaleA * CHA(i, i))
            If i < N - 1# Then
                V = XB(i)
                For i_ = i + 1# To N - 1# Step 1
                    tmp(i_) = SqrtScaleA * CHA(i, i_)
                Next i_
                For i_ = i + 1# To N - 1# Step 1
                    XB(i_) = XB(i_) - V * tmp(i_)
                Next i_
            End If
        Next i
        
        '
        ' Solve U*x=y then.
        '
        For i = N - 1# To 0# Step -1
            If i < N - 1# Then
                For i_ = i + 1# To N - 1# Step 1
                    tmp(i_) = SqrtScaleA * CHA(i, i_)
                Next i_
                V = 0#
                For i_ = i + 1# To N - 1# Step 1
                    V = V + tmp(i_) * XB(i_)
                Next i_
                XB(i) = XB(i) - V
            End If
            XB(i) = XB(i) / (SqrtScaleA * CHA(i, i))
        Next i
    Else
        
        '
        ' Solve L*y=b first
        '
        For i = 0# To N - 1# Step 1
            If i > 0# Then
                For i_ = 0# To i - 1# Step 1
                    tmp(i_) = SqrtScaleA * CHA(i, i_)
                Next i_
                V = 0#
                For i_ = 0# To i - 1# Step 1
                    V = V + tmp(i_) * XB(i_)
                Next i_
                XB(i) = XB(i) - V
            End If
            XB(i) = XB(i) / (SqrtScaleA * CHA(i, i))
        Next i
        
        '
        ' Solve L'*x=y then.
        '
        For i = N - 1# To 0# Step -1
            XB(i) = XB(i) / (SqrtScaleA * CHA(i, i))
            If i > 0# Then
                V = XB(i)
                For i_ = 0# To i - 1# Step 1
                    tmp(i_) = SqrtScaleA * CHA(i, i_)
                Next i_
                For i_ = 0# To i - 1# Step 1
                    XB(i_) = XB(i_) - V * tmp(i_)
                Next i_
            End If
        Next i
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Basic LU solver for ScaleA*PLU*x = y.
'
'This subroutine assumes that:
'* L is well-scaled, and it is U which needs scaling by ScaleA.
'* A=PLU is well-conditioned, so no zero divisions or overflow may occur
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub CBasicLUSolve(ByRef LUA() As Complex, _
         ByRef p() As Long, _
         ByVal ScaleA As Double, _
         ByVal N As Long, _
         ByRef XB() As Complex, _
         ByRef tmp() As Complex)
    Dim i As Long
    Dim V As Complex
    Dim i_ As Long
    For i = 0# To N - 1# Step 1
        If p(i) <> i Then
            V = XB(i)
            XB(i) = XB(p(i))
            XB(p(i)) = V
        End If
    Next i
    For i = 1# To N - 1# Step 1
        V = C_Complex(0#)
        For i_ = 0# To i - 1# Step 1
            V = C_Add(V, C_Mul(LUA(i, i_), XB(i_)))
        Next i_
        XB(i) = C_Sub(XB(i), V)
    Next i
    XB(N - 1#) = C_Div(XB(N - 1#), C_MulR(LUA(N - 1#, N - 1#), ScaleA))
    For i = N - 2# To 0# Step -1
        For i_ = i + 1# To N - 1# Step 1
            tmp(i_) = C_MulR(LUA(i, i_), ScaleA)
        Next i_
        V = C_Complex(0#)
        For i_ = i + 1# To N - 1# Step 1
            V = C_Add(V, C_Mul(tmp(i_), XB(i_)))
        Next i_
        XB(i) = C_Div(C_Sub(XB(i), V), C_MulR(LUA(i, i), ScaleA))
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Basic Cholesky solver for ScaleA*Cholesky(A)'*x = y.
'
'This subroutine assumes that:
'* A*ScaleA is well scaled
'* A is well-conditioned, so no zero divisions or overflow may occur
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub HPDBasicCholeskySolve(ByRef CHA() As Complex, _
         ByVal SqrtScaleA As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef XB() As Complex, _
         ByRef tmp() As Complex)
    Dim i As Long
    Dim V As Complex
    Dim i_ As Long
    
    '
    ' A = L*L' or A=U'*U
    '
    If IsUpper Then
        
        '
        ' Solve U'*y=b first.
        '
        For i = 0# To N - 1# Step 1
            XB(i) = C_Div(XB(i), C_MulR(Conj(CHA(i, i)), SqrtScaleA))
            If i < N - 1# Then
                V = XB(i)
                For i_ = i + 1# To N - 1# Step 1
                    tmp(i_) = C_MulR(Conj(CHA(i, i_)), SqrtScaleA)
                Next i_
                For i_ = i + 1# To N - 1# Step 1
                    XB(i_) = C_Sub(XB(i_), C_Mul(V, tmp(i_)))
                Next i_
            End If
        Next i
        
        '
        ' Solve U*x=y then.
        '
        For i = N - 1# To 0# Step -1
            If i < N - 1# Then
                For i_ = i + 1# To N - 1# Step 1
                    tmp(i_) = C_MulR(CHA(i, i_), SqrtScaleA)
                Next i_
                V = C_Complex(0#)
                For i_ = i + 1# To N - 1# Step 1
                    V = C_Add(V, C_Mul(tmp(i_), XB(i_)))
                Next i_
                XB(i) = C_Sub(XB(i), V)
            End If
            XB(i) = C_Div(XB(i), C_MulR(CHA(i, i), SqrtScaleA))
        Next i
    Else
        
        '
        ' Solve L*y=b first
        '
        For i = 0# To N - 1# Step 1
            If i > 0# Then
                For i_ = 0# To i - 1# Step 1
                    tmp(i_) = C_MulR(CHA(i, i_), SqrtScaleA)
                Next i_
                V = C_Complex(0#)
                For i_ = 0# To i - 1# Step 1
                    V = C_Add(V, C_Mul(tmp(i_), XB(i_)))
                Next i_
                XB(i) = C_Sub(XB(i), V)
            End If
            XB(i) = C_Div(XB(i), C_MulR(CHA(i, i), SqrtScaleA))
        Next i
        
        '
        ' Solve L'*x=y then.
        '
        For i = N - 1# To 0# Step -1
            XB(i) = C_Div(XB(i), C_MulR(Conj(CHA(i, i)), SqrtScaleA))
            If i > 0# Then
                V = XB(i)
                For i_ = 0# To i - 1# Step 1
                    tmp(i_) = C_MulR(Conj(CHA(i, i_)), SqrtScaleA)
                Next i_
                For i_ = 0# To i - 1# Step 1
                    XB(i_) = C_Sub(XB(i_), C_Mul(V, tmp(i_)))
                Next i_
            End If
        Next i
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2005-2007, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Finding the eigenvalues and eigenvectors of a symmetric matrix
'
'The algorithm finds eigen pairs of a symmetric matrix by reducing it to
'tridiagonal form and using the QL/QR algorithm.
'
'Input parameters:
'    A       -   symmetric matrix which is given by its upper or lower
'                triangular part.
'                Array whose indexes range within [0..N-1, 0..N-1].
'    N       -   size of matrix A.
'    IsUpper -   storage format.
'    ZNeeded -   flag controlling whether the eigenvectors are needed or not.
'                If ZNeeded is equal to:
'                 * 0, the eigenvectors are not returned;
'                 * 1, the eigenvectors are returned.
'
'Output parameters:
'    D       -   eigenvalues in ascending order.
'                Array whose index ranges within [0..N-1].
'    Z       -   if ZNeeded is equal to:
'                 * 0, Z hasnt changed;
'                 * 1, Z contains the eigenvectors.
'                Array whose indexes range within [0..N-1, 0..N-1].
'                The eigenvectors are stored in the matrix columns.
'
'Result:
'    True, if the algorithm has converged.
'    False, if the algorithm hasn't converged (rare case).
'
'  -- ALGLIB --
'     Copyright 2005-2008 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function SMatrixEVD(ByRef A_() As Double, _
         ByVal N As Long, _
         ByVal ZNeeded As Long, _
         ByVal IsUpper As Boolean, _
         ByRef d() As Double, _
         ByRef z() As Double) As Boolean
    Dim Result As Boolean
    Dim a() As Double
    Dim Tau() As Double
    Dim e() As Double
    a = A_
    Call SMatrixTD(a, N, IsUpper, Tau, d, e)
    If ZNeeded = 1# Then
        Call SMatrixTDUnpackQ(a, N, IsUpper, Tau, z)
    End If
    Result = SMatrixTDEVD(d, e, N, ZNeeded, z)
    SMatrixEVD = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Subroutine for finding the eigenvalues (and eigenvectors) of  a  symmetric
'matrix  in  a  given half open interval (A, B] by using  a  bisection  and
'inverse iteration
'
'Input parameters:
'    A       -   symmetric matrix which is given by its upper or lower
'                triangular part. Array [0..N-1, 0..N-1].
'    N       -   size of matrix A.
'    ZNeeded -   flag controlling whether the eigenvectors are needed or not.
'                If ZNeeded is equal to:
'                 * 0, the eigenvectors are not returned;
'                 * 1, the eigenvectors are returned.
'    IsUpperA -  storage format of matrix A.
'    B1, B2 -    half open interval (B1, B2] to search eigenvalues in.
'
'Output parameters:
'    M       -   number of eigenvalues found in a given half-interval (M>=0).
'    W       -   array of the eigenvalues found.
'                Array whose index ranges within [0..M-1].
'    Z       -   if ZNeeded is equal to:
'                 * 0, Z hasnt changed;
'                 * 1, Z contains eigenvectors.
'                Array whose indexes range within [0..N-1, 0..M-1].
'                The eigenvectors are stored in the matrix columns.
'
'Result:
'    True, if successful. M contains the number of eigenvalues in the given
'    half-interval (could be equal to 0), W contains the eigenvalues,
'    Z contains the eigenvectors (if needed).
'
'    False, if the bisection method subroutine wasn't able to find the
'    eigenvalues in the given interval or if the inverse iteration subroutine
'    wasn't able to find all the corresponding eigenvectors.
'    In that case, the eigenvalues and eigenvectors are not returned,
'    M is equal to 0.
'
'  -- ALGLIB --
'     Copyright 07.01.2006 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function SMatrixEVDR(ByRef A_() As Double, _
         ByVal N As Long, _
         ByVal ZNeeded As Long, _
         ByVal IsUpper As Boolean, _
         ByVal b1 As Double, _
         ByVal b2 As Double, _
         ByRef M As Long, _
         ByRef w() As Double, _
         ByRef z() As Double) As Boolean
    Dim Result As Boolean
    Dim a() As Double
    Dim Tau() As Double
    Dim e() As Double
    a = A_
    Call SMatrixTD(a, N, IsUpper, Tau, w, e)
    If ZNeeded = 1# Then
        Call SMatrixTDUnpackQ(a, N, IsUpper, Tau, z)
    End If
    Result = SMatrixTDEVDR(w, e, N, ZNeeded, b1, b2, M, z)
    SMatrixEVDR = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Subroutine for finding the eigenvalues and  eigenvectors  of  a  symmetric
'matrix with given indexes by using bisection and inverse iteration methods.
'
'Input parameters:
'    A       -   symmetric matrix which is given by its upper or lower
'                triangular part. Array whose indexes range within [0..N-1, 0..N-1].
'    N       -   size of matrix A.
'    ZNeeded -   flag controlling whether the eigenvectors are needed or not.
'                If ZNeeded is equal to:
'                 * 0, the eigenvectors are not returned;
'                 * 1, the eigenvectors are returned.
'    IsUpperA -  storage format of matrix A.
'    I1, I2 -    index interval for searching (from I1 to I2).
'                0 <= I1 <= I2 <= N-1.
'
'Output parameters:
'    W       -   array of the eigenvalues found.
'                Array whose index ranges within [0..I2-I1].
'    Z       -   if ZNeeded is equal to:
'                 * 0, Z hasnt changed;
'                 * 1, Z contains eigenvectors.
'                Array whose indexes range within [0..N-1, 0..I2-I1].
'                In that case, the eigenvectors are stored in the matrix columns.
'
'Result:
'    True, if successful. W contains the eigenvalues, Z contains the
'    eigenvectors (if needed).
'
'    False, if the bisection method subroutine wasn't able to find the
'    eigenvalues in the given interval or if the inverse iteration subroutine
'    wasn't able to find all the corresponding eigenvectors.
'    In that case, the eigenvalues and eigenvectors are not returned.
'
'  -- ALGLIB --
'     Copyright 07.01.2006 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function SMatrixEVDI(ByRef A_() As Double, _
         ByVal N As Long, _
         ByVal ZNeeded As Long, _
         ByVal IsUpper As Boolean, _
         ByVal I1 As Long, _
         ByVal I2 As Long, _
         ByRef w() As Double, _
         ByRef z() As Double) As Boolean
    Dim Result As Boolean
    Dim a() As Double
    Dim Tau() As Double
    Dim e() As Double
    a = A_
    Call SMatrixTD(a, N, IsUpper, Tau, w, e)
    If ZNeeded = 1# Then
        Call SMatrixTDUnpackQ(a, N, IsUpper, Tau, z)
    End If
    Result = SMatrixTDEVDI(w, e, N, ZNeeded, I1, I2, z)
    SMatrixEVDI = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Finding the eigenvalues and eigenvectors of a Hermitian matrix
'
'The algorithm finds eigen pairs of a Hermitian matrix by  reducing  it  to
'real tridiagonal form and using the QL/QR algorithm.
'
'Input parameters:
'    A       -   Hermitian matrix which is given  by  its  upper  or  lower
'                triangular part.
'                Array whose indexes range within [0..N-1, 0..N-1].
'    N       -   size of matrix A.
'    IsUpper -   storage format.
'    ZNeeded -   flag controlling whether the eigenvectors  are  needed  or
'                not. If ZNeeded is equal to:
'                 * 0, the eigenvectors are not returned;
'                 * 1, the eigenvectors are returned.
'
'Output parameters:
'    D       -   eigenvalues in ascending order.
'                Array whose index ranges within [0..N-1].
'    Z       -   if ZNeeded is equal to:
'                 * 0, Z hasnt changed;
'                 * 1, Z contains the eigenvectors.
'                Array whose indexes range within [0..N-1, 0..N-1].
'                The eigenvectors are stored in the matrix columns.
'
'Result:
'    True, if the algorithm has converged.
'    False, if the algorithm hasn't converged (rare case).
'
'Note:
'    eigenvectors of Hermitian matrix are defined up to  multiplication  by
'    a complex number L, such that |L|=1.
'
'  -- ALGLIB --
'     Copyright 2005, 23 March 2007 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function HMatrixEVD(ByRef A_() As Complex, _
         ByVal N As Long, _
         ByVal ZNeeded As Long, _
         ByVal IsUpper As Boolean, _
         ByRef d() As Double, _
         ByRef z() As Complex) As Boolean
    Dim Result As Boolean
    Dim a() As Complex
    Dim Tau() As Complex
    Dim e() As Double
    Dim WORK() As Double
    Dim t() As Double
    Dim q() As Complex
    Dim i As Long
    Dim K As Long
    Dim V As Double
    Dim i_ As Long
    a = A_
    
    '
    ' Reduce to tridiagonal form
    '
    Call HMatrixTD(a, N, IsUpper, Tau, d, e)
    If ZNeeded = 1# Then
        Call HMatrixTDUnpackQ(a, N, IsUpper, Tau, q)
        ZNeeded = 2#
    End If
    
    '
    ' TDEVD
    '
    Result = SMatrixTDEVD(d, e, N, ZNeeded, t)
    
    '
    ' Eigenvectors are needed
    ' Calculate Z = Q*T = Re(Q)*T + i*Im(Q)*T
    '
    If Result And ZNeeded <> 0# Then
        ReDim WORK(0# To N - 1#)
        ReDim z(0# To N - 1#, 0# To N - 1#)
        For i = 0# To N - 1# Step 1
            
            '
            ' Calculate real part
            '
            For K = 0# To N - 1# Step 1
                WORK(K) = 0#
            Next K
            For K = 0# To N - 1# Step 1
                V = q(i, K).x
                For i_ = 0# To N - 1# Step 1
                    WORK(i_) = WORK(i_) + V * t(K, i_)
                Next i_
            Next K
            For K = 0# To N - 1# Step 1
                z(i, K).x = WORK(K)
            Next K
            
            '
            ' Calculate imaginary part
            '
            For K = 0# To N - 1# Step 1
                WORK(K) = 0#
            Next K
            For K = 0# To N - 1# Step 1
                V = q(i, K).y
                For i_ = 0# To N - 1# Step 1
                    WORK(i_) = WORK(i_) + V * t(K, i_)
                Next i_
            Next K
            For K = 0# To N - 1# Step 1
                z(i, K).y = WORK(K)
            Next K
        Next i
    End If
    HMatrixEVD = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Subroutine for finding the eigenvalues (and eigenvectors) of  a  Hermitian
'matrix  in  a  given half-interval (A, B] by using a bisection and inverse
'iteration
'
'Input parameters:
'    A       -   Hermitian matrix which is given  by  its  upper  or  lower
'                triangular  part.  Array  whose   indexes   range   within
'                [0..N-1, 0..N-1].
'    N       -   size of matrix A.
'    ZNeeded -   flag controlling whether the eigenvectors  are  needed  or
'                not. If ZNeeded is equal to:
'                 * 0, the eigenvectors are not returned;
'                 * 1, the eigenvectors are returned.
'    IsUpperA -  storage format of matrix A.
'    B1, B2 -    half-interval (B1, B2] to search eigenvalues in.
'
'Output parameters:
'    M       -   number of eigenvalues found in a given half-interval, M>=0
'    W       -   array of the eigenvalues found.
'                Array whose index ranges within [0..M-1].
'    Z       -   if ZNeeded is equal to:
'                 * 0, Z hasnt changed;
'                 * 1, Z contains eigenvectors.
'                Array whose indexes range within [0..N-1, 0..M-1].
'                The eigenvectors are stored in the matrix columns.
'
'Result:
'    True, if successful. M contains the number of eigenvalues in the given
'    half-interval (could be equal to 0), W contains the eigenvalues,
'    Z contains the eigenvectors (if needed).
'
'    False, if the bisection method subroutine  wasn't  able  to  find  the
'    eigenvalues  in  the  given  interval  or  if  the  inverse  iteration
'    subroutine  wasn't  able  to  find all the corresponding eigenvectors.
'    In that case, the eigenvalues and eigenvectors are not returned, M  is
'    equal to 0.
'
'Note:
'    eigen vectors of Hermitian matrix are defined up to multiplication  by
'    a complex number L, such as |L|=1.
'
'  -- ALGLIB --
'     Copyright 07.01.2006, 24.03.2007 by Bochkanov Sergey.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function HMatrixEVDR(ByRef A_() As Complex, _
         ByVal N As Long, _
         ByVal ZNeeded As Long, _
         ByVal IsUpper As Boolean, _
         ByVal b1 As Double, _
         ByVal b2 As Double, _
         ByRef M As Long, _
         ByRef w() As Double, _
         ByRef z() As Complex) As Boolean
    Dim Result As Boolean
    Dim a() As Complex
    Dim q() As Complex
    Dim t() As Double
    Dim Tau() As Complex
    Dim e() As Double
    Dim WORK() As Double
    Dim i As Long
    Dim K As Long
    Dim V As Double
    Dim i_ As Long
    a = A_
    
    '
    ' Reduce to tridiagonal form
    '
    Call HMatrixTD(a, N, IsUpper, Tau, w, e)
    If ZNeeded = 1# Then
        Call HMatrixTDUnpackQ(a, N, IsUpper, Tau, q)
        ZNeeded = 2#
    End If
    
    '
    ' Bisection and inverse iteration
    '
    Result = SMatrixTDEVDR(w, e, N, ZNeeded, b1, b2, M, t)
    
    '
    ' Eigenvectors are needed
    ' Calculate Z = Q*T = Re(Q)*T + i*Im(Q)*T
    '
    If Result And ZNeeded <> 0# And M <> 0# Then
        ReDim WORK(0# To M - 1#)
        ReDim z(0# To N - 1#, 0# To M - 1#)
        For i = 0# To N - 1# Step 1
            
            '
            ' Calculate real part
            '
            For K = 0# To M - 1# Step 1
                WORK(K) = 0#
            Next K
            For K = 0# To N - 1# Step 1
                V = q(i, K).x
                For i_ = 0# To M - 1# Step 1
                    WORK(i_) = WORK(i_) + V * t(K, i_)
                Next i_
            Next K
            For K = 0# To M - 1# Step 1
                z(i, K).x = WORK(K)
            Next K
            
            '
            ' Calculate imaginary part
            '
            For K = 0# To M - 1# Step 1
                WORK(K) = 0#
            Next K
            For K = 0# To N - 1# Step 1
                V = q(i, K).y
                For i_ = 0# To M - 1# Step 1
                    WORK(i_) = WORK(i_) + V * t(K, i_)
                Next i_
            Next K
            For K = 0# To M - 1# Step 1
                z(i, K).y = WORK(K)
            Next K
        Next i
    End If
    HMatrixEVDR = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Subroutine for finding the eigenvalues and  eigenvectors  of  a  Hermitian
'matrix with given indexes by using bisection and inverse iteration methods
'
'Input parameters:
'    A       -   Hermitian matrix which is given  by  its  upper  or  lower
'                triangular part.
'                Array whose indexes range within [0..N-1, 0..N-1].
'    N       -   size of matrix A.
'    ZNeeded -   flag controlling whether the eigenvectors  are  needed  or
'                not. If ZNeeded is equal to:
'                 * 0, the eigenvectors are not returned;
'                 * 1, the eigenvectors are returned.
'    IsUpperA -  storage format of matrix A.
'    I1, I2 -    index interval for searching (from I1 to I2).
'                0 <= I1 <= I2 <= N-1.
'
'Output parameters:
'    W       -   array of the eigenvalues found.
'                Array whose index ranges within [0..I2-I1].
'    Z       -   if ZNeeded is equal to:
'                 * 0, Z hasnt changed;
'                 * 1, Z contains eigenvectors.
'                Array whose indexes range within [0..N-1, 0..I2-I1].
'                In  that  case,  the eigenvectors are stored in the matrix
'                columns.
'
'Result:
'    True, if successful. W contains the eigenvalues, Z contains the
'    eigenvectors (if needed).
'
'    False, if the bisection method subroutine  wasn't  able  to  find  the
'    eigenvalues  in  the  given  interval  or  if  the  inverse  iteration
'    subroutine wasn't able to find  all  the  corresponding  eigenvectors.
'    In that case, the eigenvalues and eigenvectors are not returned.
'
'Note:
'    eigen vectors of Hermitian matrix are defined up to multiplication  by
'    a complex number L, such as |L|=1.
'
'  -- ALGLIB --
'     Copyright 07.01.2006, 24.03.2007 by Bochkanov Sergey.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function HMatrixEVDI(ByRef A_() As Complex, _
         ByVal N As Long, _
         ByVal ZNeeded As Long, _
         ByVal IsUpper As Boolean, _
         ByVal I1 As Long, _
         ByVal I2 As Long, _
         ByRef w() As Double, _
         ByRef z() As Complex) As Boolean
    Dim Result As Boolean
    Dim a() As Complex
    Dim q() As Complex
    Dim t() As Double
    Dim Tau() As Complex
    Dim e() As Double
    Dim WORK() As Double
    Dim i As Long
    Dim K As Long
    Dim V As Double
    Dim M As Long
    Dim i_ As Long
    a = A_
    
    '
    ' Reduce to tridiagonal form
    '
    Call HMatrixTD(a, N, IsUpper, Tau, w, e)
    If ZNeeded = 1# Then
        Call HMatrixTDUnpackQ(a, N, IsUpper, Tau, q)
        ZNeeded = 2#
    End If
    
    '
    ' Bisection and inverse iteration
    '
    Result = SMatrixTDEVDI(w, e, N, ZNeeded, I1, I2, t)
    
    '
    ' Eigenvectors are needed
    ' Calculate Z = Q*T = Re(Q)*T + i*Im(Q)*T
    '
    M = I2 - I1 + 1#
    If Result And ZNeeded <> 0# Then
        ReDim WORK(0# To M - 1#)
        ReDim z(0# To N - 1#, 0# To M - 1#)
        For i = 0# To N - 1# Step 1
            
            '
            ' Calculate real part
            '
            For K = 0# To M - 1# Step 1
                WORK(K) = 0#
            Next K
            For K = 0# To N - 1# Step 1
                V = q(i, K).x
                For i_ = 0# To M - 1# Step 1
                    WORK(i_) = WORK(i_) + V * t(K, i_)
                Next i_
            Next K
            For K = 0# To M - 1# Step 1
                z(i, K).x = WORK(K)
            Next K
            
            '
            ' Calculate imaginary part
            '
            For K = 0# To M - 1# Step 1
                WORK(K) = 0#
            Next K
            For K = 0# To N - 1# Step 1
                V = q(i, K).y
                For i_ = 0# To M - 1# Step 1
                    WORK(i_) = WORK(i_) + V * t(K, i_)
                Next i_
            Next K
            For K = 0# To M - 1# Step 1
                z(i, K).y = WORK(K)
            Next K
        Next i
    End If
    HMatrixEVDI = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Finding the eigenvalues and eigenvectors of a tridiagonal symmetric matrix
'
'The algorithm finds the eigen pairs of a tridiagonal symmetric matrix by
'using an QL/QR algorithm with implicit shifts.
'
'Input parameters:
'    D       -   the main diagonal of a tridiagonal matrix.
'                Array whose index ranges within [0..N-1].
'    E       -   the secondary diagonal of a tridiagonal matrix.
'                Array whose index ranges within [0..N-2].
'    N       -   size of matrix A.
'    ZNeeded -   flag controlling whether the eigenvectors are needed or not.
'                If ZNeeded is equal to:
'                 * 0, the eigenvectors are not needed;
'                 * 1, the eigenvectors of a tridiagonal matrix
'                   are multiplied by the square matrix Z. It is used if the
'                   tridiagonal matrix is obtained by the similarity
'                   transformation of a symmetric matrix;
'                 * 2, the eigenvectors of a tridiagonal matrix replace the
'                   square matrix Z;
'                 * 3, matrix Z contains the first row of the eigenvectors
'                   matrix.
'    Z       -   if ZNeeded=1, Z contains the square matrix by which the
'                eigenvectors are multiplied.
'                Array whose indexes range within [0..N-1, 0..N-1].
'
'Output parameters:
'    D       -   eigenvalues in ascending order.
'                Array whose index ranges within [0..N-1].
'    Z       -   if ZNeeded is equal to:
'                 * 0, Z hasnt changed;
'                 * 1, Z contains the product of a given matrix (from the left)
'                   and the eigenvectors matrix (from the right);
'                 * 2, Z contains the eigenvectors.
'                 * 3, Z contains the first row of the eigenvectors matrix.
'                If ZNeeded<3, Z is the array whose indexes range within [0..N-1, 0..N-1].
'                In that case, the eigenvectors are stored in the matrix columns.
'                If ZNeeded=3, Z is the array whose indexes range within [0..0, 0..N-1].
'
'Result:
'    True, if the algorithm has converged.
'    False, if the algorithm hasn't converged.
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     September 30, 1994
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function SMatrixTDEVD(ByRef d() As Double, _
         ByRef E_() As Double, _
         ByVal N As Long, _
         ByVal ZNeeded As Long, _
         ByRef z() As Double) As Boolean
    Dim Result As Boolean
    Dim e() As Double
    Dim d1() As Double
    Dim E1() As Double
    Dim Z1() As Double
    Dim i As Long
    Dim i_ As Long
    Dim i1_ As Long
    e = E_
    
    '
    ' Prepare 1-based task
    '
    ReDim d1(1# To N)
    ReDim E1(1# To N)
    i1_ = (0#) - (1#)
    For i_ = 1# To N Step 1
        d1(i_) = d(i_ + i1_)
    Next i_
    If N > 1# Then
        i1_ = (0#) - (1#)
        For i_ = 1# To N - 1# Step 1
            E1(i_) = e(i_ + i1_)
        Next i_
    End If
    If ZNeeded = 1# Then
        ReDim Z1(1# To N, 1# To N)
        For i = 1# To N Step 1
            i1_ = (0#) - (1#)
            For i_ = 1# To N Step 1
                Z1(i, i_) = z(i - 1#, i_ + i1_)
            Next i_
        Next i
    End If
    
    '
    ' Solve 1-based task
    '
    Result = TridiagonalEVD(d1, E1, N, ZNeeded, Z1)
    If Not Result Then
        SMatrixTDEVD = Result
        Exit Function
    End If
    
    '
    ' Convert back to 0-based result
    '
    i1_ = (1#) - (0#)
    For i_ = 0# To N - 1# Step 1
        d(i_) = d1(i_ + i1_)
    Next i_
    If ZNeeded <> 0# Then
        If ZNeeded = 1# Then
            For i = 1# To N Step 1
                i1_ = (1#) - (0#)
                For i_ = 0# To N - 1# Step 1
                    z(i - 1#, i_) = Z1(i, i_ + i1_)
                Next i_
            Next i
            SMatrixTDEVD = Result
            Exit Function
        End If
        If ZNeeded = 2# Then
            ReDim z(0# To N - 1#, 0# To N - 1#)
            For i = 1# To N Step 1
                i1_ = (1#) - (0#)
                For i_ = 0# To N - 1# Step 1
                    z(i - 1#, i_) = Z1(i, i_ + i1_)
                Next i_
            Next i
            SMatrixTDEVD = Result
            Exit Function
        End If
        If ZNeeded = 3# Then
            ReDim z(0# To 0#, 0# To N - 1#)
            i1_ = (1#) - (0#)
            For i_ = 0# To N - 1# Step 1
                z(0#, i_) = Z1(1#, i_ + i1_)
            Next i_
            SMatrixTDEVD = Result
            Exit Function
        End If
    End If
    SMatrixTDEVD = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Subroutine for finding the tridiagonal matrix eigenvalues/vectors in a
'given half-interval (A, B] by using bisection and inverse iteration.
'
'Input parameters:
'    D       -   the main diagonal of a tridiagonal matrix.
'                Array whose index ranges within [0..N-1].
'    E       -   the secondary diagonal of a tridiagonal matrix.
'                Array whose index ranges within [0..N-2].
'    N       -   size of matrix, N>=0.
'    ZNeeded -   flag controlling whether the eigenvectors are needed or not.
'                If ZNeeded is equal to:
'                 * 0, the eigenvectors are not needed;
'                 * 1, the eigenvectors of a tridiagonal matrix are multiplied
'                   by the square matrix Z. It is used if the tridiagonal
'                   matrix is obtained by the similarity transformation
'                   of a symmetric matrix.
'                 * 2, the eigenvectors of a tridiagonal matrix replace matrix Z.
'    A, B    -   half-interval (A, B] to search eigenvalues in.
'    Z       -   if ZNeeded is equal to:
'                 * 0, Z isn't used and remains unchanged;
'                 * 1, Z contains the square matrix (array whose indexes range
'                   within [0..N-1, 0..N-1]) which reduces the given symmetric
'                   matrix to tridiagonal form;
'                 * 2, Z isn't used (but changed on the exit).
'
'Output parameters:
'    D       -   array of the eigenvalues found.
'                Array whose index ranges within [0..M-1].
'    M       -   number of eigenvalues found in the given half-interval (M>=0).
'    Z       -   if ZNeeded is equal to:
'                 * 0, doesn't contain any information;
'                 * 1, contains the product of a given NxN matrix Z (from the
'                   left) and NxM matrix of the eigenvectors found (from the
'                   right). Array whose indexes range within [0..N-1, 0..M-1].
'                 * 2, contains the matrix of the eigenvectors found.
'                   Array whose indexes range within [0..N-1, 0..M-1].
'
'Result:
'
'    True, if successful. In that case, M contains the number of eigenvalues
'    in the given half-interval (could be equal to 0), D contains the eigenvalues,
'    Z contains the eigenvectors (if needed).
'    It should be noted that the subroutine changes the size of arrays D and Z.
'
'    False, if the bisection method subroutine wasn't able to find the
'    eigenvalues in the given interval or if the inverse iteration subroutine
'    wasn't able to find all the corresponding eigenvectors. In that case,
'    the eigenvalues and eigenvectors are not returned, M is equal to 0.
'
'  -- ALGLIB --
'     Copyright 31.03.2008 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function SMatrixTDEVDR(ByRef d() As Double, _
         ByRef e() As Double, _
         ByVal N As Long, _
         ByVal ZNeeded As Long, _
         ByVal a As Double, _
         ByVal B As Double, _
         ByRef M As Long, _
         ByRef z() As Double) As Boolean
    Dim Result As Boolean
    Dim ErrorCode As Long
    Dim NSPLIT As Long
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim CR As Long
    Dim IBLOCK() As Long
    Dim ISPLIT() As Long
    Dim IFAIL() As Long
    Dim d1() As Double
    Dim E1() As Double
    Dim w() As Double
    Dim Z2() As Double
    Dim Z3() As Double
    Dim V As Double
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' Special cases
    '
    If B <= a Then
        M = 0#
        Result = True
        SMatrixTDEVDR = Result
        Exit Function
    End If
    If N <= 0# Then
        M = 0#
        Result = True
        SMatrixTDEVDR = Result
        Exit Function
    End If
    
    '
    ' Copy D,E to D1, E1
    '
    ReDim d1(1# To N)
    i1_ = (0#) - (1#)
    For i_ = 1# To N Step 1
        d1(i_) = d(i_ + i1_)
    Next i_
    If N > 1# Then
        ReDim E1(1# To N - 1#)
        i1_ = (0#) - (1#)
        For i_ = 1# To N - 1# Step 1
            E1(i_) = e(i_ + i1_)
        Next i_
    End If
    
    '
    ' No eigen vectors
    '
    If ZNeeded = 0# Then
        Result = InternalBisectionEigenValues(d1, E1, N, 2#, 1#, a, B, 0#, 0#, -1#, w, M, NSPLIT, IBLOCK, ISPLIT, ErrorCode)
        If Not Result Or M = 0# Then
            M = 0#
            SMatrixTDEVDR = Result
            Exit Function
        End If
        ReDim d(0# To M - 1#)
        i1_ = (1#) - (0#)
        For i_ = 0# To M - 1# Step 1
            d(i_) = w(i_ + i1_)
        Next i_
        SMatrixTDEVDR = Result
        Exit Function
    End If
    
    '
    ' Eigen vectors are multiplied by Z
    '
    If ZNeeded = 1# Then
        
        '
        ' Find eigen pairs
        '
        Result = InternalBisectionEigenValues(d1, E1, N, 2#, 2#, a, B, 0#, 0#, -1#, w, M, NSPLIT, IBLOCK, ISPLIT, ErrorCode)
        If Not Result Or M = 0# Then
            M = 0#
            SMatrixTDEVDR = Result
            Exit Function
        End If
        Call InternalDSTEIN(N, d1, E1, M, w, IBLOCK, ISPLIT, Z2, IFAIL, CR)
        If CR <> 0# Then
            M = 0#
            Result = False
            SMatrixTDEVDR = Result
            Exit Function
        End If
        
        '
        ' Sort eigen values and vectors
        '
        For i = 1# To M Step 1
            K = i
            For j = i To M Step 1
                If w(j) < w(K) Then
                    K = j
                End If
            Next j
            V = w(i)
            w(i) = w(K)
            w(K) = V
            For j = 1# To N Step 1
                V = Z2(j, i)
                Z2(j, i) = Z2(j, K)
                Z2(j, K) = V
            Next j
        Next i
        
        '
        ' Transform Z2 and overwrite Z
        '
        ReDim Z3(1# To M, 1# To N)
        For i = 1# To M Step 1
            For i_ = 1# To N Step 1
                Z3(i, i_) = Z2(i_, i)
            Next i_
        Next i
        For i = 1# To N Step 1
            For j = 1# To M Step 1
                i1_ = (1#) - (0#)
                V = 0#
                For i_ = 0# To N - 1# Step 1
                    V = V + z(i - 1#, i_) * Z3(j, i_ + i1_)
                Next i_
                Z2(i, j) = V
            Next j
        Next i
        ReDim z(0# To N - 1#, 0# To M - 1#)
        For i = 1# To M Step 1
            i1_ = (1#) - (0#)
            For i_ = 0# To N - 1# Step 1
                z(i_, i - 1#) = Z2(i_ + i1_, i)
            Next i_
        Next i
        
        '
        ' Store W
        '
        ReDim d(0# To M - 1#)
        For i = 1# To M Step 1
            d(i - 1#) = w(i)
        Next i
        SMatrixTDEVDR = Result
        Exit Function
    End If
    
    '
    ' Eigen vectors are stored in Z
    '
    If ZNeeded = 2# Then
        
        '
        ' Find eigen pairs
        '
        Result = InternalBisectionEigenValues(d1, E1, N, 2#, 2#, a, B, 0#, 0#, -1#, w, M, NSPLIT, IBLOCK, ISPLIT, ErrorCode)
        If Not Result Or M = 0# Then
            M = 0#
            SMatrixTDEVDR = Result
            Exit Function
        End If
        Call InternalDSTEIN(N, d1, E1, M, w, IBLOCK, ISPLIT, Z2, IFAIL, CR)
        If CR <> 0# Then
            M = 0#
            Result = False
            SMatrixTDEVDR = Result
            Exit Function
        End If
        
        '
        ' Sort eigen values and vectors
        '
        For i = 1# To M Step 1
            K = i
            For j = i To M Step 1
                If w(j) < w(K) Then
                    K = j
                End If
            Next j
            V = w(i)
            w(i) = w(K)
            w(K) = V
            For j = 1# To N Step 1
                V = Z2(j, i)
                Z2(j, i) = Z2(j, K)
                Z2(j, K) = V
            Next j
        Next i
        
        '
        ' Store W
        '
        ReDim d(0# To M - 1#)
        For i = 1# To M Step 1
            d(i - 1#) = w(i)
        Next i
        ReDim z(0# To N - 1#, 0# To M - 1#)
        For i = 1# To M Step 1
            i1_ = (1#) - (0#)
            For i_ = 0# To N - 1# Step 1
                z(i_, i - 1#) = Z2(i_ + i1_, i)
            Next i_
        Next i
        SMatrixTDEVDR = Result
        Exit Function
    End If
    Result = False
    SMatrixTDEVDR = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Subroutine for finding tridiagonal matrix eigenvalues/vectors with given
'indexes (in ascending order) by using the bisection and inverse iteraion.
'
'Input parameters:
'    D       -   the main diagonal of a tridiagonal matrix.
'                Array whose index ranges within [0..N-1].
'    E       -   the secondary diagonal of a tridiagonal matrix.
'                Array whose index ranges within [0..N-2].
'    N       -   size of matrix. N>=0.
'    ZNeeded -   flag controlling whether the eigenvectors are needed or not.
'                If ZNeeded is equal to:
'                 * 0, the eigenvectors are not needed;
'                 * 1, the eigenvectors of a tridiagonal matrix are multiplied
'                   by the square matrix Z. It is used if the
'                   tridiagonal matrix is obtained by the similarity transformation
'                   of a symmetric matrix.
'                 * 2, the eigenvectors of a tridiagonal matrix replace
'                   matrix Z.
'    I1, I2  -   index interval for searching (from I1 to I2).
'                0 <= I1 <= I2 <= N-1.
'    Z       -   if ZNeeded is equal to:
'                 * 0, Z isn't used and remains unchanged;
'                 * 1, Z contains the square matrix (array whose indexes range within [0..N-1, 0..N-1])
'                   which reduces the given symmetric matrix to  tridiagonal form;
'                 * 2, Z isn't used (but changed on the exit).
'
'Output parameters:
'    D       -   array of the eigenvalues found.
'                Array whose index ranges within [0..I2-I1].
'    Z       -   if ZNeeded is equal to:
'                 * 0, doesn't contain any information;
'                 * 1, contains the product of a given NxN matrix Z (from the left) and
'                   Nx(I2-I1) matrix of the eigenvectors found (from the right).
'                   Array whose indexes range within [0..N-1, 0..I2-I1].
'                 * 2, contains the matrix of the eigenvalues found.
'                   Array whose indexes range within [0..N-1, 0..I2-I1].
'
'
'Result:
'
'    True, if successful. In that case, D contains the eigenvalues,
'    Z contains the eigenvectors (if needed).
'    It should be noted that the subroutine changes the size of arrays D and Z.
'
'    False, if the bisection method subroutine wasn't able to find the eigenvalues
'    in the given interval or if the inverse iteration subroutine wasn't able
'    to find all the corresponding eigenvectors. In that case, the eigenvalues
'    and eigenvectors are not returned.
'
'  -- ALGLIB --
'     Copyright 25.12.2005 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function SMatrixTDEVDI(ByRef d() As Double, _
         ByRef e() As Double, _
         ByVal N As Long, _
         ByVal ZNeeded As Long, _
         ByVal I1 As Long, _
         ByVal I2 As Long, _
         ByRef z() As Double) As Boolean
    Dim Result As Boolean
    Dim ErrorCode As Long
    Dim NSPLIT As Long
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim M As Long
    Dim CR As Long
    Dim IBLOCK() As Long
    Dim ISPLIT() As Long
    Dim IFAIL() As Long
    Dim w() As Double
    Dim d1() As Double
    Dim E1() As Double
    Dim Z2() As Double
    Dim Z3() As Double
    Dim V As Double
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' Copy D,E to D1, E1
    '
    ReDim d1(1# To N)
    i1_ = (0#) - (1#)
    For i_ = 1# To N Step 1
        d1(i_) = d(i_ + i1_)
    Next i_
    If N > 1# Then
        ReDim E1(1# To N - 1#)
        i1_ = (0#) - (1#)
        For i_ = 1# To N - 1# Step 1
            E1(i_) = e(i_ + i1_)
        Next i_
    End If
    
    '
    ' No eigen vectors
    '
    If ZNeeded = 0# Then
        Result = InternalBisectionEigenValues(d1, E1, N, 3#, 1#, 0#, 0#, I1 + 1#, I2 + 1#, -1#, w, M, NSPLIT, IBLOCK, ISPLIT, ErrorCode)
        If Not Result Then
            SMatrixTDEVDI = Result
            Exit Function
        End If
        If M <> I2 - I1 + 1# Then
            Result = False
            SMatrixTDEVDI = Result
            Exit Function
        End If
        ReDim d(0# To M - 1#)
        For i = 1# To M Step 1
            d(i - 1#) = w(i)
        Next i
        SMatrixTDEVDI = Result
        Exit Function
    End If
    
    '
    ' Eigen vectors are multiplied by Z
    '
    If ZNeeded = 1# Then
        
        '
        ' Find eigen pairs
        '
        Result = InternalBisectionEigenValues(d1, E1, N, 3#, 2#, 0#, 0#, I1 + 1#, I2 + 1#, -1#, w, M, NSPLIT, IBLOCK, ISPLIT, ErrorCode)
        If Not Result Then
            SMatrixTDEVDI = Result
            Exit Function
        End If
        If M <> I2 - I1 + 1# Then
            Result = False
            SMatrixTDEVDI = Result
            Exit Function
        End If
        Call InternalDSTEIN(N, d1, E1, M, w, IBLOCK, ISPLIT, Z2, IFAIL, CR)
        If CR <> 0# Then
            Result = False
            SMatrixTDEVDI = Result
            Exit Function
        End If
        
        '
        ' Sort eigen values and vectors
        '
        For i = 1# To M Step 1
            K = i
            For j = i To M Step 1
                If w(j) < w(K) Then
                    K = j
                End If
            Next j
            V = w(i)
            w(i) = w(K)
            w(K) = V
            For j = 1# To N Step 1
                V = Z2(j, i)
                Z2(j, i) = Z2(j, K)
                Z2(j, K) = V
            Next j
        Next i
        
        '
        ' Transform Z2 and overwrite Z
        '
        ReDim Z3(1# To M, 1# To N)
        For i = 1# To M Step 1
            For i_ = 1# To N Step 1
                Z3(i, i_) = Z2(i_, i)
            Next i_
        Next i
        For i = 1# To N Step 1
            For j = 1# To M Step 1
                i1_ = (1#) - (0#)
                V = 0#
                For i_ = 0# To N - 1# Step 1
                    V = V + z(i - 1#, i_) * Z3(j, i_ + i1_)
                Next i_
                Z2(i, j) = V
            Next j
        Next i
        ReDim z(0# To N - 1#, 0# To M - 1#)
        For i = 1# To M Step 1
            i1_ = (1#) - (0#)
            For i_ = 0# To N - 1# Step 1
                z(i_, i - 1#) = Z2(i_ + i1_, i)
            Next i_
        Next i
        
        '
        ' Store W
        '
        ReDim d(0# To M - 1#)
        For i = 1# To M Step 1
            d(i - 1#) = w(i)
        Next i
        SMatrixTDEVDI = Result
        Exit Function
    End If
    
    '
    ' Eigen vectors are stored in Z
    '
    If ZNeeded = 2# Then
        
        '
        ' Find eigen pairs
        '
        Result = InternalBisectionEigenValues(d1, E1, N, 3#, 2#, 0#, 0#, I1 + 1#, I2 + 1#, -1#, w, M, NSPLIT, IBLOCK, ISPLIT, ErrorCode)
        If Not Result Then
            SMatrixTDEVDI = Result
            Exit Function
        End If
        If M <> I2 - I1 + 1# Then
            Result = False
            SMatrixTDEVDI = Result
            Exit Function
        End If
        Call InternalDSTEIN(N, d1, E1, M, w, IBLOCK, ISPLIT, Z2, IFAIL, CR)
        If CR <> 0# Then
            Result = False
            SMatrixTDEVDI = Result
            Exit Function
        End If
        
        '
        ' Sort eigen values and vectors
        '
        For i = 1# To M Step 1
            K = i
            For j = i To M Step 1
                If w(j) < w(K) Then
                    K = j
                End If
            Next j
            V = w(i)
            w(i) = w(K)
            w(K) = V
            For j = 1# To N Step 1
                V = Z2(j, i)
                Z2(j, i) = Z2(j, K)
                Z2(j, K) = V
            Next j
        Next i
        
        '
        ' Store Z
        '
        ReDim z(0# To N - 1#, 0# To M - 1#)
        For i = 1# To M Step 1
            i1_ = (1#) - (0#)
            For i_ = 0# To N - 1# Step 1
                z(i_, i - 1#) = Z2(i_ + i1_, i)
            Next i_
        Next i
        
        '
        ' Store W
        '
        ReDim d(0# To M - 1#)
        For i = 1# To M Step 1
            d(i - 1#) = w(i)
        Next i
        SMatrixTDEVDI = Result
        Exit Function
    End If
    Result = False
    SMatrixTDEVDI = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Finding eigenvalues and eigenvectors of a general matrix
'
'The algorithm finds eigenvalues and eigenvectors of a general matrix by
'using the QR algorithm with multiple shifts. The algorithm can find
'eigenvalues and both left and right eigenvectors.
'
'The right eigenvector is a vector x such that A*x = w*x, and the left
'eigenvector is a vector y such that y'*A = w*y' (here y' implies a complex
'conjugate transposition of vector y).
'
'Input parameters:
'    A       -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
'    N       -   size of matrix A.
'    VNeeded -   flag controlling whether eigenvectors are needed or not.
'                If VNeeded is equal to:
'                 * 0, eigenvectors are not returned;
'                 * 1, right eigenvectors are returned;
'                 * 2, left eigenvectors are returned;
'                 * 3, both left and right eigenvectors are returned.
'
'Output parameters:
'    WR      -   real parts of eigenvalues.
'                Array whose index ranges within [0..N-1].
'    WR      -   imaginary parts of eigenvalues.
'                Array whose index ranges within [0..N-1].
'    VL, VR  -   arrays of left and right eigenvectors (if they are needed).
'                If WI[i]=0, the respective eigenvalue is a real number,
'                and it corresponds to the column number I of matrices VL/VR.
'                If WI[i]>0, we have a pair of complex conjugate numbers with
'                positive and negative imaginary parts:
'                    the first eigenvalue WR[i] + sqrt(-1)*WI[i];
'                    the second eigenvalue WR[i+1] + sqrt(-1)*WI[i+1];
'                    WI[i]>0
'                    WI[i+1] = -WI[i] < 0
'                In that case, the eigenvector  corresponding to the first
'                eigenvalue is located in i and i+1 columns of matrices
'                VL/VR (the column number i contains the real part, and the
'                column number i+1 contains the imaginary part), and the vector
'                corresponding to the second eigenvalue is a complex conjugate to
'                the first vector.
'                Arrays whose indexes range within [0..N-1, 0..N-1].
'
'Result:
'    True, if the algorithm has converged.
'    False, if the algorithm has not converged.
'
'Note 1:
'    Some users may ask the following question: what if WI[N-1]>0?
'    WI[N] must contain an eigenvalue which is complex conjugate to the
'    N-th eigenvalue, but the array has only size N?
'    The answer is as follows: such a situation cannot occur because the
'    algorithm finds a pairs of eigenvalues, therefore, if WI[i]>0, I is
'    strictly less than N-1.
'
'Note 2:
'    The algorithm performance depends on the value of the internal parameter
'    NS of the InternalSchurDecomposition subroutine which defines the number
'    of shifts in the QR algorithm (similarly to the block width in block-matrix
'    algorithms of linear algebra). If you require maximum performance
'    on your machine, it is recommended to adjust this parameter manually.
'
'
'See also the InternalTREVC subroutine.
'
'The algorithm is based on the LAPACK 3.0 library.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function RMatrixEVD(ByRef A_() As Double, _
         ByVal N As Long, _
         ByVal VNeeded As Long, _
         ByRef WR() As Double, _
         ByRef WI() As Double, _
         ByRef VL() As Double, _
         ByRef VR() As Double) As Boolean
    Dim Result As Boolean
    Dim a() As Double
    Dim a1() As Double
    Dim VL1() As Double
    Dim VR1() As Double
    Dim WR1() As Double
    Dim WI1() As Double
    Dim i As Long
    Dim i_ As Long
    Dim i1_ As Long
    a = A_
    ReDim a1(1# To N, 1# To N)
    For i = 1# To N Step 1
        i1_ = (0#) - (1#)
        For i_ = 1# To N Step 1
            a1(i, i_) = a(i - 1#, i_ + i1_)
        Next i_
    Next i
    Result = NonSymmetricEVD(a1, N, VNeeded, WR1, WI1, VL1, VR1)
    If Result Then
        ReDim WR(0# To N - 1#)
        ReDim WI(0# To N - 1#)
        i1_ = (1#) - (0#)
        For i_ = 0# To N - 1# Step 1
            WR(i_) = WR1(i_ + i1_)
        Next i_
        i1_ = (1#) - (0#)
        For i_ = 0# To N - 1# Step 1
            WI(i_) = WI1(i_ + i1_)
        Next i_
        If VNeeded = 2# Or VNeeded = 3# Then
            ReDim VL(0# To N - 1#, 0# To N - 1#)
            For i = 0# To N - 1# Step 1
                i1_ = (1#) - (0#)
                For i_ = 0# To N - 1# Step 1
                    VL(i, i_) = VL1(i + 1#, i_ + i1_)
                Next i_
            Next i
        End If
        If VNeeded = 1# Or VNeeded = 3# Then
            ReDim VR(0# To N - 1#, 0# To N - 1#)
            For i = 0# To N - 1# Step 1
                i1_ = (1#) - (0#)
                For i_ = 0# To N - 1# Step 1
                    VR(i, i_) = VR1(i + 1#, i_ + i1_)
                Next i_
            Next i
        End If
    End If
    RMatrixEVD = Result
End Function
Public Function InternalBisectionEigenValues(ByRef D_() As Double, _
         ByRef E_() As Double, _
         ByVal N As Long, _
         ByVal IRANGE As Long, _
         ByVal IORDER As Long, _
         ByVal VL As Double, _
         ByVal VU As Double, _
         ByVal IL As Long, _
         ByVal IU As Long, _
         ByVal ABSTOL As Double, _
         ByRef w() As Double, _
         ByRef M As Long, _
         ByRef NSPLIT As Long, _
         ByRef IBLOCK() As Long, _
         ByRef ISPLIT() As Long, _
         ByRef ErrorCode As Long) As Boolean
    Dim Result As Boolean
    Dim d() As Double
    Dim e() As Double
    Dim FUDGE As Double
    Dim RELFAC As Double
    Dim NCNVRG As Boolean
    Dim TOOFEW As Boolean
    Dim IB As Long
    Dim IBEGIN As Long
    Dim IDISCL As Long
    Dim IDISCU As Long
    Dim IE As Long
    Dim IEND As Long
    Dim IINFO As Long
    Dim IM As Long
    Dim IIN As Long
    Dim IOFF As Long
    Dim IOUT As Long
    Dim ITMAX As Long
    Dim IW As Long
    Dim IWOFF As Long
    Dim j As Long
    Dim ITMP1 As Long
    Dim JB As Long
    Dim JDISC As Long
    Dim JE As Long
    Dim NWL As Long
    Dim NWU As Long
    Dim ATOLI As Double
    Dim BNorm As Double
    Dim GL As Double
    Dim GU As Double
    Dim PIVMIN As Double
    Dim RTOLI As Double
    Dim SAFEMN As Double
    Dim TMP1 As Double
    Dim Tmp2 As Double
    Dim TNORM As Double
    Dim Ulp As Double
    Dim WKILL As Double
    Dim WL As Double
    Dim WLU As Double
    Dim WU As Double
    Dim WUL As Double
    Dim ScaleFactor As Double
    Dim t As Double
    Dim IDUMMA() As Long
    Dim WORK() As Double
    Dim IWORK() As Long
    Dim IA1S2() As Long
    Dim RA1S2() As Double
    Dim RA1S2X2() As Double
    Dim IA1S2X2() As Long
    Dim RA1SIIN() As Double
    Dim RA2SIIN() As Double
    Dim RA3SIIN() As Double
    Dim RA4SIIN() As Double
    Dim RA1SIINX2() As Double
    Dim IA1SIINX2() As Long
    Dim IWORKSPACE() As Long
    Dim RWORKSPACE() As Double
    Dim TmpI As Long
    d = D_
    e = E_
    
    '
    ' Quick return if possible
    '
    M = 0#
    If N = 0# Then
        Result = True
        InternalBisectionEigenValues = Result
        Exit Function
    End If
    
    '
    ' Get machine constants
    ' NB is the minimum vector length for vector bisection, or 0
    ' if only scalar is to be done.
    '
    FUDGE = 2#
    RELFAC = 2#
    SAFEMN = MinRealNumber
    Ulp = 2# * MachineEpsilon
    RTOLI = Ulp * RELFAC
    ReDim IDUMMA(1# To 1#)
    ReDim WORK(1# To 4# * N)
    ReDim IWORK(1# To 3# * N)
    ReDim w(1# To N)
    ReDim IBLOCK(1# To N)
    ReDim ISPLIT(1# To N)
    ReDim IA1S2(1# To 2#)
    ReDim RA1S2(1# To 2#)
    ReDim RA1S2X2(1# To 2#, 1# To 2#)
    ReDim IA1S2X2(1# To 2#, 1# To 2#)
    ReDim RA1SIIN(1# To N)
    ReDim RA2SIIN(1# To N)
    ReDim RA3SIIN(1# To N)
    ReDim RA4SIIN(1# To N)
    ReDim RA1SIINX2(1# To N, 1# To 2#)
    ReDim IA1SIINX2(1# To N, 1# To 2#)
    ReDim IWORKSPACE(1# To N)
    ReDim RWORKSPACE(1# To N)
    
    '
    ' Check for Errors
    '
    Result = False
    ErrorCode = 0#
    If IRANGE <= 0# Or IRANGE >= 4# Then
        ErrorCode = -4#
    End If
    If IORDER <= 0# Or IORDER >= 3# Then
        ErrorCode = -5#
    End If
    If N < 0# Then
        ErrorCode = -3#
    End If
    If IRANGE = 2# And VL >= VU Then
        ErrorCode = -6#
    End If
    If IRANGE = 3# And (IL < 1# Or IL > MaxInt(1#, N)) Then
        ErrorCode = -8#
    End If
    If IRANGE = 3# And (IU < MinInt(N, IL) Or IU > N) Then
        ErrorCode = -9#
    End If
    If ErrorCode <> 0# Then
        InternalBisectionEigenValues = Result
        Exit Function
    End If
    
    '
    ' Initialize error flags
    '
    NCNVRG = False
    TOOFEW = False
    
    '
    ' Simplifications:
    '
    If IRANGE = 3# And IL = 1# And IU = N Then
        IRANGE = 1#
    End If
    
    '
    ' Special Case when N=1
    '
    If N = 1# Then
        NSPLIT = 1#
        ISPLIT(1#) = 1#
        If IRANGE = 2# And (VL >= d(1#) Or VU < d(1#)) Then
            M = 0#
        Else
            w(1#) = d(1#)
            IBLOCK(1#) = 1#
            M = 1#
        End If
        Result = True
        InternalBisectionEigenValues = Result
        Exit Function
    End If
    
    '
    ' Scaling
    '
    t = Abs(d(N))
    For j = 1# To N - 1# Step 1
        t = MaxReal(t, Abs(d(j)))
        t = MaxReal(t, Abs(e(j)))
    Next j
    ScaleFactor = 1#
    If t <> 0# Then
        If t > Sqr(Sqr(MinRealNumber)) * Sqr(MaxRealNumber) Then
            ScaleFactor = t
        End If
        If t < Sqr(Sqr(MaxRealNumber)) * Sqr(MinRealNumber) Then
            ScaleFactor = t
        End If
        For j = 1# To N - 1# Step 1
            d(j) = d(j) / ScaleFactor
            e(j) = e(j) / ScaleFactor
        Next j
        d(N) = d(N) / ScaleFactor
    End If
    
    '
    ' Compute Splitting Points
    '
    NSPLIT = 1#
    WORK(N) = 0#
    PIVMIN = 1#
    For j = 2# To N Step 1
        TMP1 = Square(e(j - 1#))
        If Abs(d(j) * d(j - 1#)) * Square(Ulp) + SAFEMN > TMP1 Then
            ISPLIT(NSPLIT) = j - 1#
            NSPLIT = NSPLIT + 1#
            WORK(j - 1#) = 0#
        Else
            WORK(j - 1#) = TMP1
            PIVMIN = MaxReal(PIVMIN, TMP1)
        End If
    Next j
    ISPLIT(NSPLIT) = N
    PIVMIN = PIVMIN * SAFEMN
    
    '
    ' Compute Interval and ATOLI
    '
    If IRANGE = 3# Then
        
        '
        ' RANGE='I': Compute the interval containing eigenvalues
        '     IL through IU.
        '
        ' Compute Gershgorin interval for entire (split) matrix
        ' and use it as the initial interval
        '
        GU = d(1#)
        GL = d(1#)
        TMP1 = 0#
        For j = 1# To N - 1# Step 1
            Tmp2 = Sqr(WORK(j))
            GU = MaxReal(GU, d(j) + TMP1 + Tmp2)
            GL = MinReal(GL, d(j) - TMP1 - Tmp2)
            TMP1 = Tmp2
        Next j
        GU = MaxReal(GU, d(N) + TMP1)
        GL = MinReal(GL, d(N) - TMP1)
        TNORM = MaxReal(Abs(GL), Abs(GU))
        GL = GL - FUDGE * TNORM * Ulp * N - FUDGE * 2# * PIVMIN
        GU = GU + FUDGE * TNORM * Ulp * N + FUDGE * PIVMIN
        
        '
        ' Compute Iteration parameters
        '
        ITMAX = Ceil((Log(TNORM + PIVMIN) - Log(PIVMIN)) / Log(2#)) + 2#
        If ABSTOL <= 0# Then
            ATOLI = Ulp * TNORM
        Else
            ATOLI = ABSTOL
        End If
        WORK(N + 1#) = GL
        WORK(N + 2#) = GL
        WORK(N + 3#) = GU
        WORK(N + 4#) = GU
        WORK(N + 5#) = GL
        WORK(N + 6#) = GU
        IWORK(1#) = -1#
        IWORK(2#) = -1#
        IWORK(3#) = N + 1#
        IWORK(4#) = N + 1#
        IWORK(5#) = IL - 1#
        IWORK(6#) = IU
        
        '
        ' Calling DLAEBZ
        '
        ' DLAEBZ( 3, ITMAX, N, 2, 2, NB, ATOLI, RTOLI, PIVMIN, D, E,
        '    WORK, IWORK( 5 ), WORK( N+1 ), WORK( N+5 ), IOUT,
        '    IWORK, W, IBLOCK, IINFO )
        '
        IA1S2(1#) = IWORK(5#)
        IA1S2(2#) = IWORK(6#)
        RA1S2(1#) = WORK(N + 5#)
        RA1S2(2#) = WORK(N + 6#)
        RA1S2X2(1#, 1#) = WORK(N + 1#)
        RA1S2X2(2#, 1#) = WORK(N + 2#)
        RA1S2X2(1#, 2#) = WORK(N + 3#)
        RA1S2X2(2#, 2#) = WORK(N + 4#)
        IA1S2X2(1#, 1#) = IWORK(1#)
        IA1S2X2(2#, 1#) = IWORK(2#)
        IA1S2X2(1#, 2#) = IWORK(3#)
        IA1S2X2(2#, 2#) = IWORK(4#)
        Call InternalDLAEBZ(3#, ITMAX, N, 2#, 2#, ATOLI, RTOLI, PIVMIN, d, e, WORK, IA1S2, RA1S2X2, RA1S2, IOUT, IA1S2X2, w, IBLOCK, IINFO)
        IWORK(5#) = IA1S2(1#)
        IWORK(6#) = IA1S2(2#)
        WORK(N + 5#) = RA1S2(1#)
        WORK(N + 6#) = RA1S2(2#)
        WORK(N + 1#) = RA1S2X2(1#, 1#)
        WORK(N + 2#) = RA1S2X2(2#, 1#)
        WORK(N + 3#) = RA1S2X2(1#, 2#)
        WORK(N + 4#) = RA1S2X2(2#, 2#)
        IWORK(1#) = IA1S2X2(1#, 1#)
        IWORK(2#) = IA1S2X2(2#, 1#)
        IWORK(3#) = IA1S2X2(1#, 2#)
        IWORK(4#) = IA1S2X2(2#, 2#)
        If IWORK(6#) = IU Then
            WL = WORK(N + 1#)
            WLU = WORK(N + 3#)
            NWL = IWORK(1#)
            WU = WORK(N + 4#)
            WUL = WORK(N + 2#)
            NWU = IWORK(4#)
        Else
            WL = WORK(N + 2#)
            WLU = WORK(N + 4#)
            NWL = IWORK(2#)
            WU = WORK(N + 3#)
            WUL = WORK(N + 1#)
            NWU = IWORK(3#)
        End If
        If NWL < 0# Or NWL >= N Or NWU < 1# Or NWU > N Then
            ErrorCode = 4#
            Result = False
            InternalBisectionEigenValues = Result
            Exit Function
        End If
    Else
        
        '
        ' RANGE='A' or 'V' -- Set ATOLI
        '
        TNORM = MaxReal(Abs(d(1#)) + Abs(e(1#)), Abs(d(N)) + Abs(e(N - 1#)))
        For j = 2# To N - 1# Step 1
            TNORM = MaxReal(TNORM, Abs(d(j)) + Abs(e(j - 1#)) + Abs(e(j)))
        Next j
        If ABSTOL <= 0# Then
            ATOLI = Ulp * TNORM
        Else
            ATOLI = ABSTOL
        End If
        If IRANGE = 2# Then
            WL = VL
            WU = VU
        Else
            WL = 0#
            WU = 0#
        End If
    End If
    
    '
    ' Find Eigenvalues -- Loop Over Blocks and recompute NWL and NWU.
    ' NWL accumulates the number of eigenvalues .le. WL,
    ' NWU accumulates the number of eigenvalues .le. WU
    '
    M = 0#
    IEND = 0#
    ErrorCode = 0#
    NWL = 0#
    NWU = 0#
    For JB = 1# To NSPLIT Step 1
        IOFF = IEND
        IBEGIN = IOFF + 1#
        IEND = ISPLIT(JB)
        IIN = IEND - IOFF
        If IIN = 1# Then
            
            '
            ' Special Case -- IIN=1
            '
            If IRANGE = 1# Or WL >= d(IBEGIN) - PIVMIN Then
                NWL = NWL + 1#
            End If
            If IRANGE = 1# Or WU >= d(IBEGIN) - PIVMIN Then
                NWU = NWU + 1#
            End If
            If IRANGE = 1# Or WL < d(IBEGIN) - PIVMIN And WU >= d(IBEGIN) - PIVMIN Then
                M = M + 1#
                w(M) = d(IBEGIN)
                IBLOCK(M) = JB
            End If
        Else
            
            '
            ' General Case -- IIN > 1
            '
            ' Compute Gershgorin Interval
            ' and use it as the initial interval
            '
            GU = d(IBEGIN)
            GL = d(IBEGIN)
            TMP1 = 0#
            For j = IBEGIN To IEND - 1# Step 1
                Tmp2 = Abs(e(j))
                GU = MaxReal(GU, d(j) + TMP1 + Tmp2)
                GL = MinReal(GL, d(j) - TMP1 - Tmp2)
                TMP1 = Tmp2
            Next j
            GU = MaxReal(GU, d(IEND) + TMP1)
            GL = MinReal(GL, d(IEND) - TMP1)
            BNorm = MaxReal(Abs(GL), Abs(GU))
            GL = GL - FUDGE * BNorm * Ulp * IIN - FUDGE * PIVMIN
            GU = GU + FUDGE * BNorm * Ulp * IIN + FUDGE * PIVMIN
            
            '
            ' Compute ATOLI for the current submatrix
            '
            If ABSTOL <= 0# Then
                ATOLI = Ulp * MaxReal(Abs(GL), Abs(GU))
            Else
                ATOLI = ABSTOL
            End If
            If IRANGE > 1# Then
                If GU < WL Then
                    NWL = NWL + IIN
                    NWU = NWU + IIN
                    GoTo Cont_6
                End If
                GL = MaxReal(GL, WL)
                GU = MinReal(GU, WU)
                If GL >= GU Then
                    GoTo Cont_6
                End If
            End If
            
            '
            ' Set Up Initial Interval
            '
            WORK(N + 1#) = GL
            WORK(N + IIN + 1#) = GU
            
            '
            ' Calling DLAEBZ
            '
            ' CALL DLAEBZ( 1, 0, IN, IN, 1, NB, ATOLI, RTOLI, PIVMIN,
            '    D( IBEGIN ), E( IBEGIN ), WORK( IBEGIN ),
            '    IDUMMA, WORK( N+1 ), WORK( N+2*IN+1 ), IM,
            '    IWORK, W( M+1 ), IBLOCK( M+1 ), IINFO )
            '
            For TmpI = 1# To IIN Step 1
                RA1SIIN(TmpI) = d(IBEGIN - 1# + TmpI)
                If IBEGIN - 1# + TmpI < N Then
                    RA2SIIN(TmpI) = e(IBEGIN - 1# + TmpI)
                End If
                RA3SIIN(TmpI) = WORK(IBEGIN - 1# + TmpI)
                RA1SIINX2(TmpI, 1#) = WORK(N + TmpI)
                RA1SIINX2(TmpI, 2#) = WORK(N + TmpI + IIN)
                RA4SIIN(TmpI) = WORK(N + 2# * IIN + TmpI)
                RWORKSPACE(TmpI) = w(M + TmpI)
                IWORKSPACE(TmpI) = IBLOCK(M + TmpI)
                IA1SIINX2(TmpI, 1#) = IWORK(TmpI)
                IA1SIINX2(TmpI, 2#) = IWORK(TmpI + IIN)
            Next TmpI
            Call InternalDLAEBZ(1#, 0#, IIN, IIN, 1#, ATOLI, RTOLI, PIVMIN, RA1SIIN, RA2SIIN, RA3SIIN, IDUMMA, RA1SIINX2, RA4SIIN, IM, IA1SIINX2, RWORKSPACE, IWORKSPACE, IINFO)
            For TmpI = 1# To IIN Step 1
                WORK(N + TmpI) = RA1SIINX2(TmpI, 1#)
                WORK(N + TmpI + IIN) = RA1SIINX2(TmpI, 2#)
                WORK(N + 2# * IIN + TmpI) = RA4SIIN(TmpI)
                w(M + TmpI) = RWORKSPACE(TmpI)
                IBLOCK(M + TmpI) = IWORKSPACE(TmpI)
                IWORK(TmpI) = IA1SIINX2(TmpI, 1#)
                IWORK(TmpI + IIN) = IA1SIINX2(TmpI, 2#)
            Next TmpI
            NWL = NWL + IWORK(1#)
            NWU = NWU + IWORK(IIN + 1#)
            IWOFF = M - IWORK(1#)
            
            '
            ' Compute Eigenvalues
            '
            ITMAX = Ceil((Log(GU - GL + PIVMIN) - Log(PIVMIN)) / Log(2#)) + 2#
            
            '
            ' Calling DLAEBZ
            '
            'CALL DLAEBZ( 2, ITMAX, IN, IN, 1, NB, ATOLI, RTOLI, PIVMIN,
            '    D( IBEGIN ), E( IBEGIN ), WORK( IBEGIN ),
            '    IDUMMA, WORK( N+1 ), WORK( N+2*IN+1 ), IOUT,
            '    IWORK, W( M+1 ), IBLOCK( M+1 ), IINFO )
            '
            For TmpI = 1# To IIN Step 1
                RA1SIIN(TmpI) = d(IBEGIN - 1# + TmpI)
                If IBEGIN - 1# + TmpI < N Then
                    RA2SIIN(TmpI) = e(IBEGIN - 1# + TmpI)
                End If
                RA3SIIN(TmpI) = WORK(IBEGIN - 1# + TmpI)
                RA1SIINX2(TmpI, 1#) = WORK(N + TmpI)
                RA1SIINX2(TmpI, 2#) = WORK(N + TmpI + IIN)
                RA4SIIN(TmpI) = WORK(N + 2# * IIN + TmpI)
                RWORKSPACE(TmpI) = w(M + TmpI)
                IWORKSPACE(TmpI) = IBLOCK(M + TmpI)
                IA1SIINX2(TmpI, 1#) = IWORK(TmpI)
                IA1SIINX2(TmpI, 2#) = IWORK(TmpI + IIN)
            Next TmpI
            Call InternalDLAEBZ(2#, ITMAX, IIN, IIN, 1#, ATOLI, RTOLI, PIVMIN, RA1SIIN, RA2SIIN, RA3SIIN, IDUMMA, RA1SIINX2, RA4SIIN, IOUT, IA1SIINX2, RWORKSPACE, IWORKSPACE, IINFO)
            For TmpI = 1# To IIN Step 1
                WORK(N + TmpI) = RA1SIINX2(TmpI, 1#)
                WORK(N + TmpI + IIN) = RA1SIINX2(TmpI, 2#)
                WORK(N + 2# * IIN + TmpI) = RA4SIIN(TmpI)
                w(M + TmpI) = RWORKSPACE(TmpI)
                IBLOCK(M + TmpI) = IWORKSPACE(TmpI)
                IWORK(TmpI) = IA1SIINX2(TmpI, 1#)
                IWORK(TmpI + IIN) = IA1SIINX2(TmpI, 2#)
            Next TmpI
            
            '
            ' Copy Eigenvalues Into W and IBLOCK
            ' Use -JB for block number for unconverged eigenvalues.
            '
            For j = 1# To IOUT Step 1
                TMP1 = 0.5 * (WORK(j + N) + WORK(j + IIN + N))
                
                '
                ' Flag non-convergence.
                '
                If j > IOUT - IINFO Then
                    NCNVRG = True
                    IB = -JB
                Else
                    IB = JB
                End If
                For JE = IWORK(j) + 1# + IWOFF To IWORK(j + IIN) + IWOFF Step 1
                    w(JE) = TMP1
                    IBLOCK(JE) = IB
                Next JE
            Next j
            M = M + IM
        End If
Cont_6:
    Next JB
    
    '
    ' If RANGE='I', then (WL,WU) contains eigenvalues NWL+1,...,NWU
    ' If NWL+1 < IL or NWU > IU, discard extra eigenvalues.
    '
    If IRANGE = 3# Then
        IM = 0#
        IDISCL = IL - 1# - NWL
        IDISCU = NWU - IU
        If IDISCL > 0# Or IDISCU > 0# Then
            For JE = 1# To M Step 1
                If w(JE) <= WLU And IDISCL > 0# Then
                    IDISCL = IDISCL - 1#
                Else
                    If w(JE) >= WUL And IDISCU > 0# Then
                        IDISCU = IDISCU - 1#
                    Else
                        IM = IM + 1#
                        w(IM) = w(JE)
                        IBLOCK(IM) = IBLOCK(JE)
                    End If
                End If
            Next JE
            M = IM
        End If
        If IDISCL > 0# Or IDISCU > 0# Then
            
            '
            ' Code to deal with effects of bad arithmetic:
            ' Some low eigenvalues to be discarded are not in (WL,WLU],
            ' or high eigenvalues to be discarded are not in (WUL,WU]
            ' so just kill off the smallest IDISCL/largest IDISCU
            ' eigenvalues, by simply finding the smallest/largest
            ' eigenvalue(s).
            '
            ' (If N(w) is monotone non-decreasing, this should never
            '  happen.)
            '
            If IDISCL > 0# Then
                WKILL = WU
                For JDISC = 1# To IDISCL Step 1
                    IW = 0#
                    For JE = 1# To M Step 1
                        If IBLOCK(JE) <> 0# And (w(JE) < WKILL Or IW = 0#) Then
                            IW = JE
                            WKILL = w(JE)
                        End If
                    Next JE
                    IBLOCK(IW) = 0#
                Next JDISC
            End If
            If IDISCU > 0# Then
                WKILL = WL
                For JDISC = 1# To IDISCU Step 1
                    IW = 0#
                    For JE = 1# To M Step 1
                        If IBLOCK(JE) <> 0# And (w(JE) > WKILL Or IW = 0#) Then
                            IW = JE
                            WKILL = w(JE)
                        End If
                    Next JE
                    IBLOCK(IW) = 0#
                Next JDISC
            End If
            IM = 0#
            For JE = 1# To M Step 1
                If IBLOCK(JE) <> 0# Then
                    IM = IM + 1#
                    w(IM) = w(JE)
                    IBLOCK(IM) = IBLOCK(JE)
                End If
            Next JE
            M = IM
        End If
        If IDISCL < 0# Or IDISCU < 0# Then
            TOOFEW = True
        End If
    End If
    
    '
    ' If ORDER='B', do nothing -- the eigenvalues are already sorted
    '    by block.
    ' If ORDER='E', sort the eigenvalues from smallest to largest
    '
    If IORDER = 1# And NSPLIT > 1# Then
        For JE = 1# To M - 1# Step 1
            IE = 0#
            TMP1 = w(JE)
            For j = JE + 1# To M Step 1
                If w(j) < TMP1 Then
                    IE = j
                    TMP1 = w(j)
                End If
            Next j
            If IE <> 0# Then
                ITMP1 = IBLOCK(IE)
                w(IE) = w(JE)
                IBLOCK(IE) = IBLOCK(JE)
                w(JE) = TMP1
                IBLOCK(JE) = ITMP1
            End If
        Next JE
    End If
    For j = 1# To M Step 1
        w(j) = w(j) * ScaleFactor
    Next j
    ErrorCode = 0#
    If NCNVRG Then
        ErrorCode = ErrorCode + 1#
    End If
    If TOOFEW Then
        ErrorCode = ErrorCode + 2#
    End If
    Result = ErrorCode = 0#
    InternalBisectionEigenValues = Result
End Function
Public Sub InternalDSTEIN(ByRef N As Long, _
         ByRef d() As Double, _
         ByRef E_() As Double, _
         ByRef M As Long, _
         ByRef W_() As Double, _
         ByRef IBLOCK() As Long, _
         ByRef ISPLIT() As Long, _
         ByRef z() As Double, _
         ByRef IFAIL() As Long, _
         ByRef Info As Long)
    Dim e() As Double
    Dim w() As Double
    Dim MaxIts As Long
    Dim EXTRA As Long
    Dim b1 As Long
    Dim BLKSIZ As Long
    Dim BN As Long
    Dim GPIND As Long
    Dim i As Long
    Dim IINFO As Long
    Dim ITS As Long
    Dim j As Long
    Dim J1 As Long
    Dim JBLK As Long
    Dim JMax As Long
    Dim NBLK As Long
    Dim NRMCHK As Long
    Dim DTPCRT As Double
    Dim eps As Double
    Dim EPS1 As Double
    Dim Nrm As Double
    Dim ONENRM As Double
    Dim ORTOL As Double
    Dim PERTOL As Double
    Dim SCL As Double
    Dim SEP As Double
    Dim TOL As Double
    Dim XJ As Double
    Dim XJM As Double
    Dim ZTR As Double
    Dim WORK1() As Double
    Dim WORK2() As Double
    Dim WORK3() As Double
    Dim WORK4() As Double
    Dim WORK5() As Double
    Dim IWORK() As Long
    Dim TmpCriterion As Boolean
    Dim TI As Long
    Dim I1 As Long
    Dim I2 As Long
    Dim V As Double
    Dim i_ As Long
    Dim i1_ As Long
    e = E_
    w = W_
    MaxIts = 5#
    EXTRA = 2#
    ReDim WORK1(1# To MaxInt(N, 1#))
    ReDim WORK2(1# To MaxInt(N - 1#, 1#))
    ReDim WORK3(1# To MaxInt(N, 1#))
    ReDim WORK4(1# To MaxInt(N, 1#))
    ReDim WORK5(1# To MaxInt(N, 1#))
    ReDim IWORK(1# To MaxInt(N, 1#))
    ReDim IFAIL(1# To MaxInt(M, 1#))
    ReDim z(1# To MaxInt(N, 1#), 1# To MaxInt(M, 1#))
    
    '
    ' Test the input parameters.
    '
    Info = 0#
    For i = 1# To M Step 1
        IFAIL(i) = 0#
    Next i
    If N < 0# Then
        Info = -1#
        Exit Sub
    End If
    If M < 0# Or M > N Then
        Info = -4#
        Exit Sub
    End If
    For j = 2# To M Step 1
        If IBLOCK(j) < IBLOCK(j - 1#) Then
            Info = -6#
            Exit For
        End If
        If IBLOCK(j) = IBLOCK(j - 1#) And w(j) < w(j - 1#) Then
            Info = -5#
            Exit For
        End If
    Next j
    If Info <> 0# Then
        Exit Sub
    End If
    
    '
    ' Quick return if possible
    '
    If N = 0# Or M = 0# Then
        Exit Sub
    End If
    If N = 1# Then
        z(1#, 1#) = 1#
        Exit Sub
    End If
    
    '
    ' Some preparations
    '
    TI = N - 1#
    For i_ = 1# To TI Step 1
        WORK1(i_) = e(i_)
    Next i_
    ReDim e(1# To N)
    For i_ = 1# To TI Step 1
        e(i_) = WORK1(i_)
    Next i_
    For i_ = 1# To M Step 1
        WORK1(i_) = w(i_)
    Next i_
    ReDim w(1# To N)
    For i_ = 1# To M Step 1
        w(i_) = WORK1(i_)
    Next i_
    
    '
    ' Get machine constants.
    '
    eps = MachineEpsilon
    
    '
    ' Compute eigenvectors of matrix blocks.
    '
    J1 = 1#
    For NBLK = 1# To IBLOCK(M) Step 1
        
        '
        ' Find starting and ending indices of block nblk.
        '
        If NBLK = 1# Then
            b1 = 1#
        Else
            b1 = ISPLIT(NBLK - 1#) + 1#
        End If
        BN = ISPLIT(NBLK)
        BLKSIZ = BN - b1 + 1#
        If BLKSIZ <> 1# Then
            
            '
            ' Compute reorthogonalization criterion and stopping criterion.
            '
            GPIND = b1
            ONENRM = Abs(d(b1)) + Abs(e(b1))
            ONENRM = MaxReal(ONENRM, Abs(d(BN)) + Abs(e(BN - 1#)))
            For i = b1 + 1# To BN - 1# Step 1
                ONENRM = MaxReal(ONENRM, Abs(d(i)) + Abs(e(i - 1#)) + Abs(e(i)))
            Next i
            ORTOL = 0.001 * ONENRM
            DTPCRT = Sqr(0.1 / BLKSIZ)
        End If
        
        '
        ' Loop through eigenvalues of block nblk.
        '
        JBLK = 0#
        For j = J1 To M Step 1
            If IBLOCK(j) <> NBLK Then
                J1 = j
                Exit For
            End If
            JBLK = JBLK + 1#
            XJ = w(j)
            If BLKSIZ = 1# Then
                
                '
                ' Skip all the work if the block size is one.
                '
                WORK1(1#) = 1#
            Else
                
                '
                ' If eigenvalues j and j-1 are too close, add a relatively
                ' small perturbation.
                '
                If JBLK > 1# Then
                    EPS1 = Abs(eps * XJ)
                    PERTOL = 10# * EPS1
                    SEP = XJ - XJM
                    If SEP < PERTOL Then
                        XJ = XJM + PERTOL
                    End If
                End If
                ITS = 0#
                NRMCHK = 0#
                
                '
                ' Get random starting vector.
                '
                For TI = 1# To BLKSIZ Step 1
                    WORK1(TI) = 2# * Rnd() - 1#
                Next TI
                
                '
                ' Copy the matrix T so it won't be destroyed in factorization.
                '
                For TI = 1# To BLKSIZ - 1# Step 1
                    WORK2(TI) = e(b1 + TI - 1#)
                    WORK3(TI) = e(b1 + TI - 1#)
                    WORK4(TI) = d(b1 + TI - 1#)
                Next TI
                WORK4(BLKSIZ) = d(b1 + BLKSIZ - 1#)
                
                '
                ' Compute LU factors with partial pivoting  ( PT = LU )
                '
                TOL = 0#
                Call TDINInternalDLAGTF(BLKSIZ, WORK4, XJ, WORK2, WORK3, TOL, WORK5, IWORK, IINFO)
                
                '
                ' Update iteration count.
                '
                Do
                    ITS = ITS + 1#
                    If ITS > MaxIts Then
                        
                        '
                        ' If stopping criterion was not satisfied, update info and
                        ' store eigenvector number in array ifail.
                        '
                        Info = Info + 1#
                        IFAIL(Info) = j
                        Exit Do
                    End If
                    
                    '
                    ' Normalize and scale the righthand side vector Pb.
                    '
                    V = 0#
                    For TI = 1# To BLKSIZ Step 1
                        V = V + Abs(WORK1(TI))
                    Next TI
                    SCL = BLKSIZ * ONENRM * MaxReal(eps, Abs(WORK4(BLKSIZ))) / V
                    For i_ = 1# To BLKSIZ Step 1
                        WORK1(i_) = SCL * WORK1(i_)
                    Next i_
                    
                    '
                    ' Solve the system LU = Pb.
                    '
                    Call TDINInternalDLAGTS(BLKSIZ, WORK4, WORK2, WORK3, WORK5, IWORK, WORK1, TOL, IINFO)
                    
                    '
                    ' Reorthogonalize by modified Gram-Schmidt if eigenvalues are
                    ' close enough.
                    '
                    If JBLK <> 1# Then
                        If Abs(XJ - XJM) > ORTOL Then
                            GPIND = j
                        End If
                        If GPIND <> j Then
                            For i = GPIND To j - 1# Step 1
                                I1 = b1
                                I2 = b1 + BLKSIZ - 1#
                                i1_ = (I1) - (1#)
                                ZTR = 0#
                                For i_ = 1# To BLKSIZ Step 1
                                    ZTR = ZTR + WORK1(i_) * z(i_ + i1_, i)
                                Next i_
                                i1_ = (I1) - (1#)
                                For i_ = 1# To BLKSIZ Step 1
                                    WORK1(i_) = WORK1(i_) - ZTR * z(i_ + i1_, i)
                                Next i_
                            Next i
                        End If
                    End If
                    
                    '
                    ' Check the infinity norm of the iterate.
                    '
                    JMax = VectorIdxAbsMax(WORK1, 1#, BLKSIZ)
                    Nrm = Abs(WORK1(JMax))
                    
                    '
                    ' Continue for additional iterations after norm reaches
                    ' stopping criterion.
                    '
                    TmpCriterion = False
                    If Nrm < DTPCRT Then
                        TmpCriterion = True
                    Else
                        NRMCHK = NRMCHK + 1#
                        If NRMCHK < EXTRA + 1# Then
                            TmpCriterion = True
                        End If
                    End If
                Loop Until Not TmpCriterion
                
                '
                ' Accept iterate as jth eigenvector.
                '
                SCL = 1# / VectorNorm2(WORK1, 1#, BLKSIZ)
                JMax = VectorIdxAbsMax(WORK1, 1#, BLKSIZ)
                If WORK1(JMax) < 0# Then
                    SCL = -SCL
                End If
                For i_ = 1# To BLKSIZ Step 1
                    WORK1(i_) = SCL * WORK1(i_)
                Next i_
            End If
            For i = 1# To N Step 1
                z(i, j) = 0#
            Next i
            For i = 1# To BLKSIZ Step 1
                z(b1 + i - 1#, j) = WORK1(i)
            Next i
            
            '
            ' Save the shift to check eigenvalue spacing at next
            ' iteration.
            '
            XJM = XJ
        Next j
    Next NBLK
End Sub
Private Function TridiagonalEVD(ByRef d() As Double, _
         ByRef E_() As Double, _
         ByVal N As Long, _
         ByVal ZNeeded As Long, _
         ByRef z() As Double) As Boolean
    Dim Result As Boolean
    Dim e() As Double
    Dim MAXIT As Long
    Dim i As Long
    Dim II As Long
    Dim ISCALE As Long
    Dim j As Long
    Dim JTOT As Long
    Dim K As Long
    Dim t As Long
    Dim L As Long
    Dim L1 As Long
    Dim LEND As Long
    Dim LENDM1 As Long
    Dim LENDP1 As Long
    Dim LENDSV As Long
    Dim LM1 As Long
    Dim LSV As Long
    Dim M As Long
    Dim MM As Long
    Dim MM1 As Long
    Dim NM1 As Long
    Dim NMAXIT As Long
    Dim TmpInt As Long
    Dim ANORM As Double
    Dim B As Double
    Dim C As Double
    Dim eps As Double
    Dim EPS2 As Double
    Dim f As Double
    Dim g As Double
    Dim p As Double
    Dim R As Double
    Dim RT1 As Double
    Dim RT2 As Double
    Dim s As Double
    Dim SAFMAX As Double
    Dim SAFMIN As Double
    Dim SSFMAX As Double
    Dim SSFMIN As Double
    Dim TST As Double
    Dim tmp As Double
    Dim WORK1() As Double
    Dim WORK2() As Double
    Dim WORKC() As Double
    Dim WORKS() As Double
    Dim WTemp() As Double
    Dim GotoFlag As Boolean
    Dim ZRows As Long
    Dim WasTranspose As Boolean
    Dim i_ As Long
    e = E_
    
    '
    ' Quick return if possible
    '
    If ZNeeded < 0# Or ZNeeded > 3# Then
        Result = False
        TridiagonalEVD = Result
        Exit Function
    End If
    Result = True
    If N = 0# Then
        TridiagonalEVD = Result
        Exit Function
    End If
    If N = 1# Then
        If ZNeeded = 2# Or ZNeeded = 3# Then
            ReDim z(1# To 1#, 1# To 1#)
            z(1#, 1#) = 1#
        End If
        TridiagonalEVD = Result
        Exit Function
    End If
    MAXIT = 30#
    
    '
    ' Initialize arrays
    '
    ReDim WTemp(1# To N)
    ReDim WORK1(1# To N - 1#)
    ReDim WORK2(1# To N - 1#)
    ReDim WORKC(1# To N)
    ReDim WORKS(1# To N)
    
    '
    ' Determine the unit roundoff and over/underflow thresholds.
    '
    eps = MachineEpsilon
    EPS2 = Square(eps)
    SAFMIN = MinRealNumber
    SAFMAX = MaxRealNumber
    SSFMAX = Sqr(SAFMAX) / 3#
    SSFMIN = Sqr(SAFMIN) / EPS2
    
    '
    ' Prepare Z
    '
    ' Here we are using transposition to get rid of column operations
    '
    '
    WasTranspose = False
    If ZNeeded = 0# Then
        ZRows = 0#
    End If
    If ZNeeded = 1# Then
        ZRows = N
    End If
    If ZNeeded = 2# Then
        ZRows = N
    End If
    If ZNeeded = 3# Then
        ZRows = 1#
    End If
    If ZNeeded = 1# Then
        WasTranspose = True
        Call InplaceTranspose(z, 1#, N, 1#, N, WTemp)
    End If
    If ZNeeded = 2# Then
        WasTranspose = True
        ReDim z(1# To N, 1# To N)
        For i = 1# To N Step 1
            For j = 1# To N Step 1
                If i = j Then
                    z(i, j) = 1#
                Else
                    z(i, j) = 0#
                End If
            Next j
        Next i
    End If
    If ZNeeded = 3# Then
        WasTranspose = False
        ReDim z(1# To 1#, 1# To N)
        For j = 1# To N Step 1
            If j = 1# Then
                z(1#, j) = 1#
            Else
                z(1#, j) = 0#
            End If
        Next j
    End If
    NMAXIT = N * MAXIT
    JTOT = 0#
    
    '
    ' Determine where the matrix splits and choose QL or QR iteration
    ' for each block, according to whether top or bottom diagonal
    ' element is smaller.
    '
    L1 = 1#
    NM1 = N - 1#
    Do While True
        If L1 > N Then
            Exit Do
        End If
        If L1 > 1# Then
            e(L1 - 1#) = 0#
        End If
        GotoFlag = False
        If L1 <= NM1 Then
            For M = L1 To NM1 Step 1
                TST = Abs(e(M))
                If TST = 0# Then
                    GotoFlag = True
                    Exit For
                End If
                If TST <= Sqr(Abs(d(M))) * Sqr(Abs(d(M + 1#))) * eps Then
                    e(M) = 0#
                    GotoFlag = True
                    Exit For
                End If
            Next M
        End If
        If Not GotoFlag Then
            M = N
        End If
        
        '
        ' label 30:
        '
        L = L1
        LSV = L
        LEND = M
        LENDSV = LEND
        L1 = M + 1#
        If LEND = L Then
            GoTo Cont_4
        End If
        
        '
        ' Scale submatrix in rows and columns L to LEND
        '
        If L = LEND Then
            ANORM = Abs(d(L))
        Else
            ANORM = MaxReal(Abs(d(L)) + Abs(e(L)), Abs(e(LEND - 1#)) + Abs(d(LEND)))
            For i = L + 1# To LEND - 1# Step 1
                ANORM = MaxReal(ANORM, Abs(d(i)) + Abs(e(i)) + Abs(e(i - 1#)))
            Next i
        End If
        ISCALE = 0#
        If ANORM = 0# Then
            GoTo Cont_4
        End If
        If ANORM > SSFMAX Then
            ISCALE = 1#
            tmp = SSFMAX / ANORM
            TmpInt = LEND - 1#
            For i_ = L To LEND Step 1
                d(i_) = tmp * d(i_)
            Next i_
            For i_ = L To TmpInt Step 1
                e(i_) = tmp * e(i_)
            Next i_
        End If
        If ANORM < SSFMIN Then
            ISCALE = 2#
            tmp = SSFMIN / ANORM
            TmpInt = LEND - 1#
            For i_ = L To LEND Step 1
                d(i_) = tmp * d(i_)
            Next i_
            For i_ = L To TmpInt Step 1
                e(i_) = tmp * e(i_)
            Next i_
        End If
        
        '
        ' Choose between QL and QR iteration
        '
        If Abs(d(LEND)) < Abs(d(L)) Then
            LEND = LSV
            L = LENDSV
        End If
        If LEND > L Then
            
            '
            ' QL Iteration
            '
            ' Look for small subdiagonal element.
            '
            Do While True
                GotoFlag = False
                If L <> LEND Then
                    LENDM1 = LEND - 1#
                    For M = L To LENDM1 Step 1
                        TST = Square(Abs(e(M)))
                        If TST <= EPS2 * Abs(d(M)) * Abs(d(M + 1#)) + SAFMIN Then
                            GotoFlag = True
                            Exit For
                        End If
                    Next M
                End If
                If Not GotoFlag Then
                    M = LEND
                End If
                If M < LEND Then
                    e(M) = 0#
                End If
                p = d(L)
                If M <> L Then
                    
                    '
                    ' If remaining matrix is 2-by-2, use DLAE2 or SLAEV2
                    ' to compute its eigensystem.
                    '
                    If M = L + 1# Then
                        If ZNeeded > 0# Then
                            Call TdEVDEV2(d(L), e(L), d(L + 1#), RT1, RT2, C, s)
                            WORK1(L) = C
                            WORK2(L) = s
                            WORKC(1#) = WORK1(L)
                            WORKS(1#) = WORK2(L)
                            If Not WasTranspose Then
                                Call ApplyRotationsFromTheRight(False, 1#, ZRows, L, L + 1#, WORKC, WORKS, z, WTemp)
                            Else
                                Call ApplyRotationsFromTheLeft(False, L, L + 1#, 1#, ZRows, WORKC, WORKS, z, WTemp)
                            End If
                        Else
                            Call TdEVDE2(d(L), e(L), d(L + 1#), RT1, RT2)
                        End If
                        d(L) = RT1
                        d(L + 1#) = RT2
                        e(L) = 0#
                        L = L + 2#
                        If L <= LEND Then
                            GoTo Cont_7
                        End If
                        
                        '
                        ' GOTO 140
                        '
                        Exit Do
                    End If
                    If JTOT = NMAXIT Then
                        
                        '
                        ' GOTO 140
                        '
                        Exit Do
                    End If
                    JTOT = JTOT + 1#
                    
                    '
                    ' Form shift.
                    '
                    g = (d(L + 1#) - p) / (2# * e(L))
                    R = TdEVDPythag(g, 1#)
                    g = d(M) - p + e(L) / (g + TdEVDExtSign(R, g))
                    s = 1#
                    C = 1#
                    p = 0#
                    
                    '
                    ' Inner loop
                    '
                    MM1 = M - 1#
                    For i = MM1 To L Step -1
                        f = s * e(i)
                        B = C * e(i)
                        Call GenerateRotation(g, f, C, s, R)
                        If i <> M - 1# Then
                            e(i + 1#) = R
                        End If
                        g = d(i + 1#) - p
                        R = (d(i) - g) * s + 2# * C * B
                        p = s * R
                        d(i + 1#) = g + p
                        g = C * R - B
                        
                        '
                        ' If eigenvectors are desired, then save rotations.
                        '
                        If ZNeeded > 0# Then
                            WORK1(i) = C
                            WORK2(i) = -s
                        End If
                    Next i
                    
                    '
                    ' If eigenvectors are desired, then apply saved rotations.
                    '
                    If ZNeeded > 0# Then
                        For i = L To M - 1# Step 1
                            WORKC(i - L + 1#) = WORK1(i)
                            WORKS(i - L + 1#) = WORK2(i)
                        Next i
                        If Not WasTranspose Then
                            Call ApplyRotationsFromTheRight(False, 1#, ZRows, L, M, WORKC, WORKS, z, WTemp)
                        Else
                            Call ApplyRotationsFromTheLeft(False, L, M, 1#, ZRows, WORKC, WORKS, z, WTemp)
                        End If
                    End If
                    d(L) = d(L) - p
                    e(L) = g
                    GoTo Cont_7
                End If
                
                '
                ' Eigenvalue found.
                '
                d(L) = p
                L = L + 1#
                If L <= LEND Then
                    GoTo Cont_7
                End If
                Exit Do
Cont_7:
            Loop
        Else
            
            '
            ' QR Iteration
            '
            ' Look for small superdiagonal element.
            '
            Do While True
                GotoFlag = False
                If L <> LEND Then
                    LENDP1 = LEND + 1#
                    For M = L To LENDP1 Step -1
                        TST = Square(Abs(e(M - 1#)))
                        If TST <= EPS2 * Abs(d(M)) * Abs(d(M - 1#)) + SAFMIN Then
                            GotoFlag = True
                            Exit For
                        End If
                    Next M
                End If
                If Not GotoFlag Then
                    M = LEND
                End If
                If M > LEND Then
                    e(M - 1#) = 0#
                End If
                p = d(L)
                If M <> L Then
                    
                    '
                    ' If remaining matrix is 2-by-2, use DLAE2 or SLAEV2
                    ' to compute its eigensystem.
                    '
                    If M = L - 1# Then
                        If ZNeeded > 0# Then
                            Call TdEVDEV2(d(L - 1#), e(L - 1#), d(L), RT1, RT2, C, s)
                            WORK1(M) = C
                            WORK2(M) = s
                            WORKC(1#) = C
                            WORKS(1#) = s
                            If Not WasTranspose Then
                                Call ApplyRotationsFromTheRight(True, 1#, ZRows, L - 1#, L, WORKC, WORKS, z, WTemp)
                            Else
                                Call ApplyRotationsFromTheLeft(True, L - 1#, L, 1#, ZRows, WORKC, WORKS, z, WTemp)
                            End If
                        Else
                            Call TdEVDE2(d(L - 1#), e(L - 1#), d(L), RT1, RT2)
                        End If
                        d(L - 1#) = RT1
                        d(L) = RT2
                        e(L - 1#) = 0#
                        L = L - 2#
                        If L >= LEND Then
                            GoTo Cont_11
                        End If
                        Exit Do
                    End If
                    If JTOT = NMAXIT Then
                        Exit Do
                    End If
                    JTOT = JTOT + 1#
                    
                    '
                    ' Form shift.
                    '
                    g = (d(L - 1#) - p) / (2# * e(L - 1#))
                    R = TdEVDPythag(g, 1#)
                    g = d(M) - p + e(L - 1#) / (g + TdEVDExtSign(R, g))
                    s = 1#
                    C = 1#
                    p = 0#
                    
                    '
                    ' Inner loop
                    '
                    LM1 = L - 1#
                    For i = M To LM1 Step 1
                        f = s * e(i)
                        B = C * e(i)
                        Call GenerateRotation(g, f, C, s, R)
                        If i <> M Then
                            e(i - 1#) = R
                        End If
                        g = d(i) - p
                        R = (d(i + 1#) - g) * s + 2# * C * B
                        p = s * R
                        d(i) = g + p
                        g = C * R - B
                        
                        '
                        ' If eigenvectors are desired, then save rotations.
                        '
                        If ZNeeded > 0# Then
                            WORK1(i) = C
                            WORK2(i) = s
                        End If
                    Next i
                    
                    '
                    ' If eigenvectors are desired, then apply saved rotations.
                    '
                    If ZNeeded > 0# Then
                        MM = L - M + 1#
                        For i = M To L - 1# Step 1
                            WORKC(i - M + 1#) = WORK1(i)
                            WORKS(i - M + 1#) = WORK2(i)
                        Next i
                        If Not WasTranspose Then
                            Call ApplyRotationsFromTheRight(True, 1#, ZRows, M, L, WORKC, WORKS, z, WTemp)
                        Else
                            Call ApplyRotationsFromTheLeft(True, M, L, 1#, ZRows, WORKC, WORKS, z, WTemp)
                        End If
                    End If
                    d(L) = d(L) - p
                    e(LM1) = g
                    GoTo Cont_11
                End If
                
                '
                ' Eigenvalue found.
                '
                d(L) = p
                L = L - 1#
                If L >= LEND Then
                    GoTo Cont_11
                End If
                Exit Do
Cont_11:
            Loop
        End If
        
        '
        ' Undo scaling if necessary
        '
        If ISCALE = 1# Then
            tmp = ANORM / SSFMAX
            TmpInt = LENDSV - 1#
            For i_ = LSV To LENDSV Step 1
                d(i_) = tmp * d(i_)
            Next i_
            For i_ = LSV To TmpInt Step 1
                e(i_) = tmp * e(i_)
            Next i_
        End If
        If ISCALE = 2# Then
            tmp = ANORM / SSFMIN
            TmpInt = LENDSV - 1#
            For i_ = LSV To LENDSV Step 1
                d(i_) = tmp * d(i_)
            Next i_
            For i_ = LSV To TmpInt Step 1
                e(i_) = tmp * e(i_)
            Next i_
        End If
        
        '
        ' Check for no convergence to an eigenvalue after a total
        ' of N*MAXIT iterations.
        '
        If JTOT >= NMAXIT Then
            Result = False
            If WasTranspose Then
                Call InplaceTranspose(z, 1#, N, 1#, N, WTemp)
            End If
            TridiagonalEVD = Result
            Exit Function
        End If
Cont_4:
    Loop
    
    '
    ' Order eigenvalues and eigenvectors.
    '
    If ZNeeded = 0# Then
        
        '
        ' Sort
        '
        If N = 1# Then
            TridiagonalEVD = Result
            Exit Function
        End If
        If N = 2# Then
            If d(1#) > d(2#) Then
                tmp = d(1#)
                d(1#) = d(2#)
                d(2#) = tmp
            End If
            TridiagonalEVD = Result
            Exit Function
        End If
        i = 2#
        Do
            t = i
            Do While t <> 1#
                K = t \ 2#
                If d(K) >= d(t) Then
                    t = 1#
                Else
                    tmp = d(K)
                    d(K) = d(t)
                    d(t) = tmp
                    t = K
                End If
            Loop
            i = i + 1#
        Loop Until Not i <= N
        i = N - 1#
        Do
            tmp = d(i + 1#)
            d(i + 1#) = d(1#)
            d(1#) = tmp
            t = 1#
            Do While t <> 0#
                K = 2# * t
                If K > i Then
                    t = 0#
                Else
                    If K < i Then
                        If d(K + 1#) > d(K) Then
                            K = K + 1#
                        End If
                    End If
                    If d(t) >= d(K) Then
                        t = 0#
                    Else
                        tmp = d(K)
                        d(K) = d(t)
                        d(t) = tmp
                        t = K
                    End If
                End If
            Loop
            i = i - 1#
        Loop Until Not i >= 1#
    Else
        
        '
        ' Use Selection Sort to minimize swaps of eigenvectors
        '
        For II = 2# To N Step 1
            i = II - 1#
            K = i
            p = d(i)
            For j = II To N Step 1
                If d(j) < p Then
                    K = j
                    p = d(j)
                End If
            Next j
            If K <> i Then
                d(K) = d(i)
                d(i) = p
                If WasTranspose Then
                    For i_ = 1# To N Step 1
                        WTemp(i_) = z(i, i_)
                    Next i_
                    For i_ = 1# To N Step 1
                        z(i, i_) = z(K, i_)
                    Next i_
                    For i_ = 1# To N Step 1
                        z(K, i_) = WTemp(i_)
                    Next i_
                Else
                    For i_ = 1# To ZRows Step 1
                        WTemp(i_) = z(i_, i)
                    Next i_
                    For i_ = 1# To ZRows Step 1
                        z(i_, i) = z(i_, K)
                    Next i_
                    For i_ = 1# To ZRows Step 1
                        z(i_, K) = WTemp(i_)
                    Next i_
                End If
            End If
        Next II
        If WasTranspose Then
            Call InplaceTranspose(z, 1#, N, 1#, N, WTemp)
        End If
    End If
    TridiagonalEVD = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'DLAE2  computes the eigenvalues of a 2-by-2 symmetric matrix
'   [  A   B  ]
'   [  B   C  ].
'On return, RT1 is the eigenvalue of larger absolute value, and RT2
'is the eigenvalue of smaller absolute value.
'
'  -- LAPACK auxiliary routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     October 31, 1992
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub TdEVDE2(ByRef a As Double, _
         ByRef B As Double, _
         ByRef C As Double, _
         ByRef RT1 As Double, _
         ByRef RT2 As Double)
    Dim AB As Double
    Dim ACMN As Double
    Dim ACMX As Double
    Dim ADF As Double
    Dim DF As Double
    Dim RT As Double
    Dim SM As Double
    Dim TB As Double
    SM = a + C
    DF = a - C
    ADF = Abs(DF)
    TB = B + B
    AB = Abs(TB)
    If Abs(a) > Abs(C) Then
        ACMX = a
        ACMN = C
    Else
        ACMX = C
        ACMN = a
    End If
    If ADF > AB Then
        RT = ADF * Sqr(1# + Square(AB / ADF))
    Else
        If ADF < AB Then
            RT = AB * Sqr(1# + Square(ADF / AB))
        Else
            
            '
            ' Includes case AB=ADF=0
            '
            RT = AB * Sqr(2#)
        End If
    End If
    If SM < 0# Then
        RT1 = 0.5 * (SM - RT)
        
        '
        ' Order of execution important.
        ' To get fully accurate smaller eigenvalue,
        ' next line needs to be executed in higher precision.
        '
        RT2 = ACMX / RT1 * ACMN - B / RT1 * B
    Else
        If SM > 0# Then
            RT1 = 0.5 * (SM + RT)
            
            '
            ' Order of execution important.
            ' To get fully accurate smaller eigenvalue,
            ' next line needs to be executed in higher precision.
            '
            RT2 = ACMX / RT1 * ACMN - B / RT1 * B
        Else
            
            '
            ' Includes case RT1 = RT2 = 0
            '
            RT1 = 0.5 * RT
            RT2 = -(0.5 * RT)
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'DLAEV2 computes the eigendecomposition of a 2-by-2 symmetric matrix
'
'   [  A   B  ]
'   [  B   C  ].
'
'On return, RT1 is the eigenvalue of larger absolute value, RT2 is the
'eigenvalue of smaller absolute value, and (CS1,SN1) is the unit right
'eigenvector for RT1, giving the decomposition
'
'   [ CS1  SN1 ] [  A   B  ] [ CS1 -SN1 ]  =  [ RT1  0  ]
'   [-SN1  CS1 ] [  B   C  ] [ SN1  CS1 ]     [  0  RT2 ].
'
'
'  -- LAPACK auxiliary routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     October 31, 1992
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub TdEVDEV2(ByRef a As Double, _
         ByRef B As Double, _
         ByRef C As Double, _
         ByRef RT1 As Double, _
         ByRef RT2 As Double, _
         ByRef CS1 As Double, _
         ByRef SN1 As Double)
    Dim SGN1 As Long
    Dim SGN2 As Long
    Dim AB As Double
    Dim ACMN As Double
    Dim ACMX As Double
    Dim ACS As Double
    Dim ADF As Double
    Dim cs As Double
    Dim Ct As Double
    Dim DF As Double
    Dim RT As Double
    Dim SM As Double
    Dim TB As Double
    Dim TN As Double
    
    '
    ' Compute the eigenvalues
    '
    SM = a + C
    DF = a - C
    ADF = Abs(DF)
    TB = B + B
    AB = Abs(TB)
    If Abs(a) > Abs(C) Then
        ACMX = a
        ACMN = C
    Else
        ACMX = C
        ACMN = a
    End If
    If ADF > AB Then
        RT = ADF * Sqr(1# + Square(AB / ADF))
    Else
        If ADF < AB Then
            RT = AB * Sqr(1# + Square(ADF / AB))
        Else
            
            '
            ' Includes case AB=ADF=0
            '
            RT = AB * Sqr(2#)
        End If
    End If
    If SM < 0# Then
        RT1 = 0.5 * (SM - RT)
        SGN1 = -1#
        
        '
        ' Order of execution important.
        ' To get fully accurate smaller eigenvalue,
        ' next line needs to be executed in higher precision.
        '
        RT2 = ACMX / RT1 * ACMN - B / RT1 * B
    Else
        If SM > 0# Then
            RT1 = 0.5 * (SM + RT)
            SGN1 = 1#
            
            '
            ' Order of execution important.
            ' To get fully accurate smaller eigenvalue,
            ' next line needs to be executed in higher precision.
            '
            RT2 = ACMX / RT1 * ACMN - B / RT1 * B
        Else
            
            '
            ' Includes case RT1 = RT2 = 0
            '
            RT1 = 0.5 * RT
            RT2 = -(0.5 * RT)
            SGN1 = 1#
        End If
    End If
    
    '
    ' Compute the eigenvector
    '
    If DF >= 0# Then
        cs = DF + RT
        SGN2 = 1#
    Else
        cs = DF - RT
        SGN2 = -1#
    End If
    ACS = Abs(cs)
    If ACS > AB Then
        Ct = -(TB / cs)
        SN1 = 1# / Sqr(1# + Ct * Ct)
        CS1 = Ct * SN1
    Else
        If AB = 0# Then
            CS1 = 1#
            SN1 = 0#
        Else
            TN = -(cs / TB)
            CS1 = 1# / Sqr(1# + TN * TN)
            SN1 = TN * CS1
        End If
    End If
    If SGN1 = SGN2 Then
        TN = CS1
        CS1 = -SN1
        SN1 = TN
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal routine
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Function TdEVDPythag(ByVal a As Double, ByVal B As Double) As Double
    Dim Result As Double
    If Abs(a) < Abs(B) Then
        Result = Abs(B) * Sqr(1# + Square(a / B))
    Else
        Result = Abs(a) * Sqr(1# + Square(B / a))
    End If
    TdEVDPythag = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal routine
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Function TdEVDExtSign(ByVal a As Double, ByVal B As Double) As Double
    Dim Result As Double
    If B >= 0# Then
        Result = Abs(a)
    Else
        Result = -Abs(a)
    End If
    TdEVDExtSign = Result
End Function
Private Sub TDINInternalDLAGTF(ByRef N As Long, _
         ByRef a() As Double, _
         ByRef lambda As Double, _
         ByRef B() As Double, _
         ByRef C() As Double, _
         ByRef TOL As Double, _
         ByRef d() As Double, _
         ByRef IIN() As Long, _
         ByRef Info As Long)
    Dim K As Long
    Dim eps As Double
    Dim MULT As Double
    Dim PIV1 As Double
    Dim PIV2 As Double
    Dim SCALE1 As Double
    Dim SCALE2 As Double
    Dim temp As Double
    Dim TL As Double
    Info = 0#
    If N < 0# Then
        Info = -1#
        Exit Sub
    End If
    If N = 0# Then
        Exit Sub
    End If
    a(1#) = a(1#) - lambda
    IIN(N) = 0#
    If N = 1# Then
        If a(1#) = 0# Then
            IIN(1#) = 1#
        End If
        Exit Sub
    End If
    eps = MachineEpsilon
    TL = MaxReal(TOL, eps)
    SCALE1 = Abs(a(1#)) + Abs(B(1#))
    For K = 1# To N - 1# Step 1
        a(K + 1#) = a(K + 1#) - lambda
        SCALE2 = Abs(C(K)) + Abs(a(K + 1#))
        If K < N - 1# Then
            SCALE2 = SCALE2 + Abs(B(K + 1#))
        End If
        If a(K) = 0# Then
            PIV1 = 0#
        Else
            PIV1 = Abs(a(K)) / SCALE1
        End If
        If C(K) = 0# Then
            IIN(K) = 0#
            PIV2 = 0#
            SCALE1 = SCALE2
            If K < N - 1# Then
                d(K) = 0#
            End If
        Else
            PIV2 = Abs(C(K)) / SCALE2
            If PIV2 <= PIV1 Then
                IIN(K) = 0#
                SCALE1 = SCALE2
                C(K) = C(K) / a(K)
                a(K + 1#) = a(K + 1#) - C(K) * B(K)
                If K < N - 1# Then
                    d(K) = 0#
                End If
            Else
                IIN(K) = 1#
                MULT = a(K) / C(K)
                a(K) = C(K)
                temp = a(K + 1#)
                a(K + 1#) = B(K) - MULT * temp
                If K < N - 1# Then
                    d(K) = B(K + 1#)
                    B(K + 1#) = -(MULT * d(K))
                End If
                B(K) = temp
                C(K) = MULT
            End If
        End If
        If MaxReal(PIV1, PIV2) <= TL And IIN(N) = 0# Then
            IIN(N) = K
        End If
    Next K
    If Abs(a(N)) <= SCALE1 * TL And IIN(N) = 0# Then
        IIN(N) = N
    End If
End Sub
Private Sub TDINInternalDLAGTS(ByRef N As Long, _
         ByRef a() As Double, _
         ByRef B() As Double, _
         ByRef C() As Double, _
         ByRef d() As Double, _
         ByRef IIN() As Long, _
         ByRef y() As Double, _
         ByRef TOL As Double, _
         ByRef Info As Long)
    Dim K As Long
    Dim ABSAK As Double
    Dim AK As Double
    Dim BIGNUM As Double
    Dim eps As Double
    Dim PERT As Double
    Dim SFMIN As Double
    Dim temp As Double
    Info = 0#
    If N < 0# Then
        Info = -1#
        Exit Sub
    End If
    If N = 0# Then
        Exit Sub
    End If
    eps = MachineEpsilon
    SFMIN = MinRealNumber
    BIGNUM = 1# / SFMIN
    If TOL <= 0# Then
        TOL = Abs(a(1#))
        If N > 1# Then
            TOL = MaxReal(TOL, MaxReal(Abs(a(2#)), Abs(B(1#))))
        End If
        For K = 3# To N Step 1
            TOL = MaxReal(TOL, MaxReal(Abs(a(K)), MaxReal(Abs(B(K - 1#)), Abs(d(K - 2#)))))
        Next K
        TOL = TOL * eps
        If TOL = 0# Then
            TOL = eps
        End If
    End If
    For K = 2# To N Step 1
        If IIN(K - 1#) = 0# Then
            y(K) = y(K) - C(K - 1#) * y(K - 1#)
        Else
            temp = y(K - 1#)
            y(K - 1#) = y(K)
            y(K) = temp - C(K - 1#) * y(K)
        End If
    Next K
    For K = N To 1# Step -1
        If K <= N - 2# Then
            temp = y(K) - B(K) * y(K + 1#) - d(K) * y(K + 2#)
        Else
            If K = N - 1# Then
                temp = y(K) - B(K) * y(K + 1#)
            Else
                temp = y(K)
            End If
        End If
        AK = a(K)
        PERT = Abs(TOL)
        If AK < 0# Then
            PERT = -PERT
        End If
        Do While True
            ABSAK = Abs(AK)
            If ABSAK < 1# Then
                If ABSAK < SFMIN Then
                    If ABSAK = 0# Or Abs(temp) * SFMIN > ABSAK Then
                        AK = AK + PERT
                        PERT = 2# * PERT
                        GoTo Cont_4
                    Else
                        temp = temp * BIGNUM
                        AK = AK * BIGNUM
                    End If
                Else
                    If Abs(temp) > ABSAK * BIGNUM Then
                        AK = AK + PERT
                        PERT = 2# * PERT
                        GoTo Cont_4
                    End If
                End If
            End If
            Exit Do
Cont_4:
        Loop
        y(K) = temp / AK
    Next K
End Sub
Private Sub InternalDLAEBZ(ByRef IJOB As Long, _
         ByRef NITMAX As Long, _
         ByRef N As Long, _
         ByRef mmax As Long, _
         ByRef MINP As Long, _
         ByRef ABSTOL As Double, _
         ByRef RELTOL As Double, _
         ByRef PIVMIN As Double, _
         ByRef d() As Double, _
         ByRef e() As Double, _
         ByRef E2() As Double, _
         ByRef NVAL() As Long, _
         ByRef AB() As Double, _
         ByRef C() As Double, _
         ByRef MOUT As Long, _
         ByRef NAB() As Long, _
         ByRef WORK() As Double, _
         ByRef IWORK() As Long, _
         ByRef Info As Long)
    Dim ITMP1 As Long
    Dim ITMP2 As Long
    Dim j As Long
    Dim JI As Long
    Dim JIT As Long
    Dim JP As Long
    Dim KF As Long
    Dim KFNEW As Long
    Dim KL As Long
    Dim KLNEW As Long
    Dim TMP1 As Double
    Dim Tmp2 As Double
    Info = 0#
    If IJOB < 1# Or IJOB > 3# Then
        Info = -1#
        Exit Sub
    End If
    
    '
    ' Initialize NAB
    '
    If IJOB = 1# Then
        
        '
        ' Compute the number of eigenvalues in the initial intervals.
        '
        MOUT = 0#
        
        '
        'DIR$ NOVECTOR
        '
        For JI = 1# To MINP Step 1
            For JP = 1# To 2# Step 1
                TMP1 = d(1#) - AB(JI, JP)
                If Abs(TMP1) < PIVMIN Then
                    TMP1 = -PIVMIN
                End If
                NAB(JI, JP) = 0#
                If TMP1 <= 0# Then
                    NAB(JI, JP) = 1#
                End If
                For j = 2# To N Step 1
                    TMP1 = d(j) - E2(j - 1#) / TMP1 - AB(JI, JP)
                    If Abs(TMP1) < PIVMIN Then
                        TMP1 = -PIVMIN
                    End If
                    If TMP1 <= 0# Then
                        NAB(JI, JP) = NAB(JI, JP) + 1#
                    End If
                Next j
            Next JP
            MOUT = MOUT + NAB(JI, 2#) - NAB(JI, 1#)
        Next JI
        Exit Sub
    End If
    
    '
    ' Initialize for loop
    '
    ' KF and KL have the following meaning:
    '   Intervals 1,...,KF-1 have converged.
    '   Intervals KF,...,KL  still need to be refined.
    '
    KF = 1#
    KL = MINP
    
    '
    ' If IJOB=2, initialize C.
    ' If IJOB=3, use the user-supplied starting point.
    '
    If IJOB = 2# Then
        For JI = 1# To MINP Step 1
            C(JI) = 0.5 * (AB(JI, 1#) + AB(JI, 2#))
        Next JI
    End If
    
    '
    ' Iteration loop
    '
    For JIT = 1# To NITMAX Step 1
        
        '
        ' Loop over intervals
        '
        '
        ' Serial Version of the loop
        '
        KLNEW = KL
        For JI = KF To KL Step 1
            
            '
            ' Compute N(w), the number of eigenvalues less than w
            '
            TMP1 = C(JI)
            Tmp2 = d(1#) - TMP1
            ITMP1 = 0#
            If Tmp2 <= PIVMIN Then
                ITMP1 = 1#
                Tmp2 = MinReal(Tmp2, -PIVMIN)
            End If
            
            '
            ' A series of compiler directives to defeat vectorization
            ' for the next loop
            '
            '*$PL$ CMCHAR=' '
            'CDIR$          NEXTSCALAR
            'C$DIR          SCALAR
            'CDIR$          NEXT SCALAR
            'CVD$L          NOVECTOR
            'CDEC$          NOVECTOR
            'CVD$           NOVECTOR
            '*VDIR          NOVECTOR
            '*VOCL          LOOP,SCALAR
            'CIBM           PREFER SCALAR
            '*$PL$ CMCHAR='*'
            '
            For j = 2# To N Step 1
                Tmp2 = d(j) - E2(j - 1#) / Tmp2 - TMP1
                If Tmp2 <= PIVMIN Then
                    ITMP1 = ITMP1 + 1#
                    Tmp2 = MinReal(Tmp2, -PIVMIN)
                End If
            Next j
            If IJOB <= 2# Then
                
                '
                ' IJOB=2: Choose all intervals containing eigenvalues.
                '
                ' Insure that N(w) is monotone
                '
                ITMP1 = MinInt(NAB(JI, 2#), MaxInt(NAB(JI, 1#), ITMP1))
                
                '
                ' Update the Queue -- add intervals if both halves
                ' contain eigenvalues.
                '
                If ITMP1 = NAB(JI, 2#) Then
                    
                    '
                    ' No eigenvalue in the upper interval:
                    ' just use the lower interval.
                    '
                    AB(JI, 2#) = TMP1
                Else
                    If ITMP1 = NAB(JI, 1#) Then
                        
                        '
                        ' No eigenvalue in the lower interval:
                        ' just use the upper interval.
                        '
                        AB(JI, 1#) = TMP1
                    Else
                        If KLNEW < mmax Then
                            
                            '
                            ' Eigenvalue in both intervals -- add upper to queue.
                            '
                            KLNEW = KLNEW + 1#
                            AB(KLNEW, 2#) = AB(JI, 2#)
                            NAB(KLNEW, 2#) = NAB(JI, 2#)
                            AB(KLNEW, 1#) = TMP1
                            NAB(KLNEW, 1#) = ITMP1
                            AB(JI, 2#) = TMP1
                            NAB(JI, 2#) = ITMP1
                        Else
                            Info = mmax + 1#
                            Exit Sub
                        End If
                    End If
                End If
            Else
                
                '
                ' IJOB=3: Binary search.  Keep only the interval
                ' containing  w  s.t. N(w) = NVAL
                '
                If ITMP1 <= NVAL(JI) Then
                    AB(JI, 1#) = TMP1
                    NAB(JI, 1#) = ITMP1
                End If
                If ITMP1 >= NVAL(JI) Then
                    AB(JI, 2#) = TMP1
                    NAB(JI, 2#) = ITMP1
                End If
            End If
        Next JI
        KL = KLNEW
        
        '
        ' Check for convergence
        '
        KFNEW = KF
        For JI = KF To KL Step 1
            TMP1 = Abs(AB(JI, 2#) - AB(JI, 1#))
            Tmp2 = MaxReal(Abs(AB(JI, 2#)), Abs(AB(JI, 1#)))
            If TMP1 < MaxReal(ABSTOL, MaxReal(PIVMIN, RELTOL * Tmp2)) Or NAB(JI, 1#) >= NAB(JI, 2#) Then
                
                '
                ' Converged -- Swap with position KFNEW,
                ' then increment KFNEW
                '
                If JI > KFNEW Then
                    TMP1 = AB(JI, 1#)
                    Tmp2 = AB(JI, 2#)
                    ITMP1 = NAB(JI, 1#)
                    ITMP2 = NAB(JI, 2#)
                    AB(JI, 1#) = AB(KFNEW, 1#)
                    AB(JI, 2#) = AB(KFNEW, 2#)
                    NAB(JI, 1#) = NAB(KFNEW, 1#)
                    NAB(JI, 2#) = NAB(KFNEW, 2#)
                    AB(KFNEW, 1#) = TMP1
                    AB(KFNEW, 2#) = Tmp2
                    NAB(KFNEW, 1#) = ITMP1
                    NAB(KFNEW, 2#) = ITMP2
                    If IJOB = 3# Then
                        ITMP1 = NVAL(JI)
                        NVAL(JI) = NVAL(KFNEW)
                        NVAL(KFNEW) = ITMP1
                    End If
                End If
                KFNEW = KFNEW + 1#
            End If
        Next JI
        KF = KFNEW
        
        '
        ' Choose Midpoints
        '
        For JI = KF To KL Step 1
            C(JI) = 0.5 * (AB(JI, 1#) + AB(JI, 2#))
        Next JI
        
        '
        ' If no more intervals to refine, quit.
        '
        If KF > KL Then
            Exit For
        End If
    Next JIT
    
    '
    ' Converged
    '
    Info = MaxInt(KL + 1# - KF, 0#)
    MOUT = KL
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal subroutine
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     June 30, 1999
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub InternalTREVC(ByRef t() As Double, _
         ByVal N As Long, _
         ByVal SIDE As Long, _
         ByVal HOWMNY As Long, _
         ByRef VSELECT_() As Boolean, _
         ByRef VL() As Double, _
         ByRef VR() As Double, _
         ByRef M As Long, _
         ByRef Info As Long)
    Dim VSELECT() As Boolean
    Dim ALLV As Boolean
    Dim BOTHV As Boolean
    Dim LEFTV As Boolean
    Dim OVER As Boolean
    Dim PAIR As Boolean
    Dim RIGHTV As Boolean
    Dim SOMEV As Boolean
    Dim i As Long
    Dim IERR As Long
    Dim II As Long
    Dim IP As Long
    Dim IIS As Long
    Dim j As Long
    Dim J1 As Long
    Dim J2 As Long
    Dim JNXT As Long
    Dim K As Long
    Dim KI As Long
    Dim N2 As Long
    Dim beta As Double
    Dim BIGNUM As Double
    Dim EMAX As Double
    Dim OVFL As Double
    Dim REC As Double
    Dim REMAX As Double
    Dim SCL As Double
    Dim SMIN As Double
    Dim SMLNUM As Double
    Dim Ulp As Double
    Dim UNFL As Double
    Dim VCRIT As Double
    Dim VMax As Double
    Dim WI As Double
    Dim WR As Double
    Dim XNorm As Double
    Dim x() As Double
    Dim WORK() As Double
    Dim temp() As Double
    Dim TEMP11() As Double
    Dim TEMP22() As Double
    Dim TEMP11B() As Double
    Dim TEMP21B() As Double
    Dim TEMP12B() As Double
    Dim TEMP22B() As Double
    Dim SkipFlag As Boolean
    Dim K1 As Long
    Dim K2 As Long
    Dim k3 As Long
    Dim k4 As Long
    Dim VT As Double
    Dim RSWAP4() As Boolean
    Dim ZSWAP4() As Boolean
    Dim IPIVOT44() As Long
    Dim CIV4() As Double
    Dim CRV4() As Double
    Dim i_ As Long
    Dim i1_ As Long
    VSELECT = VSELECT_
    ReDim x(1# To 2#, 1# To 2#)
    ReDim TEMP11(1# To 1#, 1# To 1#)
    ReDim TEMP11B(1# To 1#, 1# To 1#)
    ReDim TEMP21B(1# To 2#, 1# To 1#)
    ReDim TEMP12B(1# To 1#, 1# To 2#)
    ReDim TEMP22B(1# To 2#, 1# To 2#)
    ReDim TEMP22(1# To 2#, 1# To 2#)
    ReDim WORK(1# To 3# * N)
    ReDim temp(1# To N)
    ReDim RSWAP4(1# To 4#)
    ReDim ZSWAP4(1# To 4#)
    ReDim IPIVOT44(1# To 4#, 1# To 4#)
    ReDim CIV4(1# To 4#)
    ReDim CRV4(1# To 4#)
    If HOWMNY <> 1# Then
        If SIDE = 1# Or SIDE = 3# Then
            ReDim VR(1# To N, 1# To N)
        End If
        If SIDE = 2# Or SIDE = 3# Then
            ReDim VL(1# To N, 1# To N)
        End If
    End If
    
    '
    ' Decode and test the input parameters
    '
    BOTHV = SIDE = 3#
    RIGHTV = SIDE = 1# Or BOTHV
    LEFTV = SIDE = 2# Or BOTHV
    ALLV = HOWMNY = 2#
    OVER = HOWMNY = 1#
    SOMEV = HOWMNY = 3#
    Info = 0#
    If N < 0# Then
        Info = -2#
        Exit Sub
    End If
    If Not RIGHTV And Not LEFTV Then
        Info = -3#
        Exit Sub
    End If
    If Not ALLV And Not OVER And Not SOMEV Then
        Info = -4#
        Exit Sub
    End If
    
    '
    ' Set M to the number of columns required to store the selected
    ' eigenvectors, standardize the array SELECT if necessary, and
    ' test MM.
    '
    If SOMEV Then
        M = 0#
        PAIR = False
        For j = 1# To N Step 1
            If PAIR Then
                PAIR = False
                VSELECT(j) = False
            Else
                If j < N Then
                    If t(j + 1#, j) = 0# Then
                        If VSELECT(j) Then
                            M = M + 1#
                        End If
                    Else
                        PAIR = True
                        If VSELECT(j) Or VSELECT(j + 1#) Then
                            VSELECT(j) = True
                            M = M + 2#
                        End If
                    End If
                Else
                    If VSELECT(N) Then
                        M = M + 1#
                    End If
                End If
            End If
        Next j
    Else
        M = N
    End If
    
    '
    ' Quick return if possible.
    '
    If N = 0# Then
        Exit Sub
    End If
    
    '
    ' Set the constants to control overflow.
    '
    UNFL = MinRealNumber
    OVFL = 1# / UNFL
    Ulp = MachineEpsilon
    SMLNUM = UNFL * (N / Ulp)
    BIGNUM = (1# - Ulp) / SMLNUM
    
    '
    ' Compute 1-norm of each column of strictly upper triangular
    ' part of T to control overflow in triangular solver.
    '
    WORK(1#) = 0#
    For j = 2# To N Step 1
        WORK(j) = 0#
        For i = 1# To j - 1# Step 1
            WORK(j) = WORK(j) + Abs(t(i, j))
        Next i
    Next j
    
    '
    ' Index IP is used to specify the real or complex eigenvalue:
    ' IP = 0, real eigenvalue,
    '      1, first of conjugate complex pair: (wr,wi)
    '     -1, second of conjugate complex pair: (wr,wi)
    '
    N2 = 2# * N
    If RIGHTV Then
        
        '
        ' Compute right eigenvectors.
        '
        IP = 0#
        IIS = M
        For KI = N To 1# Step -1
            SkipFlag = False
            If IP = 1# Then
                SkipFlag = True
            Else
                If KI <> 1# Then
                    If t(KI, KI - 1#) <> 0# Then
                        IP = -1#
                    End If
                End If
                If SOMEV Then
                    If IP = 0# Then
                        If Not VSELECT(KI) Then
                            SkipFlag = True
                        End If
                    Else
                        If Not VSELECT(KI - 1#) Then
                            SkipFlag = True
                        End If
                    End If
                End If
            End If
            If Not SkipFlag Then
                
                '
                ' Compute the KI-th eigenvalue (WR,WI).
                '
                WR = t(KI, KI)
                WI = 0#
                If IP <> 0# Then
                    WI = Sqr(Abs(t(KI, KI - 1#))) * Sqr(Abs(t(KI - 1#, KI)))
                End If
                SMIN = MaxReal(Ulp * (Abs(WR) + Abs(WI)), SMLNUM)
                If IP = 0# Then
                    
                    '
                    ' Real right eigenvector
                    '
                    WORK(KI + N) = 1#
                    
                    '
                    ' Form right-hand side
                    '
                    For K = 1# To KI - 1# Step 1
                        WORK(K + N) = -t(K, KI)
                    Next K
                    
                    '
                    ' Solve the upper quasi-triangular system:
                    '   (T(1:KI-1,1:KI-1) - WR)*X = SCALE*WORK.
                    '
                    JNXT = KI - 1#
                    For j = KI - 1# To 1# Step -1
                        If j > JNXT Then
                            GoTo Cont_6
                        End If
                        J1 = j
                        J2 = j
                        JNXT = j - 1#
                        If j > 1# Then
                            If t(j, j - 1#) <> 0# Then
                                J1 = j - 1#
                                JNXT = j - 2#
                            End If
                        End If
                        If J1 = J2 Then
                            
                            '
                            ' 1-by-1 diagonal block
                            '
                            TEMP11(1#, 1#) = t(j, j)
                            TEMP11B(1#, 1#) = WORK(j + N)
                            Call InternalHSEVDLALN2(False, 1#, 1#, SMIN, 1#, TEMP11, 1#, 1#, TEMP11B, WR, 0#, RSWAP4, ZSWAP4, IPIVOT44, CIV4, CRV4, x, SCL, XNorm, IERR)
                            
                            '
                            ' Scale X(1,1) to avoid overflow when updating
                            ' the right-hand side.
                            '
                            If XNorm > 1# Then
                                If WORK(j) > BIGNUM / XNorm Then
                                    x(1#, 1#) = x(1#, 1#) / XNorm
                                    SCL = SCL / XNorm
                                End If
                            End If
                            
                            '
                            ' Scale if necessary
                            '
                            If SCL <> 1# Then
                                K1 = N + 1#
                                K2 = N + KI
                                For i_ = K1 To K2 Step 1
                                    WORK(i_) = SCL * WORK(i_)
                                Next i_
                            End If
                            WORK(j + N) = x(1#, 1#)
                            
                            '
                            ' Update right-hand side
                            '
                            K1 = 1# + N
                            K2 = j - 1# + N
                            k3 = j - 1#
                            VT = -x(1#, 1#)
                            i1_ = (1#) - (K1)
                            For i_ = K1 To K2 Step 1
                                WORK(i_) = WORK(i_) + VT * t(i_ + i1_, j)
                            Next i_
                        Else
                            
                            '
                            ' 2-by-2 diagonal block
                            '
                            TEMP22(1#, 1#) = t(j - 1#, j - 1#)
                            TEMP22(1#, 2#) = t(j - 1#, j)
                            TEMP22(2#, 1#) = t(j, j - 1#)
                            TEMP22(2#, 2#) = t(j, j)
                            TEMP21B(1#, 1#) = WORK(j - 1# + N)
                            TEMP21B(2#, 1#) = WORK(j + N)
                            Call InternalHSEVDLALN2(False, 2#, 1#, SMIN, 1#, TEMP22, 1#, 1#, TEMP21B, WR, 0#, RSWAP4, ZSWAP4, IPIVOT44, CIV4, CRV4, x, SCL, XNorm, IERR)
                            
                            '
                            ' Scale X(1,1) and X(2,1) to avoid overflow when
                            ' updating the right-hand side.
                            '
                            If XNorm > 1# Then
                                beta = MaxReal(WORK(j - 1#), WORK(j))
                                If beta > BIGNUM / XNorm Then
                                    x(1#, 1#) = x(1#, 1#) / XNorm
                                    x(2#, 1#) = x(2#, 1#) / XNorm
                                    SCL = SCL / XNorm
                                End If
                            End If
                            
                            '
                            ' Scale if necessary
                            '
                            If SCL <> 1# Then
                                K1 = 1# + N
                                K2 = KI + N
                                For i_ = K1 To K2 Step 1
                                    WORK(i_) = SCL * WORK(i_)
                                Next i_
                            End If
                            WORK(j - 1# + N) = x(1#, 1#)
                            WORK(j + N) = x(2#, 1#)
                            
                            '
                            ' Update right-hand side
                            '
                            K1 = 1# + N
                            K2 = j - 2# + N
                            k3 = j - 2#
                            k4 = j - 1#
                            VT = -x(1#, 1#)
                            i1_ = (1#) - (K1)
                            For i_ = K1 To K2 Step 1
                                WORK(i_) = WORK(i_) + VT * t(i_ + i1_, k4)
                            Next i_
                            VT = -x(2#, 1#)
                            i1_ = (1#) - (K1)
                            For i_ = K1 To K2 Step 1
                                WORK(i_) = WORK(i_) + VT * t(i_ + i1_, j)
                            Next i_
                        End If
Cont_6:
                    Next j
                    
                    '
                    ' Copy the vector x or Q*x to VR and normalize.
                    '
                    If Not OVER Then
                        K1 = 1# + N
                        K2 = KI + N
                        i1_ = (K1) - (1#)
                        For i_ = 1# To KI Step 1
                            VR(i_, IIS) = WORK(i_ + i1_)
                        Next i_
                        II = ColumnIdxAbsMax(VR, 1#, KI, IIS)
                        REMAX = 1# / Abs(VR(II, IIS))
                        For i_ = 1# To KI Step 1
                            VR(i_, IIS) = REMAX * VR(i_, IIS)
                        Next i_
                        For K = KI + 1# To N Step 1
                            VR(K, IIS) = 0#
                        Next K
                    Else
                        If KI > 1# Then
                            For i_ = 1# To N Step 1
                                temp(i_) = VR(i_, KI)
                            Next i_
                            Call MatrixVectorMultiply(VR, 1#, N, 1#, KI - 1#, False, WORK, 1# + N, KI - 1# + N, 1#, temp, 1#, N, WORK(KI + N))
                            For i_ = 1# To N Step 1
                                VR(i_, KI) = temp(i_)
                            Next i_
                        End If
                        II = ColumnIdxAbsMax(VR, 1#, N, KI)
                        REMAX = 1# / Abs(VR(II, KI))
                        For i_ = 1# To N Step 1
                            VR(i_, KI) = REMAX * VR(i_, KI)
                        Next i_
                    End If
                Else
                    
                    '
                    ' Complex right eigenvector.
                    '
                    ' Initial solve
                    '     [ (T(KI-1,KI-1) T(KI-1,KI) ) - (WR + I* WI)]*X = 0.
                    '     [ (T(KI,KI-1)   T(KI,KI)   )               ]
                    '
                    If Abs(t(KI - 1#, KI)) >= Abs(t(KI, KI - 1#)) Then
                        WORK(KI - 1# + N) = 1#
                        WORK(KI + N2) = WI / t(KI - 1#, KI)
                    Else
                        WORK(KI - 1# + N) = -(WI / t(KI, KI - 1#))
                        WORK(KI + N2) = 1#
                    End If
                    WORK(KI + N) = 0#
                    WORK(KI - 1# + N2) = 0#
                    
                    '
                    ' Form right-hand side
                    '
                    For K = 1# To KI - 2# Step 1
                        WORK(K + N) = -(WORK(KI - 1# + N) * t(K, KI - 1#))
                        WORK(K + N2) = -(WORK(KI + N2) * t(K, KI))
                    Next K
                    
                    '
                    ' Solve upper quasi-triangular system:
                    ' (T(1:KI-2,1:KI-2) - (WR+i*WI))*X = SCALE*(WORK+i*WORK2)
                    '
                    JNXT = KI - 2#
                    For j = KI - 2# To 1# Step -1
                        If j > JNXT Then
                            GoTo Cont_9
                        End If
                        J1 = j
                        J2 = j
                        JNXT = j - 1#
                        If j > 1# Then
                            If t(j, j - 1#) <> 0# Then
                                J1 = j - 1#
                                JNXT = j - 2#
                            End If
                        End If
                        If J1 = J2 Then
                            
                            '
                            ' 1-by-1 diagonal block
                            '
                            TEMP11(1#, 1#) = t(j, j)
                            TEMP12B(1#, 1#) = WORK(j + N)
                            TEMP12B(1#, 2#) = WORK(j + N + N)
                            Call InternalHSEVDLALN2(False, 1#, 2#, SMIN, 1#, TEMP11, 1#, 1#, TEMP12B, WR, WI, RSWAP4, ZSWAP4, IPIVOT44, CIV4, CRV4, x, SCL, XNorm, IERR)
                            
                            '
                            ' Scale X(1,1) and X(1,2) to avoid overflow when
                            ' updating the right-hand side.
                            '
                            If XNorm > 1# Then
                                If WORK(j) > BIGNUM / XNorm Then
                                    x(1#, 1#) = x(1#, 1#) / XNorm
                                    x(1#, 2#) = x(1#, 2#) / XNorm
                                    SCL = SCL / XNorm
                                End If
                            End If
                            
                            '
                            ' Scale if necessary
                            '
                            If SCL <> 1# Then
                                K1 = 1# + N
                                K2 = KI + N
                                For i_ = K1 To K2 Step 1
                                    WORK(i_) = SCL * WORK(i_)
                                Next i_
                                K1 = 1# + N2
                                K2 = KI + N2
                                For i_ = K1 To K2 Step 1
                                    WORK(i_) = SCL * WORK(i_)
                                Next i_
                            End If
                            WORK(j + N) = x(1#, 1#)
                            WORK(j + N2) = x(1#, 2#)
                            
                            '
                            ' Update the right-hand side
                            '
                            K1 = 1# + N
                            K2 = j - 1# + N
                            k3 = 1#
                            k4 = j - 1#
                            VT = -x(1#, 1#)
                            i1_ = (k3) - (K1)
                            For i_ = K1 To K2 Step 1
                                WORK(i_) = WORK(i_) + VT * t(i_ + i1_, j)
                            Next i_
                            K1 = 1# + N2
                            K2 = j - 1# + N2
                            k3 = 1#
                            k4 = j - 1#
                            VT = -x(1#, 2#)
                            i1_ = (k3) - (K1)
                            For i_ = K1 To K2 Step 1
                                WORK(i_) = WORK(i_) + VT * t(i_ + i1_, j)
                            Next i_
                        Else
                            
                            '
                            ' 2-by-2 diagonal block
                            '
                            TEMP22(1#, 1#) = t(j - 1#, j - 1#)
                            TEMP22(1#, 2#) = t(j - 1#, j)
                            TEMP22(2#, 1#) = t(j, j - 1#)
                            TEMP22(2#, 2#) = t(j, j)
                            TEMP22B(1#, 1#) = WORK(j - 1# + N)
                            TEMP22B(1#, 2#) = WORK(j - 1# + N + N)
                            TEMP22B(2#, 1#) = WORK(j + N)
                            TEMP22B(2#, 2#) = WORK(j + N + N)
                            Call InternalHSEVDLALN2(False, 2#, 2#, SMIN, 1#, TEMP22, 1#, 1#, TEMP22B, WR, WI, RSWAP4, ZSWAP4, IPIVOT44, CIV4, CRV4, x, SCL, XNorm, IERR)
                            
                            '
                            ' Scale X to avoid overflow when updating
                            ' the right-hand side.
                            '
                            If XNorm > 1# Then
                                beta = MaxReal(WORK(j - 1#), WORK(j))
                                If beta > BIGNUM / XNorm Then
                                    REC = 1# / XNorm
                                    x(1#, 1#) = x(1#, 1#) * REC
                                    x(1#, 2#) = x(1#, 2#) * REC
                                    x(2#, 1#) = x(2#, 1#) * REC
                                    x(2#, 2#) = x(2#, 2#) * REC
                                    SCL = SCL * REC
                                End If
                            End If
                            
                            '
                            ' Scale if necessary
                            '
                            If SCL <> 1# Then
                                For i_ = 1# + N To KI + N Step 1
                                    WORK(i_) = SCL * WORK(i_)
                                Next i_
                                For i_ = 1# + N2 To KI + N2 Step 1
                                    WORK(i_) = SCL * WORK(i_)
                                Next i_
                            End If
                            WORK(j - 1# + N) = x(1#, 1#)
                            WORK(j + N) = x(2#, 1#)
                            WORK(j - 1# + N2) = x(1#, 2#)
                            WORK(j + N2) = x(2#, 2#)
                            
                            '
                            ' Update the right-hand side
                            '
                            VT = -x(1#, 1#)
                            i1_ = (1#) - (N + 1#)
                            For i_ = N + 1# To N + j - 2# Step 1
                                WORK(i_) = WORK(i_) + VT * t(i_ + i1_, j - 1#)
                            Next i_
                            VT = -x(2#, 1#)
                            i1_ = (1#) - (N + 1#)
                            For i_ = N + 1# To N + j - 2# Step 1
                                WORK(i_) = WORK(i_) + VT * t(i_ + i1_, j)
                            Next i_
                            VT = -x(1#, 2#)
                            i1_ = (1#) - (N2 + 1#)
                            For i_ = N2 + 1# To N2 + j - 2# Step 1
                                WORK(i_) = WORK(i_) + VT * t(i_ + i1_, j - 1#)
                            Next i_
                            VT = -x(2#, 2#)
                            i1_ = (1#) - (N2 + 1#)
                            For i_ = N2 + 1# To N2 + j - 2# Step 1
                                WORK(i_) = WORK(i_) + VT * t(i_ + i1_, j)
                            Next i_
                        End If
Cont_9:
                    Next j
                    
                    '
                    ' Copy the vector x or Q*x to VR and normalize.
                    '
                    If Not OVER Then
                        i1_ = (N + 1#) - (1#)
                        For i_ = 1# To KI Step 1
                            VR(i_, IIS - 1#) = WORK(i_ + i1_)
                        Next i_
                        i1_ = (N2 + 1#) - (1#)
                        For i_ = 1# To KI Step 1
                            VR(i_, IIS) = WORK(i_ + i1_)
                        Next i_
                        EMAX = 0#
                        For K = 1# To KI Step 1
                            EMAX = MaxReal(EMAX, Abs(VR(K, IIS - 1#)) + Abs(VR(K, IIS)))
                        Next K
                        REMAX = 1# / EMAX
                        For i_ = 1# To KI Step 1
                            VR(i_, IIS - 1#) = REMAX * VR(i_, IIS - 1#)
                        Next i_
                        For i_ = 1# To KI Step 1
                            VR(i_, IIS) = REMAX * VR(i_, IIS)
                        Next i_
                        For K = KI + 1# To N Step 1
                            VR(K, IIS - 1#) = 0#
                            VR(K, IIS) = 0#
                        Next K
                    Else
                        If KI > 2# Then
                            For i_ = 1# To N Step 1
                                temp(i_) = VR(i_, KI - 1#)
                            Next i_
                            Call MatrixVectorMultiply(VR, 1#, N, 1#, KI - 2#, False, WORK, 1# + N, KI - 2# + N, 1#, temp, 1#, N, WORK(KI - 1# + N))
                            For i_ = 1# To N Step 1
                                VR(i_, KI - 1#) = temp(i_)
                            Next i_
                            For i_ = 1# To N Step 1
                                temp(i_) = VR(i_, KI)
                            Next i_
                            Call MatrixVectorMultiply(VR, 1#, N, 1#, KI - 2#, False, WORK, 1# + N2, KI - 2# + N2, 1#, temp, 1#, N, WORK(KI + N2))
                            For i_ = 1# To N Step 1
                                VR(i_, KI) = temp(i_)
                            Next i_
                        Else
                            VT = WORK(KI - 1# + N)
                            For i_ = 1# To N Step 1
                                VR(i_, KI - 1#) = VT * VR(i_, KI - 1#)
                            Next i_
                            VT = WORK(KI + N2)
                            For i_ = 1# To N Step 1
                                VR(i_, KI) = VT * VR(i_, KI)
                            Next i_
                        End If
                        EMAX = 0#
                        For K = 1# To N Step 1
                            EMAX = MaxReal(EMAX, Abs(VR(K, KI - 1#)) + Abs(VR(K, KI)))
                        Next K
                        REMAX = 1# / EMAX
                        For i_ = 1# To N Step 1
                            VR(i_, KI - 1#) = REMAX * VR(i_, KI - 1#)
                        Next i_
                        For i_ = 1# To N Step 1
                            VR(i_, KI) = REMAX * VR(i_, KI)
                        Next i_
                    End If
                End If
                IIS = IIS - 1#
                If IP <> 0# Then
                    IIS = IIS - 1#
                End If
            End If
            If IP = 1# Then
                IP = 0#
            End If
            If IP = -1# Then
                IP = 1#
            End If
        Next KI
    End If
    If LEFTV Then
        
        '
        ' Compute left eigenvectors.
        '
        IP = 0#
        IIS = 1#
        For KI = 1# To N Step 1
            SkipFlag = False
            If IP = -1# Then
                SkipFlag = True
            Else
                If KI <> N Then
                    If t(KI + 1#, KI) <> 0# Then
                        IP = 1#
                    End If
                End If
                If SOMEV Then
                    If Not VSELECT(KI) Then
                        SkipFlag = True
                    End If
                End If
            End If
            If Not SkipFlag Then
                
                '
                ' Compute the KI-th eigenvalue (WR,WI).
                '
                WR = t(KI, KI)
                WI = 0#
                If IP <> 0# Then
                    WI = Sqr(Abs(t(KI, KI + 1#))) * Sqr(Abs(t(KI + 1#, KI)))
                End If
                SMIN = MaxReal(Ulp * (Abs(WR) + Abs(WI)), SMLNUM)
                If IP = 0# Then
                    
                    '
                    ' Real left eigenvector.
                    '
                    WORK(KI + N) = 1#
                    
                    '
                    ' Form right-hand side
                    '
                    For K = KI + 1# To N Step 1
                        WORK(K + N) = -t(KI, K)
                    Next K
                    
                    '
                    ' Solve the quasi-triangular system:
                    ' (T(KI+1:N,KI+1:N) - WR)'*X = SCALE*WORK
                    '
                    VMax = 1#
                    VCRIT = BIGNUM
                    JNXT = KI + 1#
                    For j = KI + 1# To N Step 1
                        If j < JNXT Then
                            GoTo Cont_15
                        End If
                        J1 = j
                        J2 = j
                        JNXT = j + 1#
                        If j < N Then
                            If t(j + 1#, j) <> 0# Then
                                J2 = j + 1#
                                JNXT = j + 2#
                            End If
                        End If
                        If J1 = J2 Then
                            
                            '
                            ' 1-by-1 diagonal block
                            '
                            ' Scale if necessary to avoid overflow when forming
                            ' the right-hand side.
                            '
                            If WORK(j) > VCRIT Then
                                REC = 1# / VMax
                                For i_ = KI + N To N + N Step 1
                                    WORK(i_) = REC * WORK(i_)
                                Next i_
                                VMax = 1#
                                VCRIT = BIGNUM
                            End If
                            i1_ = (KI + 1# + N) - (KI + 1#)
                            VT = 0#
                            For i_ = KI + 1# To j - 1# Step 1
                                VT = VT + t(i_, j) * WORK(i_ + i1_)
                            Next i_
                            WORK(j + N) = WORK(j + N) - VT
                            
                            '
                            ' Solve (T(J,J)-WR)'*X = WORK
                            '
                            TEMP11(1#, 1#) = t(j, j)
                            TEMP11B(1#, 1#) = WORK(j + N)
                            Call InternalHSEVDLALN2(False, 1#, 1#, SMIN, 1#, TEMP11, 1#, 1#, TEMP11B, WR, 0#, RSWAP4, ZSWAP4, IPIVOT44, CIV4, CRV4, x, SCL, XNorm, IERR)
                            
                            '
                            ' Scale if necessary
                            '
                            If SCL <> 1# Then
                                For i_ = KI + N To N + N Step 1
                                    WORK(i_) = SCL * WORK(i_)
                                Next i_
                            End If
                            WORK(j + N) = x(1#, 1#)
                            VMax = MaxReal(Abs(WORK(j + N)), VMax)
                            VCRIT = BIGNUM / VMax
                        Else
                            
                            '
                            ' 2-by-2 diagonal block
                            '
                            ' Scale if necessary to avoid overflow when forming
                            ' the right-hand side.
                            '
                            beta = MaxReal(WORK(j), WORK(j + 1#))
                            If beta > VCRIT Then
                                REC = 1# / VMax
                                For i_ = KI + N To N + N Step 1
                                    WORK(i_) = REC * WORK(i_)
                                Next i_
                                VMax = 1#
                                VCRIT = BIGNUM
                            End If
                            i1_ = (KI + 1# + N) - (KI + 1#)
                            VT = 0#
                            For i_ = KI + 1# To j - 1# Step 1
                                VT = VT + t(i_, j) * WORK(i_ + i1_)
                            Next i_
                            WORK(j + N) = WORK(j + N) - VT
                            i1_ = (KI + 1# + N) - (KI + 1#)
                            VT = 0#
                            For i_ = KI + 1# To j - 1# Step 1
                                VT = VT + t(i_, j + 1#) * WORK(i_ + i1_)
                            Next i_
                            WORK(j + 1# + N) = WORK(j + 1# + N) - VT
                            
                            '
                            ' Solve
                            '    [T(J,J)-WR   T(J,J+1)     ]'* X = SCALE*( WORK1 )
                            '    [T(J+1,J)    T(J+1,J+1)-WR]             ( WORK2 )
                            '
                            TEMP22(1#, 1#) = t(j, j)
                            TEMP22(1#, 2#) = t(j, j + 1#)
                            TEMP22(2#, 1#) = t(j + 1#, j)
                            TEMP22(2#, 2#) = t(j + 1#, j + 1#)
                            TEMP21B(1#, 1#) = WORK(j + N)
                            TEMP21B(2#, 1#) = WORK(j + 1# + N)
                            Call InternalHSEVDLALN2(True, 2#, 1#, SMIN, 1#, TEMP22, 1#, 1#, TEMP21B, WR, 0#, RSWAP4, ZSWAP4, IPIVOT44, CIV4, CRV4, x, SCL, XNorm, IERR)
                            
                            '
                            ' Scale if necessary
                            '
                            If SCL <> 1# Then
                                For i_ = KI + N To N + N Step 1
                                    WORK(i_) = SCL * WORK(i_)
                                Next i_
                            End If
                            WORK(j + N) = x(1#, 1#)
                            WORK(j + 1# + N) = x(2#, 1#)
                            VMax = MaxReal(Abs(WORK(j + N)), MaxReal(Abs(WORK(j + 1# + N)), VMax))
                            VCRIT = BIGNUM / VMax
                        End If
Cont_15:
                    Next j
                    
                    '
                    ' Copy the vector x or Q*x to VL and normalize.
                    '
                    If Not OVER Then
                        i1_ = (KI + N) - (KI)
                        For i_ = KI To N Step 1
                            VL(i_, IIS) = WORK(i_ + i1_)
                        Next i_
                        II = ColumnIdxAbsMax(VL, KI, N, IIS)
                        REMAX = 1# / Abs(VL(II, IIS))
                        For i_ = KI To N Step 1
                            VL(i_, IIS) = REMAX * VL(i_, IIS)
                        Next i_
                        For K = 1# To KI - 1# Step 1
                            VL(K, IIS) = 0#
                        Next K
                    Else
                        If KI < N Then
                            For i_ = 1# To N Step 1
                                temp(i_) = VL(i_, KI)
                            Next i_
                            Call MatrixVectorMultiply(VL, 1#, N, KI + 1#, N, False, WORK, KI + 1# + N, N + N, 1#, temp, 1#, N, WORK(KI + N))
                            For i_ = 1# To N Step 1
                                VL(i_, KI) = temp(i_)
                            Next i_
                        End If
                        II = ColumnIdxAbsMax(VL, 1#, N, KI)
                        REMAX = 1# / Abs(VL(II, KI))
                        For i_ = 1# To N Step 1
                            VL(i_, KI) = REMAX * VL(i_, KI)
                        Next i_
                    End If
                Else
                    
                    '
                    ' Complex left eigenvector.
                    '
                    ' Initial solve:
                    '   ((T(KI,KI)    T(KI,KI+1) )' - (WR - I* WI))*X = 0.
                    '   ((T(KI+1,KI) T(KI+1,KI+1))                )
                    '
                    If Abs(t(KI, KI + 1#)) >= Abs(t(KI + 1#, KI)) Then
                        WORK(KI + N) = WI / t(KI, KI + 1#)
                        WORK(KI + 1# + N2) = 1#
                    Else
                        WORK(KI + N) = 1#
                        WORK(KI + 1# + N2) = -(WI / t(KI + 1#, KI))
                    End If
                    WORK(KI + 1# + N) = 0#
                    WORK(KI + N2) = 0#
                    
                    '
                    ' Form right-hand side
                    '
                    For K = KI + 2# To N Step 1
                        WORK(K + N) = -(WORK(KI + N) * t(KI, K))
                        WORK(K + N2) = -(WORK(KI + 1# + N2) * t(KI + 1#, K))
                    Next K
                    
                    '
                    ' Solve complex quasi-triangular system:
                    ' ( T(KI+2,N:KI+2,N) - (WR-i*WI) )*X = WORK1+i*WORK2
                    '
                    VMax = 1#
                    VCRIT = BIGNUM
                    JNXT = KI + 2#
                    For j = KI + 2# To N Step 1
                        If j < JNXT Then
                            GoTo Cont_18
                        End If
                        J1 = j
                        J2 = j
                        JNXT = j + 1#
                        If j < N Then
                            If t(j + 1#, j) <> 0# Then
                                J2 = j + 1#
                                JNXT = j + 2#
                            End If
                        End If
                        If J1 = J2 Then
                            
                            '
                            ' 1-by-1 diagonal block
                            '
                            ' Scale if necessary to avoid overflow when
                            ' forming the right-hand side elements.
                            '
                            If WORK(j) > VCRIT Then
                                REC = 1# / VMax
                                For i_ = KI + N To N + N Step 1
                                    WORK(i_) = REC * WORK(i_)
                                Next i_
                                For i_ = KI + N2 To N + N2 Step 1
                                    WORK(i_) = REC * WORK(i_)
                                Next i_
                                VMax = 1#
                                VCRIT = BIGNUM
                            End If
                            i1_ = (KI + 2# + N) - (KI + 2#)
                            VT = 0#
                            For i_ = KI + 2# To j - 1# Step 1
                                VT = VT + t(i_, j) * WORK(i_ + i1_)
                            Next i_
                            WORK(j + N) = WORK(j + N) - VT
                            i1_ = (KI + 2# + N2) - (KI + 2#)
                            VT = 0#
                            For i_ = KI + 2# To j - 1# Step 1
                                VT = VT + t(i_, j) * WORK(i_ + i1_)
                            Next i_
                            WORK(j + N2) = WORK(j + N2) - VT
                            
                            '
                            ' Solve (T(J,J)-(WR-i*WI))*(X11+i*X12)= WK+I*WK2
                            '
                            TEMP11(1#, 1#) = t(j, j)
                            TEMP12B(1#, 1#) = WORK(j + N)
                            TEMP12B(1#, 2#) = WORK(j + N + N)
                            Call InternalHSEVDLALN2(False, 1#, 2#, SMIN, 1#, TEMP11, 1#, 1#, TEMP12B, WR, -WI, RSWAP4, ZSWAP4, IPIVOT44, CIV4, CRV4, x, SCL, XNorm, IERR)
                            
                            '
                            ' Scale if necessary
                            '
                            If SCL <> 1# Then
                                For i_ = KI + N To N + N Step 1
                                    WORK(i_) = SCL * WORK(i_)
                                Next i_
                                For i_ = KI + N2 To N + N2 Step 1
                                    WORK(i_) = SCL * WORK(i_)
                                Next i_
                            End If
                            WORK(j + N) = x(1#, 1#)
                            WORK(j + N2) = x(1#, 2#)
                            VMax = MaxReal(Abs(WORK(j + N)), MaxReal(Abs(WORK(j + N2)), VMax))
                            VCRIT = BIGNUM / VMax
                        Else
                            
                            '
                            ' 2-by-2 diagonal block
                            '
                            ' Scale if necessary to avoid overflow when forming
                            ' the right-hand side elements.
                            '
                            beta = MaxReal(WORK(j), WORK(j + 1#))
                            If beta > VCRIT Then
                                REC = 1# / VMax
                                For i_ = KI + N To N + N Step 1
                                    WORK(i_) = REC * WORK(i_)
                                Next i_
                                For i_ = KI + N2 To N + N2 Step 1
                                    WORK(i_) = REC * WORK(i_)
                                Next i_
                                VMax = 1#
                                VCRIT = BIGNUM
                            End If
                            i1_ = (KI + 2# + N) - (KI + 2#)
                            VT = 0#
                            For i_ = KI + 2# To j - 1# Step 1
                                VT = VT + t(i_, j) * WORK(i_ + i1_)
                            Next i_
                            WORK(j + N) = WORK(j + N) - VT
                            i1_ = (KI + 2# + N2) - (KI + 2#)
                            VT = 0#
                            For i_ = KI + 2# To j - 1# Step 1
                                VT = VT + t(i_, j) * WORK(i_ + i1_)
                            Next i_
                            WORK(j + N2) = WORK(j + N2) - VT
                            i1_ = (KI + 2# + N) - (KI + 2#)
                            VT = 0#
                            For i_ = KI + 2# To j - 1# Step 1
                                VT = VT + t(i_, j + 1#) * WORK(i_ + i1_)
                            Next i_
                            WORK(j + 1# + N) = WORK(j + 1# + N) - VT
                            i1_ = (KI + 2# + N2) - (KI + 2#)
                            VT = 0#
                            For i_ = KI + 2# To j - 1# Step 1
                                VT = VT + t(i_, j + 1#) * WORK(i_ + i1_)
                            Next i_
                            WORK(j + 1# + N2) = WORK(j + 1# + N2) - VT
                            
                            '
                            ' Solve 2-by-2 complex linear equation
                            '   ([T(j,j)   T(j,j+1)  ]'-(wr-i*wi)*I)*X = SCALE*B
                            '   ([T(j+1,j) T(j+1,j+1)]             )
                            '
                            TEMP22(1#, 1#) = t(j, j)
                            TEMP22(1#, 2#) = t(j, j + 1#)
                            TEMP22(2#, 1#) = t(j + 1#, j)
                            TEMP22(2#, 2#) = t(j + 1#, j + 1#)
                            TEMP22B(1#, 1#) = WORK(j + N)
                            TEMP22B(1#, 2#) = WORK(j + N + N)
                            TEMP22B(2#, 1#) = WORK(j + 1# + N)
                            TEMP22B(2#, 2#) = WORK(j + 1# + N + N)
                            Call InternalHSEVDLALN2(True, 2#, 2#, SMIN, 1#, TEMP22, 1#, 1#, TEMP22B, WR, -WI, RSWAP4, ZSWAP4, IPIVOT44, CIV4, CRV4, x, SCL, XNorm, IERR)
                            
                            '
                            ' Scale if necessary
                            '
                            If SCL <> 1# Then
                                For i_ = KI + N To N + N Step 1
                                    WORK(i_) = SCL * WORK(i_)
                                Next i_
                                For i_ = KI + N2 To N + N2 Step 1
                                    WORK(i_) = SCL * WORK(i_)
                                Next i_
                            End If
                            WORK(j + N) = x(1#, 1#)
                            WORK(j + N2) = x(1#, 2#)
                            WORK(j + 1# + N) = x(2#, 1#)
                            WORK(j + 1# + N2) = x(2#, 2#)
                            VMax = MaxReal(Abs(x(1#, 1#)), VMax)
                            VMax = MaxReal(Abs(x(1#, 2#)), VMax)
                            VMax = MaxReal(Abs(x(2#, 1#)), VMax)
                            VMax = MaxReal(Abs(x(2#, 2#)), VMax)
                            VCRIT = BIGNUM / VMax
                        End If
Cont_18:
                    Next j
                    
                    '
                    ' Copy the vector x or Q*x to VL and normalize.
                    '
                    If Not OVER Then
                        i1_ = (KI + N) - (KI)
                        For i_ = KI To N Step 1
                            VL(i_, IIS) = WORK(i_ + i1_)
                        Next i_
                        i1_ = (KI + N2) - (KI)
                        For i_ = KI To N Step 1
                            VL(i_, IIS + 1#) = WORK(i_ + i1_)
                        Next i_
                        EMAX = 0#
                        For K = KI To N Step 1
                            EMAX = MaxReal(EMAX, Abs(VL(K, IIS)) + Abs(VL(K, IIS + 1#)))
                        Next K
                        REMAX = 1# / EMAX
                        For i_ = KI To N Step 1
                            VL(i_, IIS) = REMAX * VL(i_, IIS)
                        Next i_
                        For i_ = KI To N Step 1
                            VL(i_, IIS + 1#) = REMAX * VL(i_, IIS + 1#)
                        Next i_
                        For K = 1# To KI - 1# Step 1
                            VL(K, IIS) = 0#
                            VL(K, IIS + 1#) = 0#
                        Next K
                    Else
                        If KI < N - 1# Then
                            For i_ = 1# To N Step 1
                                temp(i_) = VL(i_, KI)
                            Next i_
                            Call MatrixVectorMultiply(VL, 1#, N, KI + 2#, N, False, WORK, KI + 2# + N, N + N, 1#, temp, 1#, N, WORK(KI + N))
                            For i_ = 1# To N Step 1
                                VL(i_, KI) = temp(i_)
                            Next i_
                            For i_ = 1# To N Step 1
                                temp(i_) = VL(i_, KI + 1#)
                            Next i_
                            Call MatrixVectorMultiply(VL, 1#, N, KI + 2#, N, False, WORK, KI + 2# + N2, N + N2, 1#, temp, 1#, N, WORK(KI + 1# + N2))
                            For i_ = 1# To N Step 1
                                VL(i_, KI + 1#) = temp(i_)
                            Next i_
                        Else
                            VT = WORK(KI + N)
                            For i_ = 1# To N Step 1
                                VL(i_, KI) = VT * VL(i_, KI)
                            Next i_
                            VT = WORK(KI + 1# + N2)
                            For i_ = 1# To N Step 1
                                VL(i_, KI + 1#) = VT * VL(i_, KI + 1#)
                            Next i_
                        End If
                        EMAX = 0#
                        For K = 1# To N Step 1
                            EMAX = MaxReal(EMAX, Abs(VL(K, KI)) + Abs(VL(K, KI + 1#)))
                        Next K
                        REMAX = 1# / EMAX
                        For i_ = 1# To N Step 1
                            VL(i_, KI) = REMAX * VL(i_, KI)
                        Next i_
                        For i_ = 1# To N Step 1
                            VL(i_, KI + 1#) = REMAX * VL(i_, KI + 1#)
                        Next i_
                    End If
                End If
                IIS = IIS + 1#
                If IP <> 0# Then
                    IIS = IIS + 1#
                End If
            End If
            If IP = -1# Then
                IP = 0#
            End If
            If IP = 1# Then
                IP = -1#
            End If
        Next KI
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'DLALN2 solves a system of the form  (ca A - w D ) X = s B
'or (ca A' - w D) X = s B   with possible scaling ("s") and
'perturbation of A.  (A' means A-transpose.)
'
'A is an NA x NA real matrix, ca is a real scalar, D is an NA x NA
'real diagonal matrix, w is a real or complex value, and X and B are
'NA x 1 matrices -- real if w is real, complex if w is complex.  NA
'may be 1 or 2.
'
'If w is complex, X and B are represented as NA x 2 matrices,
'the first column of each being the real part and the second
'being the imaginary part.
'
'"s" is a scaling factor (.LE. 1), computed by DLALN2, which is
'so chosen that X can be computed without overflow.  X is further
'scaled if necessary to assure that norm(ca A - w D)*norm(X) is less
'than overflow.
'
'If both singular values of (ca A - w D) are less than SMIN,
'SMIN*identity will be used instead of (ca A - w D).  If only one
'singular value is less than SMIN, one element of (ca A - w D) will be
'perturbed enough to make the smallest singular value roughly SMIN.
'If both singular values are at least SMIN, (ca A - w D) will not be
'perturbed.  In any case, the perturbation will be at most some small
'multiple of max( SMIN, ulp*norm(ca A - w D) ).  The singular values
'are computed by infinity-norm approximations, and thus will only be
'correct to a factor of 2 or so.
'
'Note: all input quantities are assumed to be smaller than overflow
'by a reasonable factor.  (See BIGNUM.)
'
'  -- LAPACK auxiliary routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     October 31, 1992
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub InternalHSEVDLALN2(ByRef LTRANS As Boolean, _
         ByRef NA As Long, _
         ByRef NW As Long, _
         ByRef SMIN As Double, _
         ByRef CA As Double, _
         ByRef a() As Double, _
         ByRef d1 As Double, _
         ByRef D2 As Double, _
         ByRef B() As Double, _
         ByRef WR As Double, _
         ByRef WI As Double, _
         ByRef RSWAP4() As Boolean, _
         ByRef ZSWAP4() As Boolean, _
         ByRef IPIVOT44() As Long, _
         ByRef CIV4() As Double, _
         ByRef CRV4() As Double, _
         ByRef x() As Double, _
         ByRef SCL As Double, _
         ByRef XNorm As Double, _
         ByRef Info As Long)
    Dim ICMAX As Long
    Dim j As Long
    Dim BBND As Double
    Dim BI1 As Double
    Dim BI2 As Double
    Dim BIGNUM As Double
    Dim BNorm As Double
    Dim BR1 As Double
    Dim BR2 As Double
    Dim CI21 As Double
    Dim CI22 As Double
    Dim CMAX As Double
    Dim CNORM As Double
    Dim CR21 As Double
    Dim CR22 As Double
    Dim CSI As Double
    Dim CSR As Double
    Dim LI21 As Double
    Dim LR21 As Double
    Dim SMINI As Double
    Dim SMLNUM As Double
    Dim temp As Double
    Dim U22ABS As Double
    Dim UI11 As Double
    Dim UI11R As Double
    Dim UI12 As Double
    Dim UI12S As Double
    Dim UI22 As Double
    Dim UR11 As Double
    Dim UR11R As Double
    Dim UR12 As Double
    Dim UR12S As Double
    Dim UR22 As Double
    Dim XI1 As Double
    Dim XI2 As Double
    Dim XR1 As Double
    Dim XR2 As Double
    Dim TMP1 As Double
    Dim Tmp2 As Double
    ZSWAP4(1#) = False
    ZSWAP4(2#) = False
    ZSWAP4(3#) = True
    ZSWAP4(4#) = True
    RSWAP4(1#) = False
    RSWAP4(2#) = True
    RSWAP4(3#) = False
    RSWAP4(4#) = True
    IPIVOT44(1#, 1#) = 1#
    IPIVOT44(2#, 1#) = 2#
    IPIVOT44(3#, 1#) = 3#
    IPIVOT44(4#, 1#) = 4#
    IPIVOT44(1#, 2#) = 2#
    IPIVOT44(2#, 2#) = 1#
    IPIVOT44(3#, 2#) = 4#
    IPIVOT44(4#, 2#) = 3#
    IPIVOT44(1#, 3#) = 3#
    IPIVOT44(2#, 3#) = 4#
    IPIVOT44(3#, 3#) = 1#
    IPIVOT44(4#, 3#) = 2#
    IPIVOT44(1#, 4#) = 4#
    IPIVOT44(2#, 4#) = 3#
    IPIVOT44(3#, 4#) = 2#
    IPIVOT44(4#, 4#) = 1#
    SMLNUM = 2# * MinRealNumber
    BIGNUM = 1# / SMLNUM
    SMINI = MaxReal(SMIN, SMLNUM)
    
    '
    ' Don't check for input errors
    '
    Info = 0#
    
    '
    ' Standard Initializations
    '
    SCL = 1#
    If NA = 1# Then
        
        '
        ' 1 x 1  (i.e., scalar) system   C X = B
        '
        If NW = 1# Then
            
            '
            ' Real 1x1 system.
            '
            ' C = ca A - w D
            '
            CSR = CA * a(1#, 1#) - WR * d1
            CNORM = Abs(CSR)
            
            '
            ' If | C | < SMINI, use C = SMINI
            '
            If CNORM < SMINI Then
                CSR = SMINI
                CNORM = SMINI
                Info = 1#
            End If
            
            '
            ' Check scaling for  X = B / C
            '
            BNorm = Abs(B(1#, 1#))
            If CNORM < 1# And BNorm > 1# Then
                If BNorm > BIGNUM * CNORM Then
                    SCL = 1# / BNorm
                End If
            End If
            
            '
            ' Compute X
            '
            x(1#, 1#) = B(1#, 1#) * SCL / CSR
            XNorm = Abs(x(1#, 1#))
        Else
            
            '
            ' Complex 1x1 system (w is complex)
            '
            ' C = ca A - w D
            '
            CSR = CA * a(1#, 1#) - WR * d1
            CSI = -(WI * d1)
            CNORM = Abs(CSR) + Abs(CSI)
            
            '
            ' If | C | < SMINI, use C = SMINI
            '
            If CNORM < SMINI Then
                CSR = SMINI
                CSI = 0#
                CNORM = SMINI
                Info = 1#
            End If
            
            '
            ' Check scaling for  X = B / C
            '
            BNorm = Abs(B(1#, 1#)) + Abs(B(1#, 2#))
            If CNORM < 1# And BNorm > 1# Then
                If BNorm > BIGNUM * CNORM Then
                    SCL = 1# / BNorm
                End If
            End If
            
            '
            ' Compute X
            '
            Call InternalHSEVDLADIV(SCL * B(1#, 1#), SCL * B(1#, 2#), CSR, CSI, TMP1, Tmp2)
            x(1#, 1#) = TMP1
            x(1#, 2#) = Tmp2
            XNorm = Abs(x(1#, 1#)) + Abs(x(1#, 2#))
        End If
    Else
        
        '
        ' 2x2 System
        '
        ' Compute the real part of  C = ca A - w D  (or  ca A' - w D )
        '
        CRV4(1# + 0#) = CA * a(1#, 1#) - WR * d1
        CRV4(2# + 2#) = CA * a(2#, 2#) - WR * D2
        If LTRANS Then
            CRV4(1# + 2#) = CA * a(2#, 1#)
            CRV4(2# + 0#) = CA * a(1#, 2#)
        Else
            CRV4(2# + 0#) = CA * a(2#, 1#)
            CRV4(1# + 2#) = CA * a(1#, 2#)
        End If
        If NW = 1# Then
            
            '
            ' Real 2x2 system  (w is real)
            '
            ' Find the largest element in C
            '
            CMAX = 0#
            ICMAX = 0#
            For j = 1# To 4# Step 1
                If Abs(CRV4(j)) > CMAX Then
                    CMAX = Abs(CRV4(j))
                    ICMAX = j
                End If
            Next j
            
            '
            ' If norm(C) < SMINI, use SMINI*identity.
            '
            If CMAX < SMINI Then
                BNorm = MaxReal(Abs(B(1#, 1#)), Abs(B(2#, 1#)))
                If SMINI < 1# And BNorm > 1# Then
                    If BNorm > BIGNUM * SMINI Then
                        SCL = 1# / BNorm
                    End If
                End If
                temp = SCL / SMINI
                x(1#, 1#) = temp * B(1#, 1#)
                x(2#, 1#) = temp * B(2#, 1#)
                XNorm = temp * BNorm
                Info = 1#
                Exit Sub
            End If
            
            '
            ' Gaussian elimination with complete pivoting.
            '
            UR11 = CRV4(ICMAX)
            CR21 = CRV4(IPIVOT44(2#, ICMAX))
            UR12 = CRV4(IPIVOT44(3#, ICMAX))
            CR22 = CRV4(IPIVOT44(4#, ICMAX))
            UR11R = 1# / UR11
            LR21 = UR11R * CR21
            UR22 = CR22 - UR12 * LR21
            
            '
            ' If smaller pivot < SMINI, use SMINI
            '
            If Abs(UR22) < SMINI Then
                UR22 = SMINI
                Info = 1#
            End If
            If RSWAP4(ICMAX) Then
                BR1 = B(2#, 1#)
                BR2 = B(1#, 1#)
            Else
                BR1 = B(1#, 1#)
                BR2 = B(2#, 1#)
            End If
            BR2 = BR2 - LR21 * BR1
            BBND = MaxReal(Abs(BR1 * (UR22 * UR11R)), Abs(BR2))
            If BBND > 1# And Abs(UR22) < 1# Then
                If BBND >= BIGNUM * Abs(UR22) Then
                    SCL = 1# / BBND
                End If
            End If
            XR2 = BR2 * SCL / UR22
            XR1 = SCL * BR1 * UR11R - XR2 * (UR11R * UR12)
            If ZSWAP4(ICMAX) Then
                x(1#, 1#) = XR2
                x(2#, 1#) = XR1
            Else
                x(1#, 1#) = XR1
                x(2#, 1#) = XR2
            End If
            XNorm = MaxReal(Abs(XR1), Abs(XR2))
            
            '
            ' Further scaling if  norm(A) norm(X) > overflow
            '
            If XNorm > 1# And CMAX > 1# Then
                If XNorm > BIGNUM / CMAX Then
                    temp = CMAX / BIGNUM
                    x(1#, 1#) = temp * x(1#, 1#)
                    x(2#, 1#) = temp * x(2#, 1#)
                    XNorm = temp * XNorm
                    SCL = temp * SCL
                End If
            End If
        Else
            
            '
            ' Complex 2x2 system  (w is complex)
            '
            ' Find the largest element in C
            '
            CIV4(1# + 0#) = -(WI * d1)
            CIV4(2# + 0#) = 0#
            CIV4(1# + 2#) = 0#
            CIV4(2# + 2#) = -(WI * D2)
            CMAX = 0#
            ICMAX = 0#
            For j = 1# To 4# Step 1
                If Abs(CRV4(j)) + Abs(CIV4(j)) > CMAX Then
                    CMAX = Abs(CRV4(j)) + Abs(CIV4(j))
                    ICMAX = j
                End If
            Next j
            
            '
            ' If norm(C) < SMINI, use SMINI*identity.
            '
            If CMAX < SMINI Then
                BNorm = MaxReal(Abs(B(1#, 1#)) + Abs(B(1#, 2#)), Abs(B(2#, 1#)) + Abs(B(2#, 2#)))
                If SMINI < 1# And BNorm > 1# Then
                    If BNorm > BIGNUM * SMINI Then
                        SCL = 1# / BNorm
                    End If
                End If
                temp = SCL / SMINI
                x(1#, 1#) = temp * B(1#, 1#)
                x(2#, 1#) = temp * B(2#, 1#)
                x(1#, 2#) = temp * B(1#, 2#)
                x(2#, 2#) = temp * B(2#, 2#)
                XNorm = temp * BNorm
                Info = 1#
                Exit Sub
            End If
            
            '
            ' Gaussian elimination with complete pivoting.
            '
            UR11 = CRV4(ICMAX)
            UI11 = CIV4(ICMAX)
            CR21 = CRV4(IPIVOT44(2#, ICMAX))
            CI21 = CIV4(IPIVOT44(2#, ICMAX))
            UR12 = CRV4(IPIVOT44(3#, ICMAX))
            UI12 = CIV4(IPIVOT44(3#, ICMAX))
            CR22 = CRV4(IPIVOT44(4#, ICMAX))
            CI22 = CIV4(IPIVOT44(4#, ICMAX))
            If ICMAX = 1# Or ICMAX = 4# Then
                
                '
                ' Code when off-diagonals of pivoted C are real
                '
                If Abs(UR11) > Abs(UI11) Then
                    temp = UI11 / UR11
                    UR11R = 1# / (UR11 * (1# + Square(temp)))
                    UI11R = -(temp * UR11R)
                Else
                    temp = UR11 / UI11
                    UI11R = -(1# / (UI11 * (1# + Square(temp))))
                    UR11R = -(temp * UI11R)
                End If
                LR21 = CR21 * UR11R
                LI21 = CR21 * UI11R
                UR12S = UR12 * UR11R
                UI12S = UR12 * UI11R
                UR22 = CR22 - UR12 * LR21
                UI22 = CI22 - UR12 * LI21
            Else
                
                '
                ' Code when diagonals of pivoted C are real
                '
                UR11R = 1# / UR11
                UI11R = 0#
                LR21 = CR21 * UR11R
                LI21 = CI21 * UR11R
                UR12S = UR12 * UR11R
                UI12S = UI12 * UR11R
                UR22 = CR22 - UR12 * LR21 + UI12 * LI21
                UI22 = -(UR12 * LI21) - UI12 * LR21
            End If
            U22ABS = Abs(UR22) + Abs(UI22)
            
            '
            ' If smaller pivot < SMINI, use SMINI
            '
            If U22ABS < SMINI Then
                UR22 = SMINI
                UI22 = 0#
                Info = 1#
            End If
            If RSWAP4(ICMAX) Then
                BR2 = B(1#, 1#)
                BR1 = B(2#, 1#)
                BI2 = B(1#, 2#)
                BI1 = B(2#, 2#)
            Else
                BR1 = B(1#, 1#)
                BR2 = B(2#, 1#)
                BI1 = B(1#, 2#)
                BI2 = B(2#, 2#)
            End If
            BR2 = BR2 - LR21 * BR1 + LI21 * BI1
            BI2 = BI2 - LI21 * BR1 - LR21 * BI1
            BBND = MaxReal((Abs(BR1) + Abs(BI1)) * (U22ABS * (Abs(UR11R) + Abs(UI11R))), Abs(BR2) + Abs(BI2))
            If BBND > 1# And U22ABS < 1# Then
                If BBND >= BIGNUM * U22ABS Then
                    SCL = 1# / BBND
                    BR1 = SCL * BR1
                    BI1 = SCL * BI1
                    BR2 = SCL * BR2
                    BI2 = SCL * BI2
                End If
            End If
            Call InternalHSEVDLADIV(BR2, BI2, UR22, UI22, XR2, XI2)
            XR1 = UR11R * BR1 - UI11R * BI1 - UR12S * XR2 + UI12S * XI2
            XI1 = UI11R * BR1 + UR11R * BI1 - UI12S * XR2 - UR12S * XI2
            If ZSWAP4(ICMAX) Then
                x(1#, 1#) = XR2
                x(2#, 1#) = XR1
                x(1#, 2#) = XI2
                x(2#, 2#) = XI1
            Else
                x(1#, 1#) = XR1
                x(2#, 1#) = XR2
                x(1#, 2#) = XI1
                x(2#, 2#) = XI2
            End If
            XNorm = MaxReal(Abs(XR1) + Abs(XI1), Abs(XR2) + Abs(XI2))
            
            '
            ' Further scaling if  norm(A) norm(X) > overflow
            '
            If XNorm > 1# And CMAX > 1# Then
                If XNorm > BIGNUM / CMAX Then
                    temp = CMAX / BIGNUM
                    x(1#, 1#) = temp * x(1#, 1#)
                    x(2#, 1#) = temp * x(2#, 1#)
                    x(1#, 2#) = temp * x(1#, 2#)
                    x(2#, 2#) = temp * x(2#, 2#)
                    XNorm = temp * XNorm
                    SCL = temp * SCL
                End If
            End If
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'performs complex division in  real arithmetic
'
'                        a + i*b
'             p + i*q = ---------
'                        c + i*d
'
'The algorithm is due to Robert L. Smith and can be found
'in D. Knuth, The art of Computer Programming, Vol.2, p.195
'
'  -- LAPACK auxiliary routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     October 31, 1992
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub InternalHSEVDLADIV(ByRef a As Double, _
         ByRef B As Double, _
         ByRef C As Double, _
         ByRef d As Double, _
         ByRef p As Double, _
         ByRef q As Double)
    Dim e As Double
    Dim f As Double
    If Abs(d) < Abs(C) Then
        e = d / C
        f = C + d * e
        p = (a + B * e) / f
        q = (B - a * e) / f
    Else
        e = C / d
        f = d + C * e
        p = (B + a * e) / f
        q = (-a + B * e) / f
    End If
End Sub
Private Function NonSymmetricEVD(ByRef A_() As Double, _
         ByVal N As Long, _
         ByVal VNeeded As Long, _
         ByRef WR() As Double, _
         ByRef WI() As Double, _
         ByRef VL() As Double, _
         ByRef VR() As Double) As Boolean
    Dim Result As Boolean
    Dim a() As Double
    Dim s() As Double
    Dim Tau() As Double
    Dim SEL() As Boolean
    Dim i As Long
    Dim Info As Long
    Dim M As Long
    Dim i_ As Long
    a = A_
    If VNeeded = 0# Then
        
        '
        ' Eigen values only
        '
        Call ToUpperHessenberg(a, N, Tau)
        Call InternalSchurDecomposition(a, N, 0#, 0#, WR, WI, s, Info)
        Result = Info = 0#
        NonSymmetricEVD = Result
        Exit Function
    End If
    
    '
    ' Eigen values and vectors
    '
    Call ToUpperHessenberg(a, N, Tau)
    Call UnpackQFromUpperHessenberg(a, N, Tau, s)
    Call InternalSchurDecomposition(a, N, 1#, 1#, WR, WI, s, Info)
    Result = Info = 0#
    If Not Result Then
        NonSymmetricEVD = Result
        Exit Function
    End If
    If VNeeded = 1# Or VNeeded = 3# Then
        ReDim VR(1# To N, 1# To N)
        For i = 1# To N Step 1
            For i_ = 1# To N Step 1
                VR(i, i_) = s(i, i_)
            Next i_
        Next i
    End If
    If VNeeded = 2# Or VNeeded = 3# Then
        ReDim VL(1# To N, 1# To N)
        For i = 1# To N Step 1
            For i_ = 1# To N Step 1
                VL(i, i_) = s(i, i_)
            Next i_
        Next i
    End If
    Call InternalTREVC(a, N, VNeeded, 1#, SEL, VL, VR, M, Info)
    Result = Info = 0#
    NonSymmetricEVD = Result
End Function
Private Sub ToUpperHessenberg(ByRef a() As Double, _
         ByVal N As Long, _
         ByRef Tau() As Double)
    Dim i As Long
    Dim IP1 As Long
    Dim NMI As Long
    Dim V As Double
    Dim t() As Double
    Dim WORK() As Double
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' Quick return if possible
    '
    If N <= 1# Then
        Exit Sub
    End If
    ReDim Tau(1# To N - 1#)
    ReDim t(1# To N)
    ReDim WORK(1# To N)
    For i = 1# To N - 1# Step 1
        
        '
        ' Compute elementary reflector H(i) to annihilate A(i+2:ihi,i)
        '
        IP1 = i + 1#
        NMI = N - i
        i1_ = (IP1) - (1#)
        For i_ = 1# To NMI Step 1
            t(i_) = a(i_ + i1_, i)
        Next i_
        Call GenerateReflection(t, NMI, V)
        i1_ = (1#) - (IP1)
        For i_ = IP1 To N Step 1
            a(i_, i) = t(i_ + i1_)
        Next i_
        Tau(i) = V
        t(1#) = 1#
        
        '
        ' Apply H(i) to A(1:ihi,i+1:ihi) from the right
        '
        Call ApplyReflectionFromTheRight(a, V, t, 1#, N, i + 1#, N, WORK)
        
        '
        ' Apply H(i) to A(i+1:ihi,i+1:n) from the left
        '
        Call ApplyReflectionFromTheLeft(a, V, t, i + 1#, N, i + 1#, N, WORK)
    Next i
End Sub
Private Sub UnpackQFromUpperHessenberg(ByRef a() As Double, _
         ByVal N As Long, _
         ByRef Tau() As Double, _
         ByRef q() As Double)
    Dim i As Long
    Dim j As Long
    Dim V() As Double
    Dim WORK() As Double
    Dim IP1 As Long
    Dim NMI As Long
    Dim i_ As Long
    Dim i1_ As Long
    If N = 0# Then
        Exit Sub
    End If
    
    '
    ' init
    '
    ReDim q(1# To N, 1# To N)
    ReDim V(1# To N)
    ReDim WORK(1# To N)
    For i = 1# To N Step 1
        For j = 1# To N Step 1
            If i = j Then
                q(i, j) = 1#
            Else
                q(i, j) = 0#
            End If
        Next j
    Next i
    
    '
    ' unpack Q
    '
    For i = 1# To N - 1# Step 1
        
        '
        ' Apply H(i)
        '
        IP1 = i + 1#
        NMI = N - i
        i1_ = (IP1) - (1#)
        For i_ = 1# To NMI Step 1
            V(i_) = a(i_ + i1_, i)
        Next i_
        V(1#) = 1#
        Call ApplyReflectionFromTheRight(q, Tau(i), V, 1#, N, i + 1#, N, WORK)
    Next i
End Sub
Private Sub UnpackHFromUpperHessenberg(ByRef a() As Double, _
         ByVal N As Long, _
         ByRef Tau() As Double, _
         ByRef h() As Double)
    Dim i As Long
    Dim j As Long
    Dim V() As Double
    Dim WORK() As Double
    Dim i_ As Long
    If N = 0# Then
        Exit Sub
    End If
    ReDim h(1# To N, 1# To N)
    For i = 1# To N Step 1
        For j = 1# To i - 2# Step 1
            h(i, j) = 0#
        Next j
        j = MaxInt(1#, i - 1#)
        For i_ = j To N Step 1
            h(i, i_) = a(i, i_)
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 1992-2007 The University of Tennessee.  All rights reserved.
'
'Contributors:
'    * Sergey Bochkanov (ALGLIB project). Translation from FORTRAN to
'      pseudocode.
'
'See subroutines comments for additional copyrights.
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Subroutine performing  the  Schur  decomposition  of  a  matrix  in  upper
'Hessenberg form using the QR algorithm with multiple shifts.
'
'The  source matrix  H  is  represented as  S'*H*S = T, where H - matrix in
'upper Hessenberg form,  S - orthogonal matrix (Schur vectors),   T - upper
'quasi-triangular matrix (with blocks of sizes  1x1  and  2x2  on  the main
'diagonal).
'
'Input parameters:
'    H   -   matrix to be decomposed.
'            Array whose indexes range within [1..N, 1..N].
'    N   -   size of H, N>=0.
'
'
'Output parameters:
'    H      contains the matrix T.
'            Array whose indexes range within [1..N, 1..N].
'            All elements below the blocks on the main diagonal are equal
'            to 0.
'    S   -   contains Schur vectors.
'            Array whose indexes range within [1..N, 1..N].
'
'Note 1:
'    The block structure of matrix T could be easily recognized: since  all
'    the elements  below  the blocks are zeros, the elements a[i+1,i] which
'    are equal to 0 show the block border.
'
'Note 2:
'    the algorithm  performance  depends  on  the  value  of  the  internal
'    parameter NS of InternalSchurDecomposition  subroutine  which  defines
'    the number of shifts in the QR algorithm (analog of  the  block  width
'    in block matrix algorithms in linear algebra). If you require  maximum
'    performance  on  your  machine,  it  is  recommended  to  adjust  this
'    parameter manually.
'
'Result:
'    True, if the algorithm has converged and the parameters H and S contain
'        the result.
'    False, if the algorithm has not converged.
'
'Algorithm implemented on the basis of subroutine DHSEQR (LAPACK 3.0 library).
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function UpperHessenbergSchurDecomposition(ByRef h() As Double, _
         ByVal N As Long, _
         ByRef s() As Double) As Boolean
    Dim Result As Boolean
    Dim WI() As Double
    Dim WR() As Double
    Dim Info As Long
    Call InternalSchurDecomposition(h, N, 1#, 2#, WR, WI, s, Info)
    Result = Info = 0#
    UpperHessenbergSchurDecomposition = Result
End Function
Public Sub InternalSchurDecomposition(ByRef h() As Double, _
         ByVal N As Long, _
         ByVal TNeeded As Long, _
         ByVal ZNeeded As Long, _
         ByRef WR() As Double, _
         ByRef WI() As Double, _
         ByRef z() As Double, _
         ByRef Info As Long)
    Dim WORK() As Double
    Dim i As Long
    Dim I1 As Long
    Dim I2 As Long
    Dim IERR As Long
    Dim II As Long
    Dim ITEMP As Long
    Dim ITN As Long
    Dim ITS As Long
    Dim j As Long
    Dim K As Long
    Dim L As Long
    Dim MAXB As Long
    Dim NR As Long
    Dim NS As Long
    Dim nv As Long
    Dim ABSW As Double
    Dim OVFL As Double
    Dim SMLNUM As Double
    Dim Tau As Double
    Dim temp As Double
    Dim TST1 As Double
    Dim Ulp As Double
    Dim UNFL As Double
    Dim s() As Double
    Dim V() As Double
    Dim VV() As Double
    Dim WORKC1() As Double
    Dim WORKS1() As Double
    Dim WORKV3() As Double
    Dim TmpWR() As Double
    Dim TmpWI() As Double
    Dim INITZ As Boolean
    Dim WANTT As Boolean
    Dim WANTZ As Boolean
    Dim CNST As Double
    Dim FailFlag As Boolean
    Dim p1 As Long
    Dim p2 As Long
    Dim VT As Double
    Dim i_ As Long
    Dim i1_ As Long
    '
    ' Set the order of the multi-shift QR algorithm to be used.
    ' If you want to tune algorithm, change this values
    '
    NS = 12#
    MAXB = 50#
    '
    ' Now 2 < NS <= MAXB < NH.
    '
    MAXB = MaxInt(3#, MAXB)
    NS = MinInt(MAXB, NS)
    '
    ' Initialize
    '
    CNST = 1.5
    ReDim WORK(1# To MaxInt(N, 1#))
    ReDim s(1# To NS, 1# To NS)
    ReDim V(1# To NS + 1#)
    ReDim VV(1# To NS + 1#)
    ReDim WR(1# To MaxInt(N, 1#))
    ReDim WI(1# To MaxInt(N, 1#))
    ReDim WORKC1(1# To 1#)
    ReDim WORKS1(1# To 1#)
    ReDim WORKV3(1# To 3#)
    ReDim TmpWR(1# To MaxInt(N, 1#))
    ReDim TmpWI(1# To MaxInt(N, 1#))
    WANTT = TNeeded = 1#
    INITZ = ZNeeded = 2#
    WANTZ = ZNeeded <> 0#
    Info = 0#
    '
    ' Initialize Z, if necessary
    '
    If INITZ Then
        ReDim z(1# To N, 1# To N)
        For i = 1# To N Step 1
            For j = 1# To N Step 1
                If i = j Then
                    z(i, j) = 1#
                Else
                    z(i, j) = 0#
                End If
            Next j
        Next i
    End If
    '
    ' Quick return if possible
    '
    If N = 0# Then
        Exit Sub
    End If
    If N = 1# Then
        WR(1#) = h(1#, 1#)
        WI(1#) = 0#
        Exit Sub
    End If
    '
    ' Set rows and columns 1 to N to zero below the first
    ' subdiagonal.
    '
    For j = 1# To N - 2# Step 1
        For i = j + 2# To N Step 1
            h(i, j) = 0#
        Next i
    Next j
    '
    ' Test if N is sufficiently small
    '
    If NS <= 2# Or NS > N Or MAXB >= N Then
        '
        ' Use the standard double-shift algorithm
        '
        Call InternalAuxSchur(WANTT, WANTZ, N, 1#, N, h, WR, WI, 1#, N, z, WORK, WORKV3, WORKC1, WORKS1, Info)
        '
        ' fill entries under diagonal blocks of T with zeros
        '
        If WANTT Then
            j = 1#
            Do While j <= N
                If WI(j) = 0# Then
                    For i = j + 1# To N Step 1
                        h(i, j) = 0#
                    Next i
                    j = j + 1#
                Else
                    For i = j + 2# To N Step 1
                        h(i, j) = 0#
                        h(i, j + 1#) = 0#
                    Next i
                    j = j + 2#
                End If
            Loop
        End If
        Exit Sub
    End If
    UNFL = MinRealNumber
    OVFL = 1# / UNFL
    Ulp = 2# * MachineEpsilon
    SMLNUM = UNFL * (N / Ulp)
    '
    ' I1 and I2 are the indices of the first row and last column of H
    ' to which transformations must be applied. If eigenvalues only are
    ' being computed, I1 and I2 are set inside the main loop.
    '
    I1 = 1#
    I2 = N
    '
    ' ITN is the total number of multiple-shift QR iterations allowed.
    '
    ITN = 30# * N
    '
    ' The main loop begins here. I is the loop index and decreases from
    ' IHI to ILO in steps of at most MAXB. Each iteration of the loop
    ' works with the active submatrix in rows and columns L to I.
    ' Eigenvalues I+1 to IHI have already converged. Either L = ILO or
    ' H(L,L-1) is negligible so that the matrix splits.
    '
    i = N
    Do While True
        L = 1#
        If i < 1# Then
            '
            ' fill entries under diagonal blocks of T with zeros
            '
            If WANTT Then
                j = 1#
                Do While j <= N
                    If WI(j) = 0# Then
                        For i = j + 1# To N Step 1
                            h(i, j) = 0#
                        Next i
                        j = j + 1#
                    Else
                        For i = j + 2# To N Step 1
                            h(i, j) = 0#
                            h(i, j + 1#) = 0#
                        Next i
                        j = j + 2#
                    End If
                Loop
            End If
            '
            ' Exit
            '
            Exit Sub
        End If
        '
        ' Perform multiple-shift QR iterations on rows and columns ILO to I
        ' until a submatrix of order at most MAXB splits off at the bottom
        ' because a subdiagonal element has become negligible.
        '
        FailFlag = True
        For ITS = 0# To ITN Step 1
            '
            ' Look for a single small subdiagonal element.
            '
            For K = i To L + 1# Step -1
                TST1 = Abs(h(K - 1#, K - 1#)) + Abs(h(K, K))
                If TST1 = 0# Then
                    TST1 = UpperHessenberg1Norm(h, L, i, L, i, WORK)
                End If
                If Abs(h(K, K - 1#)) <= MaxReal(Ulp * TST1, SMLNUM) Then
                    Exit For
                End If
            Next K
            L = K
            If L > 1# Then
                '
                ' H(L,L-1) is negligible.
                '
                h(L, L - 1#) = 0#
            End If
            '
            ' Exit from loop if a submatrix of order <= MAXB has split off.
            '
            If L >= i - MAXB + 1# Then
                FailFlag = False
                Exit For
            End If
            '
            ' Now the active submatrix is in rows and columns L to I. If
            ' eigenvalues only are being computed, only the active submatrix
            ' need be transformed.
            '
            If ITS = 20# Or ITS = 30# Then
                '
                ' Exceptional shifts.
                '
                For II = i - NS + 1# To i Step 1
                    WR(II) = CNST * (Abs(h(II, II - 1#)) + Abs(h(II, II)))
                    WI(II) = 0#
                Next II
            Else
                '
                ' Use eigenvalues of trailing submatrix of order NS as shifts.
                '
                Call CopyMatrix(h, i - NS + 1#, i, i - NS + 1#, i, s, 1#, NS, 1#, NS)
                Call InternalAuxSchur(False, False, NS, 1#, NS, s, TmpWR, TmpWI, 1#, NS, z, WORK, WORKV3, WORKC1, WORKS1, IERR)
                For p1 = 1# To NS Step 1
                    WR(i - NS + p1) = TmpWR(p1)
                    WI(i - NS + p1) = TmpWI(p1)
                Next p1
                If IERR > 0# Then
                    '
                    ' If DLAHQR failed to compute all NS eigenvalues, use the
                    ' unconverged diagonal elements as the remaining shifts.
                    '
                    For II = 1# To IERR Step 1
                        WR(i - NS + II) = s(II, II)
                        WI(i - NS + II) = 0#
                    Next II
                End If
            End If
            '
            ' Form the first column of (G-w(1)) (G-w(2)) . . . (G-w(ns))
            ' where G is the Hessenberg submatrix H(L:I,L:I) and w is
            ' the vector of shifts (stored in WR and WI). The result is
            ' stored in the local array V.
            '
            V(1#) = 1#
            For II = 2# To NS + 1# Step 1
                V(II) = 0#
            Next II
            nv = 1#
            For j = i - NS + 1# To i Step 1
                If WI(j) >= 0# Then
                    If WI(j) = 0# Then
                        '
                        ' real shift
                        '
                        p1 = nv + 1#
                        For i_ = 1# To p1 Step 1
                            VV(i_) = V(i_)
                        Next i_
                        Call MatrixVectorMultiply(h, L, L + nv, L, L + nv - 1#, False, VV, 1#, nv, 1#, V, 1#, nv + 1#, -WR(j))
                        nv = nv + 1#
                    Else
                        If WI(j) > 0# Then
                            '
                            ' complex conjugate pair of shifts
                            '
                            p1 = nv + 1#
                            For i_ = 1# To p1 Step 1
                                VV(i_) = V(i_)
                            Next i_
                            Call MatrixVectorMultiply(h, L, L + nv, L, L + nv - 1#, False, V, 1#, nv, 1#, VV, 1#, nv + 1#, -(2# * WR(j)))
                            ITEMP = VectorIdxAbsMax(VV, 1#, nv + 1#)
                            temp = 1# / MaxReal(Abs(VV(ITEMP)), SMLNUM)
                            p1 = nv + 1#
                            For i_ = 1# To p1 Step 1
                                VV(i_) = temp * VV(i_)
                            Next i_
                            ABSW = Pythag2(WR(j), WI(j))
                            temp = temp * ABSW * ABSW
                            Call MatrixVectorMultiply(h, L, L + nv + 1#, L, L + nv, False, VV, 1#, nv + 1#, 1#, V, 1#, nv + 2#, temp)
                            nv = nv + 2#
                        End If
                    End If
                    '
                    ' Scale V(1:NV) so that max(abs(V(i))) = 1. If V is zero,
                    ' reset it to the unit vector.
                    '
                    ITEMP = VectorIdxAbsMax(V, 1#, nv)
                    temp = Abs(V(ITEMP))
                    If temp = 0# Then
                        V(1#) = 1#
                        For II = 2# To nv Step 1
                            V(II) = 0#
                        Next II
                    Else
                        temp = MaxReal(temp, SMLNUM)
                        VT = 1# / temp
                        For i_ = 1# To nv Step 1
                            V(i_) = VT * V(i_)
                        Next i_
                    End If
                End If
            Next j
            '
            ' Multiple-shift QR step
            '
            For K = L To i - 1# Step 1
                '
                ' The first iteration of this loop determines a reflection G
                ' from the vector V and applies it from left and right to H,
                ' thus creating a nonzero bulge below the subdiagonal.
                '
                ' Each subsequent iteration determines a reflection G to
                ' restore the Hessenberg form in the (K-1)th column, and thus
                ' chases the bulge one step toward the bottom of the active
                ' submatrix. NR is the order of G.
                '
                NR = MinInt(NS + 1#, i - K + 1#)
                If K > L Then
                    p1 = K - 1#
                    p2 = K + NR - 1#
                    i1_ = (K) - (1#)
                    For i_ = 1# To NR Step 1
                        V(i_) = h(i_ + i1_, p1)
                    Next i_
                End If
                Call GenerateReflection(V, NR, Tau)
                If K > L Then
                    h(K, K - 1#) = V(1#)
                    For II = K + 1# To i Step 1
                        h(II, K - 1#) = 0#
                    Next II
                End If
                V(1#) = 1#
                '
                ' Apply G from the left to transform the rows of the matrix in
                ' columns K to I2.
                '
                Call ApplyReflectionFromTheLeft(h, Tau, V, K, K + NR - 1#, K, I2, WORK)
                '
                ' Apply G from the right to transform the columns of the
                ' matrix in rows I1 to min(K+NR,I).
                '
                Call ApplyReflectionFromTheRight(h, Tau, V, I1, MinInt(K + NR, i), K, K + NR - 1#, WORK)
                If WANTZ Then
                    '
                    ' Accumulate transformations in the matrix Z
                    '
                    Call ApplyReflectionFromTheRight(z, Tau, V, 1#, N, K, K + NR - 1#, WORK)
                End If
            Next K
        Next ITS
        '
        ' Failure to converge in remaining number of iterations
        '
        If FailFlag Then
            Info = i
            Exit Sub
        End If
        '
        ' A submatrix of order <= MAXB in rows and columns L to I has split
        ' off. Use the double-shift QR algorithm to handle it.
        '
        Call InternalAuxSchur(WANTT, WANTZ, N, L, i, h, WR, WI, 1#, N, z, WORK, WORKV3, WORKC1, WORKS1, Info)
        If Info > 0# Then
            Exit Sub
        End If
        '
        ' Decrement number of remaining iterations, and return to start of
        ' the main loop with a new value of I.
        '
        ITN = ITN - ITS
        i = L - 1#
    Loop
End Sub
Private Sub InternalAuxSchur(ByVal WANTT As Boolean, _
         ByVal WANTZ As Boolean, _
         ByVal N As Long, _
         ByVal ILO As Long, _
         ByVal IHI As Long, _
         ByRef h() As Double, _
         ByRef WR() As Double, _
         ByRef WI() As Double, _
         ByVal ILOZ As Long, _
         ByVal IHIZ As Long, _
         ByRef z() As Double, _
         ByRef WORK() As Double, _
         ByRef WORKV3() As Double, _
         ByRef WORKC1() As Double, _
         ByRef WORKS1() As Double, _
         ByRef Info As Long)
    Dim i As Long
    Dim I1 As Long
    Dim I2 As Long
    Dim ITN As Long
    Dim ITS As Long
    Dim j As Long
    Dim K As Long
    Dim L As Long
    Dim M As Long
    Dim NH As Long
    Dim NR As Long
    Dim nz As Long
    Dim AVE As Double
    Dim cs As Double
    Dim DISC As Double
    Dim H00 As Double
    Dim H10 As Double
    Dim H11 As Double
    Dim H12 As Double
    Dim H21 As Double
    Dim H22 As Double
    Dim H33 As Double
    Dim H33S As Double
    Dim H43H34 As Double
    Dim H44 As Double
    Dim H44S As Double
    Dim OVFL As Double
    Dim s As Double
    Dim SMLNUM As Double
    Dim SN As Double
    Dim SUM As Double
    Dim T1 As Double
    Dim T2 As Double
    Dim T3 As Double
    Dim TST1 As Double
    Dim UNFL As Double
    Dim V1 As Double
    Dim V2 As Double
    Dim V3 As Double
    Dim FailFlag As Boolean
    Dim DAT1 As Double
    Dim DAT2 As Double
    Dim p1 As Long
    Dim HIM1IM1 As Double
    Dim HIM1I As Double
    Dim HIIM1 As Double
    Dim HII As Double
    Dim WRIM1 As Double
    Dim WRI As Double
    Dim WIIM1 As Double
    Dim WII As Double
    Dim Ulp As Double
    Info = 0#
    DAT1 = 0.75
    DAT2 = -0.4375
    Ulp = MachineEpsilon
    '
    ' Quick return if possible
    '
    If N = 0# Then
        Exit Sub
    End If
    If ILO = IHI Then
        WR(ILO) = h(ILO, ILO)
        WI(ILO) = 0#
        Exit Sub
    End If
    NH = IHI - ILO + 1#
    nz = IHIZ - ILOZ + 1#
    '
    ' Set machine-dependent constants for the stopping criterion.
    ' If norm(H) <= sqrt(OVFL), overflow should not occur.
    '
    UNFL = MinRealNumber
    OVFL = 1# / UNFL
    SMLNUM = UNFL * (NH / Ulp)
    '
    ' I1 and I2 are the indices of the first row and last column of H
    ' to which transformations must be applied. If eigenvalues only are
    ' being computed, I1 and I2 are set inside the main loop.
    '
    I1 = 1#
    I2 = N
    '
    ' ITN is the total number of QR iterations allowed.
    '
    ITN = 30# * NH
    '
    ' The main loop begins here. I is the loop index and decreases from
    ' IHI to ILO in steps of 1 or 2. Each iteration of the loop works
    ' with the active submatrix in rows and columns L to I.
    ' Eigenvalues I+1 to IHI have already converged. Either L = ILO or
    ' H(L,L-1) is negligible so that the matrix splits.
    '
    i = IHI
    Do While True
        L = ILO
        If i < ILO Then
            Exit Sub
        End If
        '
        ' Perform QR iterations on rows and columns ILO to I until a
        ' submatrix of order 1 or 2 splits off at the bottom because a
        ' subdiagonal element has become negligible.
        '
        FailFlag = True
        For ITS = 0# To ITN Step 1
            '
            ' Look for a single small subdiagonal element.
            '
            For K = i To L + 1# Step -1
                TST1 = Abs(h(K - 1#, K - 1#)) + Abs(h(K, K))
                If TST1 = 0# Then
                    TST1 = UpperHessenberg1Norm(h, L, i, L, i, WORK)
                End If
                If Abs(h(K, K - 1#)) <= MaxReal(Ulp * TST1, SMLNUM) Then
                    Exit For
                End If
            Next K
            L = K
            If L > ILO Then
                '
                ' H(L,L-1) is negligible
                '
                h(L, L - 1#) = 0#
            End If
            '
            ' Exit from loop if a submatrix of order 1 or 2 has split off.
            '
            If L >= i - 1# Then
                FailFlag = False
                Exit For
            End If
            '
            ' Now the active submatrix is in rows and columns L to I. If
            ' eigenvalues only are being computed, only the active submatrix
            ' need be transformed.
            '
            If ITS = 10# Or ITS = 20# Then
                '
                ' Exceptional shift.
                '
                s = Abs(h(i, i - 1#)) + Abs(h(i - 1#, i - 2#))
                H44 = DAT1 * s + h(i, i)
                H33 = H44
                H43H34 = DAT2 * s * s
            Else
                '
                ' Prepare to use Francis' double shift
                ' (i.e. 2nd degree generalized Rayleigh quotient)
                '
                H44 = h(i, i)
                H33 = h(i - 1#, i - 1#)
                H43H34 = h(i, i - 1#) * h(i - 1#, i)
                s = h(i - 1#, i - 2#) * h(i - 1#, i - 2#)
                DISC = (H33 - H44) * 0.5
                DISC = DISC * DISC + H43H34
                If DISC > 0# Then
                    '
                    ' Real roots: use Wilkinson's shift twice
                    '
                    DISC = Sqr(DISC)
                    AVE = 0.5 * (H33 + H44)
                    If Abs(H33) - Abs(H44) > 0# Then
                        H33 = H33 * H44 - H43H34
                        H44 = H33 / (ExtSchurSign(DISC, AVE) + AVE)
                    Else
                        H44 = ExtSchurSign(DISC, AVE) + AVE
                    End If
                    H33 = H44
                    H43H34 = 0#
                End If
            End If
            '
            ' Look for two consecutive small subdiagonal elements.
            '
            For M = i - 2# To L Step -1
                '
                ' Determine the effect of starting the double-shift QR
                ' iteration at row M, and see if this would make H(M,M-1)
                ' negligible.
                '
                H11 = h(M, M)
                H22 = h(M + 1#, M + 1#)
                H21 = h(M + 1#, M)
                H12 = h(M, M + 1#)
                H44S = H44 - H11
                H33S = H33 - H11
                V1 = (H33S * H44S - H43H34) / H21 + H12
                V2 = H22 - H11 - H33S - H44S
                V3 = h(M + 2#, M + 1#)
                s = Abs(V1) + Abs(V2) + Abs(V3)
                V1 = V1 / s
                V2 = V2 / s
                V3 = V3 / s
                WORKV3(1#) = V1
                WORKV3(2#) = V2
                WORKV3(3#) = V3
                If M = L Then
                    Exit For
                End If
                H00 = h(M - 1#, M - 1#)
                H10 = h(M, M - 1#)
                TST1 = Abs(V1) * (Abs(H00) + Abs(H11) + Abs(H22))
                If Abs(H10) * (Abs(V2) + Abs(V3)) <= Ulp * TST1 Then
                    Exit For
                End If
            Next M
            '
            ' Double-shift QR step
            '
            For K = M To i - 1# Step 1
                '
                ' The first iteration of this loop determines a reflection G
                ' from the vector V and applies it from left and right to H,
                ' thus creating a nonzero bulge below the subdiagonal.
                '
                ' Each subsequent iteration determines a reflection G to
                ' restore the Hessenberg form in the (K-1)th column, and thus
                ' chases the bulge one step toward the bottom of the active
                ' submatrix. NR is the order of G.
                '
                NR = MinInt(3#, i - K + 1#)
                If K > M Then
                    For p1 = 1# To NR Step 1
                        WORKV3(p1) = h(K + p1 - 1#, K - 1#)
                    Next p1
                End If
                Call GenerateReflection(WORKV3, NR, T1)
                If K > M Then
                    h(K, K - 1#) = WORKV3(1#)
                    h(K + 1#, K - 1#) = 0#
                    If K < i - 1# Then
                        h(K + 2#, K - 1#) = 0#
                    End If
                Else
                    If M > L Then
                        h(K, K - 1#) = -h(K, K - 1#)
                    End If
                End If
                V2 = WORKV3(2#)
                T2 = T1 * V2
                If NR = 3# Then
                    V3 = WORKV3(3#)
                    T3 = T1 * V3
                    '
                    ' Apply G from the left to transform the rows of the matrix
                    ' in columns K to I2.
                    '
                    For j = K To I2 Step 1
                        SUM = h(K, j) + V2 * h(K + 1#, j) + V3 * h(K + 2#, j)
                        h(K, j) = h(K, j) - SUM * T1
                        h(K + 1#, j) = h(K + 1#, j) - SUM * T2
                        h(K + 2#, j) = h(K + 2#, j) - SUM * T3
                    Next j
                    '
                    ' Apply G from the right to transform the columns of the
                    ' matrix in rows I1 to min(K+3,I).
                    '
                    For j = I1 To MinInt(K + 3#, i) Step 1
                        SUM = h(j, K) + V2 * h(j, K + 1#) + V3 * h(j, K + 2#)
                        h(j, K) = h(j, K) - SUM * T1
                        h(j, K + 1#) = h(j, K + 1#) - SUM * T2
                        h(j, K + 2#) = h(j, K + 2#) - SUM * T3
                    Next j
                    If WANTZ Then
                        '
                        ' Accumulate transformations in the matrix Z
                        '
                        For j = ILOZ To IHIZ Step 1
                            SUM = z(j, K) + V2 * z(j, K + 1#) + V3 * z(j, K + 2#)
                            z(j, K) = z(j, K) - SUM * T1
                            z(j, K + 1#) = z(j, K + 1#) - SUM * T2
                            z(j, K + 2#) = z(j, K + 2#) - SUM * T3
                        Next j
                    End If
                Else
                    If NR = 2# Then
                        '
                        ' Apply G from the left to transform the rows of the matrix
                        ' in columns K to I2.
                        '
                        For j = K To I2 Step 1
                            SUM = h(K, j) + V2 * h(K + 1#, j)
                            h(K, j) = h(K, j) - SUM * T1
                            h(K + 1#, j) = h(K + 1#, j) - SUM * T2
                        Next j
                        '
                        ' Apply G from the right to transform the columns of the
                        ' matrix in rows I1 to min(K+3,I).
                        '
                        For j = I1 To i Step 1
                            SUM = h(j, K) + V2 * h(j, K + 1#)
                            h(j, K) = h(j, K) - SUM * T1
                            h(j, K + 1#) = h(j, K + 1#) - SUM * T2
                        Next j
                        If WANTZ Then
                            '
                            ' Accumulate transformations in the matrix Z
                            '
                            For j = ILOZ To IHIZ Step 1
                                SUM = z(j, K) + V2 * z(j, K + 1#)
                                z(j, K) = z(j, K) - SUM * T1
                                z(j, K + 1#) = z(j, K + 1#) - SUM * T2
                            Next j
                        End If
                    End If
                End If
            Next K
        Next ITS
        If FailFlag Then
            '
            ' Failure to converge in remaining number of iterations
            '
            Info = i
            Exit Sub
        End If
        If L = i Then
            '
            ' H(I,I-1) is negligible: one eigenvalue has converged.
            '
            WR(i) = h(i, i)
            WI(i) = 0#
        Else
            If L = i - 1# Then
                '
                ' H(I-1,I-2) is negligible: a pair of eigenvalues have converged.
                '
                '        Transform the 2-by-2 submatrix to standard Schur form,
                '        and compute and store the eigenvalues.
                '
                HIM1IM1 = h(i - 1#, i - 1#)
                HIM1I = h(i - 1#, i)
                HIIM1 = h(i, i - 1#)
                HII = h(i, i)
                Call Aux2X2Schur(HIM1IM1, HIM1I, HIIM1, HII, WRIM1, WIIM1, WRI, WII, cs, SN)
                WR(i - 1#) = WRIM1
                WI(i - 1#) = WIIM1
                WR(i) = WRI
                WI(i) = WII
                h(i - 1#, i - 1#) = HIM1IM1
                h(i - 1#, i) = HIM1I
                h(i, i - 1#) = HIIM1
                h(i, i) = HII
                If WANTT Then
                    '
                    ' Apply the transformation to the rest of H.
                    '
                    If I2 > i Then
                        WORKC1(1#) = cs
                        WORKS1(1#) = SN
                        Call ApplyRotationsFromTheLeft(True, i - 1#, i, i + 1#, I2, WORKC1, WORKS1, h, WORK)
                    End If
                    WORKC1(1#) = cs
                    WORKS1(1#) = SN
                    Call ApplyRotationsFromTheRight(True, I1, i - 2#, i - 1#, i, WORKC1, WORKS1, h, WORK)
                End If
                If WANTZ Then
                    '
                    ' Apply the transformation to Z.
                    '
                    WORKC1(1#) = cs
                    WORKS1(1#) = SN
                    Call ApplyRotationsFromTheRight(True, ILOZ, ILOZ + nz - 1#, i - 1#, i, WORKC1, WORKS1, z, WORK)
                End If
            End If
        End If
        '
        ' Decrement number of remaining iterations, and return to start of
        ' the main loop with new value of I.
        '
        ITN = ITN - ITS
        i = L - 1#
    Loop
End Sub
Private Sub Aux2X2Schur(ByRef a As Double, _
         ByRef B As Double, _
         ByRef C As Double, _
         ByRef d As Double, _
         ByRef RT1R As Double, _
         ByRef RT1I As Double, _
         ByRef RT2R As Double, _
         ByRef RT2I As Double, _
         ByRef cs As Double, _
         ByRef SN As Double)
    Dim MULTPL As Double
    Dim AA As Double
    Dim BB As Double
    Dim BCMAX As Double
    Dim BCMIS As Double
    Dim CC As Double
    Dim CS1 As Double
    Dim DD As Double
    Dim eps As Double
    Dim p As Double
    Dim SAB As Double
    Dim SAC As Double
    Dim SCL As Double
    Dim Sigma As Double
    Dim SN1 As Double
    Dim Tau As Double
    Dim temp As Double
    Dim z As Double
    MULTPL = 4#
    eps = MachineEpsilon
    If C = 0# Then
        cs = 1#
        SN = 0#
    Else
        If B = 0# Then
            '
            ' Swap rows and columns
            '
            cs = 0#
            SN = 1#
            temp = d
            d = a
            a = temp
            B = -C
            C = 0#
        Else
            If a - d = 0# And ExtSchurSignToOne(B) <> ExtSchurSignToOne(C) Then
                cs = 1#
                SN = 0#
            Else
                temp = a - d
                p = 0.5 * temp
                BCMAX = MaxReal(Abs(B), Abs(C))
                BCMIS = MinReal(Abs(B), Abs(C)) * ExtSchurSignToOne(B) * ExtSchurSignToOne(C)
                SCL = MaxReal(Abs(p), BCMAX)
                z = p / SCL * p + BCMAX / SCL * BCMIS
                '
                ' If Z is of the order of the machine accuracy, postpone the
                ' decision on the nature of eigenvalues
                '
                If z >= MULTPL * eps Then
                    '
                    ' Real eigenvalues. Compute A and D.
                    '
                    z = p + ExtSchurSign(Sqr(SCL) * Sqr(z), p)
                    a = d + z
                    d = d - BCMAX / z * BCMIS
                    '
                    ' Compute B and the rotation matrix
                    '
                    Tau = Pythag2(C, z)
                    cs = z / Tau
                    SN = C / Tau
                    B = B - C
                    C = 0#
                Else
                    '
                    ' Complex eigenvalues, or real (almost) equal eigenvalues.
                    ' Make diagonal elements equal.
                    '
                    Sigma = B + C
                    Tau = Pythag2(Sigma, temp)
                    cs = Sqr(0.5 * (1# + Abs(Sigma) / Tau))
                    SN = -(p / (Tau * cs) * ExtSchurSign(1#, Sigma))
                    '
                    ' Compute [ AA  BB ] = [ A  B ] [ CS -SN ]
                    '         [ CC  DD ]   [ C  D ] [ SN  CS ]
                    '
                    AA = a * cs + B * SN
                    BB = -(a * SN) + B * cs
                    CC = C * cs + d * SN
                    DD = -(C * SN) + d * cs
                    '
                    ' Compute [ A  B ] = [ CS  SN ] [ AA  BB ]
                    '         [ C  D ]   [-SN  CS ] [ CC  DD ]
                    '
                    a = AA * cs + CC * SN
                    B = BB * cs + DD * SN
                    C = -(AA * SN) + CC * cs
                    d = -(BB * SN) + DD * cs
                    temp = 0.5 * (a + d)
                    a = temp
                    d = temp
                    If C <> 0# Then
                        If B <> 0# Then
                            If ExtSchurSignToOne(B) = ExtSchurSignToOne(C) Then
                                '
                                ' Real eigenvalues: reduce to upper triangular form
                                '
                                SAB = Sqr(Abs(B))
                                SAC = Sqr(Abs(C))
                                p = ExtSchurSign(SAB * SAC, C)
                                Tau = 1# / Sqr(Abs(B + C))
                                a = temp + p
                                d = temp - p
                                B = B - C
                                C = 0#
                                CS1 = SAB * Tau
                                SN1 = SAC * Tau
                                temp = cs * CS1 - SN * SN1
                                SN = cs * SN1 + SN * CS1
                                cs = temp
                            End If
                        Else
                            B = -C
                            C = 0#
                            temp = cs
                            cs = -SN
                            SN = temp
                        End If
                    End If
                End If
            End If
        End If
    End If
    '
    ' Store eigenvalues in (RT1R,RT1I) and (RT2R,RT2I).
    '
    RT1R = a
    RT2R = d
    If C = 0# Then
        RT1I = 0#
        RT2I = 0#
    Else
        RT1I = Sqr(Abs(B)) * Sqr(Abs(C))
        RT2I = -RT1I
    End If
End Sub
Private Function ExtSchurSign(ByVal a As Double, ByVal B As Double) As Double
    Dim Result As Double
    If B >= 0# Then
        Result = Abs(a)
    Else
        Result = -Abs(a)
    End If
    ExtSchurSign = Result
End Function
Private Function ExtSchurSignToOne(ByVal B As Double) As Long
    Dim Result As Long
    If B >= 0# Then
        Result = 1#
    Else
        Result = -1#
    End If
    ExtSchurSignToOne = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright 2009 by Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Cash-Karp adaptive ODE solver.
'
'This subroutine solves ODE  Y'=f(Y,x)  with  initial  conditions  Y(xs)=Ys
'(here Y may be single variable or vector of N variables).
'
'INPUT PARAMETERS:
'    Y       -   initial conditions, array[0..N-1].
'                contains values of Y[] at X[0]
'    N       -   system size
'    X       -   points at which Y should be tabulated, array[0..M-1]
'                integrations starts at X[0], ends at X[M-1],  intermediate
'                values at X[i] are returned too.
'                SHOULD BE ORDERED BY ASCENDING OR BY DESCENDING!!!!
'    M       -   number of intermediate points + first point + last point:
'                * M>2 means that you need both Y(X[M-1]) and M-2 values at
'                  intermediate points
'                * M=2 means that you want just to integrate from  X[0]  to
'                  X[1] and don't interested in intermediate values.
'                * M=1 means that you don't want to integrate :)
'                  it is degenerate case, but it will be handled correctly.
'                * M<1 means error
'    Eps     -   tolerance (absolute/relative error on each  step  will  be
'                less than Eps). When passing:
'                * Eps>0, it means desired ABSOLUTE error
'                * Eps<0, it means desired RELATIVE error.  Relative errors
'                  are calculated with respect to maximum values of  Y seen
'                  so far. Be careful to use this criterion  when  starting
'                  from Y[] that are close to zero.
'    H       -   initial  step  lenth,  it  will  be adjusted automatically
'                after the first  step.  If  H=0,  step  will  be  selected
'                automatically  (usualy  it  will  be  equal  to  0.001  of
'                min(x[i]-x[j])).
'
'OUTPUT PARAMETERS
'    State   -   structure which stores algorithm state between  subsequent
'                calls of OdeSolverIteration. Used for reverse communication.
'                This structure should be passed  to the OdeSolverIteration
'                subroutine.
'
'SEE ALSO
'    AutoGKSmoothW, AutoGKSingular, AutoGKIteration, AutoGKResults.
'
'
'  -- ALGLIB --
'     Copyright 01.09.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub ODESolverRKCK(ByRef y() As Double, _
         ByVal N As Long, _
         ByRef x() As Double, _
         ByVal M As Long, _
         ByVal eps As Double, _
         ByVal h As Double, _
         ByRef State As ODESolverState)
    Call ODESolverInit(0#, y, N, x, M, eps, h, State)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'One iteration of ODE solver.
'
'Called after inialization of State structure with OdeSolverXXX subroutine.
'See HTML docs for examples.
'
'INPUT PARAMETERS:
'    State   -   structure which stores algorithm state between subsequent
'                calls and which is used for reverse communication. Must be
'                initialized with OdeSolverXXX() call first.
'
'If subroutine returned False, algorithm have finished its work.
'If subroutine returned True, then user should:
'* calculate F(State.X, State.Y)
'* store it in State.DY
'Here State.X is real, State.Y and State.DY are arrays[0..N-1] of reals.
'
'  -- ALGLIB --
'     Copyright 01.09.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function ODESolverIteration(ByRef State As ODESolverState) As Boolean
    Dim Result As Boolean
    Dim N As Long
    Dim M As Long
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim XC As Double
    Dim V As Double
    Dim h As Double
    Dim H2 As Double
    Dim GridPoint As Boolean
    Dim Err As Double
    Dim MaxGrowPow As Double
    Dim KLimit As Long
    Dim i_ As Long
    
    '
    ' Reverse communication preparations
    ' I know it looks ugly, but it works the same way
    ' anywhere from C++ to Python.
    '
    ' This code initializes locals by:
    ' * random values determined during code
    '   generation - on first subroutine call
    ' * values from previous call - on subsequent calls
    '
    If State.RState.Stage >= 0# Then
        N = State.RState.IA(0#)
        M = State.RState.IA(1#)
        i = State.RState.IA(2#)
        j = State.RState.IA(3#)
        K = State.RState.IA(4#)
        KLimit = State.RState.IA(5#)
        GridPoint = State.RState.BA(0#)
        XC = State.RState.RA(0#)
        V = State.RState.RA(1#)
        h = State.RState.RA(2#)
        H2 = State.RState.RA(3#)
        Err = State.RState.RA(4#)
        MaxGrowPow = State.RState.RA(5#)
    Else
        N = -983#
        M = -989#
        i = -834#
        j = 900#
        K = -287#
        KLimit = 364#
        GridPoint = False
        XC = -338#
        V = -686#
        h = 912#
        H2 = 585#
        Err = 497#
        MaxGrowPow = -271#
    End If
    If State.RState.Stage = 0# Then
        GoTo lbl_0
    End If
    
    '
    ' Routine body
    '
    
    '
    ' prepare
    '
    If State.RepTerminationType <> 0# Then
        Result = False
        ODESolverIteration = Result
        Exit Function
    End If
    N = State.N
    M = State.M
    h = State.h
    ReDim State.y(0 To N - 1)
    ReDim State.DY(0 To N - 1)
    MaxGrowPow = Power(ODESolverMaxGrow, 5#)
    State.RepNFEV = 0#
    
    '
    ' some preliminary checks for internal errors
    ' after this we assume that H>0 and M>1
    '
    
    '
    ' choose solver
    '
    If State.SolverType <> 0# Then
        GoTo lbl_1
    End If
    
    '
    ' Cask-Karp solver
    ' Prepare coefficients table.
    ' Check it for errors
    '
    ReDim State.RKA(0 To 6# - 1)
    State.RKA(0#) = 0#
    State.RKA(1#) = 1# / 5#
    State.RKA(2#) = 3# / 10#
    State.RKA(3#) = 3# / 5#
    State.RKA(4#) = 1#
    State.RKA(5#) = 7# / 8#
    ReDim State.RKB(0 To 6# - 1, 0 To 5# - 1)
    State.RKB(1#, 0#) = 1# / 5#
    State.RKB(2#, 0#) = 3# / 40#
    State.RKB(2#, 1#) = 9# / 40#
    State.RKB(3#, 0#) = 3# / 10#
    State.RKB(3#, 1#) = -(9# / 10#)
    State.RKB(3#, 2#) = 6# / 5#
    State.RKB(4#, 0#) = -(11# / 54#)
    State.RKB(4#, 1#) = 5# / 2#
    State.RKB(4#, 2#) = -(70# / 27#)
    State.RKB(4#, 3#) = 35# / 27#
    State.RKB(5#, 0#) = 1631# / 55296#
    State.RKB(5#, 1#) = 175# / 512#
    State.RKB(5#, 2#) = 575# / 13824#
    State.RKB(5#, 3#) = 44275# / 110592#
    State.RKB(5#, 4#) = 253# / 4096#
    ReDim State.RKC(0 To 6# - 1)
    State.RKC(0#) = 37# / 378#
    State.RKC(1#) = 0#
    State.RKC(2#) = 250# / 621#
    State.RKC(3#) = 125# / 594#
    State.RKC(4#) = 0#
    State.RKC(5#) = 512# / 1771#
    ReDim State.RKCS(0 To 6# - 1)
    State.RKCS(0#) = 2825# / 27648#
    State.RKCS(1#) = 0#
    State.RKCS(2#) = 18575# / 48384#
    State.RKCS(3#) = 13525# / 55296#
    State.RKCS(4#) = 277# / 14336#
    State.RKCS(5#) = 1# / 4#
    ReDim State.RKK(0 To 6# - 1, 0 To N - 1)
    
    '
    ' Main cycle consists of two iterations:
    ' * outer where we travel from X[i-1] to X[i]
    ' * inner where we travel inside [X[i-1],X[i]]
    '
    ReDim State.YTbl(0 To M - 1, 0 To N - 1)
    ReDim State.EScale(0 To N - 1)
    ReDim State.YN(0 To N - 1)
    ReDim State.YNS(0 To N - 1)
    XC = State.XG(0#)
    For i_ = 0# To N - 1# Step 1
        State.YTbl(0#, i_) = State.YC(i_)
    Next i_
    For j = 0# To N - 1# Step 1
        State.EScale(j) = 0#
    Next j
    i = 1#
lbl_3:
    If i > M - 1# Then
        GoTo lbl_5
    End If
    
    '
    ' begin inner iteration
    '
lbl_6:
    If False Then
        GoTo lbl_7
    End If
    
    '
    ' truncate step if needed (beyond right boundary).
    ' determine should we store X or not
    '
    If XC + h >= State.XG(i) Then
        h = State.XG(i) - XC
        GridPoint = True
    Else
        GridPoint = False
    End If
    
    '
    ' Update error scale maximums
    '
    ' These maximums are initialized by zeros,
    ' then updated every iterations.
    '
    For j = 0# To N - 1# Step 1
        State.EScale(j) = MaxReal(State.EScale(j), Abs(State.YC(j)))
    Next j
    
    '
    ' make one step:
    ' 1. calculate all info needed to do step
    ' 2. update errors scale maximums using values/derivatives
    '    obtained during (1)
    '
    ' Take into account that we use scaling of X to reduce task
    ' to the form where x[0] < x[1] < ... < x[n-1]. So X is
    ' replaced by x=xscale*t, and dy/dx=f(y,x) is replaced
    ' by dy/dt=xscale*f(y,xscale*t).
    '
    For i_ = 0# To N - 1# Step 1
        State.YN(i_) = State.YC(i_)
    Next i_
    For i_ = 0# To N - 1# Step 1
        State.YNS(i_) = State.YC(i_)
    Next i_
    K = 0#
lbl_8:
    If K > 5# Then
        GoTo lbl_10
    End If
    
    '
    ' prepare data for the next update of YN/YNS
    '
    State.x = State.XScale * (XC + State.RKA(K) * h)
    For i_ = 0# To N - 1# Step 1
        State.y(i_) = State.YC(i_)
    Next i_
    For j = 0# To K - 1# Step 1
        V = State.RKB(K, j)
        For i_ = 0# To N - 1# Step 1
            State.y(i_) = State.y(i_) + V * State.RKK(j, i_)
        Next i_
    Next j
    State.RState.Stage = 0#
    GoTo lbl_rcomm
lbl_0:
    State.RepNFEV = State.RepNFEV + 1#
    V = h * State.XScale
    For i_ = 0# To N - 1# Step 1
        State.RKK(K, i_) = V * State.DY(i_)
    Next i_
    
    '
    ' update YN/YNS
    '
    V = State.RKC(K)
    For i_ = 0# To N - 1# Step 1
        State.YN(i_) = State.YN(i_) + V * State.RKK(K, i_)
    Next i_
    V = State.RKCS(K)
    For i_ = 0# To N - 1# Step 1
        State.YNS(i_) = State.YNS(i_) + V * State.RKK(K, i_)
    Next i_
    K = K + 1#
    GoTo lbl_8
lbl_10:
    
    '
    ' estimate error
    '
    Err = 0#
    For j = 0# To N - 1# Step 1
        If Not State.FracEps Then
            
            '
            ' absolute error is estimated
            '
            Err = MaxReal(Err, Abs(State.YN(j) - State.YNS(j)))
        Else
            
            '
            ' Relative error is estimated
            '
            V = State.EScale(j)
            If V = 0# Then
                V = 1#
            End If
            Err = MaxReal(Err, Abs(State.YN(j) - State.YNS(j)) / V)
        End If
    Next j
    
    '
    ' calculate new step, restart if necessary
    '
    If MaxGrowPow * Err <= State.eps Then
        H2 = ODESolverMaxGrow * h
    Else
        H2 = h * Power(State.eps / Err, 0.2)
    End If
    If H2 < h / ODESolverMaxShrink Then
        H2 = h / ODESolverMaxShrink
    End If
    If Err > State.eps Then
        h = H2
        GoTo lbl_6
    End If
    
    '
    ' advance position
    '
    XC = XC + h
    For i_ = 0# To N - 1# Step 1
        State.YC(i_) = State.YN(i_)
    Next i_
    
    '
    ' update H
    '
    h = H2
    
    '
    ' break on grid point
    '
    If GridPoint Then
        GoTo lbl_7
    End If
    GoTo lbl_6
lbl_7:
    
    '
    ' save result
    '
    For i_ = 0# To N - 1# Step 1
        State.YTbl(i, i_) = State.YC(i_)
    Next i_
    i = i + 1#
    GoTo lbl_3
lbl_5:
    State.RepTerminationType = 1#
    Result = False
    ODESolverIteration = Result
    Exit Function
lbl_1:
    Result = False
    ODESolverIteration = Result
    Exit Function
    
    '
    ' Saving state
    '
lbl_rcomm:
    Result = True
    State.RState.IA(0#) = N
    State.RState.IA(1#) = M
    State.RState.IA(2#) = i
    State.RState.IA(3#) = j
    State.RState.IA(4#) = K
    State.RState.IA(5#) = KLimit
    State.RState.BA(0#) = GridPoint
    State.RState.RA(0#) = XC
    State.RState.RA(1#) = V
    State.RState.RA(2#) = h
    State.RState.RA(3#) = H2
    State.RState.RA(4#) = Err
    State.RState.RA(5#) = MaxGrowPow
    ODESolverIteration = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'ODE solver results
'
'Called after OdeSolverIteration returned False.
'
'INPUT PARAMETERS:
'    State   -   algorithm state (used by OdeSolverIteration).
'
'OUTPUT PARAMETERS:
'    M       -   number of tabulated values, M>=1
'    XTbl    -   array[0..M-1], values of X
'    YTbl    -   array[0..M-1,0..N-1], values of Y in X[i]
'    Rep     -   solver report:
'                * Rep.TerminationType completetion code:
'                    * -2    X is not ordered  by  ascending/descending  or
'                            there are non-distinct X[],  i.e.  X[i]=X[i+1]
'                    * -1    incorrect parameters were specified
'                    *  1    task has been solved
'                * Rep.NFEV contains number of function calculations
'
'  -- ALGLIB --
'     Copyright 01.09.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub ODESolverResults(ByRef State As ODESolverState, _
         ByRef M As Long, _
         ByRef XTbl() As Double, _
         ByRef YTbl() As Double, _
         ByRef Rep As ODESolverReport)
    Dim V As Double
    Dim i As Long
    Dim i_ As Long
    Rep.TerminationType = State.RepTerminationType
    If Rep.TerminationType > 0# Then
        M = State.M
        Rep.NFEV = State.RepNFEV
        ReDim XTbl(0 To State.M - 1)
        V = State.XScale
        For i_ = 0# To State.M - 1# Step 1
            XTbl(i_) = V * State.XG(i_)
        Next i_
        ReDim YTbl(0 To State.M - 1, 0 To State.N - 1)
        For i = 0# To State.M - 1# Step 1
            For i_ = 0# To State.N - 1# Step 1
                YTbl(i, i_) = State.YTbl(i, i_)
            Next i_
        Next i
    Else
        Rep.NFEV = 0#
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal initialization subroutine
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub ODESolverInit(ByVal SolverType As Long, _
         ByRef y() As Double, _
         ByVal N As Long, _
         ByRef x() As Double, _
         ByVal M As Long, _
         ByVal eps As Double, _
         ByVal h As Double, _
         ByRef State As ODESolverState)
    Dim i As Long
    Dim V As Double
    Dim i_ As Long
    
    '
    ' Prepare RComm
    '
    ReDim State.RState.IA(0# To 5#)
    ReDim State.RState.BA(0# To 0#)
    ReDim State.RState.RA(0# To 5#)
    State.RState.Stage = -1#
    
    '
    ' check parameters.
    '
    If N <= 0# Or M < 1# Or eps = 0# Then
        State.RepTerminationType = -1#
        Exit Sub
    End If
    If h < 0# Then
        h = -h
    End If
    
    '
    ' quick exit if necessary.
    ' after this block we assume that M>1
    '
    If M = 1# Then
        State.RepNFEV = 0#
        State.RepTerminationType = 1#
        ReDim State.YTbl(0 To 1# - 1, 0 To N - 1)
        For i_ = 0# To N - 1# Step 1
            State.YTbl(0#, i_) = y(i_)
        Next i_
        ReDim State.XG(0 To M - 1)
        For i_ = 0# To M - 1# Step 1
            State.XG(i_) = x(i_)
        Next i_
        Exit Sub
    End If
    
    '
    ' check again: correct order of X[]
    '
    If x(1#) = x(0#) Then
        State.RepTerminationType = -2#
        Exit Sub
    End If
    For i = 1# To M - 1# Step 1
        If x(1#) > x(0#) And x(i) <= x(i - 1#) Or x(1#) < x(0#) And x(i) >= x(i - 1#) Then
            State.RepTerminationType = -2#
            Exit Sub
        End If
    Next i
    
    '
    ' auto-select H if necessary
    '
    If h = 0# Then
        V = Abs(x(1#) - x(0#))
        For i = 2# To M - 1# Step 1
            V = MinReal(V, Abs(x(i) - x(i - 1#)))
        Next i
        h = 0.001 * V
    End If
    
    '
    ' store parameters
    '
    State.N = N
    State.M = M
    State.h = h
    State.eps = Abs(eps)
    State.FracEps = eps < 0#
    ReDim State.XG(0 To M - 1)
    For i_ = 0# To M - 1# Step 1
        State.XG(i_) = x(i_)
    Next i_
    If x(1#) > x(0#) Then
        State.XScale = 1#
    Else
        State.XScale = -1#
        For i_ = 0# To M - 1# Step 1
            State.XG(i_) = -1 * State.XG(i_)
        Next i_
    End If
    ReDim State.YC(0 To N - 1)
    For i_ = 0# To N - 1# Step 1
        State.YC(i_) = y(i_)
    Next i_
    State.SolverType = SolverType
    State.RepTerminationType = 0#
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2006-2009, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This subroutine builds linear spline interpolant
'
'INPUT PARAMETERS:
'    X   -   spline nodes, array[0..N-1]
'    Y   -   function values, array[0..N-1]
'    N   -   points count, N>=2
'
'OUTPUT PARAMETERS:
'    C   -   spline interpolant
'
'
'ORDER OF POINTS
'
'Subroutine automatically sorts points, so caller may pass unsorted array.
'
'  -- ALGLIB PROJECT --
'     Copyright 24.06.2007 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub Spline1DBuildLinear(ByRef x_() As Double, _
         ByRef y_() As Double, _
         ByVal N As Long, _
         ByRef C As Spline1DInterpolant)
    Dim x() As Double
    Dim y() As Double
    Dim i As Long
    x = x_
    y = y_
    
    '
    ' Sort points
    '
    Call HeapSortPoints(x, y, N)
    
    '
    ' Build
    '
    C.Periodic = False
    C.N = N
    C.K = 3#
    ReDim C.x(0 To N - 1)
    ReDim C.C(0 To 4# * (N - 1#) - 1)
    For i = 0# To N - 1# Step 1
        C.x(i) = x(i)
    Next i
    For i = 0# To N - 2# Step 1
        C.C(4# * i + 0#) = y(i)
        C.C(4# * i + 1#) = (y(i + 1#) - y(i)) / (x(i + 1#) - x(i))
        C.C(4# * i + 2#) = 0#
        C.C(4# * i + 3#) = 0#
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This subroutine builds cubic spline interpolant.
'
'INPUT PARAMETERS:
'    X           -   spline nodes, array[0..N-1].
'    Y           -   function values, array[0..N-1].
'    N           -   points count, N>=2
'    BoundLType  -   boundary condition type for the left boundary
'    BoundL      -   left boundary condition (first or second derivative,
'                    depending on the BoundLType)
'    BoundRType  -   boundary condition type for the right boundary
'    BoundR      -   right boundary condition (first or second derivative,
'                    depending on the BoundRType)
'
'OUTPUT PARAMETERS:
'    C           -   spline interpolant
'
'
'ORDER OF POINTS
'
'Subroutine automatically sorts points, so caller may pass unsorted array.
'
'SETTING BOUNDARY VALUES:
'
'The BoundLType/BoundRType parameters can have the following values:
'    * -1, which corresonds to the periodic (cyclic) boundary conditions.
'          In this case:
'          * both BoundLType and BoundRType must be equal to -1.
'          * BoundL/BoundR are ignored
'          * Y[last] is ignored (it is assumed to be equal to Y[first]).
'    *  0, which  corresponds  to  the  parabolically   terminated  spline
'          (BoundL and/or BoundR are ignored).
'    *  1, which corresponds to the first derivative boundary condition
'    *  2, which corresponds to the second derivative boundary condition
'
'PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:
'
'Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
'However, this subroutine doesn't require you to specify equal  values  for
'the first and last points - it automatically forces them to be equal.
'
'  -- ALGLIB PROJECT --
'     Copyright 23.06.2007 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub Spline1DBuildCubic(ByRef x_() As Double, _
         ByRef y_() As Double, _
         ByVal N As Long, _
         ByVal BoundLType As Long, _
         ByVal BoundL As Double, _
         ByVal BoundRType As Long, _
         ByVal BoundR As Double, _
         ByRef C As Spline1DInterpolant)
    Dim x() As Double
    Dim y() As Double
    Dim a1() As Double
    Dim a2() As Double
    Dim a3() As Double
    Dim B() As Double
    Dim d() As Double
    Dim dt() As Double
    Dim i As Long
    Dim V As Double
    Dim i_ As Long
    x = x_
    y = y_
    
    '
    ' Special cases:
    ' * N=2, parabolic terminated boundary condition on both ends
    ' * N=2, periodic boundary condition
    '
    If N = 2# And BoundLType = 0# And BoundRType = 0# Then
        
        '
        ' Change task type
        '
        BoundLType = 2#
        BoundL = 0#
        BoundRType = 2#
        BoundR = 0#
    End If
    If N = 2# And BoundLType = -1# And BoundRType = -1# Then
        
        '
        ' Change task type
        '
        BoundLType = 1#
        BoundL = 0#
        BoundRType = 1#
        BoundR = 0#
        y(1#) = y(0#)
    End If
    
    '
    ' Periodic and non-periodic boundary conditions are
    ' two separate classes
    '
    If BoundRType = -1# And BoundLType = -1# Then
        
        '
        ' Periodic boundary conditions
        '
        ReDim a1(0 To N - 1# - 1)
        ReDim a2(0 To N - 1# - 1)
        ReDim a3(0 To N - 1# - 1)
        ReDim B(0 To N - 1# - 1)
        
        '
        ' Sort points.
        '
        Call HeapSortPoints(x, y, N)
        y(N - 1#) = y(0#)
        
        '
        ' Boundary conditions at N-1 points
        ' (one point less because last point is the same as first point).
        '
        a1(0#) = x(1#) - x(0#)
        a2(0#) = 2# * (x(1#) - x(0#) + x(N - 1#) - x(N - 2#))
        a3(0#) = x(N - 1#) - x(N - 2#)
        B(0#) = 3# * (y(N - 1#) - y(N - 2#)) / (x(N - 1#) - x(N - 2#)) * (x(1#) - x(0#)) + 3# * (y(1#) - y(0#)) / (x(1#) - x(0#)) * (x(N - 1#) - x(N - 2#))
        For i = 1# To N - 2# Step 1
            
            '
            ' Altough last point is [N-2], we use X[N-1] and Y[N-1]
            ' (because of periodicity)
            '
            a1(i) = x(i + 1#) - x(i)
            a2(i) = 2# * (x(i + 1#) - x(i - 1#))
            a3(i) = x(i) - x(i - 1#)
            B(i) = 3# * (y(i) - y(i - 1#)) / (x(i) - x(i - 1#)) * (x(i + 1#) - x(i)) + 3# * (y(i + 1#) - y(i)) / (x(i + 1#) - x(i)) * (x(i) - x(i - 1#))
        Next i
        
        '
        ' Solve, add last point (with index N-1)
        '
        Call SolveCyclicTridiagonal(a1, a2, a3, B, N - 1#, dt)
        ReDim d(0 To N - 1)
        For i_ = 0# To N - 2# Step 1
            d(i_) = dt(i_)
        Next i_
        d(N - 1#) = d(0#)
        
        '
        ' Now problem is reduced to the cubic Hermite spline
        '
        Call Spline1DBuildHermite(x, y, d, N, C)
        C.Periodic = True
    Else
        
        '
        ' Non-periodic boundary condition
        '
        ReDim a1(0 To N - 1)
        ReDim a2(0 To N - 1)
        ReDim a3(0 To N - 1)
        ReDim B(0 To N - 1)
        
        '
        ' Sort points.
        '
        Call HeapSortPoints(x, y, N)
        
        '
        ' Left boundary conditions
        '
        If BoundLType = 0# Then
            a1(0#) = 0#
            a2(0#) = 1#
            a3(0#) = 1#
            B(0#) = 2# * (y(1#) - y(0#)) / (x(1#) - x(0#))
        End If
        If BoundLType = 1# Then
            a1(0#) = 0#
            a2(0#) = 1#
            a3(0#) = 0#
            B(0#) = BoundL
        End If
        If BoundLType = 2# Then
            a1(0#) = 0#
            a2(0#) = 2#
            a3(0#) = 1#
            B(0#) = 3# * (y(1#) - y(0#)) / (x(1#) - x(0#)) - 0.5 * BoundL * (x(1#) - x(0#))
        End If
        
        '
        ' Central conditions
        '
        For i = 1# To N - 2# Step 1
            a1(i) = x(i + 1#) - x(i)
            a2(i) = 2# * (x(i + 1#) - x(i - 1#))
            a3(i) = x(i) - x(i - 1#)
            B(i) = 3# * (y(i) - y(i - 1#)) / (x(i) - x(i - 1#)) * (x(i + 1#) - x(i)) + 3# * (y(i + 1#) - y(i)) / (x(i + 1#) - x(i)) * (x(i) - x(i - 1#))
        Next i
        
        '
        ' Right boundary conditions
        '
        If BoundRType = 0# Then
            a1(N - 1#) = 1#
            a2(N - 1#) = 1#
            a3(N - 1#) = 0#
            B(N - 1#) = 2# * (y(N - 1#) - y(N - 2#)) / (x(N - 1#) - x(N - 2#))
        End If
        If BoundRType = 1# Then
            a1(N - 1#) = 0#
            a2(N - 1#) = 1#
            a3(N - 1#) = 0#
            B(N - 1#) = BoundR
        End If
        If BoundRType = 2# Then
            a1(N - 1#) = 1#
            a2(N - 1#) = 2#
            a3(N - 1#) = 0#
            B(N - 1#) = 3# * (y(N - 1#) - y(N - 2#)) / (x(N - 1#) - x(N - 2#)) + 0.5 * BoundR * (x(N - 1#) - x(N - 2#))
        End If
        
        '
        ' Solve
        '
        Call SolveTridiagonal(a1, a2, a3, B, N, d)
        
        '
        ' Now problem is reduced to the cubic Hermite spline
        '
        Call Spline1DBuildHermite(x, y, d, N, C)
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This subroutine builds Catmull-Rom spline interpolant.
'
'INPUT PARAMETERS:
'    X           -   spline nodes, array[0..N-1].
'    Y           -   function values, array[0..N-1].
'    N           -   points count, N>=2
'    BoundType   -   boundary condition type:
'                    * -1 for periodic boundary condition
'                    *  0 for parabolically terminated spline
'    Tension     -   tension parameter:
'                    * tension=0   corresponds to classic Catmull-Rom spline
'                    * 0<tension<1 corresponds to more general form - cardinal spline
'
'OUTPUT PARAMETERS:
'    C           -   spline interpolant
'
'
'ORDER OF POINTS
'
'Subroutine automatically sorts points, so caller may pass unsorted array.
'
'PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:
'
'Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
'However, this subroutine doesn't require you to specify equal  values  for
'the first and last points - it automatically forces them to be equal.
'
'  -- ALGLIB PROJECT --
'     Copyright 23.06.2007 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub Spline1DBuildCatmullRom(ByRef x_() As Double, _
         ByRef y_() As Double, _
         ByVal N As Long, _
         ByVal BoundType As Long, _
         ByVal Tension As Double, _
         ByRef C As Spline1DInterpolant)
    Dim x() As Double
    Dim y() As Double
    Dim a1() As Double
    Dim a2() As Double
    Dim a3() As Double
    Dim B() As Double
    Dim d() As Double
    Dim dt() As Double
    Dim i As Long
    Dim V As Double
    x = x_
    y = y_
    
    '
    ' Special cases:
    ' * N=2, parabolic terminated boundary condition on both ends
    ' * N=2, periodic boundary condition
    '
    If N = 2# And BoundType = 0# Then
        
        '
        ' Just linear spline
        '
        Call Spline1DBuildLinear(x, y, N, C)
        Exit Sub
    End If
    If N = 2# And BoundType = -1# Then
        
        '
        ' Same as cubic spline with periodic conditions
        '
        Call Spline1DBuildCubic(x, y, N, -1#, 0#, -1#, 0#, C)
        Exit Sub
    End If
    
    '
    ' Periodic or non-periodic boundary conditions
    '
    If BoundType = -1# Then
        
        '
        ' Sort points.
        '
        Call HeapSortPoints(x, y, N)
        y(N - 1#) = y(0#)
        
        '
        ' Periodic boundary conditions
        '
        ReDim d(0 To N - 1)
        d(0#) = (y(1#) - y(N - 2#)) / (2# * (x(1#) - x(0#) + x(N - 1#) - x(N - 2#)))
        For i = 1# To N - 2# Step 1
            d(i) = (1# - Tension) * (y(i + 1#) - y(i - 1#)) / (x(i + 1#) - x(i - 1#))
        Next i
        d(N - 1#) = d(0#)
        
        '
        ' Now problem is reduced to the cubic Hermite spline
        '
        Call Spline1DBuildHermite(x, y, d, N, C)
        C.Periodic = True
    Else
        
        '
        ' Sort points.
        '
        Call HeapSortPoints(x, y, N)
        
        '
        ' Non-periodic boundary conditions
        '
        ReDim d(0 To N - 1)
        For i = 1# To N - 2# Step 1
            d(i) = (1# - Tension) * (y(i + 1#) - y(i - 1#)) / (x(i + 1#) - x(i - 1#))
        Next i
        d(0#) = 2# * (y(1#) - y(0#)) / (x(1#) - x(0#)) - d(1#)
        d(N - 1#) = 2# * (y(N - 1#) - y(N - 2#)) / (x(N - 1#) - x(N - 2#)) - d(N - 2#)
        
        '
        ' Now problem is reduced to the cubic Hermite spline
        '
        Call Spline1DBuildHermite(x, y, d, N, C)
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This subroutine builds Hermite spline interpolant.
'
'INPUT PARAMETERS:
'    X           -   spline nodes, array[0..N-1]
'    Y           -   function values, array[0..N-1]
'    D           -   derivatives, array[0..N-1]
'    N           -   points count, N>=2
'
'OUTPUT PARAMETERS:
'    C           -   spline interpolant.
'
'
'ORDER OF POINTS
'
'Subroutine automatically sorts points, so caller may pass unsorted array.
'
'  -- ALGLIB PROJECT --
'     Copyright 23.06.2007 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub Spline1DBuildHermite(ByRef x_() As Double, _
         ByRef y_() As Double, _
         ByRef D_() As Double, _
         ByVal N As Long, _
         ByRef C As Spline1DInterpolant)
    Dim x() As Double
    Dim y() As Double
    Dim d() As Double
    Dim i As Long
    Dim Delta As Double
    Dim Delta2 As Double
    Dim Delta3 As Double
    x = x_
    y = y_
    d = D_
    
    '
    ' Sort points
    '
    Call HeapSortDPoints(x, y, d, N)
    
    '
    ' Build
    '
    ReDim C.x(0 To N - 1)
    ReDim C.C(0 To 4# * (N - 1#) - 1)
    C.Periodic = False
    C.K = 3#
    C.N = N
    For i = 0# To N - 1# Step 1
        C.x(i) = x(i)
    Next i
    For i = 0# To N - 2# Step 1
        Delta = x(i + 1#) - x(i)
        Delta2 = Square(Delta)
        Delta3 = Delta * Delta2
        C.C(4# * i + 0#) = y(i)
        C.C(4# * i + 1#) = d(i)
        C.C(4# * i + 2#) = (3# * (y(i + 1#) - y(i)) - 2# * d(i) * Delta - d(i + 1#) * Delta) / Delta2
        C.C(4# * i + 3#) = (2# * (y(i) - y(i + 1#)) + d(i) * Delta + d(i + 1#) * Delta) / Delta3
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This subroutine builds Akima spline interpolant
'
'INPUT PARAMETERS:
'    X           -   spline nodes, array[0..N-1]
'    Y           -   function values, array[0..N-1]
'    N           -   points count, N>=5
'
'OUTPUT PARAMETERS:
'    C           -   spline interpolant
'
'
'ORDER OF POINTS
'
'Subroutine automatically sorts points, so caller may pass unsorted array.
'
'  -- ALGLIB PROJECT --
'     Copyright 24.06.2007 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub Spline1DBuildAkima(ByRef x_() As Double, _
         ByRef y_() As Double, _
         ByVal N As Long, _
         ByRef C As Spline1DInterpolant)
    Dim x() As Double
    Dim y() As Double
    Dim i As Long
    Dim d() As Double
    Dim w() As Double
    Dim Diff() As Double
    x = x_
    y = y_
    
    '
    ' Sort points
    '
    Call HeapSortPoints(x, y, N)
    
    '
    ' Prepare W (weights), Diff (divided differences)
    '
    ReDim w(0 To N - 1# - 1)
    ReDim Diff(0 To N - 1# - 1)
    For i = 0# To N - 2# Step 1
        Diff(i) = (y(i + 1#) - y(i)) / (x(i + 1#) - x(i))
    Next i
    For i = 1# To N - 2# Step 1
        w(i) = Abs(Diff(i) - Diff(i - 1#))
    Next i
    
    '
    ' Prepare Hermite interpolation scheme
    '
    ReDim d(0 To N - 1)
    For i = 2# To N - 3# Step 1
        If Abs(w(i - 1#)) + Abs(w(i + 1#)) <> 0# Then
            d(i) = (w(i + 1#) * Diff(i - 1#) + w(i - 1#) * Diff(i)) / (w(i + 1#) + w(i - 1#))
        Else
            d(i) = ((x(i + 1#) - x(i)) * Diff(i - 1#) + (x(i) - x(i - 1#)) * Diff(i)) / (x(i + 1#) - x(i - 1#))
        End If
    Next i
    d(0#) = DiffThreePoint(x(0#), x(0#), y(0#), x(1#), y(1#), x(2#), y(2#))
    d(1#) = DiffThreePoint(x(1#), x(0#), y(0#), x(1#), y(1#), x(2#), y(2#))
    d(N - 2#) = DiffThreePoint(x(N - 2#), x(N - 3#), y(N - 3#), x(N - 2#), y(N - 2#), x(N - 1#), y(N - 1#))
    d(N - 1#) = DiffThreePoint(x(N - 1#), x(N - 3#), y(N - 3#), x(N - 2#), y(N - 2#), x(N - 1#), y(N - 1#))
    
    '
    ' Build Akima spline using Hermite interpolation scheme
    '
    Call Spline1DBuildHermite(x, y, d, N, C)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Weighted fitting by cubic  spline,  with constraints on function values or
'derivatives.
'
'Equidistant grid with M-2 nodes on [min(x,xc),max(x,xc)] is  used to build
'basis functions. Basis functions are cubic splines with continuous  second
'derivatives  and  non-fixed first  derivatives  at  interval  ends.  Small
'regularizing term is used  when  solving  constrained  tasks  (to  improve
'stability).
'
'Task is linear, so linear least squares solver is used. Complexity of this
'computational scheme is O(N*M^2), mostly dominated by least squares solver
'
'SEE ALSO
'    Spline1DFitHermiteWC()  -   fitting by Hermite splines (more flexible,
'                                less smooth)
'    Spline1DFitCubic()      -   "lightweight" fitting  by  cubic  splines,
'                                without invididual weights and constraints
'
'INPUT PARAMETERS:
'    X   -   points, array[0..N-1].
'    Y   -   function values, array[0..N-1].
'    W   -   weights, array[0..N-1]
'            Each summand in square  sum  of  approximation deviations from
'            given  values  is  multiplied  by  the square of corresponding
'            weight. Fill it by 1's if you don't  want  to  solve  weighted
'            task.
'    N   -   number of points, N>0.
'    XC  -   points where spline values/derivatives are constrained,
'            array[0..K-1].
'    YC  -   values of constraints, array[0..K-1]
'    DC  -   array[0..K-1], types of constraints:
'            * DC[i]=0   means that S(XC[i])=YC[i]
'            * DC[i]=1   means that S'(XC[i])=YC[i]
'            SEE BELOW FOR IMPORTANT INFORMATION ON CONSTRAINTS
'    K   -   number of constraints, 0<=K<M.
'            K=0 means no constraints (XC/YC/DC are not used in such cases)
'    M   -   number of basis functions ( = number_of_nodes+2), M>=4.
'
'OUTPUT PARAMETERS:
'    Info-   same format as in LSFitLinearWC() subroutine.
'            * Info>0    task is solved
'            * Info<=0   an error occured:
'                        -4 means inconvergence of internal SVD
'                        -3 means inconsistent constraints
'                        -1 means another errors in parameters passed
'                           (N<=0, for example)
'    S   -   spline interpolant.
'    Rep -   report, same format as in LSFitLinearWC() subroutine.
'            Following fields are set:
'            * RMSError      rms error on the (X,Y).
'            * AvgError      average error on the (X,Y).
'            * AvgRelError   average relative error on the non-zero Y
'            * MaxError      maximum error
'                            NON-WEIGHTED ERRORS ARE CALCULATED
'
'IMPORTANT:
'    this subroitine doesn't calculate task's condition number for K<>0.
'
'
'ORDER OF POINTS
'
'Subroutine automatically sorts points, so caller may pass unsorted array.
'
'SETTING CONSTRAINTS - DANGERS AND OPPORTUNITIES:
'
'Setting constraints can lead  to undesired  results,  like ill-conditioned
'behavior, or inconsistency being detected. From the other side,  it allows
'us to improve quality of the fit. Here we summarize  our  experience  with
'constrained regression splines:
'* excessive constraints can be inconsistent. Splines are  piecewise  cubic
'  functions, and it is easy to create an example, where  large  number  of
'  constraints  concentrated  in  small  area will result in inconsistency.
'  Just because spline is not flexible enough to satisfy all of  them.  And
'  same constraints spread across the  [min(x),max(x)]  will  be  perfectly
'  consistent.
'* the more evenly constraints are spread across [min(x),max(x)],  the more
'  chances that they will be consistent
'* the  greater  is  M (given  fixed  constraints),  the  more chances that
'  constraints will be consistent
'* in the general case, consistency of constraints IS NOT GUARANTEED.
'* in the several special cases, however, we CAN guarantee consistency.
'* one of this cases is constraints  on  the  function  values  AND/OR  its
'  derivatives at the interval boundaries.
'* another  special  case  is ONE constraint on the function value (OR, but
'  not AND, derivative) anywhere in the interval
'
'Our final recommendation is to use constraints  WHEN  AND  ONLY  WHEN  you
'can't solve your task without them. Anything beyond  special  cases  given
'above is not guaranteed and may result in inconsistency.
'
'
'  -- ALGLIB PROJECT --
'     Copyright 18.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub Spline1DFitCubicWC(ByRef x() As Double, _
         ByRef y() As Double, _
         ByRef w() As Double, _
         ByVal N As Long, _
         ByRef XC() As Double, _
         ByRef YC() As Double, _
         ByRef DC() As Long, _
         ByVal K As Long, _
         ByVal M As Long, _
         ByRef Info As Long, _
         ByRef s As Spline1DInterpolant, _
         ByRef Rep As Spline1DFitReport)
    Call Spline1DFitInternal(0#, x, y, w, N, XC, YC, DC, K, M, Info, s, Rep)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Weighted  fitting  by Hermite spline,  with constraints on function values
'or first derivatives.
'
'Equidistant grid with M nodes on [min(x,xc),max(x,xc)] is  used  to  build
'basis functions. Basis functions are Hermite splines.  Small  regularizing
'term is used when solving constrained tasks (to improve stability).
'
'Task is linear, so linear least squares solver is used. Complexity of this
'computational scheme is O(N*M^2), mostly dominated by least squares solver
'
'SEE ALSO
'    Spline1DFitCubicWC()    -   fitting by Cubic splines (less flexible,
'                                more smooth)
'    Spline1DFitHermite()    -   "lightweight" Hermite fitting, without
'                                invididual weights and constraints
'
'INPUT PARAMETERS:
'    X   -   points, array[0..N-1].
'    Y   -   function values, array[0..N-1].
'    W   -   weights, array[0..N-1]
'            Each summand in square  sum  of  approximation deviations from
'            given  values  is  multiplied  by  the square of corresponding
'            weight. Fill it by 1's if you don't  want  to  solve  weighted
'            task.
'    N   -   number of points, N>0.
'    XC  -   points where spline values/derivatives are constrained,
'            array[0..K-1].
'    YC  -   values of constraints, array[0..K-1]
'    DC  -   array[0..K-1], types of constraints:
'            * DC[i]=0   means that S(XC[i])=YC[i]
'            * DC[i]=1   means that S'(XC[i])=YC[i]
'            SEE BELOW FOR IMPORTANT INFORMATION ON CONSTRAINTS
'    K   -   number of constraints, 0<=K<M.
'            K=0 means no constraints (XC/YC/DC are not used in such cases)
'    M   -   number of basis functions (= 2 * number of nodes),
'            M>=4,
'            M IS EVEN!
'
'OUTPUT PARAMETERS:
'    Info-   same format as in LSFitLinearW() subroutine:
'            * Info>0    task is solved
'            * Info<=0   an error occured:
'                        -4 means inconvergence of internal SVD
'                        -3 means inconsistent constraints
'                        -2 means odd M was passed (which is not supported)
'                        -1 means another errors in parameters passed
'                           (N<=0, for example)
'    S   -   spline interpolant.
'    Rep -   report, same format as in LSFitLinearW() subroutine.
'            Following fields are set:
'            * RMSError      rms error on the (X,Y).
'            * AvgError      average error on the (X,Y).
'            * AvgRelError   average relative error on the non-zero Y
'            * MaxError      maximum error
'                            NON-WEIGHTED ERRORS ARE CALCULATED
'
'IMPORTANT:
'    this subroitine doesn't calculate task's condition number for K<>0.
'
'IMPORTANT:
'    this subroitine supports only even M's
'
'
'ORDER OF POINTS
'
'Subroutine automatically sorts points, so caller may pass unsorted array.
'
'SETTING CONSTRAINTS - DANGERS AND OPPORTUNITIES:
'
'Setting constraints can lead  to undesired  results,  like ill-conditioned
'behavior, or inconsistency being detected. From the other side,  it allows
'us to improve quality of the fit. Here we summarize  our  experience  with
'constrained regression splines:
'* excessive constraints can be inconsistent. Splines are  piecewise  cubic
'  functions, and it is easy to create an example, where  large  number  of
'  constraints  concentrated  in  small  area will result in inconsistency.
'  Just because spline is not flexible enough to satisfy all of  them.  And
'  same constraints spread across the  [min(x),max(x)]  will  be  perfectly
'  consistent.
'* the more evenly constraints are spread across [min(x),max(x)],  the more
'  chances that they will be consistent
'* the  greater  is  M (given  fixed  constraints),  the  more chances that
'  constraints will be consistent
'* in the general case, consistency of constraints is NOT GUARANTEED.
'* in the several special cases, however, we can guarantee consistency.
'* one of this cases is  M>=4  and   constraints  on   the  function  value
'  (AND/OR its derivative) at the interval boundaries.
'* another special case is M>=4  and  ONE  constraint on the function value
'  (OR, BUT NOT AND, derivative) anywhere in [min(x),max(x)]
'
'Our final recommendation is to use constraints  WHEN  AND  ONLY  when  you
'can't solve your task without them. Anything beyond  special  cases  given
'above is not guaranteed and may result in inconsistency.
'
'  -- ALGLIB PROJECT --
'     Copyright 18.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub Spline1DFitHermiteWC(ByRef x() As Double, _
         ByRef y() As Double, _
         ByRef w() As Double, _
         ByVal N As Long, _
         ByRef XC() As Double, _
         ByRef YC() As Double, _
         ByRef DC() As Long, _
         ByVal K As Long, _
         ByVal M As Long, _
         ByRef Info As Long, _
         ByRef s As Spline1DInterpolant, _
         ByRef Rep As Spline1DFitReport)
    Call Spline1DFitInternal(1#, x, y, w, N, XC, YC, DC, K, M, Info, s, Rep)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Least squares fitting by cubic spline.
'
'This subroutine is "lightweight" alternative for more complex and feature-
'rich Spline1DFitCubicWC().  See  Spline1DFitCubicWC() for more information
'about subroutine parameters (we don't duplicate it here because of length)
'
'  -- ALGLIB PROJECT --
'     Copyright 18.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub Spline1DFitCubic(ByRef x() As Double, _
         ByRef y() As Double, _
         ByVal N As Long, _
         ByVal M As Long, _
         ByRef Info As Long, _
         ByRef s As Spline1DInterpolant, _
         ByRef Rep As Spline1DFitReport)
    Dim i As Long
    Dim w() As Double
    Dim XC() As Double
    Dim YC() As Double
    Dim DC() As Long
    If N > 0# Then
        ReDim w(0 To N - 1)
        For i = 0# To N - 1# Step 1
            w(i) = 1#
        Next i
    End If
    Call Spline1DFitCubicWC(x, y, w, N, XC, YC, DC, 0#, M, Info, s, Rep)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Least squares fitting by Hermite spline.
'
'This subroutine is "lightweight" alternative for more complex and feature-
'rich Spline1DFitHermiteWC().  See Spline1DFitHermiteWC()  description  for
'more information about subroutine parameters (we don't duplicate  it  here
'because of length).
'
'  -- ALGLIB PROJECT --
'     Copyright 18.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub Spline1DFitHermite(ByRef x() As Double, _
         ByRef y() As Double, _
         ByVal N As Long, _
         ByVal M As Long, _
         ByRef Info As Long, _
         ByRef s As Spline1DInterpolant, _
         ByRef Rep As Spline1DFitReport)
    Dim i As Long
    Dim w() As Double
    Dim XC() As Double
    Dim YC() As Double
    Dim DC() As Long
    If N > 0# Then
        ReDim w(0 To N - 1)
        For i = 0# To N - 1# Step 1
            w(i) = 1#
        Next i
    End If
    Call Spline1DFitHermiteWC(x, y, w, N, XC, YC, DC, 0#, M, Info, s, Rep)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This subroutine calculates the value of the spline at the given point X.
'
'INPUT PARAMETERS:
'    C   -   spline interpolant
'    X   -   point
'
'Result:
'    S(x)
'
'  -- ALGLIB PROJECT --
'     Copyright 23.06.2007 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function Spline1DCalc(ByRef C As Spline1DInterpolant, _
         ByVal x As Double) As Double
    Dim Result As Double
    Dim L As Long
    Dim R As Long
    Dim M As Long
    Dim t As Double
    
    '
    ' correct if periodic
    '
    If C.Periodic Then
        Call APPeriodicMap(x, C.x(0#), C.x(C.N - 1#), t)
    End If
    
    '
    ' Binary search in the [ x[0], ..., x[n-2] ] (x[n-1] is not included)
    '
    L = 0#
    R = C.N - 2# + 1#
    Do While L <> R - 1#
        M = (L + R) \ 2#
        If C.x(M) >= x Then
            R = M
        Else
            L = M
        End If
    Loop
    
    '
    ' Interpolation
    '
    x = x - C.x(L)
    M = 4# * L
    Result = C.C(M) + x * (C.C(M + 1#) + x * (C.C(M + 2#) + x * C.C(M + 3#)))
    Spline1DCalc = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This subroutine differentiates the spline.
'
'INPUT PARAMETERS:
'    C   -   spline interpolant.
'    X   -   point
'
'Result:
'    S   -   S(x)
'    DS  -   S'(x)
'    D2S -   S''(x)
'
'  -- ALGLIB PROJECT --
'     Copyright 24.06.2007 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub Spline1DDiff(ByRef C As Spline1DInterpolant, _
         ByVal x As Double, _
         ByRef s As Double, _
         ByRef DS As Double, _
         ByRef D2S As Double)
    Dim L As Long
    Dim R As Long
    Dim M As Long
    Dim t As Double
    
    '
    ' correct if periodic
    '
    If C.Periodic Then
        Call APPeriodicMap(x, C.x(0#), C.x(C.N - 1#), t)
    End If
    
    '
    ' Binary search
    '
    L = 0#
    R = C.N - 2# + 1#
    Do While L <> R - 1#
        M = (L + R) \ 2#
        If C.x(M) >= x Then
            R = M
        Else
            L = M
        End If
    Loop
    
    '
    ' Differentiation
    '
    x = x - C.x(L)
    M = 4# * L
    s = C.C(M) + x * (C.C(M + 1#) + x * (C.C(M + 2#) + x * C.C(M + 3#)))
    DS = C.C(M + 1#) + 2# * x * C.C(M + 2#) + 3# * Square(x) * C.C(M + 3#)
    D2S = 2# * C.C(M + 2#) + 6# * x * C.C(M + 3#)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This subroutine makes the copy of the spline.
'
'INPUT PARAMETERS:
'    C   -   spline interpolant.
'
'Result:
'    CC  -   spline copy
'
'  -- ALGLIB PROJECT --
'     Copyright 29.06.2007 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub Spline1DCopy(ByRef C As Spline1DInterpolant, _
         ByRef CC As Spline1DInterpolant)
    Dim i_ As Long
    CC.Periodic = C.Periodic
    CC.N = C.N
    CC.K = C.K
    ReDim CC.x(0 To CC.N - 1)
    For i_ = 0# To CC.N - 1# Step 1
        CC.x(i_) = C.x(i_)
    Next i_
    ReDim CC.C(0 To (CC.K + 1#) * (CC.N - 1#) - 1)
    For i_ = 0# To (CC.K + 1#) * (CC.N - 1#) - 1# Step 1
        CC.C(i_) = C.C(i_)
    Next i_
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This subroutine unpacks the spline into the coefficients table.
'
'INPUT PARAMETERS:
'    C   -   spline interpolant.
'    X   -   point
'
'Result:
'    Tbl -   coefficients table, unpacked format, array[0..N-2, 0..5].
'            For I = 0...N-2:
'                Tbl[I,0] = X[i]
'                Tbl[I,1] = X[i+1]
'                Tbl[I,2] = C0
'                Tbl[I,3] = C1
'                Tbl[I,4] = C2
'                Tbl[I,5] = C3
'            On [x[i], x[i+1]] spline is equals to:
'                S(x) = C0 + C1*t + C2*t^2 + C3*t^3
'                t = x-x[i]
'
'  -- ALGLIB PROJECT --
'     Copyright 29.06.2007 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub Spline1DUnpack(ByRef C As Spline1DInterpolant, _
         ByRef N As Long, _
         ByRef Tbl() As Double)
    Dim i As Long
    Dim j As Long
    ReDim Tbl(0# To C.N - 2#, 0# To 2# + C.K)
    N = C.N
    
    '
    ' Fill
    '
    For i = 0# To N - 2# Step 1
        Tbl(i, 0#) = C.x(i)
        Tbl(i, 1#) = C.x(i + 1#)
        For j = 0# To C.K Step 1
            Tbl(i, 2# + j) = C.C((C.K + 1#) * i + j)
        Next j
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This subroutine performs linear transformation of the spline argument.
'
'INPUT PARAMETERS:
'    C   -   spline interpolant.
'    A, B-   transformation coefficients: x = A*t + B
'Result:
'    C   -   transformed spline
'
'  -- ALGLIB PROJECT --
'     Copyright 30.06.2007 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub Spline1DLinTransX(ByRef C As Spline1DInterpolant, _
         ByVal a As Double, _
         ByVal B As Double)
    Dim i As Long
    Dim j As Long
    Dim N As Long
    Dim V As Double
    Dim DV As Double
    Dim D2V As Double
    Dim x() As Double
    Dim y() As Double
    Dim d() As Double
    N = C.N
    
    '
    ' Special case: A=0
    '
    If a = 0# Then
        V = Spline1DCalc(C, B)
        For i = 0# To N - 2# Step 1
            C.C((C.K + 1#) * i) = V
            For j = 1# To C.K Step 1
                C.C((C.K + 1#) * i + j) = 0#
            Next j
        Next i
        Exit Sub
    End If
    
    '
    ' General case: A<>0.
    ' Unpack, X, Y, dY/dX.
    ' Scale and pack again.
    '
    ReDim x(0# To N - 1#)
    ReDim y(0# To N - 1#)
    ReDim d(0# To N - 1#)
    For i = 0# To N - 1# Step 1
        x(i) = C.x(i)
        Call Spline1DDiff(C, x(i), V, DV, D2V)
        x(i) = (x(i) - B) / a
        y(i) = V
        d(i) = a * DV
    Next i
    Call Spline1DBuildHermite(x, y, d, N, C)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This subroutine performs linear transformation of the spline.
'
'INPUT PARAMETERS:
'    C   -   spline interpolant.
'    A, B-   transformation coefficients: S2(x) = A*S(x) + B
'Result:
'    C   -   transformed spline
'
'  -- ALGLIB PROJECT --
'     Copyright 30.06.2007 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub Spline1DLinTransY(ByRef C As Spline1DInterpolant, _
         ByVal a As Double, _
         ByVal B As Double)
    Dim i As Long
    Dim j As Long
    Dim N As Long
    N = C.N
    For i = 0# To N - 2# Step 1
        C.C((C.K + 1#) * i) = a * C.C((C.K + 1#) * i) + B
        For j = 1# To C.K Step 1
            C.C((C.K + 1#) * i + j) = a * C.C((C.K + 1#) * i + j)
        Next j
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This subroutine integrates the spline.
'
'INPUT PARAMETERS:
'    C   -   spline interpolant.
'    X   -   right bound of the integration interval [a, x],
'            here 'a' denotes min(x[])
'Result:
'    integral(S(t)dt,a,x)
'
'  -- ALGLIB PROJECT --
'     Copyright 23.06.2007 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function Spline1DIntegrate(ByRef C As Spline1DInterpolant, _
         ByVal x As Double) As Double
    Dim Result As Double
    Dim N As Long
    Dim i As Long
    Dim j As Long
    Dim L As Long
    Dim R As Long
    Dim M As Long
    Dim w As Double
    Dim V As Double
    Dim t As Double
    Dim IntAB As Double
    Dim AdditionalTerm As Double
    N = C.N
    
    '
    ' Periodic splines require special treatment. We make
    ' following transformation:
    '
    '     integral(S(t)dt,A,X) = integral(S(t)dt,A,Z)+AdditionalTerm
    '
    ' here X may lie outside of [A,B], Z lies strictly in [A,B],
    ' AdditionalTerm is equals to integral(S(t)dt,A,B) times some
    ' integer number (may be zero).
    '
    If C.Periodic And (x < C.x(0#) Or x > C.x(C.N - 1#)) Then
        
        '
        ' compute integral(S(x)dx,A,B)
        '
        IntAB = 0#
        For i = 0# To C.N - 2# Step 1
            w = C.x(i + 1#) - C.x(i)
            M = (C.K + 1#) * i
            IntAB = IntAB + C.C(M) * w
            V = w
            For j = 1# To C.K Step 1
                V = V * w
                IntAB = IntAB + C.C(M + j) * V / (j + 1#)
            Next j
        Next i
        
        '
        ' map X into [A,B]
        '
        Call APPeriodicMap(x, C.x(0#), C.x(C.N - 1#), t)
        AdditionalTerm = t * IntAB
    Else
        AdditionalTerm = 0#
    End If
    
    '
    ' Binary search in the [ x[0], ..., x[n-2] ] (x[n-1] is not included)
    '
    L = 0#
    R = N - 2# + 1#
    Do While L <> R - 1#
        M = (L + R) \ 2#
        If C.x(M) >= x Then
            R = M
        Else
            L = M
        End If
    Loop
    
    '
    ' Integration
    '
    Result = 0#
    For i = 0# To L - 1# Step 1
        w = C.x(i + 1#) - C.x(i)
        M = (C.K + 1#) * i
        Result = Result + C.C(M) * w
        V = w
        For j = 1# To C.K Step 1
            V = V * w
            Result = Result + C.C(M + j) * V / (j + 1#)
        Next j
    Next i
    w = x - C.x(L)
    M = (C.K + 1#) * L
    V = w
    Result = Result + C.C(M) * w
    For j = 1# To C.K Step 1
        V = V * w
        Result = Result + C.C(M + j) * V / (j + 1#)
    Next j
    Result = Result + AdditionalTerm
    Spline1DIntegrate = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal spline fitting subroutine
'
'  -- ALGLIB PROJECT --
'     Copyright 08.09.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub Spline1DFitInternal(ByVal ST As Long, _
         ByRef x_() As Double, _
         ByRef y_() As Double, _
         ByRef w() As Double, _
         ByVal N As Long, _
         ByRef XC_() As Double, _
         ByRef YC_() As Double, _
         ByRef DC() As Long, _
         ByVal K As Long, _
         ByVal M As Long, _
         ByRef Info As Long, _
         ByRef s As Spline1DInterpolant, _
         ByRef Rep As Spline1DFitReport)
    Dim x() As Double
    Dim y() As Double
    Dim XC() As Double
    Dim YC() As Double
    Dim FMatrix() As Double
    Dim CMatrix() As Double
    Dim Y2() As Double
    Dim W2() As Double
    Dim SX() As Double
    Dim SY() As Double
    Dim SD() As Double
    Dim tmp() As Double
    Dim XOriginal() As Double
    Dim YOriginal() As Double
    Dim LRep As LSFitReport
    Dim V0 As Double
    Dim V1 As Double
    Dim V2 As Double
    Dim MX As Double
    Dim S2 As Spline1DInterpolant
    Dim i As Long
    Dim j As Long
    Dim RelCnt As Long
    Dim XA As Double
    Dim XB As Double
    Dim SA As Double
    Dim SB As Double
    Dim BL As Double
    Dim BR As Double
    Dim Decay As Double
    Dim i_ As Long
    x = x_
    y = y_
    XC = XC_
    YC = YC_
    If ST = 0# And M < 4# Then
        Info = -1#
        Exit Sub
    End If
    If ST = 1# And M < 4# Then
        Info = -1#
        Exit Sub
    End If
    If N < 1# Or K < 0# Or K >= M Then
        Info = -1#
        Exit Sub
    End If
    For i = 0# To K - 1# Step 1
        Info = 0#
        If DC(i) < 0# Then
            Info = -1#
        End If
        If DC(i) > 1# Then
            Info = -1#
        End If
        If Info < 0# Then
            Exit Sub
        End If
    Next i
    If ST = 1# And M Mod 2# <> 0# Then
        
        '
        ' Hermite fitter must have even number of basis functions
        '
        Info = -2#
        Exit Sub
    End If
    
    '
    ' weight decay for correct handling of task which becomes
    ' degenerate after constraints are applied
    '
    Decay = 10000# * MachineEpsilon
    
    '
    ' Scale X, Y, XC, YC
    '
    Call LSFitScaleXY(x, y, N, XC, YC, DC, K, XA, XB, SA, SB, XOriginal, YOriginal)
    
    '
    ' allocate space, initialize:
    ' * SX     -   grid for basis functions
    ' * SY     -   values of basis functions at grid points
    ' * FMatrix-   values of basis functions at X[]
    ' * CMatrix-   values (derivatives) of basis functions at XC[]
    '
    ReDim Y2(0 To N + M - 1)
    ReDim W2(0 To N + M - 1)
    ReDim FMatrix(0 To N + M - 1, 0 To M - 1)
    If K > 0# Then
        ReDim CMatrix(0 To K - 1, 0 To M + 1# - 1)
    End If
    If ST = 0# Then
        
        '
        ' allocate space for cubic spline
        '
        ReDim SX(0 To M - 2# - 1)
        ReDim SY(0 To M - 2# - 1)
        For j = 0# To M - 2# - 1# Step 1
            SX(j) = 2# * j / (M - 2# - 1#) - 1#
        Next j
    End If
    If ST = 1# Then
        
        '
        ' allocate space for Hermite spline
        '
        ReDim SX(0 To M \ 2# - 1)
        ReDim SY(0 To M \ 2# - 1)
        ReDim SD(0 To M \ 2# - 1)
        For j = 0# To M \ 2# - 1# Step 1
            SX(j) = 2# * j / (M \ 2# - 1#) - 1#
        Next j
    End If
    
    '
    ' Prepare design and constraints matrices:
    ' * fill constraints matrix
    ' * fill first N rows of design matrix with values
    ' * fill next M rows of design matrix with regularizing term
    ' * append M zeros to Y
    ' * append M elements, mean(abs(W)) each, to W
    '
    For j = 0# To M - 1# Step 1
        
        '
        ' prepare Jth basis function
        '
        If ST = 0# Then
            
            '
            ' cubic spline basis
            '
            For i = 0# To M - 2# - 1# Step 1
                SY(i) = 0#
            Next i
            BL = 0#
            BR = 0#
            If j < M - 2# Then
                SY(j) = 1#
            End If
            If j = M - 2# Then
                BL = 1#
            End If
            If j = M - 1# Then
                BR = 1#
            End If
            Call Spline1DBuildCubic(SX, SY, M - 2#, 1#, BL, 1#, BR, S2)
        End If
        If ST = 1# Then
            
            '
            ' Hermite basis
            '
            For i = 0# To M \ 2# - 1# Step 1
                SY(i) = 0#
                SD(i) = 0#
            Next i
            If j Mod 2# = 0# Then
                SY(j \ 2#) = 1#
            Else
                SD(j \ 2#) = 1#
            End If
            Call Spline1DBuildHermite(SX, SY, SD, M \ 2#, S2)
        End If
        
        '
        ' values at X[], XC[]
        '
        For i = 0# To N - 1# Step 1
            FMatrix(i, j) = Spline1DCalc(S2, x(i))
        Next i
        For i = 0# To K - 1# Step 1
            Call Spline1DDiff(S2, XC(i), V0, V1, V2)
            If DC(i) = 0# Then
                CMatrix(i, j) = V0
            End If
            If DC(i) = 1# Then
                CMatrix(i, j) = V1
            End If
            If DC(i) = 2# Then
                CMatrix(i, j) = V2
            End If
        Next i
    Next j
    For i = 0# To K - 1# Step 1
        CMatrix(i, M) = YC(i)
    Next i
    For i = 0# To M - 1# Step 1
        For j = 0# To M - 1# Step 1
            If i = j Then
                FMatrix(N + i, j) = Decay
            Else
                FMatrix(N + i, j) = 0#
            End If
        Next j
    Next i
    ReDim Y2(0 To N + M - 1)
    ReDim W2(0 To N + M - 1)
    For i_ = 0# To N - 1# Step 1
        Y2(i_) = y(i_)
    Next i_
    For i_ = 0# To N - 1# Step 1
        W2(i_) = w(i_)
    Next i_
    MX = 0#
    For i = 0# To N - 1# Step 1
        MX = MX + Abs(w(i))
    Next i
    MX = MX / N
    For i = 0# To M - 1# Step 1
        Y2(N + i) = 0#
        W2(N + i) = MX
    Next i
    
    '
    ' Solve constrained task
    '
    If K > 0# Then
        
        '
        ' solve using regularization
        '
        Call LSFitLinearWC(Y2, W2, FMatrix, CMatrix, N + M, M, K, Info, tmp, LRep)
    Else
        
        '
        ' no constraints, no regularization needed
        '
        Call LSFitLinearWC(y, w, FMatrix, CMatrix, N, M, K, Info, tmp, LRep)
    End If
    If Info < 0# Then
        Exit Sub
    End If
    
    '
    ' Generate spline and scale it
    '
    If ST = 0# Then
        
        '
        ' cubic spline basis
        '
        For i_ = 0# To M - 2# - 1# Step 1
            SY(i_) = tmp(i_)
        Next i_
        Call Spline1DBuildCubic(SX, SY, M - 2#, 1#, tmp(M - 2#), 1#, tmp(M - 1#), s)
    End If
    If ST = 1# Then
        
        '
        ' Hermite basis
        '
        For i = 0# To M \ 2# - 1# Step 1
            SY(i) = tmp(2# * i)
            SD(i) = tmp(2# * i + 1#)
        Next i
        Call Spline1DBuildHermite(SX, SY, SD, M \ 2#, s)
    End If
    Call Spline1DLinTransX(s, 2# / (XB - XA), -((XA + XB) / (XB - XA)))
    Call Spline1DLinTransY(s, SB - SA, SA)
    
    '
    ' Scale absolute errors obtained from LSFitLinearW.
    ' Relative error should be calculated separately
    ' (because of shifting/scaling of the task)
    '
    Rep.TaskRCond = LRep.TaskRCond
    Rep.RMSError = LRep.RMSError * (SB - SA)
    Rep.AvgError = LRep.AvgError * (SB - SA)
    Rep.MaxError = LRep.MaxError * (SB - SA)
    Rep.AvgRelError = 0#
    RelCnt = 0#
    For i = 0# To N - 1# Step 1
        If YOriginal(i) <> 0# Then
            Rep.AvgRelError = Rep.AvgRelError + Abs(Spline1DCalc(s, XOriginal(i)) - YOriginal(i)) / Abs(YOriginal(i))
            RelCnt = RelCnt + 1#
        End If
    Next i
    If RelCnt <> 0# Then
        Rep.AvgRelError = Rep.AvgRelError / RelCnt
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal subroutine. Heap sort.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub HeapSortPoints(ByRef x() As Double, _
         ByRef y() As Double, _
         ByVal N As Long)
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim t As Long
    Dim tmp As Double
    Dim IsAscending As Boolean
    Dim IsDescending As Boolean
    
    '
    ' Test for already sorted set
    '
    IsAscending = True
    IsDescending = True
    For i = 1# To N - 1# Step 1
        IsAscending = IsAscending And x(i) > x(i - 1#)
        IsDescending = IsDescending And x(i) < x(i - 1#)
    Next i
    If IsAscending Then
        Exit Sub
    End If
    If IsDescending Then
        For i = 0# To N - 1# Step 1
            j = N - 1# - i
            If j <= i Then
                Exit For
            End If
            tmp = x(i)
            x(i) = x(j)
            x(j) = tmp
            tmp = y(i)
            y(i) = y(j)
            y(j) = tmp
        Next i
        Exit Sub
    End If
    
    '
    ' Special case: N=1
    '
    If N = 1# Then
        Exit Sub
    End If
    
    '
    ' General case
    '
    i = 2#
    Do
        t = i
        Do While t <> 1#
            K = t \ 2#
            If x(K - 1#) >= x(t - 1#) Then
                t = 1#
            Else
                tmp = x(K - 1#)
                x(K - 1#) = x(t - 1#)
                x(t - 1#) = tmp
                tmp = y(K - 1#)
                y(K - 1#) = y(t - 1#)
                y(t - 1#) = tmp
                t = K
            End If
        Loop
        i = i + 1#
    Loop Until Not i <= N
    i = N - 1#
    Do
        tmp = x(i)
        x(i) = x(0#)
        x(0#) = tmp
        tmp = y(i)
        y(i) = y(0#)
        y(0#) = tmp
        t = 1#
        Do While t <> 0#
            K = 2# * t
            If K > i Then
                t = 0#
            Else
                If K < i Then
                    If x(K) > x(K - 1#) Then
                        K = K + 1#
                    End If
                End If
                If x(t - 1#) >= x(K - 1#) Then
                    t = 0#
                Else
                    tmp = x(K - 1#)
                    x(K - 1#) = x(t - 1#)
                    x(t - 1#) = tmp
                    tmp = y(K - 1#)
                    y(K - 1#) = y(t - 1#)
                    y(t - 1#) = tmp
                    t = K
                End If
            End If
        Loop
        i = i - 1#
    Loop Until Not i >= 1#
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal subroutine. Heap sort.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub HeapSortDPoints(ByRef x() As Double, _
         ByRef y() As Double, _
         ByRef d() As Double, _
         ByVal N As Long)
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim t As Long
    Dim tmp As Double
    Dim IsAscending As Boolean
    Dim IsDescending As Boolean
    
    '
    ' Test for already sorted set
    '
    IsAscending = True
    IsDescending = True
    For i = 1# To N - 1# Step 1
        IsAscending = IsAscending And x(i) > x(i - 1#)
        IsDescending = IsDescending And x(i) < x(i - 1#)
    Next i
    If IsAscending Then
        Exit Sub
    End If
    If IsDescending Then
        For i = 0# To N - 1# Step 1
            j = N - 1# - i
            If j <= i Then
                Exit For
            End If
            tmp = x(i)
            x(i) = x(j)
            x(j) = tmp
            tmp = y(i)
            y(i) = y(j)
            y(j) = tmp
            tmp = d(i)
            d(i) = d(j)
            d(j) = tmp
        Next i
        Exit Sub
    End If
    
    '
    ' Special case: N=1
    '
    If N = 1# Then
        Exit Sub
    End If
    
    '
    ' General case
    '
    i = 2#
    Do
        t = i
        Do While t <> 1#
            K = t \ 2#
            If x(K - 1#) >= x(t - 1#) Then
                t = 1#
            Else
                tmp = x(K - 1#)
                x(K - 1#) = x(t - 1#)
                x(t - 1#) = tmp
                tmp = y(K - 1#)
                y(K - 1#) = y(t - 1#)
                y(t - 1#) = tmp
                tmp = d(K - 1#)
                d(K - 1#) = d(t - 1#)
                d(t - 1#) = tmp
                t = K
            End If
        Loop
        i = i + 1#
    Loop Until Not i <= N
    i = N - 1#
    Do
        tmp = x(i)
        x(i) = x(0#)
        x(0#) = tmp
        tmp = y(i)
        y(i) = y(0#)
        y(0#) = tmp
        tmp = d(i)
        d(i) = d(0#)
        d(0#) = tmp
        t = 1#
        Do While t <> 0#
            K = 2# * t
            If K > i Then
                t = 0#
            Else
                If K < i Then
                    If x(K) > x(K - 1#) Then
                        K = K + 1#
                    End If
                End If
                If x(t - 1#) >= x(K - 1#) Then
                    t = 0#
                Else
                    tmp = x(K - 1#)
                    x(K - 1#) = x(t - 1#)
                    x(t - 1#) = tmp
                    tmp = y(K - 1#)
                    y(K - 1#) = y(t - 1#)
                    y(t - 1#) = tmp
                    tmp = d(K - 1#)
                    d(K - 1#) = d(t - 1#)
                    d(t - 1#) = tmp
                    t = K
                End If
            End If
        Loop
        i = i - 1#
    Loop Until Not i >= 1#
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal subroutine. Tridiagonal solver. Solves
'
'( B[0] C[0]                      )
'( A[1] B[1] C[1]                 )
'(      A[2] B[2] C[2]            )
'(            ..........          ) * X = D
'(            ..........          )
'(           A[N-2] B[N-2] C[N-2] )
'(                  A[N-1] B[N-1] )
'
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub SolveTridiagonal(ByRef A_() As Double, _
         ByRef B_() As Double, _
         ByRef C_() As Double, _
         ByRef D_() As Double, _
         ByVal N As Long, _
         ByRef x() As Double)
    Dim a() As Double
    Dim B() As Double
    Dim C() As Double
    Dim d() As Double
    Dim K As Long
    Dim t As Double
    a = A_
    B = B_
    C = C_
    d = D_
    ReDim x(0# To N - 1#)
    a(0#) = 0#
    C(N - 1#) = 0#
    For K = 1# To N - 1# Step 1
        t = a(K) / B(K - 1#)
        B(K) = B(K) - t * C(K - 1#)
        d(K) = d(K) - t * d(K - 1#)
    Next K
    x(N - 1#) = d(N - 1#) / B(N - 1#)
    For K = N - 2# To 0# Step -1
        x(K) = (d(K) - C(K) * x(K + 1#)) / B(K)
    Next K
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal subroutine. Cyclic tridiagonal solver. Solves
'
'( B[0] C[0]                 A[0] )
'( A[1] B[1] C[1]                 )
'(      A[2] B[2] C[2]            )
'(            ..........          ) * X = D
'(            ..........          )
'(           A[N-2] B[N-2] C[N-2] )
'( C[N-1]           A[N-1] B[N-1] )
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub SolveCyclicTridiagonal(ByRef a() As Double, _
         ByRef B_() As Double, _
         ByRef C() As Double, _
         ByRef d() As Double, _
         ByVal N As Long, _
         ByRef x() As Double)
    Dim B() As Double
    Dim K As Long
    Dim t As Double
    Dim alpha As Double
    Dim beta As Double
    Dim Gamma As Double
    Dim y() As Double
    Dim z() As Double
    Dim U() As Double
    B = B_
    beta = a(0#)
    alpha = C(N - 1#)
    Gamma = -B(0#)
    B(0#) = 2# * B(0#)
    B(N - 1#) = B(N - 1#) - alpha * beta / Gamma
    ReDim U(0 To N - 1)
    For K = 0# To N - 1# Step 1
        U(K) = 0#
    Next K
    U(0#) = Gamma
    U(N - 1#) = alpha
    Call SolveTridiagonal(a, B, C, d, N, y)
    Call SolveTridiagonal(a, B, C, U, N, z)
    ReDim x(0 To N - 1)
    For K = 0# To N - 1# Step 1
        x(K) = y(K) - (y(0#) + beta / Gamma * y(N - 1#)) / (1# + z(0#) + beta / Gamma * z(N - 1#)) * z(K)
    Next K
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal subroutine. Three-point differentiation
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Function DiffThreePoint(ByVal t As Double, _
         ByVal X0 As Double, _
         ByVal F0 As Double, _
         ByVal X1 As Double, _
         ByVal F1 As Double, _
         ByVal X2 As Double, _
         ByVal F2 As Double) As Double
    Dim Result As Double
    Dim a As Double
    Dim B As Double
    t = t - X0
    X1 = X1 - X0
    X2 = X2 - X0
    a = (F2 - F0 - X2 / X1 * (F1 - F0)) / (Square(X2) - X1 * X2)
    B = (F1 - F0 - a * Square(X1)) / X1
    Result = 2# * a * t + B
    DiffThreePoint = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2007, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This subroutine builds bilinear spline coefficients table.
'
'Input parameters:
'    X   -   spline abscissas, array[0..N-1]
'    Y   -   spline ordinates, array[0..M-1]
'    F   -   function values, array[0..M-1,0..N-1]
'    M,N -   grid size, M>=2, N>=2
'
'Output parameters:
'    C   -   spline interpolant
'
'  -- ALGLIB PROJECT --
'     Copyright 05.07.2007 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub Spline2DBuildBilinear(ByRef x_() As Double, _
         ByRef y_() As Double, _
         ByRef F_() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef C As Spline2DInterpolant)
    Dim x() As Double
    Dim y() As Double
    Dim f() As Double
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim TblSize As Long
    Dim shift As Long
    Dim t As Double
    Dim DX() As Double
    Dim DY() As Double
    Dim DXY() As Double
    x = x_
    y = y_
    f = F_
    
    '
    ' Sort points
    '
    For j = 0# To N - 1# Step 1
        K = j
        For i = j + 1# To N - 1# Step 1
            If x(i) < x(K) Then
                K = i
            End If
        Next i
        If K <> j Then
            For i = 0# To M - 1# Step 1
                t = f(i, j)
                f(i, j) = f(i, K)
                f(i, K) = t
            Next i
            t = x(j)
            x(j) = x(K)
            x(K) = t
        End If
    Next j
    For i = 0# To M - 1# Step 1
        K = i
        For j = i + 1# To M - 1# Step 1
            If y(j) < y(K) Then
                K = j
            End If
        Next j
        If K <> i Then
            For j = 0# To N - 1# Step 1
                t = f(i, j)
                f(i, j) = f(K, j)
                f(K, j) = t
            Next j
            t = y(i)
            y(i) = y(K)
            y(K) = t
        End If
    Next i
    
    '
    ' Fill C:
    '  C[0]            -   length(C)
    '  C[1]            -   type(C):
    '                      -1 = bilinear interpolant
    '                      -3 = general cubic spline
    '                           (see BuildBicubicSpline)
    '  C[2]:
    '      N (x count)
    '  C[3]:
    '      M (y count)
    '  C[4]...C[4+N-1]:
    '      x[i], i = 0...N-1
    '  C[4+N]...C[4+N+M-1]:
    '      y[i], i = 0...M-1
    '  C[4+N+M]...C[4+N+M+(N*M-1)]:
    '      f(i,j) table. f(0,0), f(0, 1), f(0,2) and so on...
    '
    C.K = 1#
    TblSize = 4# + N + M + N * M
    ReDim C.C(0# To TblSize - 1#)
    C.C(0#) = TblSize
    C.C(1#) = -1#
    C.C(2#) = N
    C.C(3#) = M
    For i = 0# To N - 1# Step 1
        C.C(4# + i) = x(i)
    Next i
    For i = 0# To M - 1# Step 1
        C.C(4# + N + i) = y(i)
    Next i
    For i = 0# To M - 1# Step 1
        For j = 0# To N - 1# Step 1
            shift = i * N + j
            C.C(4# + N + M + shift) = f(i, j)
        Next j
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This subroutine builds bicubic spline coefficients table.
'
'Input parameters:
'    X   -   spline abscissas, array[0..N-1]
'    Y   -   spline ordinates, array[0..M-1]
'    F   -   function values, array[0..M-1,0..N-1]
'    M,N -   grid size, M>=2, N>=2
'
'Output parameters:
'    C   -   spline interpolant
'
'  -- ALGLIB PROJECT --
'     Copyright 05.07.2007 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub Spline2DBuildBicubic(ByRef x_() As Double, _
         ByRef y_() As Double, _
         ByRef F_() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef C As Spline2DInterpolant)
    Dim x() As Double
    Dim y() As Double
    Dim f() As Double
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim TblSize As Long
    Dim shift As Long
    Dim t As Double
    Dim DX() As Double
    Dim DY() As Double
    Dim DXY() As Double
    x = x_
    y = y_
    f = F_
    
    '
    ' Sort points
    '
    For j = 0# To N - 1# Step 1
        K = j
        For i = j + 1# To N - 1# Step 1
            If x(i) < x(K) Then
                K = i
            End If
        Next i
        If K <> j Then
            For i = 0# To M - 1# Step 1
                t = f(i, j)
                f(i, j) = f(i, K)
                f(i, K) = t
            Next i
            t = x(j)
            x(j) = x(K)
            x(K) = t
        End If
    Next j
    For i = 0# To M - 1# Step 1
        K = i
        For j = i + 1# To M - 1# Step 1
            If y(j) < y(K) Then
                K = j
            End If
        Next j
        If K <> i Then
            For j = 0# To N - 1# Step 1
                t = f(i, j)
                f(i, j) = f(K, j)
                f(K, j) = t
            Next j
            t = y(i)
            y(i) = y(K)
            y(K) = t
        End If
    Next i
    
    '
    ' Fill C:
    '  C[0]            -   length(C)
    '  C[1]            -   type(C):
    '                      -1 = bilinear interpolant
    '                           (see BuildBilinearInterpolant)
    '                      -3 = general cubic spline
    '  C[2]:
    '      N (x count)
    '  C[3]:
    '      M (y count)
    '  C[4]...C[4+N-1]:
    '      x[i], i = 0...N-1
    '  C[4+N]...C[4+N+M-1]:
    '      y[i], i = 0...M-1
    '  C[4+N+M]...C[4+N+M+(N*M-1)]:
    '      f(i,j) table. f(0,0), f(0, 1), f(0,2) and so on...
    '  C[4+N+M+N*M]...C[4+N+M+(2*N*M-1)]:
    '      df(i,j)/dx table.
    '  C[4+N+M+2*N*M]...C[4+N+M+(3*N*M-1)]:
    '      df(i,j)/dy table.
    '  C[4+N+M+3*N*M]...C[4+N+M+(4*N*M-1)]:
    '      d2f(i,j)/dxdy table.
    '
    C.K = 3#
    TblSize = 4# + N + M + 4# * N * M
    ReDim C.C(0# To TblSize - 1#)
    C.C(0#) = TblSize
    C.C(1#) = -3#
    C.C(2#) = N
    C.C(3#) = M
    For i = 0# To N - 1# Step 1
        C.C(4# + i) = x(i)
    Next i
    For i = 0# To M - 1# Step 1
        C.C(4# + N + i) = y(i)
    Next i
    Call BicubicCalcDerivatives(f, x, y, M, N, DX, DY, DXY)
    For i = 0# To M - 1# Step 1
        For j = 0# To N - 1# Step 1
            shift = i * N + j
            C.C(4# + N + M + shift) = f(i, j)
            C.C(4# + N + M + N * M + shift) = DX(i, j)
            C.C(4# + N + M + 2# * N * M + shift) = DY(i, j)
            C.C(4# + N + M + 3# * N * M + shift) = DXY(i, j)
        Next j
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This subroutine calculates the value of the bilinear or bicubic spline  at
'the given point X.
'
'Input parameters:
'    C   -   coefficients table.
'            Built by BuildBilinearSpline or BuildBicubicSpline.
'    X, Y-   point
'
'Result:
'    S(x,y)
'
'  -- ALGLIB PROJECT --
'     Copyright 05.07.2007 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function Spline2DCalc(ByRef C As Spline2DInterpolant, _
         ByVal x As Double, _
         ByVal y As Double) As Double
    Dim Result As Double
    Dim V As Double
    Dim VX As Double
    Dim VY As Double
    Dim VXY As Double
    Call Spline2DDiff(C, x, y, V, VX, VY, VXY)
    Result = V
    Spline2DCalc = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This subroutine calculates the value of the bilinear or bicubic spline  at
'the given point X and its derivatives.
'
'Input parameters:
'    C   -   spline interpolant.
'    X, Y-   point
'
'Output parameters:
'    F   -   S(x,y)
'    FX  -   dS(x,y)/dX
'    FY  -   dS(x,y)/dY
'    FXY -   d2S(x,y)/dXdY
'
'  -- ALGLIB PROJECT --
'     Copyright 05.07.2007 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub Spline2DDiff(ByRef C As Spline2DInterpolant, _
         ByVal x As Double, _
         ByVal y As Double, _
         ByRef f As Double, _
         ByRef FX As Double, _
         ByRef FY As Double, _
         ByRef FXY As Double)
    Dim N As Long
    Dim M As Long
    Dim t As Double
    Dim dt As Double
    Dim U As Double
    Dim DU As Double
    Dim IX As Long
    Dim IY As Long
    Dim L As Long
    Dim R As Long
    Dim h As Long
    Dim Shift1 As Long
    Dim S1 As Long
    Dim S2 As Long
    Dim S3 As Long
    Dim S4 As Long
    Dim SF As Long
    Dim SFX As Long
    Dim SFY As Long
    Dim SFXY As Long
    Dim Y1 As Double
    Dim Y2 As Double
    Dim Y3 As Double
    Dim Y4 As Double
    Dim V As Double
    Dim T0 As Double
    Dim T1 As Double
    Dim T2 As Double
    Dim T3 As Double
    Dim U0 As Double
    Dim U1 As Double
    Dim U2 As Double
    Dim U3 As Double
    N = Round(C.C(2#))
    M = Round(C.C(3#))
    
    '
    ' Binary search in the [ x[0], ..., x[n-2] ] (x[n-1] is not included)
    '
    L = 4#
    R = 4# + N - 2# + 1#
    Do While L <> R - 1#
        h = (L + R) \ 2#
        If C.C(h) >= x Then
            R = h
        Else
            L = h
        End If
    Loop
    t = (x - C.C(L)) / (C.C(L + 1#) - C.C(L))
    dt = 1# / (C.C(L + 1#) - C.C(L))
    IX = L - 4#
    
    '
    ' Binary search in the [ y[0], ..., y[m-2] ] (y[m-1] is not included)
    '
    L = 4# + N
    R = 4# + N + (M - 2#) + 1#
    Do While L <> R - 1#
        h = (L + R) \ 2#
        If C.C(h) >= y Then
            R = h
        Else
            L = h
        End If
    Loop
    U = (y - C.C(L)) / (C.C(L + 1#) - C.C(L))
    DU = 1# / (C.C(L + 1#) - C.C(L))
    IY = L - (4# + N)
    
    '
    ' Prepare F, dF/dX, dF/dY, d2F/dXdY
    '
    f = 0#
    FX = 0#
    FY = 0#
    FXY = 0#
    
    '
    ' Bilinear interpolation
    '
    If Round(C.C(1#)) = -1# Then
        Shift1 = 4# + N + M
        Y1 = C.C(Shift1 + N * IY + IX)
        Y2 = C.C(Shift1 + N * IY + (IX + 1#))
        Y3 = C.C(Shift1 + N * (IY + 1#) + (IX + 1#))
        Y4 = C.C(Shift1 + N * (IY + 1#) + IX)
        f = (1# - t) * (1# - U) * Y1 + t * (1# - U) * Y2 + t * U * Y3 + (1# - t) * U * Y4
        FX = (-((1# - U) * Y1) + (1# - U) * Y2 + U * Y3 - U * Y4) * dt
        FY = (-((1# - t) * Y1) - t * Y2 + t * Y3 + (1# - t) * Y4) * DU
        FXY = (Y1 - Y2 + Y3 - Y4) * DU * dt
        Exit Sub
    End If
    
    '
    ' Bicubic interpolation
    '
    If Round(C.C(1#)) = -3# Then
        
        '
        ' Prepare info
        '
        T0 = 1#
        T1 = t
        T2 = Square(t)
        T3 = t * T2
        U0 = 1#
        U1 = U
        U2 = Square(U)
        U3 = U * U2
        SF = 4# + N + M
        SFX = 4# + N + M + N * M
        SFY = 4# + N + M + 2# * N * M
        SFXY = 4# + N + M + 3# * N * M
        S1 = N * IY + IX
        S2 = N * IY + (IX + 1#)
        S3 = N * (IY + 1#) + (IX + 1#)
        S4 = N * (IY + 1#) + IX
        
        '
        ' Calculate
        '
        V = (1# * C.C(SF + S1))
        f = f + V * T0 * U0
        V = (1# * C.C(SFY + S1) / DU)
        f = f + V * T0 * U1
        FY = FY + 1# * V * T0 * U0 * DU
        V = -(3# * C.C(SF + S1)) + 3# * C.C(SF + S4) - 2# * C.C(SFY + S1) / DU - 1# * C.C(SFY + S4) / DU
        f = f + V * T0 * U2
        FY = FY + 2# * V * T0 * U1 * DU
        V = (2# * C.C(SF + S1)) - 2# * C.C(SF + S4) + 1# * C.C(SFY + S1) / DU + 1# * C.C(SFY + S4) / DU
        f = f + V * T0 * U3
        FY = FY + 3# * V * T0 * U2 * DU
        V = (1# * C.C(SFX + S1) / dt)
        f = f + V * T1 * U0
        FX = FX + 1# * V * T0 * U0 * dt
        V = (1# * C.C(SFXY + S1) / (dt * DU))
        f = f + V * T1 * U1
        FX = FX + 1# * V * T0 * U1 * dt
        FY = FY + 1# * V * T1 * U0 * DU
        FXY = FXY + 1# * V * T0 * U0 * dt * DU
        V = -(3# * C.C(SFX + S1) / dt) + 3# * C.C(SFX + S4) / dt - 2# * C.C(SFXY + S1) / (dt * DU) - 1# * C.C(SFXY + S4) / (dt * DU)
        f = f + V * T1 * U2
        FX = FX + 1# * V * T0 * U2 * dt
        FY = FY + 2# * V * T1 * U1 * DU
        FXY = FXY + 2# * V * T0 * U1 * dt * DU
        V = (2# * C.C(SFX + S1) / dt) - 2# * C.C(SFX + S4) / dt + 1# * C.C(SFXY + S1) / (dt * DU) + 1# * C.C(SFXY + S4) / (dt * DU)
        f = f + V * T1 * U3
        FX = FX + 1# * V * T0 * U3 * dt
        FY = FY + 3# * V * T1 * U2 * DU
        FXY = FXY + 3# * V * T0 * U2 * dt * DU
        V = -(3# * C.C(SF + S1)) + 3# * C.C(SF + S2) - 2# * C.C(SFX + S1) / dt - 1# * C.C(SFX + S2) / dt
        f = f + V * T2 * U0
        FX = FX + 2# * V * T1 * U0 * dt
        V = -(3# * C.C(SFY + S1) / DU) + 3# * C.C(SFY + S2) / DU - 2# * C.C(SFXY + S1) / (dt * DU) - 1# * C.C(SFXY + S2) / (dt * DU)
        f = f + V * T2 * U1
        FX = FX + 2# * V * T1 * U1 * dt
        FY = FY + 1# * V * T2 * U0 * DU
        FXY = FXY + 2# * V * T1 * U0 * dt * DU
        V = (9# * C.C(SF + S1)) - 9# * C.C(SF + S2) + 9# * C.C(SF + S3) - 9# * C.C(SF + S4) + 6# * C.C(SFX + S1) / dt + 3# * C.C(SFX + S2) / dt - 3# * C.C(SFX + S3) / dt - 6# * C.C(SFX + S4) / dt + 6# * C.C(SFY + S1) / DU - 6# * C.C(SFY + S2) / DU - 3# * C.C(SFY + S3) / DU + 3# * C.C(SFY + S4) / DU + 4# * C.C(SFXY + S1) / (dt * DU) + 2# * C.C(SFXY + S2) / (dt * DU) + 1# * C.C(SFXY + S3) / (dt * DU) + 2# * C.C(SFXY + S4) / (dt * DU)
        f = f + V * T2 * U2
        FX = FX + 2# * V * T1 * U2 * dt
        FY = FY + 2# * V * T2 * U1 * DU
        FXY = FXY + 4# * V * T1 * U1 * dt * DU
        V = -(6# * C.C(SF + S1)) + 6# * C.C(SF + S2) - 6# * C.C(SF + S3) + 6# * C.C(SF + S4) - 4# * C.C(SFX + S1) / dt - 2# * C.C(SFX + S2) / dt + 2# * C.C(SFX + S3) / dt + 4# * C.C(SFX + S4) / dt - 3# * C.C(SFY + S1) / DU + 3# * C.C(SFY + S2) / DU + 3# * C.C(SFY + S3) / DU - 3# * C.C(SFY + S4) / DU - 2# * C.C(SFXY + S1) / (dt * DU) - 1# * C.C(SFXY + S2) / (dt * DU) - 1# * C.C(SFXY + S3) / (dt * DU) - 2# * C.C(SFXY + S4) / (dt * DU)
        f = f + V * T2 * U3
        FX = FX + 2# * V * T1 * U3 * dt
        FY = FY + 3# * V * T2 * U2 * DU
        FXY = FXY + 6# * V * T1 * U2 * dt * DU
        V = (2# * C.C(SF + S1)) - 2# * C.C(SF + S2) + 1# * C.C(SFX + S1) / dt + 1# * C.C(SFX + S2) / dt
        f = f + V * T3 * U0
        FX = FX + 3# * V * T2 * U0 * dt
        V = (2# * C.C(SFY + S1) / DU) - 2# * C.C(SFY + S2) / DU + 1# * C.C(SFXY + S1) / (dt * DU) + 1# * C.C(SFXY + S2) / (dt * DU)
        f = f + V * T3 * U1
        FX = FX + 3# * V * T2 * U1 * dt
        FY = FY + 1# * V * T3 * U0 * DU
        FXY = FXY + 3# * V * T2 * U0 * dt * DU
        V = -(6# * C.C(SF + S1)) + 6# * C.C(SF + S2) - 6# * C.C(SF + S3) + 6# * C.C(SF + S4) - 3# * C.C(SFX + S1) / dt - 3# * C.C(SFX + S2) / dt + 3# * C.C(SFX + S3) / dt + 3# * C.C(SFX + S4) / dt - 4# * C.C(SFY + S1) / DU + 4# * C.C(SFY + S2) / DU + 2# * C.C(SFY + S3) / DU - 2# * C.C(SFY + S4) / DU - 2# * C.C(SFXY + S1) / (dt * DU) - 2# * C.C(SFXY + S2) / (dt * DU) - 1# * C.C(SFXY + S3) / (dt * DU) - 1# * C.C(SFXY + S4) / (dt * DU)
        f = f + V * T3 * U2
        FX = FX + 3# * V * T2 * U2 * dt
        FY = FY + 2# * V * T3 * U1 * DU
        FXY = FXY + 6# * V * T2 * U1 * dt * DU
        V = (4# * C.C(SF + S1)) - 4# * C.C(SF + S2) + 4# * C.C(SF + S3) - 4# * C.C(SF + S4) + 2# * C.C(SFX + S1) / dt + 2# * C.C(SFX + S2) / dt - 2# * C.C(SFX + S3) / dt - 2# * C.C(SFX + S4) / dt + 2# * C.C(SFY + S1) / DU - 2# * C.C(SFY + S2) / DU - 2# * C.C(SFY + S3) / DU + 2# * C.C(SFY + S4) / DU + 1# * C.C(SFXY + S1) / (dt * DU) + 1# * C.C(SFXY + S2) / (dt * DU) + 1# * C.C(SFXY + S3) / (dt * DU) + 1# * C.C(SFXY + S4) / (dt * DU)
        f = f + V * T3 * U3
        FX = FX + 3# * V * T2 * U3 * dt
        FY = FY + 3# * V * T3 * U2 * DU
        FXY = FXY + 9# * V * T2 * U2 * dt * DU
        Exit Sub
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This subroutine unpacks two-dimensional spline into the coefficients table
'
'Input parameters:
'    C   -   spline interpolant.
'
'Result:
'    M, N-   grid size (x-axis and y-axis)
'    Tbl -   coefficients table, unpacked format,
'            [0..(N-1)*(M-1)-1, 0..19].
'            For I = 0...M-2, J=0..N-2:
'                K =  I*(N-1)+J
'                Tbl[K,0] = X[j]
'                Tbl[K,1] = X[j+1]
'                Tbl[K,2] = Y[i]
'                Tbl[K,3] = Y[i+1]
'                Tbl[K,4] = C00
'                Tbl[K,5] = C01
'                Tbl[K,6] = C02
'                Tbl[K,7] = C03
'                Tbl[K,8] = C10
'                Tbl[K,9] = C11
'                ...
'                Tbl[K,19] = C33
'            On each grid square spline is equals to:
'                S(x) = SUM(c[i,j]*(x^i)*(y^j), i=0..3, j=0..3)
'                t = x-x[j]
'                u = y-y[i]
'
'  -- ALGLIB PROJECT --
'     Copyright 29.06.2007 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub Spline2DUnpack(ByRef C As Spline2DInterpolant, _
         ByRef M As Long, _
         ByRef N As Long, _
         ByRef Tbl() As Double)
    Dim i As Long
    Dim j As Long
    Dim CI As Long
    Dim CJ As Long
    Dim K As Long
    Dim p As Long
    Dim shift As Long
    Dim S1 As Long
    Dim S2 As Long
    Dim S3 As Long
    Dim S4 As Long
    Dim SF As Long
    Dim SFX As Long
    Dim SFY As Long
    Dim SFXY As Long
    Dim Y1 As Double
    Dim Y2 As Double
    Dim Y3 As Double
    Dim Y4 As Double
    Dim dt As Double
    Dim DU As Double
    N = Round(C.C(2#))
    M = Round(C.C(3#))
    ReDim Tbl(0# To (N - 1#) * (M - 1#) - 1#, 0# To 19#)
    
    '
    ' Fill
    '
    For i = 0# To M - 2# Step 1
        For j = 0# To N - 2# Step 1
            p = i * (N - 1#) + j
            Tbl(p, 0#) = C.C(4# + j)
            Tbl(p, 1#) = C.C(4# + j + 1#)
            Tbl(p, 2#) = C.C(4# + N + i)
            Tbl(p, 3#) = C.C(4# + N + i + 1#)
            dt = 1# / (Tbl(p, 1#) - Tbl(p, 0#))
            DU = 1# / (Tbl(p, 3#) - Tbl(p, 2#))
            
            '
            ' Bilinear interpolation
            '
            If Round(C.C(1#)) = -1# Then
                For K = 4# To 19# Step 1
                    Tbl(p, K) = 0#
                Next K
                shift = 4# + N + M
                Y1 = C.C(shift + N * i + j)
                Y2 = C.C(shift + N * i + (j + 1#))
                Y3 = C.C(shift + N * (i + 1#) + (j + 1#))
                Y4 = C.C(shift + N * (i + 1#) + j)
                Tbl(p, 4#) = Y1
                Tbl(p, 4# + 1# * 4# + 0#) = Y2 - Y1
                Tbl(p, 4# + 0# * 4# + 1#) = Y4 - Y1
                Tbl(p, 4# + 1# * 4# + 1#) = Y3 - Y2 - Y4 + Y1
            End If
            
            '
            ' Bicubic interpolation
            '
            If Round(C.C(1#)) = -3# Then
                SF = 4# + N + M
                SFX = 4# + N + M + N * M
                SFY = 4# + N + M + 2# * N * M
                SFXY = 4# + N + M + 3# * N * M
                S1 = N * i + j
                S2 = N * i + (j + 1#)
                S3 = N * (i + 1#) + (j + 1#)
                S4 = N * (i + 1#) + j
                Tbl(p, 4# + 0# * 4# + 0#) = (1# * C.C(SF + S1))
                Tbl(p, 4# + 0# * 4# + 1#) = (1# * C.C(SFY + S1) / DU)
                Tbl(p, 4# + 0# * 4# + 2#) = -(3# * C.C(SF + S1)) + 3# * C.C(SF + S4) - 2# * C.C(SFY + S1) / DU - 1# * C.C(SFY + S4) / DU
                Tbl(p, 4# + 0# * 4# + 3#) = (2# * C.C(SF + S1)) - 2# * C.C(SF + S4) + 1# * C.C(SFY + S1) / DU + 1# * C.C(SFY + S4) / DU
                Tbl(p, 4# + 1# * 4# + 0#) = (1# * C.C(SFX + S1) / dt)
                Tbl(p, 4# + 1# * 4# + 1#) = (1# * C.C(SFXY + S1) / (dt * DU))
                Tbl(p, 4# + 1# * 4# + 2#) = -(3# * C.C(SFX + S1) / dt) + 3# * C.C(SFX + S4) / dt - 2# * C.C(SFXY + S1) / (dt * DU) - 1# * C.C(SFXY + S4) / (dt * DU)
                Tbl(p, 4# + 1# * 4# + 3#) = (2# * C.C(SFX + S1) / dt) - 2# * C.C(SFX + S4) / dt + 1# * C.C(SFXY + S1) / (dt * DU) + 1# * C.C(SFXY + S4) / (dt * DU)
                Tbl(p, 4# + 2# * 4# + 0#) = -(3# * C.C(SF + S1)) + 3# * C.C(SF + S2) - 2# * C.C(SFX + S1) / dt - 1# * C.C(SFX + S2) / dt
                Tbl(p, 4# + 2# * 4# + 1#) = -(3# * C.C(SFY + S1) / DU) + 3# * C.C(SFY + S2) / DU - 2# * C.C(SFXY + S1) / (dt * DU) - 1# * C.C(SFXY + S2) / (dt * DU)
                Tbl(p, 4# + 2# * 4# + 2#) = (9# * C.C(SF + S1)) - 9# * C.C(SF + S2) + 9# * C.C(SF + S3) - 9# * C.C(SF + S4) + 6# * C.C(SFX + S1) / dt + 3# * C.C(SFX + S2) / dt - 3# * C.C(SFX + S3) / dt - 6# * C.C(SFX + S4) / dt + 6# * C.C(SFY + S1) / DU - 6# * C.C(SFY + S2) / DU - 3# * C.C(SFY + S3) / DU + 3# * C.C(SFY + S4) / DU + 4# * C.C(SFXY + S1) / (dt * DU) + 2# * C.C(SFXY + S2) / (dt * DU) + 1# * C.C(SFXY + S3) / (dt * DU) + 2# * C.C(SFXY + S4) / (dt * DU)
                Tbl(p, 4# + 2# * 4# + 3#) = -(6# * C.C(SF + S1)) + 6# * C.C(SF + S2) - 6# * C.C(SF + S3) + 6# * C.C(SF + S4) - 4# * C.C(SFX + S1) / dt - 2# * C.C(SFX + S2) / dt + 2# * C.C(SFX + S3) / dt + 4# * C.C(SFX + S4) / dt - 3# * C.C(SFY + S1) / DU + 3# * C.C(SFY + S2) / DU + 3# * C.C(SFY + S3) / DU - 3# * C.C(SFY + S4) / DU - 2# * C.C(SFXY + S1) / (dt * DU) - 1# * C.C(SFXY + S2) / (dt * DU) - 1# * C.C(SFXY + S3) / (dt * DU) - 2# * C.C(SFXY + S4) / (dt * DU)
                Tbl(p, 4# + 3# * 4# + 0#) = (2# * C.C(SF + S1)) - 2# * C.C(SF + S2) + 1# * C.C(SFX + S1) / dt + 1# * C.C(SFX + S2) / dt
                Tbl(p, 4# + 3# * 4# + 1#) = (2# * C.C(SFY + S1) / DU) - 2# * C.C(SFY + S2) / DU + 1# * C.C(SFXY + S1) / (dt * DU) + 1# * C.C(SFXY + S2) / (dt * DU)
                Tbl(p, 4# + 3# * 4# + 2#) = -(6# * C.C(SF + S1)) + 6# * C.C(SF + S2) - 6# * C.C(SF + S3) + 6# * C.C(SF + S4) - 3# * C.C(SFX + S1) / dt - 3# * C.C(SFX + S2) / dt + 3# * C.C(SFX + S3) / dt + 3# * C.C(SFX + S4) / dt - 4# * C.C(SFY + S1) / DU + 4# * C.C(SFY + S2) / DU + 2# * C.C(SFY + S3) / DU - 2# * C.C(SFY + S4) / DU - 2# * C.C(SFXY + S1) / (dt * DU) - 2# * C.C(SFXY + S2) / (dt * DU) - 1# * C.C(SFXY + S3) / (dt * DU) - 1# * C.C(SFXY + S4) / (dt * DU)
                Tbl(p, 4# + 3# * 4# + 3#) = (4# * C.C(SF + S1)) - 4# * C.C(SF + S2) + 4# * C.C(SF + S3) - 4# * C.C(SF + S4) + 2# * C.C(SFX + S1) / dt + 2# * C.C(SFX + S2) / dt - 2# * C.C(SFX + S3) / dt - 2# * C.C(SFX + S4) / dt + 2# * C.C(SFY + S1) / DU - 2# * C.C(SFY + S2) / DU - 2# * C.C(SFY + S3) / DU + 2# * C.C(SFY + S4) / DU + 1# * C.C(SFXY + S1) / (dt * DU) + 1# * C.C(SFXY + S2) / (dt * DU) + 1# * C.C(SFXY + S3) / (dt * DU) + 1# * C.C(SFXY + S4) / (dt * DU)
            End If
            
            '
            ' Rescale Cij
            '
            For CI = 0# To 3# Step 1
                For CJ = 0# To 3# Step 1
                    Tbl(p, 4# + CI * 4# + CJ) = Tbl(p, 4# + CI * 4# + CJ) * Power(dt, CI) * Power(DU, CJ)
                Next CJ
            Next CI
        Next j
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This subroutine performs linear transformation of the spline argument.
'
'Input parameters:
'    C       -   spline interpolant
'    AX, BX  -   transformation coefficients: x = A*t + B
'    AY, BY  -   transformation coefficients: y = A*u + B
'Result:
'    C   -   transformed spline
'
'  -- ALGLIB PROJECT --
'     Copyright 30.06.2007 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub Spline2DLinTransXY(ByRef C As Spline2DInterpolant, _
         ByVal AX As Double, _
         ByVal BX As Double, _
         ByVal AY As Double, _
         ByVal BY As Double)
    Dim i As Long
    Dim j As Long
    Dim N As Long
    Dim M As Long
    Dim V As Double
    Dim x() As Double
    Dim y() As Double
    Dim f() As Double
    Dim TypeC As Long
    TypeC = Round(C.C(1#))
    N = Round(C.C(2#))
    M = Round(C.C(3#))
    ReDim x(0# To N - 1#)
    ReDim y(0# To M - 1#)
    ReDim f(0# To M - 1#, 0# To N - 1#)
    For j = 0# To N - 1# Step 1
        x(j) = C.C(4# + j)
    Next j
    For i = 0# To M - 1# Step 1
        y(i) = C.C(4# + N + i)
    Next i
    For i = 0# To M - 1# Step 1
        For j = 0# To N - 1# Step 1
            f(i, j) = C.C(4# + N + M + i * N + j)
        Next j
    Next i
    
    '
    ' Special case: AX=0 or AY=0
    '
    If AX = 0# Then
        For i = 0# To M - 1# Step 1
            V = Spline2DCalc(C, BX, y(i))
            For j = 0# To N - 1# Step 1
                f(i, j) = V
            Next j
        Next i
        If TypeC = -3# Then
            Call Spline2DBuildBicubic(x, y, f, M, N, C)
        End If
        If TypeC = -1# Then
            Call Spline2DBuildBilinear(x, y, f, M, N, C)
        End If
        AX = 1#
        BX = 0#
    End If
    If AY = 0# Then
        For j = 0# To N - 1# Step 1
            V = Spline2DCalc(C, x(j), BY)
            For i = 0# To M - 1# Step 1
                f(i, j) = V
            Next i
        Next j
        If TypeC = -3# Then
            Call Spline2DBuildBicubic(x, y, f, M, N, C)
        End If
        If TypeC = -1# Then
            Call Spline2DBuildBilinear(x, y, f, M, N, C)
        End If
        AY = 1#
        BY = 0#
    End If
    
    '
    ' General case: AX<>0, AY<>0
    ' Unpack, scale and pack again.
    '
    For j = 0# To N - 1# Step 1
        x(j) = (x(j) - BX) / AX
    Next j
    For i = 0# To M - 1# Step 1
        y(i) = (y(i) - BY) / AY
    Next i
    If TypeC = -3# Then
        Call Spline2DBuildBicubic(x, y, f, M, N, C)
    End If
    If TypeC = -1# Then
        Call Spline2DBuildBilinear(x, y, f, M, N, C)
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This subroutine performs linear transformation of the spline.
'
'Input parameters:
'    C   -   spline interpolant.
'    A, B-   transformation coefficients: S2(x,y) = A*S(x,y) + B
'
'Output parameters:
'    C   -   transformed spline
'
'  -- ALGLIB PROJECT --
'     Copyright 30.06.2007 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub Spline2DLinTransF(ByRef C As Spline2DInterpolant, _
         ByVal a As Double, _
         ByVal B As Double)
    Dim i As Long
    Dim j As Long
    Dim N As Long
    Dim M As Long
    Dim x() As Double
    Dim y() As Double
    Dim f() As Double
    Dim TypeC As Long
    TypeC = Round(C.C(1#))
    N = Round(C.C(2#))
    M = Round(C.C(3#))
    ReDim x(0# To N - 1#)
    ReDim y(0# To M - 1#)
    ReDim f(0# To M - 1#, 0# To N - 1#)
    For j = 0# To N - 1# Step 1
        x(j) = C.C(4# + j)
    Next j
    For i = 0# To M - 1# Step 1
        y(i) = C.C(4# + N + i)
    Next i
    For i = 0# To M - 1# Step 1
        For j = 0# To N - 1# Step 1
            f(i, j) = a * C.C(4# + N + M + i * N + j) + B
        Next j
    Next i
    If TypeC = -3# Then
        Call Spline2DBuildBicubic(x, y, f, M, N, C)
    End If
    If TypeC = -1# Then
        Call Spline2DBuildBilinear(x, y, f, M, N, C)
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This subroutine makes the copy of the spline model.
'
'Input parameters:
'    C   -   spline interpolant
'
'Output parameters:
'    CC  -   spline copy
'
'  -- ALGLIB PROJECT --
'     Copyright 29.06.2007 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub Spline2DCopy(ByRef C As Spline2DInterpolant, _
         ByRef CC As Spline2DInterpolant)
    Dim N As Long
    Dim i_ As Long
    CC.K = C.K
    N = Round(C.C(0#))
    ReDim CC.C(0 To N - 1)
    For i_ = 0# To N - 1# Step 1
        CC.C(i_) = C.C(i_)
    Next i_
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Serialization of the spline interpolant
'
'INPUT PARAMETERS:
'    B   -   spline interpolant
'
'OUTPUT PARAMETERS:
'    RA      -   array of real numbers which contains interpolant,
'                array[0..RLen-1]
'    RLen    -   RA lenght
'
'  -- ALGLIB --
'     Copyright 17.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub Spline2DSerialize(ByRef C As Spline2DInterpolant, _
         ByRef RA() As Double, _
         ByRef RALen As Long)
    Dim CLen As Long
    Dim i_ As Long
    Dim i1_ As Long
    CLen = Round(C.C(0#))
    RALen = 3# + CLen
    ReDim RA(0 To RALen - 1)
    RA(0#) = RALen
    RA(1#) = Spline2DVNum
    RA(2#) = C.K
    i1_ = (0#) - (3#)
    For i_ = 3# To 3# + CLen - 1# Step 1
        RA(i_) = C.C(i_ + i1_)
    Next i_
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Unserialization of the spline interpolant
'
'INPUT PARAMETERS:
'    RA  -   array of real numbers which contains interpolant,
'
'OUTPUT PARAMETERS:
'    B   -   spline interpolant
'
'  -- ALGLIB --
'     Copyright 17.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub Spline2DUnserialize(ByRef RA() As Double, _
         ByRef C As Spline2DInterpolant)
    Dim CLen As Long
    Dim i_ As Long
    Dim i1_ As Long
    C.K = Round(RA(2#))
    CLen = Round(RA(3#))
    ReDim C.C(0 To CLen - 1)
    i1_ = (3#) - (0#)
    For i_ = 0# To CLen - 1# Step 1
        C.C(i_) = RA(i_ + i1_)
    Next i_
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Bicubic spline resampling
'
'Input parameters:
'    A           -   function values at the old grid,
'                    array[0..OldHeight-1, 0..OldWidth-1]
'    OldHeight   -   old grid height, OldHeight>1
'    OldWidth    -   old grid width, OldWidth>1
'    NewHeight   -   new grid height, NewHeight>1
'    NewWidth    -   new grid width, NewWidth>1
'
'Output parameters:
'    B           -   function values at the new grid,
'                    array[0..NewHeight-1, 0..NewWidth-1]
'
'  -- ALGLIB routine --
'     15 May, 2007
'     Copyright by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub Spline2DResampleBicubic(ByRef a() As Double, _
         ByVal OldHeight As Long, _
         ByVal OldWidth As Long, _
         ByRef B() As Double, _
         ByVal NewHeight As Long, _
         ByVal NewWidth As Long)
    Dim Buf() As Double
    Dim x() As Double
    Dim y() As Double
    Dim C As Spline1DInterpolant
    Dim i As Long
    Dim j As Long
    Dim mw As Long
    Dim MH As Long
    
    '
    ' Prepare
    '
    mw = MaxInt(OldWidth, NewWidth)
    MH = MaxInt(OldHeight, NewHeight)
    ReDim B(0# To NewHeight - 1#, 0# To NewWidth - 1#)
    ReDim Buf(0# To OldHeight - 1#, 0# To NewWidth - 1#)
    ReDim x(0# To MaxInt(mw, MH) - 1#)
    ReDim y(0# To MaxInt(mw, MH) - 1#)
    
    '
    ' Horizontal interpolation
    '
    For i = 0# To OldHeight - 1# Step 1
        
        '
        ' Fill X, Y
        '
        For j = 0# To OldWidth - 1# Step 1
            x(j) = j / (OldWidth - 1#)
            y(j) = a(i, j)
        Next j
        
        '
        ' Interpolate and place result into temporary matrix
        '
        Call Spline1DBuildCubic(x, y, OldWidth, 0#, 0#, 0#, 0#, C)
        For j = 0# To NewWidth - 1# Step 1
            Buf(i, j) = Spline1DCalc(C, j / (NewWidth - 1#))
        Next j
    Next i
    
    '
    ' Vertical interpolation
    '
    For j = 0# To NewWidth - 1# Step 1
        
        '
        ' Fill X, Y
        '
        For i = 0# To OldHeight - 1# Step 1
            x(i) = i / (OldHeight - 1#)
            y(i) = Buf(i, j)
        Next i
        
        '
        ' Interpolate and place result into B
        '
        Call Spline1DBuildCubic(x, y, OldHeight, 0#, 0#, 0#, 0#, C)
        For i = 0# To NewHeight - 1# Step 1
            B(i, j) = Spline1DCalc(C, i / (NewHeight - 1#))
        Next i
    Next j
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Bilinear spline resampling
'
'Input parameters:
'    A           -   function values at the old grid,
'                    array[0..OldHeight-1, 0..OldWidth-1]
'    OldHeight   -   old grid height, OldHeight>1
'    OldWidth    -   old grid width, OldWidth>1
'    NewHeight   -   new grid height, NewHeight>1
'    NewWidth    -   new grid width, NewWidth>1
'
'Output parameters:
'    B           -   function values at the new grid,
'                    array[0..NewHeight-1, 0..NewWidth-1]
'
'  -- ALGLIB routine --
'     09.07.2007
'     Copyright by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub Spline2DResampleBilinear(ByRef a() As Double, _
         ByVal OldHeight As Long, _
         ByVal OldWidth As Long, _
         ByRef B() As Double, _
         ByVal NewHeight As Long, _
         ByVal NewWidth As Long)
    Dim i As Long
    Dim j As Long
    Dim L As Long
    Dim C As Long
    Dim t As Double
    Dim U As Double
    ReDim B(0# To NewHeight - 1#, 0# To NewWidth - 1#)
    For i = 0# To NewHeight - 1# Step 1
        For j = 0# To NewWidth - 1# Step 1
            L = i * (OldHeight - 1#) \ (NewHeight - 1#)
            If L = OldHeight - 1# Then
                L = OldHeight - 2#
            End If
            U = i / (NewHeight - 1#) * (OldHeight - 1#) - L
            C = j * (OldWidth - 1#) \ (NewWidth - 1#)
            If C = OldWidth - 1# Then
                C = OldWidth - 2#
            End If
            t = j * (OldWidth - 1#) / (NewWidth - 1#) - C
            B(i, j) = (1# - t) * (1# - U) * a(L, C) + t * (1# - U) * a(L, C + 1#) + t * U * a(L + 1#, C + 1#) + (1# - t) * U * a(L + 1#, C)
        Next j
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal subroutine.
'Calculation of the first derivatives and the cross-derivative.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub BicubicCalcDerivatives(ByRef a() As Double, _
         ByRef x() As Double, _
         ByRef y() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef DX() As Double, _
         ByRef DY() As Double, _
         ByRef DXY() As Double)
    Dim i As Long
    Dim j As Long
    Dim XT() As Double
    Dim FT() As Double
    Dim C() As Double
    Dim s As Double
    Dim DS As Double
    Dim D2S As Double
    ReDim DX(0# To M - 1#, 0# To N - 1#)
    ReDim DY(0# To M - 1#, 0# To N - 1#)
    ReDim DXY(0# To M - 1#, 0# To N - 1#)
    
    '
    ' dF/dX
    '
    ReDim XT(0# To N - 1#)
    ReDim FT(0# To N - 1#)
    For i = 0# To M - 1# Step 1
        For j = 0# To N - 1# Step 1
            XT(j) = x(j)
            FT(j) = a(i, j)
        Next j
        Call BuildCubicSpline(XT, FT, N, 0#, 0#, 0#, 0#, C)
        For j = 0# To N - 1# Step 1
            Call SplineDifferentiation(C, x(j), s, DS, D2S)
            DX(i, j) = DS
        Next j
    Next i
    
    '
    ' dF/dY
    '
    ReDim XT(0# To M - 1#)
    ReDim FT(0# To M - 1#)
    For j = 0# To N - 1# Step 1
        For i = 0# To M - 1# Step 1
            XT(i) = y(i)
            FT(i) = a(i, j)
        Next i
        Call BuildCubicSpline(XT, FT, M, 0#, 0#, 0#, 0#, C)
        For i = 0# To M - 1# Step 1
            Call SplineDifferentiation(C, y(i), s, DS, D2S)
            DY(i, j) = DS
        Next i
    Next j
    
    '
    ' d2F/dXdY
    '
    ReDim XT(0# To N - 1#)
    ReDim FT(0# To N - 1#)
    For i = 0# To M - 1# Step 1
        For j = 0# To N - 1# Step 1
            XT(j) = x(j)
            FT(j) = DY(i, j)
        Next j
        Call BuildCubicSpline(XT, FT, N, 0#, 0#, 0#, 0#, C)
        For j = 0# To N - 1# Step 1
            Call SplineDifferentiation(C, x(j), s, DS, D2S)
            DXY(i, j) = DS
        Next j
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2007, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
Public Sub BuildLinearSpline(ByRef x_() As Double, _
         ByRef y_() As Double, _
         ByVal N As Long, _
         ByRef C() As Double)
    Dim x() As Double
    Dim y() As Double
    Dim i As Long
    Dim TblSize As Long
    x = x_
    y = y_
    '
    ' Sort points
    '
    Call HeapSortPoints(x, y, N)
    '
    ' Fill C:
    '  C[0]            -   length(C)
    '  C[1]            -   type(C):
    '                      3 - general cubic spline
    '  C[2]            -   N
    '  C[3]...C[3+N-1] -   x[i], i = 0...N-1
    '  C[3+N]...C[3+N+(N-1)*4-1] - coefficients table
    '
    TblSize = 3# + N + (N - 1#) * 4#
    ReDim C(0# To TblSize - 1#)
    C(0#) = TblSize
    C(1#) = 3#
    C(2#) = N
    For i = 0# To N - 1# Step 1
        C(3# + i) = x(i)
    Next i
    For i = 0# To N - 2# Step 1
        C(3# + N + 4# * i + 0#) = y(i)
        C(3# + N + 4# * i + 1#) = (y(i + 1#) - y(i)) / (x(i + 1#) - x(i))
        C(3# + N + 4# * i + 2#) = 0#
        C(3# + N + 4# * i + 3#) = 0#
    Next i
End Sub
Public Sub BuildCubicSpline(ByRef x_() As Double, _
         ByRef y_() As Double, _
         ByVal N As Long, _
         ByVal BoundLType As Long, _
         ByVal BoundL As Double, _
         ByVal BoundRType As Long, _
         ByVal BoundR As Double, _
         ByRef C() As Double)
    Dim x() As Double
    Dim y() As Double
    Dim a1() As Double
    Dim a2() As Double
    Dim a3() As Double
    Dim B() As Double
    Dim d() As Double
    Dim i As Long
    Dim TblSize As Long
    Dim Delta As Double
    Dim Delta2 As Double
    Dim Delta3 As Double
    x = x_
    y = y_
    ReDim a1(0# To N - 1#)
    ReDim a2(0# To N - 1#)
    ReDim a3(0# To N - 1#)
    ReDim B(0# To N - 1#)
    '
    ' Special case:
    ' * N=2
    ' * parabolic terminated boundary condition on both ends
    '
    If N = 2# And BoundLType = 0# And BoundRType = 0# Then
        '
        ' Change task type
        '
        BoundLType = 2#
        BoundL = 0#
        BoundRType = 2#
        BoundR = 0#
    End If
    '
    '
    ' Sort points
    '
    Call HeapSortPoints(x, y, N)
    '
    ' Left boundary conditions
    '
    If BoundLType = 0# Then
        a1(0#) = 0#
        a2(0#) = 1#
        a3(0#) = 1#
        B(0#) = 2# * (y(1#) - y(0#)) / (x(1#) - x(0#))
    End If
    If BoundLType = 1# Then
        a1(0#) = 0#
        a2(0#) = 1#
        a3(0#) = 0#
        B(0#) = BoundL
    End If
    If BoundLType = 2# Then
        a1(0#) = 0#
        a2(0#) = 2#
        a3(0#) = 1#
        B(0#) = 3# * (y(1#) - y(0#)) / (x(1#) - x(0#)) - 0.5 * BoundL * (x(1#) - x(0#))
    End If
    '
    ' Central conditions
    '
    For i = 1# To N - 2# Step 1
        a1(i) = x(i + 1#) - x(i)
        a2(i) = 2# * (x(i + 1#) - x(i - 1#))
        a3(i) = x(i) - x(i - 1#)
        B(i) = 3# * (y(i) - y(i - 1#)) / (x(i) - x(i - 1#)) * (x(i + 1#) - x(i)) + 3# * (y(i + 1#) - y(i)) / (x(i + 1#) - x(i)) * (x(i) - x(i - 1#))
    Next i
    '
    ' Right boundary conditions
    '
    If BoundRType = 0# Then
        a1(N - 1#) = 1#
        a2(N - 1#) = 1#
        a3(N - 1#) = 0#
        B(N - 1#) = 2# * (y(N - 1#) - y(N - 2#)) / (x(N - 1#) - x(N - 2#))
    End If
    If BoundRType = 1# Then
        a1(N - 1#) = 0#
        a2(N - 1#) = 1#
        a3(N - 1#) = 0#
        B(N - 1#) = BoundR
    End If
    If BoundRType = 2# Then
        a1(N - 1#) = 1#
        a2(N - 1#) = 2#
        a3(N - 1#) = 0#
        B(N - 1#) = 3# * (y(N - 1#) - y(N - 2#)) / (x(N - 1#) - x(N - 2#)) + 0.5 * BoundR * (x(N - 1#) - x(N - 2#))
    End If
    '
    ' Solve
    '
    Call SolveTridiagonal(a1, a2, a3, B, N, d)
    '
    ' Now problem is reduced to the cubic Hermite spline
    '
    Call BuildHermiteSpline(x, y, d, N, C)
End Sub
Public Sub BuildHermiteSpline(ByRef x_() As Double, _
         ByRef y_() As Double, _
         ByRef D_() As Double, _
         ByVal N As Long, _
         ByRef C() As Double)
    Dim x() As Double
    Dim y() As Double
    Dim d() As Double
    Dim i As Long
    Dim TblSize As Long
    Dim Delta As Double
    Dim Delta2 As Double
    Dim Delta3 As Double
    x = x_
    y = y_
    d = D_
    '
    ' Sort points
    '
    Call HeapSortDPoints(x, y, d, N)
    '
    ' Fill C:
    '  C[0]            -   length(C)
    '  C[1]            -   type(C):
    '                      3 - general cubic spline
    '  C[2]            -   N
    '  C[3]...C[3+N-1] -   x[i], i = 0...N-1
    '  C[3+N]...C[3+N+(N-1)*4-1] - coefficients table
    '
    TblSize = 3# + N + (N - 1#) * 4#
    ReDim C(0# To TblSize - 1#)
    C(0#) = TblSize
    C(1#) = 3#
    C(2#) = N
    For i = 0# To N - 1# Step 1
        C(3# + i) = x(i)
    Next i
    For i = 0# To N - 2# Step 1
        Delta = x(i + 1#) - x(i)
        Delta2 = Square(Delta)
        Delta3 = Delta * Delta2
        C(3# + N + 4# * i + 0#) = y(i)
        C(3# + N + 4# * i + 1#) = d(i)
        C(3# + N + 4# * i + 2#) = (3# * (y(i + 1#) - y(i)) - 2# * d(i) * Delta - d(i + 1#) * Delta) / Delta2
        C(3# + N + 4# * i + 3#) = (2# * (y(i) - y(i + 1#)) + d(i) * Delta + d(i + 1#) * Delta) / Delta3
    Next i
End Sub
Public Sub BuildAkimaSpline(ByRef x_() As Double, _
         ByRef y_() As Double, _
         ByVal N As Long, _
         ByRef C() As Double)
    Dim x() As Double
    Dim y() As Double
    Dim i As Long
    Dim d() As Double
    Dim w() As Double
    Dim Diff() As Double
    x = x_
    y = y_
    '
    ' Sort points
    '
    Call HeapSortPoints(x, y, N)
    '
    ' Prepare W (weights), Diff (divided differences)
    '
    ReDim w(1# To N - 2#)
    ReDim Diff(0# To N - 2#)
    For i = 0# To N - 2# Step 1
        Diff(i) = (y(i + 1#) - y(i)) / (x(i + 1#) - x(i))
    Next i
    For i = 1# To N - 2# Step 1
        w(i) = Abs(Diff(i) - Diff(i - 1#))
    Next i
    '
    ' Prepare Hermite interpolation scheme
    '
    ReDim d(0# To N - 1#)
    For i = 2# To N - 3# Step 1
        If Abs(w(i - 1#)) + Abs(w(i + 1#)) <> 0# Then
            d(i) = (w(i + 1#) * Diff(i - 1#) + w(i - 1#) * Diff(i)) / (w(i + 1#) + w(i - 1#))
        Else
            d(i) = ((x(i + 1#) - x(i)) * Diff(i - 1#) + (x(i) - x(i - 1#)) * Diff(i)) / (x(i + 1#) - x(i - 1#))
        End If
    Next i
    d(0#) = DiffThreePoint(x(0#), x(0#), y(0#), x(1#), y(1#), x(2#), y(2#))
    d(1#) = DiffThreePoint(x(1#), x(0#), y(0#), x(1#), y(1#), x(2#), y(2#))
    d(N - 2#) = DiffThreePoint(x(N - 2#), x(N - 3#), y(N - 3#), x(N - 2#), y(N - 2#), x(N - 1#), y(N - 1#))
    d(N - 1#) = DiffThreePoint(x(N - 1#), x(N - 3#), y(N - 3#), x(N - 2#), y(N - 2#), x(N - 1#), y(N - 1#))
    '
    ' Build Akima spline using Hermite interpolation scheme
    '
    Call BuildHermiteSpline(x, y, d, N, C)
End Sub
Public Function SplineInterpolation(ByRef C() As Double, _
         ByVal x As Double) As Double
    Dim Result As Double
    Dim N As Long
    Dim L As Long
    Dim R As Long
    Dim M As Long
    N = Round(C(2#))
    '
    ' Binary search in the [ x[0], ..., x[n-2] ] (x[n-1] is not included)
    '
    L = 3#
    R = 3# + N - 2# + 1#
    Do While L <> R - 1#
        M = (L + R) \ 2#
        If C(M) >= x Then
            R = M
        Else
            L = M
        End If
    Loop
    '
    ' Interpolation
    '
    x = x - C(L)
    M = 3# + N + 4# * (L - 3#)
    Result = C(M) + x * (C(M + 1#) + x * (C(M + 2#) + x * C(M + 3#)))
    SplineInterpolation = Result
End Function
Public Sub SplineDifferentiation(ByRef C() As Double, _
         ByVal x As Double, _
         ByRef s As Double, _
         ByRef DS As Double, _
         ByRef D2S As Double)
    Dim N As Long
    Dim L As Long
    Dim R As Long
    Dim M As Long
    N = Round(C(2#))
    '
    ' Binary search
    '
    L = 3#
    R = 3# + N - 2# + 1#
    Do While L <> R - 1#
        M = (L + R) \ 2#
        If C(M) >= x Then
            R = M
        Else
            L = M
        End If
    Loop
    '
    ' Differentiation
    '
    x = x - C(L)
    M = 3# + N + 4# * (L - 3#)
    s = C(M) + x * (C(M + 1#) + x * (C(M + 2#) + x * C(M + 3#)))
    DS = C(M + 1#) + 2# * x * C(M + 2#) + 3# * Square(x) * C(M + 3#)
    D2S = 2# * C(M + 2#) + 6# * x * C(M + 3#)
End Sub
Public Sub SplineCopy(ByRef C() As Double, ByRef CC() As Double)
    Dim s As Long
    Dim i_ As Long
    s = Round(C(0#))
    ReDim CC(0# To s - 1#)
    For i_ = 0# To s - 1# Step 1
        CC(i_) = C(i_)
    Next i_
End Sub
Public Sub SplineUnpack(ByRef C() As Double, _
         ByRef N As Long, _
         ByRef Tbl() As Double)
    Dim i As Long
    N = Round(C(2#))
    ReDim Tbl(0# To N - 2#, 0# To 5#)
    '
    ' Fill
    '
    For i = 0# To N - 2# Step 1
        Tbl(i, 0#) = C(3# + i)
        Tbl(i, 1#) = C(3# + i + 1#)
        Tbl(i, 2#) = C(3# + N + 4# * i)
        Tbl(i, 3#) = C(3# + N + 4# * i + 1#)
        Tbl(i, 4#) = C(3# + N + 4# * i + 2#)
        Tbl(i, 5#) = C(3# + N + 4# * i + 3#)
    Next i
End Sub
Public Sub SplineLinTransX(ByRef C() As Double, _
         ByVal a As Double, _
         ByVal B As Double)
    Dim i As Long
    Dim N As Long
    Dim V As Double
    Dim DV As Double
    Dim D2V As Double
    Dim x() As Double
    Dim y() As Double
    Dim d() As Double
    N = Round(C(2#))
    '
    ' Special case: A=0
    '
    If a = 0# Then
        V = SplineInterpolation(C, B)
        For i = 0# To N - 2# Step 1
            C(3# + N + 4# * i) = V
            C(3# + N + 4# * i + 1#) = 0#
            C(3# + N + 4# * i + 2#) = 0#
            C(3# + N + 4# * i + 3#) = 0#
        Next i
        Exit Sub
    End If
    '
    ' General case: A<>0.
    ' Unpack, X, Y, dY/dX.
    ' Scale and pack again.
    '
    ReDim x(0# To N - 1#)
    ReDim y(0# To N - 1#)
    ReDim d(0# To N - 1#)
    For i = 0# To N - 1# Step 1
        x(i) = C(3# + i)
        Call SplineDifferentiation(C, x(i), V, DV, D2V)
        x(i) = (x(i) - B) / a
        y(i) = V
        d(i) = a * DV
    Next i
    Call BuildHermiteSpline(x, y, d, N, C)
End Sub
Public Sub SplineLinTransY(ByRef C() As Double, _
         ByVal a As Double, _
         ByVal B As Double)
    Dim i As Long
    Dim N As Long
    Dim V As Double
    Dim DV As Double
    Dim D2V As Double
    Dim x() As Double
    Dim y() As Double
    Dim d() As Double
    N = Round(C(2#))
    '
    ' Special case: A=0
    '
    For i = 0# To N - 2# Step 1
        C(3# + N + 4# * i) = a * C(3# + N + 4# * i) + B
        C(3# + N + 4# * i + 1#) = a * C(3# + N + 4# * i + 1#)
        C(3# + N + 4# * i + 2#) = a * C(3# + N + 4# * i + 2#)
        C(3# + N + 4# * i + 3#) = a * C(3# + N + 4# * i + 3#)
    Next i
End Sub
Public Function SplineIntegration(ByRef C() As Double, _
         ByVal x As Double) As Double
    Dim Result As Double
    Dim N As Long
    Dim i As Long
    Dim L As Long
    Dim R As Long
    Dim M As Long
    Dim w As Double
    N = Round(C(2#))
    '
    ' Binary search in the [ x[0], ..., x[n-2] ] (x[n-1] is not included)
    '
    L = 3#
    R = 3# + N - 2# + 1#
    Do While L <> R - 1#
        M = (L + R) \ 2#
        If C(M) >= x Then
            R = M
        Else
            L = M
        End If
    Loop
    '
    ' Integration
    '
    Result = 0#
    For i = 3# To L - 1# Step 1
        w = C(i + 1#) - C(i)
        M = 3# + N + 4# * (i - 3#)
        Result = Result + C(M) * w
        Result = Result + C(M + 1#) * Square(w) / 2#
        Result = Result + C(M + 2#) * Square(w) * w / 3#
        Result = Result + C(M + 3#) * Square(Square(w)) / 4#
    Next i
    w = x - C(L)
    M = 3# + N + 4# * (L - 3#)
    Result = Result + C(M) * w
    Result = Result + C(M + 1#) * Square(w) / 2#
    Result = Result + C(M + 2#) * Square(w) * w / 3#
    Result = Result + C(M + 3#) * Square(Square(w)) / 4#
    SplineIntegration = Result
End Function
Public Sub Spline3BuildTable(ByVal N As Long, _
         ByRef DiffN As Long, _
         ByRef x_() As Double, _
         ByRef y_() As Double, _
         ByRef BoundL As Double, _
         ByRef BoundR As Double, _
         ByRef ctbl() As Double)
    Dim x() As Double
    Dim y() As Double
    Dim C As Boolean
    Dim e As Long
    Dim g As Long
    Dim tmp As Double
    Dim nxm1 As Long
    Dim i As Long
    Dim j As Long
    Dim DX As Double
    Dim DXJ As Double
    Dim DYJ As Double
    Dim DXJP1 As Double
    Dim DYJP1 As Double
    Dim DXP As Double
    Dim DYP As Double
    Dim YPPA As Double
    Dim YPPB As Double
    Dim PJ As Double
    Dim b1 As Double
    Dim b2 As Double
    Dim b3 As Double
    Dim b4 As Double
    x = x_
    y = y_
    N = N - 1#
    g = (N + 1#) \ 2#
    Do
        i = g
        Do
            j = i - g
            C = True
            Do
                If x(j) <= x(j + g) Then
                    C = False
                Else
                    tmp = x(j)
                    x(j) = x(j + g)
                    x(j + g) = tmp
                    tmp = y(j)
                    y(j) = y(j + g)
                    y(j + g) = tmp
                End If
                j = j - 1#
            Loop Until Not (j >= 0# And C)
            i = i + 1#
        Loop Until Not i <= N
        g = g \ 2#
    Loop Until Not g > 0#
    ReDim ctbl(0# To 4#, 0# To N)
    N = N + 1#
    If DiffN = 1# Then
        b1 = 1#
        b2 = 6# / (x(1#) - x(0#)) * ((y(1#) - y(0#)) / (x(1#) - x(0#)) - BoundL)
        b3 = 1#
        b4 = 6# / (x(N - 1#) - x(N - 2#)) * (BoundR - (y(N - 1#) - y(N - 2#)) / (x(N - 1#) - x(N - 2#)))
    Else
        b1 = 0#
        b2 = 2# * BoundL
        b3 = 0#
        b4 = 2# * BoundR
    End If
    nxm1 = N - 1#
    If N >= 2# Then
        If N > 2# Then
            DXJ = x(1#) - x(0#)
            DYJ = y(1#) - y(0#)
            j = 2#
            Do While j <= nxm1
                DXJP1 = x(j) - x(j - 1#)
                DYJP1 = y(j) - y(j - 1#)
                DXP = DXJ + DXJP1
                ctbl(1#, j - 1#) = DXJP1 / DXP
                ctbl(2#, j - 1#) = 1# - ctbl(1#, j - 1#)
                ctbl(3#, j - 1#) = 6# * (DYJP1 / DXJP1 - DYJ / DXJ) / DXP
                DXJ = DXJP1
                DYJ = DYJP1
                j = j + 1#
            Loop
        End If
        ctbl(1#, 0#) = -(b1 / 2#)
        ctbl(2#, 0#) = b2 / 2#
        If N <> 2# Then
            j = 2#
            Do While j <= nxm1
                PJ = ctbl(2#, j - 1#) * ctbl(1#, j - 2#) + 2#
                ctbl(1#, j - 1#) = -(ctbl(1#, j - 1#) / PJ)
                ctbl(2#, j - 1#) = (ctbl(3#, j - 1#) - ctbl(2#, j - 1#) * ctbl(2#, j - 2#)) / PJ
                j = j + 1#
            Loop
        End If
        YPPB = (b4 - b3 * ctbl(2#, nxm1 - 1#)) / (b3 * ctbl(1#, nxm1 - 1#) + 2#)
        i = 1#
        Do While i <= nxm1
            j = N - i
            YPPA = ctbl(1#, j - 1#) * YPPB + ctbl(2#, j - 1#)
            DX = x(j) - x(j - 1#)
            ctbl(3#, j - 1#) = (YPPB - YPPA) / DX / 6#
            ctbl(2#, j - 1#) = YPPA / 2#
            ctbl(1#, j - 1#) = (y(j) - y(j - 1#)) / DX - (ctbl(2#, j - 1#) + ctbl(3#, j - 1#) * DX) * DX
            YPPB = YPPA
            i = i + 1#
        Loop
        For i = 1# To N Step 1
            ctbl(0#, i - 1#) = y(i - 1#)
            ctbl(4#, i - 1#) = x(i - 1#)
        Next i
    End If
End Sub
Public Function Spline3Interpolate(ByVal N As Long, _
         ByRef C() As Double, _
         ByRef x As Double) As Double
    Dim Result As Double
    Dim i As Long
    Dim L As Long
    Dim Half As Long
    Dim First As Long
    Dim Middle As Long
    N = N - 1#
    L = N
    First = 0#
    Do While L > 0#
        Half = L \ 2#
        Middle = First + Half
        If C(4#, Middle) < x Then
            First = Middle + 1#
            L = L - Half - 1#
        Else
            L = Half
        End If
    Loop
    i = First - 1#
    If i < 0# Then
        i = 0#
    End If
    Result = C(0#, i) + (x - C(4#, i)) * (C(1#, i) + (x - C(4#, i)) * (C(2#, i) + C(3#, i) * (x - C(4#, i))))
    Spline3Interpolate = Result
End Function
'Private Sub HeapSortPoints(ByRef X() As Double, _
'         ByRef y() As Double, _
'         ByVal N As Long)
'    Dim i As Long
'    Dim j As Long
'    Dim K As Long
'    Dim T As Long
'    Dim Tmp As Double
'    Dim IsAscending As Boolean
'    Dim IsDescending As Boolean
'
'
'    '
'    ' Test for already sorted set
'    '
'    IsAscending = True
'    IsDescending = True
'    For i = 1# To N - 1# Step 1
'        IsAscending = IsAscending And X(i) > X(i - 1#)
'        IsDescending = IsDescending And X(i) < X(i - 1#)
'    Next i
'    If IsAscending Then
'        Exit Sub
'    End If
'    If IsDescending Then
'        For i = 0# To N - 1# Step 1
'            j = N - 1# - i
'            If j <= i Then
'                Exit For
'            End If
'            Tmp = X(i)
'            X(i) = X(j)
'            X(j) = Tmp
'            Tmp = y(i)
'            y(i) = y(j)
'            y(j) = Tmp
'        Next i
'        Exit Sub
'    End If
'
'    '
'    ' Special case: N=1
'    '
'    If N = 1# Then
'        Exit Sub
'    End If
'
'    '
'    ' General case
'    '
'    i = 2#
'    Do
'        T = i
'        Do While T <> 1#
'            K = T \ 2#
'            If X(K - 1#) >= X(T - 1#) Then
'                T = 1#
'            Else
'                Tmp = X(K - 1#)
'                X(K - 1#) = X(T - 1#)
'                X(T - 1#) = Tmp
'                Tmp = y(K - 1#)
'                y(K - 1#) = y(T - 1#)
'                y(T - 1#) = Tmp
'                T = K
'            End If
'        Loop
'        i = i + 1#
'    Loop Until Not i <= N
'    i = N - 1#
'    Do
'        Tmp = X(i)
'        X(i) = X(0#)
'        X(0#) = Tmp
'        Tmp = y(i)
'        y(i) = y(0#)
'        y(0#) = Tmp
'        T = 1#
'        Do While T <> 0#
'            K = 2# * T
'            If K > i Then
'                T = 0#
'            Else
'                If K < i Then
'                    If X(K) > X(K - 1#) Then
'                        K = K + 1#
'                    End If
'                End If
'                If X(T - 1#) >= X(K - 1#) Then
'                    T = 0#
'                Else
'                    Tmp = X(K - 1#)
'                    X(K - 1#) = X(T - 1#)
'                    X(T - 1#) = Tmp
'                    Tmp = y(K - 1#)
'                    y(K - 1#) = y(T - 1#)
'                    y(T - 1#) = Tmp
'                    T = K
'                End If
'            End If
'        Loop
'        i = i - 1#
'    Loop Until Not i >= 1#
'End Sub
'
'
'Private Sub HeapSortDPoints(ByRef X() As Double, _
'         ByRef y() As Double, _
'         ByRef D() As Double, _
'         ByVal N As Long)
'    Dim i As Long
'    Dim j As Long
'    Dim K As Long
'    Dim T As Long
'    Dim Tmp As Double
'    Dim IsAscending As Boolean
'    Dim IsDescending As Boolean
'
'
'    '
'    ' Test for already sorted set
'    '
'    IsAscending = True
'    IsDescending = True
'    For i = 1# To N - 1# Step 1
'        IsAscending = IsAscending And X(i) > X(i - 1#)
'        IsDescending = IsDescending And X(i) < X(i - 1#)
'    Next i
'    If IsAscending Then
'        Exit Sub
'    End If
'    If IsDescending Then
'        For i = 0# To N - 1# Step 1
'            j = N - 1# - i
'            If j <= i Then
'                Exit For
'            End If
'            Tmp = X(i)
'            X(i) = X(j)
'            X(j) = Tmp
'            Tmp = y(i)
'            y(i) = y(j)
'            y(j) = Tmp
'            Tmp = D(i)
'            D(i) = D(j)
'            D(j) = Tmp
'        Next i
'        Exit Sub
'    End If
'
'    '
'    ' Special case: N=1
'    '
'    If N = 1# Then
'        Exit Sub
'    End If
'
'    '
'    ' General case
'    '
'    i = 2#
'    Do
'        T = i
'        Do While T <> 1#
'            K = T \ 2#
'            If X(K - 1#) >= X(T - 1#) Then
'                T = 1#
'            Else
'                Tmp = X(K - 1#)
'                X(K - 1#) = X(T - 1#)
'                X(T - 1#) = Tmp
'                Tmp = y(K - 1#)
'                y(K - 1#) = y(T - 1#)
'                y(T - 1#) = Tmp
'                Tmp = D(K - 1#)
'                D(K - 1#) = D(T - 1#)
'                D(T - 1#) = Tmp
'                T = K
'            End If
'        Loop
'        i = i + 1#
'    Loop Until Not i <= N
'    i = N - 1#
'    Do
'        Tmp = X(i)
'        X(i) = X(0#)
'        X(0#) = Tmp
'        Tmp = y(i)
'        y(i) = y(0#)
'        y(0#) = Tmp
'        Tmp = D(i)
'        D(i) = D(0#)
'        D(0#) = Tmp
'        T = 1#
'        Do While T <> 0#
'            K = 2# * T
'            If K > i Then
'                T = 0#
'            Else
'                If K < i Then
'                    If X(K) > X(K - 1#) Then
'                        K = K + 1#
'                    End If
'                End If
'                If X(T - 1#) >= X(K - 1#) Then
'                    T = 0#
'                Else
'                    Tmp = X(K - 1#)
'                    X(K - 1#) = X(T - 1#)
'                    X(T - 1#) = Tmp
'                    Tmp = y(K - 1#)
'                    y(K - 1#) = y(T - 1#)
'                    y(T - 1#) = Tmp
'                    Tmp = D(K - 1#)
'                    D(K - 1#) = D(T - 1#)
'                    D(T - 1#) = Tmp
'                    T = K
'                End If
'            End If
'        Loop
'        i = i - 1#
'    Loop Until Not i >= 1#
'End Sub
'Private Sub SolveTridiagonal(ByRef A_() As Double, _
'         ByRef B_() As Double, _
'         ByRef C_() As Double, _
'         ByRef D_() As Double, _
'         ByVal N As Long, _
'         ByRef X() As Double)
'    Dim A() As Double
'    Dim B() As Double
'    Dim C() As Double
'    Dim D() As Double
'    Dim K As Long
'    Dim T As Double
'    A = A_
'    B = B_
'    C = C_
'    D = D_
'
'    ReDim X(0# To N - 1#)
'    A(0#) = 0#
'    C(N - 1#) = 0#
'    For K = 1# To N - 1# Step 1
'        T = A(K) / B(K - 1#)
'        B(K) = B(K) - T * C(K - 1#)
'        D(K) = D(K) - T * D(K - 1#)
'    Next K
'    X(N - 1#) = D(N - 1#) / B(N - 1#)
'    For K = N - 2# To 0# Step -1
'        X(K) = (D(K) - C(K) * X(K + 1#)) / B(K)
'    Next K
'End Sub
'
'Private Function DiffThreePoint(ByVal T As Double, _
'         ByVal X0 As Double, _
'         ByVal F0 As Double, _
'         ByVal X1 As Double, _
'         ByVal F1 As Double, _
'         ByVal X2 As Double, _
'         ByVal F2 As Double) As Double
'    Dim Result As Double
'    Dim A As Double
'    Dim B As Double
'
'    T = T - X0
'    X1 = X1 - X0
'    X2 = X2 - X0
'    A = (F2 - F0 - X2 / X1 * (F1 - F0)) / (Square(X2) - X1 * X2)
'    B = (F1 - F0 - A * Square(X1)) / X1
'    Result = 2# * A * T + B
'
'    DiffThreePoint = Result
'End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2006-2010, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function  builds  non-periodic 2-dimensional parametric spline  which
'starts at (X[0],Y[0]) and ends at (X[N-1],Y[N-1]).
'
'INPUT PARAMETERS:
'    XY  -   points, array[0..N-1,0..1].
'            XY[I,0:1] corresponds to the Ith point.
'            Order of points is important!
'    N   -   points count, N>=5 for Akima splines, N>=2 for other types  of
'            splines.
'    ST  -   spline type:
'            * 0     Akima spline
'            * 1     parabolically terminated Catmull-Rom spline (Tension=0)
'            * 2     parabolically terminated cubic spline
'    PT  -   parameterization type:
'            * 0     uniform
'            * 1     chord length
'            * 2     centripetal
'
'OUTPUT PARAMETERS:
'    P   -   parametric spline interpolant
'
'
'NOTES:
'* this function  assumes  that  there all consequent points  are distinct.
'  I.e. (x0,y0)<>(x1,y1),  (x1,y1)<>(x2,y2),  (x2,y2)<>(x3,y3)  and  so on.
'  However, non-consequent points may coincide, i.e. we can  have  (x0,y0)=
'  =(x2,y2).
'
'  -- ALGLIB PROJECT --
'     Copyright 28.05.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub PSpline2Build(ByRef XY_() As Double, _
         ByVal N As Long, _
         ByVal ST As Long, _
         ByVal PT As Long, _
         ByRef p As PSpline2Interpolant)
    Dim XY() As Double
    Dim tmp() As Double
    Dim V As Double
    Dim i As Long
    Dim i_ As Long
    XY = XY_
    If ST = 0# Then
    Else
    End If
    
    '
    ' Prepare
    '
    p.N = N
    p.Periodic = False
    ReDim tmp(0 To N - 1)
    
    '
    ' Build parameterization, check that all parameters are distinct
    '
    Call PSpline2Par(XY, N, PT, p.p)
    
    '
    ' Build splines
    '
    If ST = 0# Then
        For i_ = 0# To N - 1# Step 1
            tmp(i_) = XY(i_, 0#)
        Next i_
        Call Spline1DBuildAkima(p.p, tmp, N, p.x)
        For i_ = 0# To N - 1# Step 1
            tmp(i_) = XY(i_, 1#)
        Next i_
        Call Spline1DBuildAkima(p.p, tmp, N, p.y)
    End If
    If ST = 1# Then
        For i_ = 0# To N - 1# Step 1
            tmp(i_) = XY(i_, 0#)
        Next i_
        Call Spline1DBuildCatmullRom(p.p, tmp, N, 0#, 0#, p.x)
        For i_ = 0# To N - 1# Step 1
            tmp(i_) = XY(i_, 1#)
        Next i_
        Call Spline1DBuildCatmullRom(p.p, tmp, N, 0#, 0#, p.y)
    End If
    If ST = 2# Then
        For i_ = 0# To N - 1# Step 1
            tmp(i_) = XY(i_, 0#)
        Next i_
        Call Spline1DBuildCubic(p.p, tmp, N, 0#, 0#, 0#, 0#, p.x)
        For i_ = 0# To N - 1# Step 1
            tmp(i_) = XY(i_, 1#)
        Next i_
        Call Spline1DBuildCubic(p.p, tmp, N, 0#, 0#, 0#, 0#, p.y)
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function  builds  non-periodic 3-dimensional parametric spline  which
'starts at (X[0],Y[0],Z[0]) and ends at (X[N-1],Y[N-1],Z[N-1]).
'
'Same as PSpline2Build() function, but for 3D, so we  won't  duplicate  its
'description here.
'
'  -- ALGLIB PROJECT --
'     Copyright 28.05.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub PSpline3Build(ByRef XY_() As Double, _
         ByVal N As Long, _
         ByVal ST As Long, _
         ByVal PT As Long, _
         ByRef p As PSpline3Interpolant)
    Dim XY() As Double
    Dim tmp() As Double
    Dim V As Double
    Dim i As Long
    Dim i_ As Long
    XY = XY_
    If ST = 0# Then
    Else
    End If
    
    '
    ' Prepare
    '
    p.N = N
    p.Periodic = False
    ReDim tmp(0 To N - 1)
    
    '
    ' Build parameterization, check that all parameters are distinct
    '
    Call PSpline3Par(XY, N, PT, p.p)
    
    '
    ' Build splines
    '
    If ST = 0# Then
        For i_ = 0# To N - 1# Step 1
            tmp(i_) = XY(i_, 0#)
        Next i_
        Call Spline1DBuildAkima(p.p, tmp, N, p.x)
        For i_ = 0# To N - 1# Step 1
            tmp(i_) = XY(i_, 1#)
        Next i_
        Call Spline1DBuildAkima(p.p, tmp, N, p.y)
        For i_ = 0# To N - 1# Step 1
            tmp(i_) = XY(i_, 2#)
        Next i_
        Call Spline1DBuildAkima(p.p, tmp, N, p.z)
    End If
    If ST = 1# Then
        For i_ = 0# To N - 1# Step 1
            tmp(i_) = XY(i_, 0#)
        Next i_
        Call Spline1DBuildCatmullRom(p.p, tmp, N, 0#, 0#, p.x)
        For i_ = 0# To N - 1# Step 1
            tmp(i_) = XY(i_, 1#)
        Next i_
        Call Spline1DBuildCatmullRom(p.p, tmp, N, 0#, 0#, p.y)
        For i_ = 0# To N - 1# Step 1
            tmp(i_) = XY(i_, 2#)
        Next i_
        Call Spline1DBuildCatmullRom(p.p, tmp, N, 0#, 0#, p.z)
    End If
    If ST = 2# Then
        For i_ = 0# To N - 1# Step 1
            tmp(i_) = XY(i_, 0#)
        Next i_
        Call Spline1DBuildCubic(p.p, tmp, N, 0#, 0#, 0#, 0#, p.x)
        For i_ = 0# To N - 1# Step 1
            tmp(i_) = XY(i_, 1#)
        Next i_
        Call Spline1DBuildCubic(p.p, tmp, N, 0#, 0#, 0#, 0#, p.y)
        For i_ = 0# To N - 1# Step 1
            tmp(i_) = XY(i_, 2#)
        Next i_
        Call Spline1DBuildCubic(p.p, tmp, N, 0#, 0#, 0#, 0#, p.z)
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This  function  builds  periodic  2-dimensional  parametric  spline  which
'starts at (X[0],Y[0]), goes through all points to (X[N-1],Y[N-1]) and then
'back to (X[0],Y[0]).
'
'INPUT PARAMETERS:
'    XY  -   points, array[0..N-1,0..1].
'            XY[I,0:1] corresponds to the Ith point.
'            XY[N-1,0:1] must be different from XY[0,0:1].
'            Order of points is important!
'    N   -   points count, N>=3 for other types of splines.
'    ST  -   spline type:
'            * 1     Catmull-Rom spline (Tension=0) with cyclic boundary conditions
'            * 2     cubic spline with cyclic boundary conditions
'    PT  -   parameterization type:
'            * 0     uniform
'            * 1     chord length
'            * 2     centripetal
'
'OUTPUT PARAMETERS:
'    P   -   parametric spline interpolant
'
'
'NOTES:
'* this function  assumes  that there all consequent points  are  distinct.
'  I.e. (x0,y0)<>(x1,y1), (x1,y1)<>(x2,y2),  (x2,y2)<>(x3,y3)  and  so  on.
'  However, non-consequent points may coincide, i.e. we can  have  (x0,y0)=
'  =(x2,y2).
'* last point of sequence is NOT equal to the first  point.  You  shouldn't
'  make curve "explicitly periodic" by making them equal.
'
'  -- ALGLIB PROJECT --
'     Copyright 28.05.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub PSpline2BuildPeriodic(ByRef XY_() As Double, _
         ByVal N As Long, _
         ByVal ST As Long, _
         ByVal PT As Long, _
         ByRef p As PSpline2Interpolant)
    Dim XY() As Double
    Dim XYP() As Double
    Dim tmp() As Double
    Dim V As Double
    Dim i As Long
    Dim i_ As Long
    XY = XY_
    
    '
    ' Prepare
    '
    p.N = N
    p.Periodic = True
    ReDim tmp(0 To N + 1# - 1)
    ReDim XYP(0 To N + 1# - 1, 0 To 2# - 1)
    For i_ = 0# To N - 1# Step 1
        XYP(i_, 0#) = XY(i_, 0#)
    Next i_
    For i_ = 0# To N - 1# Step 1
        XYP(i_, 1#) = XY(i_, 1#)
    Next i_
    For i_ = 0# To 1# Step 1
        XYP(N, i_) = XY(0#, i_)
    Next i_
    
    '
    ' Build parameterization, check that all parameters are distinct
    '
    Call PSpline2Par(XYP, N + 1#, PT, p.p)
    
    '
    ' Build splines
    '
    If ST = 1# Then
        For i_ = 0# To N Step 1
            tmp(i_) = XYP(i_, 0#)
        Next i_
        Call Spline1DBuildCatmullRom(p.p, tmp, N + 1#, -1#, 0#, p.x)
        For i_ = 0# To N Step 1
            tmp(i_) = XYP(i_, 1#)
        Next i_
        Call Spline1DBuildCatmullRom(p.p, tmp, N + 1#, -1#, 0#, p.y)
    End If
    If ST = 2# Then
        For i_ = 0# To N Step 1
            tmp(i_) = XYP(i_, 0#)
        Next i_
        Call Spline1DBuildCubic(p.p, tmp, N + 1#, -1#, 0#, -1#, 0#, p.x)
        For i_ = 0# To N Step 1
            tmp(i_) = XYP(i_, 1#)
        Next i_
        Call Spline1DBuildCubic(p.p, tmp, N + 1#, -1#, 0#, -1#, 0#, p.y)
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This  function  builds  periodic  3-dimensional  parametric  spline  which
'starts at (X[0],Y[0],Z[0]), goes through all points to (X[N-1],Y[N-1],Z[N-1])
'and then back to (X[0],Y[0],Z[0]).
'
'Same as PSpline2Build() function, but for 3D, so we  won't  duplicate  its
'description here.
'
'  -- ALGLIB PROJECT --
'     Copyright 28.05.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub PSpline3BuildPeriodic(ByRef XY_() As Double, _
         ByVal N As Long, _
         ByVal ST As Long, _
         ByVal PT As Long, _
         ByRef p As PSpline3Interpolant)
    Dim XY() As Double
    Dim XYP() As Double
    Dim tmp() As Double
    Dim V As Double
    Dim i As Long
    Dim i_ As Long
    XY = XY_
    
    '
    ' Prepare
    '
    p.N = N
    p.Periodic = True
    ReDim tmp(0 To N + 1# - 1)
    ReDim XYP(0 To N + 1# - 1, 0 To 3# - 1)
    For i_ = 0# To N - 1# Step 1
        XYP(i_, 0#) = XY(i_, 0#)
    Next i_
    For i_ = 0# To N - 1# Step 1
        XYP(i_, 1#) = XY(i_, 1#)
    Next i_
    For i_ = 0# To N - 1# Step 1
        XYP(i_, 2#) = XY(i_, 2#)
    Next i_
    For i_ = 0# To 2# Step 1
        XYP(N, i_) = XY(0#, i_)
    Next i_
    
    '
    ' Build parameterization, check that all parameters are distinct
    '
    Call PSpline3Par(XYP, N + 1#, PT, p.p)
    
    '
    ' Build splines
    '
    If ST = 1# Then
        For i_ = 0# To N Step 1
            tmp(i_) = XYP(i_, 0#)
        Next i_
        Call Spline1DBuildCatmullRom(p.p, tmp, N + 1#, -1#, 0#, p.x)
        For i_ = 0# To N Step 1
            tmp(i_) = XYP(i_, 1#)
        Next i_
        Call Spline1DBuildCatmullRom(p.p, tmp, N + 1#, -1#, 0#, p.y)
        For i_ = 0# To N Step 1
            tmp(i_) = XYP(i_, 2#)
        Next i_
        Call Spline1DBuildCatmullRom(p.p, tmp, N + 1#, -1#, 0#, p.z)
    End If
    If ST = 2# Then
        For i_ = 0# To N Step 1
            tmp(i_) = XYP(i_, 0#)
        Next i_
        Call Spline1DBuildCubic(p.p, tmp, N + 1#, -1#, 0#, -1#, 0#, p.x)
        For i_ = 0# To N Step 1
            tmp(i_) = XYP(i_, 1#)
        Next i_
        Call Spline1DBuildCubic(p.p, tmp, N + 1#, -1#, 0#, -1#, 0#, p.y)
        For i_ = 0# To N Step 1
            tmp(i_) = XYP(i_, 2#)
        Next i_
        Call Spline1DBuildCubic(p.p, tmp, N + 1#, -1#, 0#, -1#, 0#, p.z)
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function returns vector of parameter values correspoding to points.
'
'I.e. for P created from (X[0],Y[0])...(X[N-1],Y[N-1]) and U=TValues(P)  we
'have
'    (X[0],Y[0]) = PSpline2Calc(P,U[0]),
'    (X[1],Y[1]) = PSpline2Calc(P,U[1]),
'    (X[2],Y[2]) = PSpline2Calc(P,U[2]),
'    ...
'
'INPUT PARAMETERS:
'    P   -   parametric spline interpolant
'
'OUTPUT PARAMETERS:
'    N   -   array size
'    T   -   array[0..N-1]
'
'
'NOTES:
'* for non-periodic splines U[0]=0, U[0]<U[1]<...<U[N-1], U[N-1]=1
'* for periodic splines     U[0]=0, U[0]<U[1]<...<U[N-1], U[N-1]<1
'
'  -- ALGLIB PROJECT --
'     Copyright 28.05.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub PSpline2ParameterValues(ByRef p As PSpline2Interpolant, _
         ByRef N As Long, _
         ByRef t() As Double)
    Dim i_ As Long
    N = p.N
    ReDim t(0 To N - 1)
    For i_ = 0# To N - 1# Step 1
        t(i_) = p.p(i_)
    Next i_
    t(0#) = 0#
    If Not p.Periodic Then
        t(N - 1#) = 1#
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function returns vector of parameter values correspoding to points.
'
'Same as PSpline2ParameterValues(), but for 3D.
'
'  -- ALGLIB PROJECT --
'     Copyright 28.05.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub PSpline3ParameterValues(ByRef p As PSpline3Interpolant, _
         ByRef N As Long, _
         ByRef t() As Double)
    Dim i_ As Long
    N = p.N
    ReDim t(0 To N - 1)
    For i_ = 0# To N - 1# Step 1
        t(i_) = p.p(i_)
    Next i_
    t(0#) = 0#
    If Not p.Periodic Then
        t(N - 1#) = 1#
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function  calculates  the value of the parametric spline for a  given
'value of parameter T
'
'INPUT PARAMETERS:
'    P   -   parametric spline interpolant
'    T   -   point:
'            * T in [0,1] corresponds to interval spanned by points
'            * for non-periodic splines T<0 (or T>1) correspond to parts of
'              the curve before the first (after the last) point
'            * for periodic splines T<0 (or T>1) are projected  into  [0,1]
'              by making T=T-floor(T).
'
'OUTPUT PARAMETERS:
'    X   -   X-position
'    Y   -   Y-position
'
'
'  -- ALGLIB PROJECT --
'     Copyright 28.05.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub PSpline2Calc(ByRef p As PSpline2Interpolant, _
         ByVal t As Double, _
         ByRef x As Double, _
         ByRef y As Double)
    If p.Periodic Then
        t = t - Int(t)
    End If
    x = Spline1DCalc(p.x, t)
    y = Spline1DCalc(p.y, t)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function  calculates  the value of the parametric spline for a  given
'value of parameter T.
'
'INPUT PARAMETERS:
'    P   -   parametric spline interpolant
'    T   -   point:
'            * T in [0,1] corresponds to interval spanned by points
'            * for non-periodic splines T<0 (or T>1) correspond to parts of
'              the curve before the first (after the last) point
'            * for periodic splines T<0 (or T>1) are projected  into  [0,1]
'              by making T=T-floor(T).
'
'OUTPUT PARAMETERS:
'    X   -   X-position
'    Y   -   Y-position
'    Z   -   Z-position
'
'
'  -- ALGLIB PROJECT --
'     Copyright 28.05.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub PSpline3Calc(ByRef p As PSpline3Interpolant, _
         ByVal t As Double, _
         ByRef x As Double, _
         ByRef y As Double, _
         ByRef z As Double)
    If p.Periodic Then
        t = t - Int(t)
    End If
    x = Spline1DCalc(p.x, t)
    y = Spline1DCalc(p.y, t)
    z = Spline1DCalc(p.z, t)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function  calculates  tangent vector for a given value of parameter T
'
'INPUT PARAMETERS:
'    P   -   parametric spline interpolant
'    T   -   point:
'            * T in [0,1] corresponds to interval spanned by points
'            * for non-periodic splines T<0 (or T>1) correspond to parts of
'              the curve before the first (after the last) point
'            * for periodic splines T<0 (or T>1) are projected  into  [0,1]
'              by making T=T-floor(T).
'
'OUTPUT PARAMETERS:
'    X    -   X-component of tangent vector (normalized)
'    Y    -   Y-component of tangent vector (normalized)
'
'NOTE:
'    X^2+Y^2 is either 1 (for non-zero tangent vector) or 0.
'
'
'  -- ALGLIB PROJECT --
'     Copyright 28.05.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub PSpline2Tangent(ByRef p As PSpline2Interpolant, _
         ByVal t As Double, _
         ByRef x As Double, _
         ByRef y As Double)
    Dim V As Double
    Dim V0 As Double
    Dim V1 As Double
    If p.Periodic Then
        t = t - Int(t)
    End If
    Call PSpline2Diff(p, t, V0, x, V1, y)
    If x <> 0# Or y <> 0# Then
        
        '
        ' this code is a bit more complex than X^2+Y^2 to avoid
        ' overflow for large values of X and Y.
        '
        V = SafePythag2(x, y)
        x = x / V
        y = y / V
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function  calculates  tangent vector for a given value of parameter T
'
'INPUT PARAMETERS:
'    P   -   parametric spline interpolant
'    T   -   point:
'            * T in [0,1] corresponds to interval spanned by points
'            * for non-periodic splines T<0 (or T>1) correspond to parts of
'              the curve before the first (after the last) point
'            * for periodic splines T<0 (or T>1) are projected  into  [0,1]
'              by making T=T-floor(T).
'
'OUTPUT PARAMETERS:
'    X    -   X-component of tangent vector (normalized)
'    Y    -   Y-component of tangent vector (normalized)
'    Z    -   Z-component of tangent vector (normalized)
'
'NOTE:
'    X^2+Y^2+Z^2 is either 1 (for non-zero tangent vector) or 0.
'
'
'  -- ALGLIB PROJECT --
'     Copyright 28.05.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub PSpline3Tangent(ByRef p As PSpline3Interpolant, _
         ByVal t As Double, _
         ByRef x As Double, _
         ByRef y As Double, _
         ByRef z As Double)
    Dim V As Double
    Dim V0 As Double
    Dim V1 As Double
    Dim V2 As Double
    If p.Periodic Then
        t = t - Int(t)
    End If
    Call PSpline3Diff(p, t, V0, x, V1, y, V2, z)
    If x <> 0# Or y <> 0# Or z <> 0# Then
        V = SafePythag3(x, y, z)
        x = x / V
        y = y / V
        z = z / V
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function calculates derivative, i.e. it returns (dX/dT,dY/dT).
'
'INPUT PARAMETERS:
'    P   -   parametric spline interpolant
'    T   -   point:
'            * T in [0,1] corresponds to interval spanned by points
'            * for non-periodic splines T<0 (or T>1) correspond to parts of
'              the curve before the first (after the last) point
'            * for periodic splines T<0 (or T>1) are projected  into  [0,1]
'              by making T=T-floor(T).
'
'OUTPUT PARAMETERS:
'    X   -   X-value
'    DX  -   X-derivative
'    Y   -   Y-value
'    DY  -   Y-derivative
'
'
'  -- ALGLIB PROJECT --
'     Copyright 28.05.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub PSpline2Diff(ByRef p As PSpline2Interpolant, _
         ByVal t As Double, _
         ByRef x As Double, _
         ByRef DX As Double, _
         ByRef y As Double, _
         ByRef DY As Double)
    Dim D2S As Double
    If p.Periodic Then
        t = t - Int(t)
    End If
    Call Spline1DDiff(p.x, t, x, DX, D2S)
    Call Spline1DDiff(p.y, t, y, DY, D2S)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function calculates derivative, i.e. it returns (dX/dT,dY/dT,dZ/dT).
'
'INPUT PARAMETERS:
'    P   -   parametric spline interpolant
'    T   -   point:
'            * T in [0,1] corresponds to interval spanned by points
'            * for non-periodic splines T<0 (or T>1) correspond to parts of
'              the curve before the first (after the last) point
'            * for periodic splines T<0 (or T>1) are projected  into  [0,1]
'              by making T=T-floor(T).
'
'OUTPUT PARAMETERS:
'    X   -   X-value
'    DX  -   X-derivative
'    Y   -   Y-value
'    DY  -   Y-derivative
'    Z   -   Z-value
'    DZ  -   Z-derivative
'
'
'  -- ALGLIB PROJECT --
'     Copyright 28.05.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub PSpline3Diff(ByRef p As PSpline3Interpolant, _
         ByVal t As Double, _
         ByRef x As Double, _
         ByRef DX As Double, _
         ByRef y As Double, _
         ByRef DY As Double, _
         ByRef z As Double, _
         ByRef DZ As Double)
    Dim D2S As Double
    If p.Periodic Then
        t = t - Int(t)
    End If
    Call Spline1DDiff(p.x, t, x, DX, D2S)
    Call Spline1DDiff(p.y, t, y, DY, D2S)
    Call Spline1DDiff(p.z, t, z, DZ, D2S)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function calculates first and second derivative with respect to T.
'
'INPUT PARAMETERS:
'    P   -   parametric spline interpolant
'    T   -   point:
'            * T in [0,1] corresponds to interval spanned by points
'            * for non-periodic splines T<0 (or T>1) correspond to parts of
'              the curve before the first (after the last) point
'            * for periodic splines T<0 (or T>1) are projected  into  [0,1]
'              by making T=T-floor(T).
'
'OUTPUT PARAMETERS:
'    X   -   X-value
'    DX  -   derivative
'    D2X -   second derivative
'    Y   -   Y-value
'    DY  -   derivative
'    D2Y -   second derivative
'
'
'  -- ALGLIB PROJECT --
'     Copyright 28.05.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub PSpline2Diff2(ByRef p As PSpline2Interpolant, _
         ByVal t As Double, _
         ByRef x As Double, _
         ByRef DX As Double, _
         ByRef D2X As Double, _
         ByRef y As Double, _
         ByRef DY As Double, _
         ByRef D2Y As Double)
    If p.Periodic Then
        t = t - Int(t)
    End If
    Call Spline1DDiff(p.x, t, x, DX, D2X)
    Call Spline1DDiff(p.y, t, y, DY, D2Y)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function calculates first and second derivative with respect to T.
'
'INPUT PARAMETERS:
'    P   -   parametric spline interpolant
'    T   -   point:
'            * T in [0,1] corresponds to interval spanned by points
'            * for non-periodic splines T<0 (or T>1) correspond to parts of
'              the curve before the first (after the last) point
'            * for periodic splines T<0 (or T>1) are projected  into  [0,1]
'              by making T=T-floor(T).
'
'OUTPUT PARAMETERS:
'    X   -   X-value
'    DX  -   derivative
'    D2X -   second derivative
'    Y   -   Y-value
'    DY  -   derivative
'    D2Y -   second derivative
'    Z   -   Z-value
'    DZ  -   derivative
'    D2Z -   second derivative
'
'
'  -- ALGLIB PROJECT --
'     Copyright 28.05.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub PSpline3Diff2(ByRef p As PSpline3Interpolant, _
         ByVal t As Double, _
         ByRef x As Double, _
         ByRef DX As Double, _
         ByRef D2X As Double, _
         ByRef y As Double, _
         ByRef DY As Double, _
         ByRef D2Y As Double, _
         ByRef z As Double, _
         ByRef DZ As Double, _
         ByRef D2Z As Double)
    If p.Periodic Then
        t = t - Int(t)
    End If
    Call Spline1DDiff(p.x, t, x, DX, D2X)
    Call Spline1DDiff(p.y, t, y, DY, D2Y)
    Call Spline1DDiff(p.z, t, z, DZ, D2Z)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function  calculates  arc length, i.e. length of  curve  between  t=a
'and t=b.
'
'INPUT PARAMETERS:
'    P   -   parametric spline interpolant
'    A,B -   parameter values corresponding to arc ends:
'            * B>A will result in positive length returned
'            * B<A will result in negative length returned
'
'RESULT:
'    length of arc starting at T=A and ending at T=B.
'
'
'  -- ALGLIB PROJECT --
'     Copyright 30.05.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function PSpline2ArcLength(ByRef p As PSpline2Interpolant, _
         ByVal a As Double, _
         ByVal B As Double) As Double
    Dim Result As Double
    Dim State As AutoGKState
    Dim Rep As AutoGKReport
    Dim SX As Double
    Dim DSX As Double
    Dim D2SX As Double
    Dim SY As Double
    Dim DSY As Double
    Dim D2SY As Double
    Call AutoGKSmooth(a, B, State)
    Do While AutoGKIteration(State)
        Call Spline1DDiff(p.x, State.x, SX, DSX, D2SX)
        Call Spline1DDiff(p.y, State.x, SY, DSY, D2SY)
        State.f = SafePythag2(DSX, DSY)
    Loop
    Call AutoGKResults(State, Result, Rep)
    PSpline2ArcLength = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function  calculates  arc length, i.e. length of  curve  between  t=a
'and t=b.
'
'INPUT PARAMETERS:
'    P   -   parametric spline interpolant
'    A,B -   parameter values corresponding to arc ends:
'            * B>A will result in positive length returned
'            * B<A will result in negative length returned
'
'RESULT:
'    length of arc starting at T=A and ending at T=B.
'
'
'  -- ALGLIB PROJECT --
'     Copyright 30.05.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function PSpline3ArcLength(ByRef p As PSpline3Interpolant, _
         ByVal a As Double, _
         ByVal B As Double) As Double
    Dim Result As Double
    Dim State As AutoGKState
    Dim Rep As AutoGKReport
    Dim SX As Double
    Dim DSX As Double
    Dim D2SX As Double
    Dim SY As Double
    Dim DSY As Double
    Dim D2SY As Double
    Dim SZ As Double
    Dim DSZ As Double
    Dim D2SZ As Double
    Call AutoGKSmooth(a, B, State)
    Do While AutoGKIteration(State)
        Call Spline1DDiff(p.x, State.x, SX, DSX, D2SX)
        Call Spline1DDiff(p.y, State.x, SY, DSY, D2SY)
        Call Spline1DDiff(p.z, State.x, SZ, DSZ, D2SZ)
        State.f = SafePythag3(DSX, DSY, DSZ)
    Loop
    Call AutoGKResults(State, Result, Rep)
    PSpline3ArcLength = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Builds non-periodic parameterization for 2-dimensional spline
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub PSpline2Par(ByRef XY() As Double, _
         ByVal N As Long, _
         ByVal PT As Long, _
         ByRef p() As Double)
    Dim V As Double
    Dim i As Long
    Dim i_ As Long
    
    '
    ' Build parameterization:
    ' * fill by non-normalized values
    ' * normalize them so we have P[0]=0, P[N-1]=1.
    '
    ReDim p(0 To N - 1)
    If PT = 0# Then
        For i = 0# To N - 1# Step 1
            p(i) = i
        Next i
    End If
    If PT = 1# Then
        p(0#) = 0#
        For i = 1# To N - 1# Step 1
            p(i) = p(i - 1#) + SafePythag2(XY(i, 0#) - XY(i - 1#, 0#), XY(i, 1#) - XY(i - 1#, 1#))
        Next i
    End If
    If PT = 2# Then
        p(0#) = 0#
        For i = 1# To N - 1# Step 1
            p(i) = p(i - 1#) + Sqr(SafePythag2(XY(i, 0#) - XY(i - 1#, 0#), XY(i, 1#) - XY(i - 1#, 1#)))
        Next i
    End If
    V = 1# / p(N - 1#)
    For i_ = 0# To N - 1# Step 1
        p(i_) = V * p(i_)
    Next i_
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Builds non-periodic parameterization for 3-dimensional spline
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub PSpline3Par(ByRef XY() As Double, _
         ByVal N As Long, _
         ByVal PT As Long, _
         ByRef p() As Double)
    Dim V As Double
    Dim i As Long
    Dim i_ As Long
    
    '
    ' Build parameterization:
    ' * fill by non-normalized values
    ' * normalize them so we have P[0]=0, P[N-1]=1.
    '
    ReDim p(0 To N - 1)
    If PT = 0# Then
        For i = 0# To N - 1# Step 1
            p(i) = i
        Next i
    End If
    If PT = 1# Then
        p(0#) = 0#
        For i = 1# To N - 1# Step 1
            p(i) = p(i - 1#) + SafePythag3(XY(i, 0#) - XY(i - 1#, 0#), XY(i, 1#) - XY(i - 1#, 1#), XY(i, 2#) - XY(i - 1#, 2#))
        Next i
    End If
    If PT = 2# Then
        p(0#) = 0#
        For i = 1# To N - 1# Step 1
            p(i) = p(i - 1#) + Sqr(SafePythag3(XY(i, 0#) - XY(i - 1#, 0#), XY(i, 1#) - XY(i - 1#, 1#), XY(i, 2#) - XY(i - 1#, 2#)))
        Next i
    End If
    V = 1# / p(N - 1#)
    For i_ = 0# To N - 1# Step 1
        p(i_) = V * p(i_)
    Next i_
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'ARGONNE NATIONAL LABORATORY. MINPACK PROJECT. JUNE 1983
'JORGE J. MORE', DAVID J. THUENTE
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Normalizes direction/step pair: makes |D|=1, scales Stp.
'If |D|=0, it returns, leavind D/Stp unchanged.
'
'  -- ALGLIB --
'     Copyright 01.04.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub LinMinNormalizeD(ByRef d() As Double, _
         ByRef Stp As Double, _
         ByVal N As Long)
    Dim MX As Double
    Dim s As Double
    Dim i As Long
    Dim i_ As Long
    
    '
    ' first, scale D to avoid underflow/overflow durng squaring
    '
    MX = 0#
    For i = 0# To N - 1# Step 1
        MX = MaxReal(MX, Abs(d(i)))
    Next i
    If MX = 0# Then
        Exit Sub
    End If
    s = 1# / MX
    For i_ = 0# To N - 1# Step 1
        d(i_) = s * d(i_)
    Next i_
    Stp = Stp / s
    
    '
    ' normalize D
    '
    s = 0#
    For i_ = 0# To N - 1# Step 1
        s = s + d(i_) * d(i_)
    Next i_
    s = 1# / Sqr(s)
    For i_ = 0# To N - 1# Step 1
        d(i_) = s * d(i_)
    Next i_
    Stp = Stp / s
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'THE  PURPOSE  OF  MCSRCH  IS  TO  FIND A STEP WHICH SATISFIES A SUFFICIENT
'DECREASE CONDITION AND A CURVATURE CONDITION.
'
'AT EACH STAGE THE SUBROUTINE  UPDATES  AN  INTERVAL  OF  UNCERTAINTY  WITH
'ENDPOINTS  STX  AND  STY.  THE INTERVAL OF UNCERTAINTY IS INITIALLY CHOSEN
'SO THAT IT CONTAINS A MINIMIZER OF THE MODIFIED FUNCTION
'
'    F(X+STP*S) - F(X) - FTOL*STP*(GRADF(X)'S).
'
'IF  A STEP  IS OBTAINED FOR  WHICH THE MODIFIED FUNCTION HAS A NONPOSITIVE
'FUNCTION  VALUE  AND  NONNEGATIVE  DERIVATIVE,   THEN   THE   INTERVAL  OF
'UNCERTAINTY IS CHOSEN SO THAT IT CONTAINS A MINIMIZER OF F(X+STP*S).
'
'THE  ALGORITHM  IS  DESIGNED TO FIND A STEP WHICH SATISFIES THE SUFFICIENT
'DECREASE CONDITION
'
'    F(X+STP*S) .LE. F(X) + FTOL*STP*(GRADF(X)'S),
'
'AND THE CURVATURE CONDITION
'
'    ABS(GRADF(X+STP*S)'S)) .LE. GTOL*ABS(GRADF(X)'S).
'
'IF  FTOL  IS  LESS  THAN GTOL AND IF, FOR EXAMPLE, THE FUNCTION IS BOUNDED
'BELOW,  THEN  THERE  IS  ALWAYS  A  STEP  WHICH SATISFIES BOTH CONDITIONS.
'IF  NO  STEP  CAN BE FOUND  WHICH  SATISFIES  BOTH  CONDITIONS,  THEN  THE
'ALGORITHM  USUALLY STOPS  WHEN  ROUNDING ERRORS  PREVENT FURTHER PROGRESS.
'IN THIS CASE STP ONLY SATISFIES THE SUFFICIENT DECREASE CONDITION.
'
'PARAMETERS DESCRIPRION
'
'N IS A POSITIVE INTEGER INPUT VARIABLE SET TO THE NUMBER OF VARIABLES.
'
'X IS  AN  ARRAY  OF  LENGTH N. ON INPUT IT MUST CONTAIN THE BASE POINT FOR
'THE LINE SEARCH. ON OUTPUT IT CONTAINS X+STP*S.
'
'F IS  A  VARIABLE. ON INPUT IT MUST CONTAIN THE VALUE OF F AT X. ON OUTPUT
'IT CONTAINS THE VALUE OF F AT X + STP*S.
'
'G IS AN ARRAY OF LENGTH N. ON INPUT IT MUST CONTAIN THE GRADIENT OF F AT X.
'ON OUTPUT IT CONTAINS THE GRADIENT OF F AT X + STP*S.
'
'S IS AN INPUT ARRAY OF LENGTH N WHICH SPECIFIES THE SEARCH DIRECTION.
'
'STP  IS  A NONNEGATIVE VARIABLE. ON INPUT STP CONTAINS AN INITIAL ESTIMATE
'OF A SATISFACTORY STEP. ON OUTPUT STP CONTAINS THE FINAL ESTIMATE.
'
'FTOL AND GTOL ARE NONNEGATIVE INPUT VARIABLES. TERMINATION OCCURS WHEN THE
'SUFFICIENT DECREASE CONDITION AND THE DIRECTIONAL DERIVATIVE CONDITION ARE
'SATISFIED.
'
'XTOL IS A NONNEGATIVE INPUT VARIABLE. TERMINATION OCCURS WHEN THE RELATIVE
'WIDTH OF THE INTERVAL OF UNCERTAINTY IS AT MOST XTOL.
'
'STPMIN AND STPMAX ARE NONNEGATIVE INPUT VARIABLES WHICH SPECIFY LOWER  AND
'UPPER BOUNDS FOR THE STEP.
'
'MAXFEV IS A POSITIVE INTEGER INPUT VARIABLE. TERMINATION OCCURS WHEN THE
'NUMBER OF CALLS TO FCN IS AT LEAST MAXFEV BY THE END OF AN ITERATION.
'
'INFO IS AN INTEGER OUTPUT VARIABLE SET AS FOLLOWS:
'    INFO = 0  IMPROPER INPUT PARAMETERS.
'
'    INFO = 1  THE SUFFICIENT DECREASE CONDITION AND THE
'              DIRECTIONAL DERIVATIVE CONDITION HOLD.
'
'    INFO = 2  RELATIVE WIDTH OF THE INTERVAL OF UNCERTAINTY
'              IS AT MOST XTOL.
'
'    INFO = 3  NUMBER OF CALLS TO FCN HAS REACHED MAXFEV.
'
'    INFO = 4  THE STEP IS AT THE LOWER BOUND STPMIN.
'
'    INFO = 5  THE STEP IS AT THE UPPER BOUND STPMAX.
'
'    INFO = 6  ROUNDING ERRORS PREVENT FURTHER PROGRESS.
'              THERE MAY NOT BE A STEP WHICH SATISFIES THE
'              SUFFICIENT DECREASE AND CURVATURE CONDITIONS.
'              TOLERANCES MAY BE TOO SMALL.
'
'NFEV IS AN INTEGER OUTPUT VARIABLE SET TO THE NUMBER OF CALLS TO FCN.
'
'WA IS A WORK ARRAY OF LENGTH N.
'
'ARGONNE NATIONAL LABORATORY. MINPACK PROJECT. JUNE 1983
'JORGE J. MORE', DAVID J. THUENTE
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MCSRCH(ByRef N As Long, _
         ByRef x() As Double, _
         ByRef f As Double, _
         ByRef g() As Double, _
         ByRef s() As Double, _
         ByRef Stp As Double, _
         ByVal StpMax As Double, _
         ByRef Info As Long, _
         ByRef NFEV As Long, _
         ByRef WA() As Double, _
         ByRef State As LINMINState, _
         ByRef Stage As Long)
    Dim V As Double
    Dim P5 As Double
    Dim P66 As Double
    Dim ZERO As Double
    Dim i_ As Long
    
    '
    ' init
    '
    P5 = 0.5
    P66 = 0.66
    State.XTRAPF = 4#
    ZERO = 0#
    If StpMax = 0# Then
        StpMax = DefSTPMAX
    End If
    If Stp < STPMIN Then
        Stp = STPMIN
    End If
    If Stp > StpMax Then
        Stp = StpMax
    End If
    
    '
    ' Main cycle
    '
    Do While True
        If Stage = 0# Then
            
            '
            ' NEXT
            '
            Stage = 2#
            GoTo Cont_1
        End If
        If Stage = 2# Then
            State.INFOC = 1#
            Info = 0#
            
            '
            '     CHECK THE INPUT PARAMETERS FOR ERRORS.
            '
            If N <= 0# Or Stp <= 0# Or FTOL < 0# Or GTOL < ZERO Or XTOL < ZERO Or STPMIN < ZERO Or StpMax < STPMIN Or MAXFEV <= 0# Then
                Stage = 0#
                Exit Sub
            End If
            
            '
            '     COMPUTE THE INITIAL GRADIENT IN THE SEARCH DIRECTION
            '     AND CHECK THAT S IS A DESCENT DIRECTION.
            '
            V = 0#
            For i_ = 0# To N - 1# Step 1
                V = V + g(i_) * s(i_)
            Next i_
            State.DGInit = V
            If State.DGInit >= 0# Then
                Stage = 0#
                Exit Sub
            End If
            
            '
            '     INITIALIZE LOCAL VARIABLES.
            '
            State.BRACKT = False
            State.STAGE1 = True
            NFEV = 0#
            State.FInit = f
            State.DGTEST = FTOL * State.DGInit
            State.WIDTH = StpMax - STPMIN
            State.WIDTH1 = State.WIDTH / P5
            For i_ = 0# To N - 1# Step 1
                WA(i_) = x(i_)
            Next i_
            
            '
            '     THE VARIABLES STX, FX, DGX CONTAIN THE VALUES OF THE STEP,
            '     FUNCTION, AND DIRECTIONAL DERIVATIVE AT THE BEST STEP.
            '     THE VARIABLES STY, FY, DGY CONTAIN THE VALUE OF THE STEP,
            '     FUNCTION, AND DERIVATIVE AT THE OTHER ENDPOINT OF
            '     THE INTERVAL OF UNCERTAINTY.
            '     THE VARIABLES STP, F, DG CONTAIN THE VALUES OF THE STEP,
            '     FUNCTION, AND DERIVATIVE AT THE CURRENT STEP.
            '
            State.STX = 0#
            State.FX = State.FInit
            State.DGX = State.DGInit
            State.STY = 0#
            State.FY = State.FInit
            State.DGY = State.DGInit
            
            '
            ' NEXT
            '
            Stage = 3#
            GoTo Cont_1
        End If
        If Stage = 3# Then
            
            '
            '     START OF ITERATION.
            '
            '     SET THE MINIMUM AND MAXIMUM STEPS TO CORRESPOND
            '     TO THE PRESENT INTERVAL OF UNCERTAINTY.
            '
            If State.BRACKT Then
                If State.STX < State.STY Then
                    State.STMIN = State.STX
                    State.STMAX = State.STY
                Else
                    State.STMIN = State.STY
                    State.STMAX = State.STX
                End If
            Else
                State.STMIN = State.STX
                State.STMAX = Stp + State.XTRAPF * (Stp - State.STX)
            End If
            
            '
            '        FORCE THE STEP TO BE WITHIN THE BOUNDS STPMAX AND STPMIN.
            '
            If Stp > StpMax Then
                Stp = StpMax
            End If
            If Stp < STPMIN Then
                Stp = STPMIN
            End If
            
            '
            '        IF AN UNUSUAL TERMINATION IS TO OCCUR THEN LET
            '        STP BE THE LOWEST POINT OBTAINED SO FAR.
            '
            If State.BRACKT And (Stp <= State.STMIN Or Stp >= State.STMAX) Or NFEV >= MAXFEV - 1# Or State.INFOC = 0# Or State.BRACKT And State.STMAX - State.STMIN <= XTOL * State.STMAX Then
                Stp = State.STX
            End If
            
            '
            '        EVALUATE THE FUNCTION AND GRADIENT AT STP
            '        AND COMPUTE THE DIRECTIONAL DERIVATIVE.
            '
            For i_ = 0# To N - 1# Step 1
                x(i_) = WA(i_)
            Next i_
            For i_ = 0# To N - 1# Step 1
                x(i_) = x(i_) + Stp * s(i_)
            Next i_
            
            '
            ' NEXT
            '
            Stage = 4#
            Exit Sub
        End If
        If Stage = 4# Then
            Info = 0#
            NFEV = NFEV + 1#
            V = 0#
            For i_ = 0# To N - 1# Step 1
                V = V + g(i_) * s(i_)
            Next i_
            State.DG = V
            State.FTEST1 = State.FInit + Stp * State.DGTEST
            
            '
            '        TEST FOR CONVERGENCE.
            '
            If State.BRACKT And (Stp <= State.STMIN Or Stp >= State.STMAX) Or State.INFOC = 0# Then
                Info = 6#
            End If
            If Stp = StpMax And f <= State.FTEST1 And State.DG <= State.DGTEST Then
                Info = 5#
            End If
            If Stp = STPMIN And (f > State.FTEST1 Or State.DG >= State.DGTEST) Then
                Info = 4#
            End If
            If NFEV >= MAXFEV Then
                Info = 3#
            End If
            If State.BRACKT And State.STMAX - State.STMIN <= XTOL * State.STMAX Then
                Info = 2#
            End If
            If f <= State.FTEST1 And Abs(State.DG) <= -(GTOL * State.DGInit) Then
                Info = 1#
            End If
            
            '
            '        CHECK FOR TERMINATION.
            '
            If Info <> 0# Then
                Stage = 0#
                Exit Sub
            End If
            
            '
            '        IN THE FIRST STAGE WE SEEK A STEP FOR WHICH THE MODIFIED
            '        FUNCTION HAS A NONPOSITIVE VALUE AND NONNEGATIVE DERIVATIVE.
            '
            If State.STAGE1 And f <= State.FTEST1 And State.DG >= MinReal(FTOL, GTOL) * State.DGInit Then
                State.STAGE1 = False
            End If
            
            '
            '        A MODIFIED FUNCTION IS USED TO PREDICT THE STEP ONLY IF
            '        WE HAVE NOT OBTAINED A STEP FOR WHICH THE MODIFIED
            '        FUNCTION HAS A NONPOSITIVE FUNCTION VALUE AND NONNEGATIVE
            '        DERIVATIVE, AND IF A LOWER FUNCTION VALUE HAS BEEN
            '        OBTAINED BUT THE DECREASE IS NOT SUFFICIENT.
            '
            If State.STAGE1 And f <= State.FX And f > State.FTEST1 Then
                
                '
                '           DEFINE THE MODIFIED FUNCTION AND DERIVATIVE VALUES.
                '
                State.FM = f - Stp * State.DGTEST
                State.FXM = State.FX - State.STX * State.DGTEST
                State.FYM = State.FY - State.STY * State.DGTEST
                State.DGM = State.DG - State.DGTEST
                State.DGXM = State.DGX - State.DGTEST
                State.DGYM = State.DGY - State.DGTEST
                
                '
                '           CALL CSTEP TO UPDATE THE INTERVAL OF UNCERTAINTY
                '           AND TO COMPUTE THE NEW STEP.
                '
                Call MCSTEP(State.STX, State.FXM, State.DGXM, State.STY, State.FYM, State.DGYM, Stp, State.FM, State.DGM, State.BRACKT, State.STMIN, State.STMAX, State.INFOC)
                
                '
                '           RESET THE FUNCTION AND GRADIENT VALUES FOR F.
                '
                State.FX = State.FXM + State.STX * State.DGTEST
                State.FY = State.FYM + State.STY * State.DGTEST
                State.DGX = State.DGXM + State.DGTEST
                State.DGY = State.DGYM + State.DGTEST
            Else
                
                '
                '           CALL MCSTEP TO UPDATE THE INTERVAL OF UNCERTAINTY
                '           AND TO COMPUTE THE NEW STEP.
                '
                Call MCSTEP(State.STX, State.FX, State.DGX, State.STY, State.FY, State.DGY, Stp, f, State.DG, State.BRACKT, State.STMIN, State.STMAX, State.INFOC)
            End If
            
            '
            '        FORCE A SUFFICIENT DECREASE IN THE SIZE OF THE
            '        INTERVAL OF UNCERTAINTY.
            '
            If State.BRACKT Then
                If Abs(State.STY - State.STX) >= P66 * State.WIDTH1 Then
                    Stp = State.STX + P5 * (State.STY - State.STX)
                End If
                State.WIDTH1 = State.WIDTH
                State.WIDTH = Abs(State.STY - State.STX)
            End If
            
            '
            '  NEXT.
            '
            Stage = 3#
            GoTo Cont_1
        End If
Cont_1:
    Loop
End Sub
Private Sub MCSTEP(ByRef STX As Double, _
         ByRef FX As Double, _
         ByRef DX As Double, _
         ByRef STY As Double, _
         ByRef FY As Double, _
         ByRef DY As Double, _
         ByRef Stp As Double, _
         ByRef FP As Double, _
         ByRef DP As Double, _
         ByRef BRACKT As Boolean, _
         ByRef STMIN As Double, _
         ByRef STMAX As Double, _
         ByRef Info As Long)
    Dim BOUND As Boolean
    Dim Gamma As Double
    Dim p As Double
    Dim q As Double
    Dim R As Double
    Dim s As Double
    Dim SGND As Double
    Dim STPC As Double
    Dim STPF As Double
    Dim STPQ As Double
    Dim THETA As Double
    Info = 0#
    
    '
    '     CHECK THE INPUT PARAMETERS FOR ERRORS.
    '
    If BRACKT And (Stp <= MinReal(STX, STY) Or Stp >= MaxReal(STX, STY)) Or DX * (Stp - STX) >= 0# Or STMAX < STMIN Then
        Exit Sub
    End If
    
    '
    '     DETERMINE IF THE DERIVATIVES HAVE OPPOSITE SIGN.
    '
    SGND = DP * (DX / Abs(DX))
    
    '
    '     FIRST CASE. A HIGHER FUNCTION VALUE.
    '     THE MINIMUM IS BRACKETED. IF THE CUBIC STEP IS CLOSER
    '     TO STX THAN THE QUADRATIC STEP, THE CUBIC STEP IS TAKEN,
    '     ELSE THE AVERAGE OF THE CUBIC AND QUADRATIC STEPS IS TAKEN.
    '
    If FP > FX Then
        Info = 1#
        BOUND = True
        THETA = 3# * (FX - FP) / (Stp - STX) + DX + DP
        s = MaxReal(Abs(THETA), MaxReal(Abs(DX), Abs(DP)))
        Gamma = s * Sqr(Square(THETA / s) - DX / s * (DP / s))
        If Stp < STX Then
            Gamma = -Gamma
        End If
        p = Gamma - DX + THETA
        q = Gamma - DX + Gamma + DP
        R = p / q
        STPC = STX + R * (Stp - STX)
        STPQ = STX + DX / ((FX - FP) / (Stp - STX) + DX) / 2# * (Stp - STX)
        If Abs(STPC - STX) < Abs(STPQ - STX) Then
            STPF = STPC
        Else
            STPF = STPC + (STPQ - STPC) / 2#
        End If
        BRACKT = True
    Else
        If SGND < 0# Then
            
            '
            '     SECOND CASE. A LOWER FUNCTION VALUE AND DERIVATIVES OF
            '     OPPOSITE SIGN. THE MINIMUM IS BRACKETED. IF THE CUBIC
            '     STEP IS CLOSER TO STX THAN THE QUADRATIC (SECANT) STEP,
            '     THE CUBIC STEP IS TAKEN, ELSE THE QUADRATIC STEP IS TAKEN.
            '
            Info = 2#
            BOUND = False
            THETA = 3# * (FX - FP) / (Stp - STX) + DX + DP
            s = MaxReal(Abs(THETA), MaxReal(Abs(DX), Abs(DP)))
            Gamma = s * Sqr(Square(THETA / s) - DX / s * (DP / s))
            If Stp > STX Then
                Gamma = -Gamma
            End If
            p = Gamma - DP + THETA
            q = Gamma - DP + Gamma + DX
            R = p / q
            STPC = Stp + R * (STX - Stp)
            STPQ = Stp + DP / (DP - DX) * (STX - Stp)
            If Abs(STPC - Stp) > Abs(STPQ - Stp) Then
                STPF = STPC
            Else
                STPF = STPQ
            End If
            BRACKT = True
        Else
            If Abs(DP) < Abs(DX) Then
                
                '
                '     THIRD CASE. A LOWER FUNCTION VALUE, DERIVATIVES OF THE
                '     SAME SIGN, AND THE MAGNITUDE OF THE DERIVATIVE DECREASES.
                '     THE CUBIC STEP IS ONLY USED IF THE CUBIC TENDS TO INFINITY
                '     IN THE DIRECTION OF THE STEP OR IF THE MINIMUM OF THE CUBIC
                '     IS BEYOND STP. OTHERWISE THE CUBIC STEP IS DEFINED TO BE
                '     EITHER STPMIN OR STPMAX. THE QUADRATIC (SECANT) STEP IS ALSO
                '     COMPUTED AND IF THE MINIMUM IS BRACKETED THEN THE THE STEP
                '     CLOSEST TO STX IS TAKEN, ELSE THE STEP FARTHEST AWAY IS TAKEN.
                '
                Info = 3#
                BOUND = True
                THETA = 3# * (FX - FP) / (Stp - STX) + DX + DP
                s = MaxReal(Abs(THETA), MaxReal(Abs(DX), Abs(DP)))
                
                '
                '        THE CASE GAMMA = 0 ONLY ARISES IF THE CUBIC DOES NOT TEND
                '        TO INFINITY IN THE DIRECTION OF THE STEP.
                '
                Gamma = s * Sqr(MaxReal(0#, Square(THETA / s) - DX / s * (DP / s)))
                If Stp > STX Then
                    Gamma = -Gamma
                End If
                p = Gamma - DP + THETA
                q = Gamma + (DX - DP) + Gamma
                R = p / q
                If R < 0# And Gamma <> 0# Then
                    STPC = Stp + R * (STX - Stp)
                Else
                    If Stp > STX Then
                        STPC = STMAX
                    Else
                        STPC = STMIN
                    End If
                End If
                STPQ = Stp + DP / (DP - DX) * (STX - Stp)
                If BRACKT Then
                    If Abs(Stp - STPC) < Abs(Stp - STPQ) Then
                        STPF = STPC
                    Else
                        STPF = STPQ
                    End If
                Else
                    If Abs(Stp - STPC) > Abs(Stp - STPQ) Then
                        STPF = STPC
                    Else
                        STPF = STPQ
                    End If
                End If
            Else
                
                '
                '     FOURTH CASE. A LOWER FUNCTION VALUE, DERIVATIVES OF THE
                '     SAME SIGN, AND THE MAGNITUDE OF THE DERIVATIVE DOES
                '     NOT DECREASE. IF THE MINIMUM IS NOT BRACKETED, THE STEP
                '     IS EITHER STPMIN OR STPMAX, ELSE THE CUBIC STEP IS TAKEN.
                '
                Info = 4#
                BOUND = False
                If BRACKT Then
                    THETA = 3# * (FP - FY) / (STY - Stp) + DY + DP
                    s = MaxReal(Abs(THETA), MaxReal(Abs(DY), Abs(DP)))
                    Gamma = s * Sqr(Square(THETA / s) - DY / s * (DP / s))
                    If Stp > STY Then
                        Gamma = -Gamma
                    End If
                    p = Gamma - DP + THETA
                    q = Gamma - DP + Gamma + DY
                    R = p / q
                    STPC = Stp + R * (STY - Stp)
                    STPF = STPC
                Else
                    If Stp > STX Then
                        STPF = STMAX
                    Else
                        STPF = STMIN
                    End If
                End If
            End If
        End If
    End If
    
    '
    '     UPDATE THE INTERVAL OF UNCERTAINTY. THIS UPDATE DOES NOT
    '     DEPEND ON THE NEW STEP OR THE CASE ANALYSIS ABOVE.
    '
    If FP > FX Then
        STY = Stp
        FY = FP
        DY = DP
    Else
        If SGND < 0# Then
            STY = STX
            FY = FX
            DY = DX
        End If
        STX = Stp
        FX = FP
        DX = DP
    End If
    
    '
    '     COMPUTE THE NEW STEP AND SAFEGUARD IT.
    '
    STPF = MinReal(STMAX, STPF)
    STPF = MaxReal(STMIN, STPF)
    Stp = STPF
    If BRACKT And BOUND Then
        If STY > STX Then
            Stp = MinReal(STX + 0.66 * (STY - STX), Stp)
        Else
            Stp = MaxReal(STX + 0.66 * (STY - STX), Stp)
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2010, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'              NONLINEAR BOUND CONSTRAINED OPTIMIZATION USING
'                               MODIFIED
'                   WILLIAM W. HAGER AND HONGCHAO ZHANG
'                         ACTIVE SET ALGORITHM
'
'The  subroutine  minimizes  function  F(x)  of  N  arguments  with   bound
'constraints: BndL[i] <= x[i] <= BndU[i]
'
'This method is  globally  convergent  as  long  as  grad(f)  is  Lipschitz
'continuous on a level set: L = { x : f(x)<=f(x0) }.
'
'INPUT PARAMETERS:
'    N       -   problem dimension. N>0
'    X       -   initial solution approximation, array[0..N-1].
'    BndL    -   lower bounds, array[0..N-1].
'                all elements MUST be specified,  i.e.  all  variables  are
'                bounded. However, if some (all) variables  are  unbounded,
'                you may specify very small number as bound: -1000,  -1.0E6
'                or -1.0E300, or something like that.
'    BndU    -   upper bounds, array[0..N-1].
'                all elements MUST be specified,  i.e.  all  variables  are
'                bounded. However, if some (all) variables  are  unbounded,
'                you may specify very large number as bound: +1000,  +1.0E6
'                or +1.0E300, or something like that.
'    EpsG    -   positive number which  defines  a  precision  of  search.  The
'                subroutine finishes its work if the condition ||G|| < EpsG  is
'                satisfied, where ||.|| means Euclidian norm, G - gradient, X -
'                current approximation.
'    EpsF    -   positive number which  defines  a  precision  of  search.  The
'                subroutine finishes its work if on iteration  number  k+1  the
'                condition |F(k+1)-F(k)| <= EpsF*max{|F(k)|, |F(k+1)|, 1}    is
'                satisfied.
'    EpsX    -   positive number which  defines  a  precision  of  search.  The
'                subroutine finishes its work if on iteration number k+1    the
'                condition |X(k+1)-X(k)| <= EpsX is fulfilled.
'    MaxIts  -   maximum number of iterations. If MaxIts=0, the number of
'                iterations is unlimited.
'
'OUTPUT PARAMETERS:
'    State - structure used for reverse communication.
'
'This function  initializes  State   structure  with  default  optimization
'parameters (stopping conditions, step size, etc.).  Use  MinASASet??????()
'functions to tune optimization parameters.
'
'After   all   optimization   parameters   are   tuned,   you   should  use
'MinASAIteration() function to advance algorithm iterations.
'
'NOTES:
'
'1. you may tune stopping conditions with MinASASetCond() function
'2. if target function contains exp() or other fast growing functions,  and
'   optimization algorithm makes too large steps which leads  to  overflow,
'   use MinASASetStpMax() function to bound algorithm's steps.
'
'  -- ALGLIB --
'     Copyright 25.03.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MinASACreate(ByVal N As Long, _
         ByRef x() As Double, _
         ByRef BndL() As Double, _
         ByRef BndU() As Double, _
         ByRef State As MinASAState)
    Dim i As Long
    Dim i_ As Long
    For i = 0# To N - 1# Step 1
    Next i
    
    '
    ' Initialize
    '
    State.N = N
    Call MinASASetCond(State, 0#, 0#, 0#, 0#)
    Call MinASASetXRep(State, False)
    Call MinASASetStpMax(State, 0#)
    Call MinASASetAlgorithm(State, -1#)
    ReDim State.BndL(0 To N - 1)
    ReDim State.BndU(0 To N - 1)
    ReDim State.AK(0 To N - 1)
    ReDim State.XK(0 To N - 1)
    ReDim State.DK(0 To N - 1)
    ReDim State.AN(0 To N - 1)
    ReDim State.XN(0 To N - 1)
    ReDim State.dn(0 To N - 1)
    ReDim State.x(0 To N - 1)
    ReDim State.d(0 To N - 1)
    ReDim State.g(0 To N - 1)
    ReDim State.GC(0 To N - 1)
    ReDim State.WORK(0 To N - 1)
    ReDim State.YK(0 To N - 1)
    For i_ = 0# To N - 1# Step 1
        State.BndL(i_) = BndL(i_)
    Next i_
    For i_ = 0# To N - 1# Step 1
        State.BndU(i_) = BndU(i_)
    Next i_
    
    '
    ' Prepare first run
    '
    For i_ = 0# To N - 1# Step 1
        State.x(i_) = x(i_)
    Next i_
    ReDim State.RState.IA(0# To 3#)
    ReDim State.RState.BA(0# To 1#)
    ReDim State.RState.RA(0# To 2#)
    State.RState.Stage = -1#
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function sets stopping conditions for the ASA optimization algorithm.
'
'INPUT PARAMETERS:
'    State   -   structure which stores algorithm state between calls and
'                which is used for reverse communication. Must be initialized
'                with MinASACreate()
'    EpsG    -   >=0
'                The  subroutine  finishes  its  work   if   the  condition
'                ||G||<EpsG is satisfied, where ||.|| means Euclidian norm,
'                G - gradient.
'    EpsF    -   >=0
'                The  subroutine  finishes  its work if on k+1-th iteration
'                the  condition  |F(k+1)-F(k)|<=EpsF*max{|F(k)|,|F(k+1)|,1}
'                is satisfied.
'    EpsX    -   >=0
'                The subroutine finishes its work if  on  k+1-th  iteration
'                the condition |X(k+1)-X(k)| <= EpsX is fulfilled.
'    MaxIts  -   maximum number of iterations. If MaxIts=0, the  number  of
'                iterations is unlimited.
'
'Passing EpsG=0, EpsF=0, EpsX=0 and MaxIts=0 (simultaneously) will lead to
'automatic stopping criterion selection (small EpsX).
'
'  -- ALGLIB --
'     Copyright 02.04.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MinASASetCond(ByRef State As MinASAState, _
         ByVal EpsG As Double, _
         ByVal EpsF As Double, _
         ByVal EpsX As Double, _
         ByVal MaxIts As Long)
    If EpsG = 0# And EpsF = 0# And EpsX = 0# And MaxIts = 0# Then
        EpsX = 0.000001
    End If
    State.EpsG = EpsG
    State.EpsF = EpsF
    State.EpsX = EpsX
    State.MaxIts = MaxIts
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function turns on/off reporting.
'
'INPUT PARAMETERS:
'    State   -   structure which stores algorithm state between calls and
'                which is used for reverse communication. Must be
'                initialized with MinASACreate()
'    NeedXRep-   whether iteration reports are needed or not
'
'Usually  algorithm  returns from  MinASAIteration()  only  when  it  needs
'function/gradient. However, with this function we can let  it  stop  after
'each  iteration  (one  iteration  may  include   more  than  one  function
'evaluation), which is indicated by XUpdated field.
'
'  -- ALGLIB --
'     Copyright 02.04.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MinASASetXRep(ByRef State As MinASAState, ByVal NeedXRep As Boolean)
    State.XRep = NeedXRep
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function sets optimization algorithm.
'
'INPUT PARAMETERS:
'    State   -   structure which stores algorithm state between calls and
'                which is used for reverse communication. Must be
'                initialized with MinASACreate()
'    UAType  -   algorithm type:
'                * -1    automatic selection of the best algorithm
'                * 0     DY (Dai and Yuan) algorithm
'                * 1     Hybrid DY-HS algorithm
'
'  -- ALGLIB --
'     Copyright 02.04.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MinASASetAlgorithm(ByRef State As MinASAState, _
         ByVal AlgoType As Long)
    If AlgoType = -1# Then
        AlgoType = 1#
    End If
    State.CGType = AlgoType
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function sets maximum step length
'
'INPUT PARAMETERS:
'    State   -   structure which stores algorithm state between calls and
'                which is used for reverse communication. Must be
'                initialized with MinCGCreate()
'    StpMax  -   maximum step length, >=0. Set StpMax to 0.0,  if you don't
'                want to limit step length.
'
'Use this subroutine when you optimize target function which contains exp()
'or  other  fast  growing  functions,  and optimization algorithm makes too
'large  steps  which  leads  to overflow. This function allows us to reject
'steps  that  are  too  large  (and  therefore  expose  us  to the possible
'overflow) without actually calculating function value at the x+stp*d.
'
'  -- ALGLIB --
'     Copyright 02.04.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MinASASetStpMax(ByRef State As MinASAState, ByVal StpMax As Double)
    State.StpMax = StpMax
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'One ASA iteration
'
'Called after initialization with MinASACreate.
'See HTML documentation for examples.
'
'INPUT PARAMETERS:
'    State   -   structure which stores algorithm state between calls and
'                which is used for reverse communication. Must be initialized
'                with MinASACreate.
'RESULT:
'* if function returned False, iterative proces has converged.
'  Use MinLBFGSResults() to obtain optimization results.
'* if subroutine returned True, then, depending on structure fields, we
'  have one of the following situations
'
'
'=== FUNC/GRAD REQUEST ===
'State.NeedFG is True => function value/gradient are needed.
'Caller should calculate function value State.F and gradient
'State.G[0..N-1] at State.X[0..N-1] and call MinLBFGSIteration() again.
'
'=== NEW INTERATION IS REPORTED ===
'State.XUpdated is True => one more iteration was made.
'State.X contains current position, State.F contains function value at X.
'You can read info from these fields, but never modify  them  because  they
'contain the only copy of optimization algorithm state.
'
'One and only one of these fields (NeedFG, XUpdated) is true on return. New
'iterations are reported only when reports  are  explicitly  turned  on  by
'MinLBFGSSetXRep() function, so if you never called it, you can expect that
'NeedFG is always True.
'
'
'  -- ALGLIB --
'     Copyright 20.03.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function MinASAIteration(ByRef State As MinASAState) As Boolean
    Dim Result As Boolean
    Dim N As Long
    Dim i As Long
    Dim BetaK As Double
    Dim V As Double
    Dim VV As Double
    Dim MCINFO As Long
    Dim B As Boolean
    Dim StepFound As Boolean
    Dim DiffCnt As Long
    Dim i_ As Long
    
    '
    ' Reverse communication preparations
    ' I know it looks ugly, but it works the same way
    ' anywhere from C++ to Python.
    '
    ' This code initializes locals by:
    ' * random values determined during code
    '   generation - on first subroutine call
    ' * values from previous call - on subsequent calls
    '
    If State.RState.Stage >= 0# Then
        N = State.RState.IA(0#)
        i = State.RState.IA(1#)
        MCINFO = State.RState.IA(2#)
        DiffCnt = State.RState.IA(3#)
        B = State.RState.BA(0#)
        StepFound = State.RState.BA(1#)
        BetaK = State.RState.RA(0#)
        V = State.RState.RA(1#)
        VV = State.RState.RA(2#)
    Else
        N = -983#
        i = -989#
        MCINFO = -834#
        DiffCnt = 900#
        B = True
        StepFound = False
        BetaK = 214#
        V = -338#
        VV = -686#
    End If
    If State.RState.Stage = 0# Then
        GoTo lbl_0
    End If
    If State.RState.Stage = 1# Then
        GoTo lbl_1
    End If
    If State.RState.Stage = 2# Then
        GoTo lbl_2
    End If
    If State.RState.Stage = 3# Then
        GoTo lbl_3
    End If
    If State.RState.Stage = 4# Then
        GoTo lbl_4
    End If
    If State.RState.Stage = 5# Then
        GoTo lbl_5
    End If
    If State.RState.Stage = 6# Then
        GoTo lbl_6
    End If
    If State.RState.Stage = 7# Then
        GoTo lbl_7
    End If
    If State.RState.Stage = 8# Then
        GoTo lbl_8
    End If
    If State.RState.Stage = 9# Then
        GoTo lbl_9
    End If
    If State.RState.Stage = 10# Then
        GoTo lbl_10
    End If
    If State.RState.Stage = 11# Then
        GoTo lbl_11
    End If
    If State.RState.Stage = 12# Then
        GoTo lbl_12
    End If
    If State.RState.Stage = 13# Then
        GoTo lbl_13
    End If
    If State.RState.Stage = 14# Then
        GoTo lbl_14
    End If
    
    '
    ' Routine body
    '
    
    '
    ' Prepare
    '
    N = State.N
    State.RepTerminationType = 0#
    State.RepIterationsCount = 0#
    State.RepNFEV = 0#
    State.DebugRestartsCount = 0#
    State.CGType = 1#
    For i_ = 0# To N - 1# Step 1
        State.XK(i_) = State.x(i_)
    Next i_
    For i = 0# To N - 1# Step 1
        If State.XK(i) = State.BndL(i) Or State.XK(i) = State.BndU(i) Then
            State.AK(i) = 0#
        Else
            State.AK(i) = 1#
        End If
    Next i
    State.mu = 0.1
    State.CurAlgo = 0#
    
    '
    ' Calculate F/G, initialize algorithm
    '
    Call ClearRequestFields(State)
    State.NeedFG = True
    State.RState.Stage = 0#
    GoTo lbl_rcomm
lbl_0:
    If Not State.XRep Then
        GoTo lbl_15
    End If
    
    '
    ' progress report
    '
    Call ClearRequestFields(State)
    State.XUpdated = True
    State.RState.Stage = 1#
    GoTo lbl_rcomm
lbl_1:
lbl_15:
    If ASABoundedAntiGradNorm(State) <= State.EpsG Then
        State.RepTerminationType = 4#
        Result = False
        MinASAIteration = Result
        Exit Function
    End If
    State.RepNFEV = State.RepNFEV + 1#
    
    '
    ' Main cycle
    '
    ' At the beginning of new iteration:
    ' * CurAlgo stores current algorithm selector
    ' * State.XK, State.F and State.G store current X/F/G
    ' * State.AK stores current set of active constraints
    '
lbl_17:
    If False Then
        GoTo lbl_18
    End If
    
    '
    ' GPA algorithm
    '
    If State.CurAlgo <> 0# Then
        GoTo lbl_19
    End If
    State.K = 0#
    State.ACount = 0#
lbl_21:
    If False Then
        GoTo lbl_22
    End If
    
    '
    ' Determine Dk = proj(xk - gk)-xk
    '
    For i = 0# To N - 1# Step 1
        State.d(i) = ASABoundVal(State.XK(i) - State.g(i), State.BndL(i), State.BndU(i)) - State.XK(i)
    Next i
    
    '
    ' Armijo line search.
    ' * exact search with alpha=1 is tried first,
    '   'exact' means that we evaluate f() EXACTLY at
    '   bound(x-g,bndl,bndu), without intermediate floating
    '   point operations.
    ' * alpha<1 are tried if explicit search wasn't successful
    ' Result is placed into XN.
    '
    ' Two types of search are needed because we can't
    ' just use second type with alpha=1 because in finite
    ' precision arithmetics (x1-x0)+x0 may differ from x1.
    ' So while x1 is correctly bounded (it lie EXACTLY on
    ' boundary, if it is active), (x1-x0)+x0 may be
    ' not bounded.
    '
    V = 0#
    For i_ = 0# To N - 1# Step 1
        V = V + State.d(i_) * State.g(i_)
    Next i_
    State.DGInit = V
    State.FInit = State.f
    If Not (ASAD1Norm(State) <= State.StpMax Or State.StpMax = 0#) Then
        GoTo lbl_23
    End If
    
    '
    ' Try alpha=1 step first
    '
    For i = 0# To N - 1# Step 1
        State.x(i) = ASABoundVal(State.XK(i) - State.g(i), State.BndL(i), State.BndU(i))
    Next i
    Call ClearRequestFields(State)
    State.NeedFG = True
    State.RState.Stage = 2#
    GoTo lbl_rcomm
lbl_2:
    State.RepNFEV = State.RepNFEV + 1#
    StepFound = State.f <= State.FInit + GPAFTol * State.DGInit
    GoTo lbl_24
lbl_23:
    StepFound = False
lbl_24:
    If Not StepFound Then
        GoTo lbl_25
    End If
    
    '
    ' we are at the boundary(ies)
    '
    For i_ = 0# To N - 1# Step 1
        State.XN(i_) = State.x(i_)
    Next i_
    State.Stp = 1#
    GoTo lbl_26
lbl_25:
    
    '
    ' alpha=1 is too large, try smaller values
    '
    State.Stp = 1#
    Call LinMinNormalizeD(State.d, State.Stp, N)
    State.DGInit = State.DGInit / State.Stp
    State.Stp = GPADecay * State.Stp
    If State.StpMax > 0# Then
        State.Stp = MinReal(State.Stp, State.StpMax)
    End If
lbl_27:
    If False Then
        GoTo lbl_28
    End If
    V = State.Stp
    For i_ = 0# To N - 1# Step 1
        State.x(i_) = State.XK(i_)
    Next i_
    For i_ = 0# To N - 1# Step 1
        State.x(i_) = State.x(i_) + V * State.d(i_)
    Next i_
    Call ClearRequestFields(State)
    State.NeedFG = True
    State.RState.Stage = 3#
    GoTo lbl_rcomm
lbl_3:
    State.RepNFEV = State.RepNFEV + 1#
    If State.Stp <= STPMIN Then
        GoTo lbl_28
    End If
    If State.f <= State.FInit + State.Stp * GPAFTol * State.DGInit Then
        GoTo lbl_28
    End If
    State.Stp = State.Stp * GPADecay
    GoTo lbl_27
lbl_28:
    For i_ = 0# To N - 1# Step 1
        State.XN(i_) = State.x(i_)
    Next i_
lbl_26:
    State.RepIterationsCount = State.RepIterationsCount + 1#
    If Not State.XRep Then
        GoTo lbl_29
    End If
    
    '
    ' progress report
    '
    Call ClearRequestFields(State)
    State.XUpdated = True
    State.RState.Stage = 4#
    GoTo lbl_rcomm
lbl_4:
lbl_29:
    
    '
    ' Calculate new set of active constraints.
    ' Reset counter if active set was changed.
    ' Prepare for the new iteration
    '
    For i = 0# To N - 1# Step 1
        If State.XN(i) = State.BndL(i) Or State.XN(i) = State.BndU(i) Then
            State.AN(i) = 0#
        Else
            State.AN(i) = 1#
        End If
    Next i
    For i = 0# To N - 1# Step 1
        If State.AK(i) <> State.AN(i) Then
            State.ACount = -1#
            Exit For
        End If
    Next i
    State.ACount = State.ACount + 1#
    For i_ = 0# To N - 1# Step 1
        State.XK(i_) = State.XN(i_)
    Next i_
    For i_ = 0# To N - 1# Step 1
        State.AK(i_) = State.AN(i_)
    Next i_
    
    '
    ' Stopping conditions
    '
    If Not (State.RepIterationsCount >= State.MaxIts And State.MaxIts > 0#) Then
        GoTo lbl_31
    End If
    
    '
    ' Too many iterations
    '
    State.RepTerminationType = 5#
    If Not State.XRep Then
        GoTo lbl_33
    End If
    Call ClearRequestFields(State)
    State.XUpdated = True
    State.RState.Stage = 5#
    GoTo lbl_rcomm
lbl_5:
lbl_33:
    Result = False
    MinASAIteration = Result
    Exit Function
lbl_31:
    If ASABoundedAntiGradNorm(State) > State.EpsG Then
        GoTo lbl_35
    End If
    
    '
    ' Gradient is small enough
    '
    State.RepTerminationType = 4#
    If Not State.XRep Then
        GoTo lbl_37
    End If
    Call ClearRequestFields(State)
    State.XUpdated = True
    State.RState.Stage = 6#
    GoTo lbl_rcomm
lbl_6:
lbl_37:
    Result = False
    MinASAIteration = Result
    Exit Function
lbl_35:
    V = 0#
    For i_ = 0# To N - 1# Step 1
        V = V + State.d(i_) * State.d(i_)
    Next i_
    If Sqr(V) * State.Stp > State.EpsX Then
        GoTo lbl_39
    End If
    
    '
    ' Step size is too small, no further improvement is
    ' possible
    '
    State.RepTerminationType = 2#
    If Not State.XRep Then
        GoTo lbl_41
    End If
    Call ClearRequestFields(State)
    State.XUpdated = True
    State.RState.Stage = 7#
    GoTo lbl_rcomm
lbl_7:
lbl_41:
    Result = False
    MinASAIteration = Result
    Exit Function
lbl_39:
    If State.FInit - State.f > State.EpsF * MaxReal(Abs(State.FInit), MaxReal(Abs(State.f), 1#)) Then
        GoTo lbl_43
    End If
    
    '
    ' F(k+1)-F(k) is small enough
    '
    State.RepTerminationType = 1#
    If Not State.XRep Then
        GoTo lbl_45
    End If
    Call ClearRequestFields(State)
    State.XUpdated = True
    State.RState.Stage = 8#
    GoTo lbl_rcomm
lbl_8:
lbl_45:
    Result = False
    MinASAIteration = Result
    Exit Function
lbl_43:
    
    '
    ' Decide - should we switch algorithm or not
    '
    If ASAUIsEmpty(State) Then
        If ASAGINorm(State) >= State.mu * ASAD1Norm(State) Then
            State.CurAlgo = 1#
            GoTo lbl_22
        Else
            State.mu = State.mu * ASARho
        End If
    Else
        If State.ACount = N1 Then
            If ASAGINorm(State) >= State.mu * ASAD1Norm(State) Then
                State.CurAlgo = 1#
                GoTo lbl_22
            End If
        End If
    End If
    
    '
    ' Next iteration
    '
    State.K = State.K + 1#
    GoTo lbl_21
lbl_22:
lbl_19:
    
    '
    ' CG algorithm
    '
    If State.CurAlgo <> 1# Then
        GoTo lbl_47
    End If
    
    '
    ' first, check that there are non-active constraints.
    ' move to GPA algorithm, if all constraints are active
    '
    B = True
    For i = 0# To N - 1# Step 1
        If State.AK(i) <> 0# Then
            B = False
            Exit For
        End If
    Next i
    If B Then
        State.CurAlgo = 0#
        GoTo lbl_17
    End If
    
    '
    ' CG iterations
    '
    State.Fold = State.f
    For i_ = 0# To N - 1# Step 1
        State.XK(i_) = State.x(i_)
    Next i_
    For i = 0# To N - 1# Step 1
        State.DK(i) = -(State.g(i) * State.AK(i))
        State.GC(i) = State.g(i) * State.AK(i)
    Next i
lbl_49:
    If False Then
        GoTo lbl_50
    End If
    
    '
    ' Store G[k] for later calculation of Y[k]
    '
    For i = 0# To N - 1# Step 1
        State.YK(i) = -State.GC(i)
    Next i
    
    '
    ' Make a CG step in direction given by DK[]:
    ' * calculate step. Step projection into feasible set
    '   is used. It has several benefits: a) step may be
    '   found with usual line search, b) multiple constraints
    '   may be activated with one step, c) activated constraints
    '   are detected in a natural way - just compare x[i] with
    '   bounds
    ' * update active set, set B to True, if there
    '   were changes in the set.
    '
    For i_ = 0# To N - 1# Step 1
        State.d(i_) = State.DK(i_)
    Next i_
    For i_ = 0# To N - 1# Step 1
        State.XN(i_) = State.XK(i_)
    Next i_
    State.MCStage = 0#
    State.Stp = 1#
    Call LinMinNormalizeD(State.d, State.Stp, N)
    Call MCSRCH(N, State.XN, State.f, State.GC, State.d, State.Stp, State.StpMax, MCINFO, State.NFEV, State.WORK, State.LState, State.MCStage)
lbl_51:
    If State.MCStage = 0# Then
        GoTo lbl_52
    End If
    
    '
    ' preprocess data: bound State.XN so it belongs to the
    ' feasible set and store it in the State.X
    '
    For i = 0# To N - 1# Step 1
        State.x(i) = ASABoundVal(State.XN(i), State.BndL(i), State.BndU(i))
    Next i
    
    '
    ' RComm
    '
    Call ClearRequestFields(State)
    State.NeedFG = True
    State.RState.Stage = 9#
    GoTo lbl_rcomm
lbl_9:
    
    '
    ' postprocess data: zero components of G corresponding to
    ' the active constraints
    '
    For i = 0# To N - 1# Step 1
        If State.x(i) = State.BndL(i) Or State.x(i) = State.BndU(i) Then
            State.GC(i) = 0#
        Else
            State.GC(i) = State.g(i)
        End If
    Next i
    Call MCSRCH(N, State.XN, State.f, State.GC, State.d, State.Stp, State.StpMax, MCINFO, State.NFEV, State.WORK, State.LState, State.MCStage)
    GoTo lbl_51
lbl_52:
    DiffCnt = 0#
    For i = 0# To N - 1# Step 1
        
        '
        ' XN contains unprojected result, project it,
        ' save copy to X (will be used for progress reporting)
        '
        State.XN(i) = ASABoundVal(State.XN(i), State.BndL(i), State.BndU(i))
        
        '
        ' update active set
        '
        If State.XN(i) = State.BndL(i) Or State.XN(i) = State.BndU(i) Then
            State.AN(i) = 0#
        Else
            State.AN(i) = 1#
        End If
        If State.AN(i) <> State.AK(i) Then
            DiffCnt = DiffCnt + 1#
        End If
        State.AK(i) = State.AN(i)
    Next i
    For i_ = 0# To N - 1# Step 1
        State.XK(i_) = State.XN(i_)
    Next i_
    State.RepNFEV = State.RepNFEV + State.NFEV
    State.RepIterationsCount = State.RepIterationsCount + 1#
    If Not State.XRep Then
        GoTo lbl_53
    End If
    
    '
    ' progress report
    '
    Call ClearRequestFields(State)
    State.XUpdated = True
    State.RState.Stage = 10#
    GoTo lbl_rcomm
lbl_10:
lbl_53:
    
    '
    ' Check stopping conditions.
    '
    If ASABoundedAntiGradNorm(State) > State.EpsG Then
        GoTo lbl_55
    End If
    
    '
    ' Gradient is small enough
    '
    State.RepTerminationType = 4#
    If Not State.XRep Then
        GoTo lbl_57
    End If
    Call ClearRequestFields(State)
    State.XUpdated = True
    State.RState.Stage = 11#
    GoTo lbl_rcomm
lbl_11:
lbl_57:
    Result = False
    MinASAIteration = Result
    Exit Function
lbl_55:
    If Not (State.RepIterationsCount >= State.MaxIts And State.MaxIts > 0#) Then
        GoTo lbl_59
    End If
    
    '
    ' Too many iterations
    '
    State.RepTerminationType = 5#
    If Not State.XRep Then
        GoTo lbl_61
    End If
    Call ClearRequestFields(State)
    State.XUpdated = True
    State.RState.Stage = 12#
    GoTo lbl_rcomm
lbl_12:
lbl_61:
    Result = False
    MinASAIteration = Result
    Exit Function
lbl_59:
    If Not (ASAGINorm(State) >= State.mu * ASAD1Norm(State) And DiffCnt = 0#) Then
        GoTo lbl_63
    End If
    
    '
    ' These conditions are explicitly or implicitly
    ' related to the current step size and influenced
    ' by changes in the active constraints.
    '
    ' For these reasons they are checked only when we don't
    ' want to 'unstick' at the end of the iteration and there
    ' were no changes in the active set.
    '
    ' NOTE: consition |G|>=Mu*|D1| must be exactly opposite
    ' to the condition used to switch back to GPA. At least
    ' one inequality must be strict, otherwise infinite cycle
    ' may occur when |G|=Mu*|D1| (we DON'T test stopping
    ' conditions and we DON'T switch to GPA, so we cycle
    ' indefinitely).
    '
    If State.Fold - State.f > State.EpsF * MaxReal(Abs(State.Fold), MaxReal(Abs(State.f), 1#)) Then
        GoTo lbl_65
    End If
    
    '
    ' F(k+1)-F(k) is small enough
    '
    State.RepTerminationType = 1#
    If Not State.XRep Then
        GoTo lbl_67
    End If
    Call ClearRequestFields(State)
    State.XUpdated = True
    State.RState.Stage = 13#
    GoTo lbl_rcomm
lbl_13:
lbl_67:
    Result = False
    MinASAIteration = Result
    Exit Function
lbl_65:
    V = 0#
    For i_ = 0# To N - 1# Step 1
        V = V + State.d(i_) * State.d(i_)
    Next i_
    If Sqr(V) * State.Stp > State.EpsX Then
        GoTo lbl_69
    End If
    
    '
    ' X(k+1)-X(k) is small enough
    '
    State.RepTerminationType = 2#
    If Not State.XRep Then
        GoTo lbl_71
    End If
    Call ClearRequestFields(State)
    State.XUpdated = True
    State.RState.Stage = 14#
    GoTo lbl_rcomm
lbl_14:
lbl_71:
    Result = False
    MinASAIteration = Result
    Exit Function
lbl_69:
lbl_63:
    
    '
    ' Check conditions for switching
    '
    If ASAGINorm(State) < State.mu * ASAD1Norm(State) Then
        State.CurAlgo = 0#
        GoTo lbl_50
    End If
    If DiffCnt > 0# Then
        If ASAUIsEmpty(State) Or DiffCnt >= N2 Then
            State.CurAlgo = 1#
        Else
            State.CurAlgo = 0#
        End If
        GoTo lbl_50
    End If
    
    '
    ' Calculate D(k+1)
    '
    ' Line search may result in:
    ' * maximum feasible step being taken (already processed)
    ' * point satisfying Wolfe conditions
    ' * some kind of error (CG is restarted by assigning 0.0 to Beta)
    '
    If MCINFO = 1# Then
        
        '
        ' Standard Wolfe conditions are satisfied:
        ' * calculate Y[K] and BetaK
        '
        For i_ = 0# To N - 1# Step 1
            State.YK(i_) = State.YK(i_) + State.GC(i_)
        Next i_
        VV = 0#
        For i_ = 0# To N - 1# Step 1
            VV = VV + State.YK(i_) * State.DK(i_)
        Next i_
        V = 0#
        For i_ = 0# To N - 1# Step 1
            V = V + State.GC(i_) * State.GC(i_)
        Next i_
        State.BetaDY = V / VV
        V = 0#
        For i_ = 0# To N - 1# Step 1
            V = V + State.GC(i_) * State.YK(i_)
        Next i_
        State.BetaHS = V / VV
        If State.CGType = 0# Then
            BetaK = State.BetaDY
        End If
        If State.CGType = 1# Then
            BetaK = MaxReal(0#, MinReal(State.BetaDY, State.BetaHS))
        End If
    Else
        
        '
        ' Something is wrong (may be function is too wild or too flat).
        '
        ' We'll set BetaK=0, which will restart CG algorithm.
        ' We can stop later (during normal checks) if stopping conditions are met.
        '
        BetaK = 0#
        State.DebugRestartsCount = State.DebugRestartsCount + 1#
    End If
    For i_ = 0# To N - 1# Step 1
        State.dn(i_) = -State.GC(i_)
    Next i_
    For i_ = 0# To N - 1# Step 1
        State.dn(i_) = State.dn(i_) + BetaK * State.DK(i_)
    Next i_
    For i_ = 0# To N - 1# Step 1
        State.DK(i_) = State.dn(i_)
    Next i_
    
    '
    ' update other information
    '
    State.Fold = State.f
    State.K = State.K + 1#
    GoTo lbl_49
lbl_50:
lbl_47:
    GoTo lbl_17
lbl_18:
    Result = False
    MinASAIteration = Result
    Exit Function
    
    '
    ' Saving state
    '
lbl_rcomm:
    Result = True
    State.RState.IA(0#) = N
    State.RState.IA(1#) = i
    State.RState.IA(2#) = MCINFO
    State.RState.IA(3#) = DiffCnt
    State.RState.BA(0#) = B
    State.RState.BA(1#) = StepFound
    State.RState.RA(0#) = BetaK
    State.RState.RA(1#) = V
    State.RState.RA(2#) = VV
    MinASAIteration = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Conjugate gradient results
'
'Called after MinASA returned False.
'
'INPUT PARAMETERS:
'    State   -   algorithm state (used by MinASAIteration).
'
'OUTPUT PARAMETERS:
'    X       -   array[0..N-1], solution
'    Rep     -   optimization report:
'                * Rep.TerminationType completetion code:
'                    * -2    rounding errors prevent further improvement.
'                            X contains best point found.
'                    * -1    incorrect parameters were specified
'                    *  1    relative function improvement is no more than
'                            EpsF.
'                    *  2    relative step is no more than EpsX.
'                    *  4    gradient norm is no more than EpsG
'                    *  5    MaxIts steps was taken
'                    *  7    stopping conditions are too stringent,
'                            further improvement is impossible
'                * Rep.IterationsCount contains iterations count
'                * NFEV countains number of function calculations
'                * ActiveConstraints contains number of active constraints
'
'  -- ALGLIB --
'     Copyright 20.03.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MinASAResults(ByRef State As MinASAState, _
         ByRef x() As Double, _
         ByRef Rep As MinASAReport)
    Dim i As Long
    Dim i_ As Long
    ReDim x(0# To State.N - 1#)
    For i_ = 0# To State.N - 1# Step 1
        x(i_) = State.x(i_)
    Next i_
    Rep.IterationsCount = State.RepIterationsCount
    Rep.NFEV = State.RepNFEV
    Rep.TerminationType = State.RepTerminationType
    Rep.ActiveConstraints = 0#
    For i = 0# To State.N - 1# Step 1
        If State.AK(i) = 0# Then
            Rep.ActiveConstraints = Rep.ActiveConstraints + 1#
        End If
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''bound' value: map X to [B1,B2]
'
'  -- ALGLIB --
'     Copyright 20.03.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Function ASABoundVal(ByVal x As Double, _
         ByVal b1 As Double, _
         ByVal b2 As Double) As Double
    Dim Result As Double
    If x <= b1 Then
        Result = b1
        ASABoundVal = Result
        Exit Function
    End If
    If x >= b2 Then
        Result = b2
        ASABoundVal = Result
        Exit Function
    End If
    Result = x
    ASABoundVal = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Returns norm of bounded anti-gradient.
'
'Bounded antigradient is a vector obtained from  anti-gradient  by  zeroing
'components which point outwards:
'    result = norm(v)
'    v[i]=0     if ((-g[i]<0)and(x[i]=bndl[i])) or
'                  ((-g[i]>0)and(x[i]=bndu[i]))
'    v[i]=-g[i] otherwise
'
'This function may be used to check a stopping criterion.
'
'  -- ALGLIB --
'     Copyright 20.03.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Function ASABoundedAntiGradNorm(ByRef State As MinASAState) As Double
    Dim Result As Double
    Dim i As Long
    Dim V As Double
    Result = 0#
    For i = 0# To State.N - 1# Step 1
        V = -State.g(i)
        If State.x(i) = State.BndL(i) And -State.g(i) < 0# Then
            V = 0#
        End If
        If State.x(i) = State.BndU(i) And -State.g(i) > 0# Then
            V = 0#
        End If
        Result = Result + Square(V)
    Next i
    Result = Sqr(Result)
    ASABoundedAntiGradNorm = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Returns norm of GI(x).
'
'GI(x) is  a  gradient  vector  whose  components  associated  with  active
'constraints are zeroed. It  differs  from  bounded  anti-gradient  because
'components  of   GI(x)   are   zeroed  independently  of  sign(g[i]),  and
'anti-gradient's components are zeroed with respect to both constraint  and
'sign.
'
'  -- ALGLIB --
'     Copyright 20.03.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Function ASAGINorm(ByRef State As MinASAState) As Double
    Dim Result As Double
    Dim i As Long
    Dim V As Double
    Result = 0#
    For i = 0# To State.N - 1# Step 1
        If State.x(i) <> State.BndL(i) And State.x(i) <> State.BndU(i) Then
            Result = Result + Square(State.g(i))
        End If
    Next i
    Result = Sqr(Result)
    ASAGINorm = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Returns norm(D1(State.X))
'
'For a meaning of D1 see 'NEW ACTIVE SET ALGORITHM FOR BOX CONSTRAINED
'OPTIMIZATION' by WILLIAM W. HAGER AND HONGCHAO ZHANG.
'
'  -- ALGLIB --
'     Copyright 20.03.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Function ASAD1Norm(ByRef State As MinASAState) As Double
    Dim Result As Double
    Dim i As Long
    Result = 0#
    For i = 0# To State.N - 1# Step 1
        Result = Result + Square(ASABoundVal(State.x(i) - State.g(i), State.BndL(i), State.BndU(i)) - State.x(i))
    Next i
    Result = Sqr(Result)
    ASAD1Norm = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Returns True, if U set is empty.
'
'* State.X is used as point,
'* State.G - as gradient,
'* D is calculated within function (because State.D may have different
'  meaning depending on current optimization algorithm)
'
'For a meaning of U see 'NEW ACTIVE SET ALGORITHM FOR BOX CONSTRAINED
'OPTIMIZATION' by WILLIAM W. HAGER AND HONGCHAO ZHANG.
'
'  -- ALGLIB --
'     Copyright 20.03.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Function ASAUIsEmpty(ByRef State As MinASAState) As Boolean
    Dim Result As Boolean
    Dim i As Long
    Dim d As Double
    Dim D2 As Double
    Dim D32 As Double
    d = ASAD1Norm(State)
    D2 = Sqr(d)
    D32 = d * D2
    Result = True
    For i = 0# To State.N - 1# Step 1
        If Abs(State.g(i)) >= D2 And MinReal(State.x(i) - State.BndL(i), State.BndU(i) - State.x(i)) >= D32 Then
            Result = False
            ASAUIsEmpty = Result
            Exit Function
        End If
    Next i
    ASAUIsEmpty = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Returns True, if optimizer "want  to  unstick"  from  one  of  the  active
'constraints, i.e. there is such active constraint with index I that either
'lower bound is active and g[i]<0, or upper bound is active and g[i]>0.
'
'State.X is used as current point, State.X - as gradient.
'  -- ALGLIB --
'     Copyright 20.03.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Function ASAWantToUnstick(ByRef State As MinASAState) As Boolean
    Dim Result As Boolean
    Dim i As Long
    Result = False
    For i = 0# To State.N - 1# Step 1
        If State.x(i) = State.BndL(i) And State.g(i) < 0# Then
            Result = True
        End If
        If State.x(i) = State.BndU(i) And State.g(i) > 0# Then
            Result = True
        End If
        If Result Then
            ASAWantToUnstick = Result
            Exit Function
        End If
    Next i
    ASAWantToUnstick = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Clears request fileds (to be sure that we don't forgot to clear something)
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub ClearRequestFields(ByRef State As MinASAState)
    State.NeedFG = False
    State.XUpdated = False
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2010, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'        NONLINEAR CONJUGATE GRADIENT METHOD
'
'The subroutine minimizes function F(x) of N arguments by using one of  the
'nonlinear conjugate gradient methods.
'
'These CG methods are globally convergent (even on non-convex functions) as
'long as grad(f) is Lipschitz continuous in  a  some  neighborhood  of  the
'L = { x : f(x)<=f(x0) }.
'
'INPUT PARAMETERS:
'    N       -   problem dimension. N>0
'    X       -   initial solution approximation, array[0..N-1].
'    EpsG    -   positive number which  defines  a  precision  of  search.  The
'                subroutine finishes its work if the condition ||G|| < EpsG  is
'                satisfied, where ||.|| means Euclidian norm, G - gradient, X -
'                current approximation.
'    EpsF    -   positive number which  defines  a  precision  of  search.  The
'                subroutine finishes its work if on iteration  number  k+1  the
'                condition |F(k+1)-F(k)| <= EpsF*max{|F(k)|, |F(k+1)|, 1}    is
'                satisfied.
'    EpsX    -   positive number which  defines  a  precision  of  search.  The
'                subroutine finishes its work if on iteration number k+1    the
'                condition |X(k+1)-X(k)| <= EpsX is fulfilled.
'    MaxIts  -   maximum number of iterations. If MaxIts=0, the number of
'                iterations is unlimited.
'
'OUTPUT PARAMETERS:
'    State - structure used for reverse communication.
'
'See also MinCGIteration, MinCGResults
'
'NOTE:
'
'Passing EpsG=0, EpsF=0, EpsX=0 and MaxIts=0 (simultaneously) will lead to
'automatic stopping criterion selection (small EpsX).
'
'  -- ALGLIB --
'     Copyright 25.03.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MinCGCreate(ByVal N As Long, _
         ByRef x() As Double, _
         ByRef State As MinCGState)
    Dim i_ As Long
    
    '
    ' Initialize
    '
    State.N = N
    Call MinCGSetCond(State, 0#, 0#, 0#, 0#)
    Call MinCGSetXRep(State, False)
    Call MinCGSetStpMax(State, 0#)
    Call MinCGSetCGType(State, -1#)
    ReDim State.XK(0 To N - 1)
    ReDim State.DK(0 To N - 1)
    ReDim State.XN(0 To N - 1)
    ReDim State.dn(0 To N - 1)
    ReDim State.x(0 To N - 1)
    ReDim State.d(0 To N - 1)
    ReDim State.g(0 To N - 1)
    ReDim State.WORK(0 To N - 1)
    ReDim State.YK(0 To N - 1)
    
    '
    ' Prepare first run
    '
    For i_ = 0# To N - 1# Step 1
        State.x(i_) = x(i_)
    Next i_
    ReDim State.RState.IA(0# To 2#)
    ReDim State.RState.RA(0# To 2#)
    State.RState.Stage = -1#
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function sets stopping conditions for CG optimization algorithm.
'
'INPUT PARAMETERS:
'    State   -   structure which stores algorithm state between calls and
'                which is used for reverse communication. Must be initialized
'                with MinCGCreate()
'    EpsG    -   >=0
'                The  subroutine  finishes  its  work   if   the  condition
'                ||G||<EpsG is satisfied, where ||.|| means Euclidian norm,
'                G - gradient.
'    EpsF    -   >=0
'                The  subroutine  finishes  its work if on k+1-th iteration
'                the  condition  |F(k+1)-F(k)|<=EpsF*max{|F(k)|,|F(k+1)|,1}
'                is satisfied.
'    EpsX    -   >=0
'                The subroutine finishes its work if  on  k+1-th  iteration
'                the condition |X(k+1)-X(k)| <= EpsX is fulfilled.
'    MaxIts  -   maximum number of iterations. If MaxIts=0, the  number  of
'                iterations is unlimited.
'
'Passing EpsG=0, EpsF=0, EpsX=0 and MaxIts=0 (simultaneously) will lead to
'automatic stopping criterion selection (small EpsX).
'
'  -- ALGLIB --
'     Copyright 02.04.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MinCGSetCond(ByRef State As MinCGState, _
         ByVal EpsG As Double, _
         ByVal EpsF As Double, _
         ByVal EpsX As Double, _
         ByVal MaxIts As Long)
    If EpsG = 0# And EpsF = 0# And EpsX = 0# And MaxIts = 0# Then
        EpsX = 0.000001
    End If
    State.EpsG = EpsG
    State.EpsF = EpsF
    State.EpsX = EpsX
    State.MaxIts = MaxIts
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function turns on/off reporting.
'
'INPUT PARAMETERS:
'    State   -   structure which stores algorithm state between calls and
'                which is used for reverse communication. Must be
'                initialized with MinCGCreate()
'    NeedXRep-   whether iteration reports are needed or not
'
'Usually  algorithm  returns  from  MinCGIteration()  only  when  it  needs
'function/gradient. However, with this function we can let  it  stop  after
'each  iteration  (one  iteration  may  include   more  than  one  function
'evaluation), which is indicated by XUpdated field.
'
'  -- ALGLIB --
'     Copyright 02.04.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MinCGSetXRep(ByRef State As MinCGState, ByVal NeedXRep As Boolean)
    State.XRep = NeedXRep
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function sets CG algorithm.
'
'INPUT PARAMETERS:
'    State   -   structure which stores algorithm state between calls and
'                which is used for reverse communication. Must be
'                initialized with MinCGCreate()
'    CGType  -   algorithm type:
'                * -1    automatic selection of the best algorithm
'                * 0     DY (Dai and Yuan) algorithm
'                * 1     Hybrid DY-HS algorithm
'
'  -- ALGLIB --
'     Copyright 02.04.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MinCGSetCGType(ByRef State As MinCGState, ByVal CGType As Long)
    If CGType = -1# Then
        CGType = 1#
    End If
    State.CGType = CGType
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function sets maximum step length
'
'INPUT PARAMETERS:
'    State   -   structure which stores algorithm state between calls and
'                which is used for reverse communication. Must be
'                initialized with MinCGCreate()
'    StpMax  -   maximum step length, >=0. Set StpMax to 0.0,  if you don't
'                want to limit step length.
'
'Use this subroutine when you optimize target function which contains exp()
'or  other  fast  growing  functions,  and optimization algorithm makes too
'large  steps  which  leads  to overflow. This function allows us to reject
'steps  that  are  too  large  (and  therefore  expose  us  to the possible
'overflow) without actually calculating function value at the x+stp*d.
'
'  -- ALGLIB --
'     Copyright 02.04.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MinCGSetStpMax(ByRef State As MinCGState, ByVal StpMax As Double)
    State.StpMax = StpMax
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'One conjugate gradient iteration
'
'Called after initialization with MinCG.
'See HTML documentation for examples.
'
'INPUT PARAMETERS:
'    State   -   structure which stores algorithm state between calls and
'                which is used for reverse communication. Must be initialized
'                with MinCG.
'
'RESULT:
'* if function returned False, iterative proces has converged.
'  Use MinLBFGSResults() to obtain optimization results.
'* if subroutine returned True, then, depending on structure fields, we
'  have one of the following situations
'
'
'=== FUNC/GRAD REQUEST ===
'State.NeedFG is True => function value/gradient are needed.
'Caller should calculate function value State.F and gradient
'State.G[0..N-1] at State.X[0..N-1] and call MinLBFGSIteration() again.
'
'=== NEW INTERATION IS REPORTED ===
'State.XUpdated is True => one more iteration was made.
'State.X contains current position, State.F contains function value at X.
'You can read info from these fields, but never modify  them  because  they
'contain the only copy of optimization algorithm state.
'
'One and only one of these fields (NeedFG, XUpdated) is true on return. New
'iterations are reported only when reports  are  explicitly  turned  on  by
'MinLBFGSSetXRep() function, so if you never called it, you can expect that
'NeedFG is always True.
'
'
'  -- ALGLIB --
'     Copyright 20.04.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function MinCGIteration(ByRef State As MinCGState) As Boolean
    Dim Result As Boolean
    Dim N As Long
    Dim i As Long
    Dim BetaK As Double
    Dim V As Double
    Dim VV As Double
    Dim MCINFO As Long
    Dim i_ As Long
    
    '
    ' Reverse communication preparations
    ' I know it looks ugly, but it works the same way
    ' anywhere from C++ to Python.
    '
    ' This code initializes locals by:
    ' * random values determined during code
    '   generation - on first subroutine call
    ' * values from previous call - on subsequent calls
    '
    If State.RState.Stage >= 0# Then
        N = State.RState.IA(0#)
        i = State.RState.IA(1#)
        MCINFO = State.RState.IA(2#)
        BetaK = State.RState.RA(0#)
        V = State.RState.RA(1#)
        VV = State.RState.RA(2#)
    Else
        N = -983#
        i = -989#
        MCINFO = -834#
        BetaK = 900#
        V = -287#
        VV = 364#
    End If
    If State.RState.Stage = 0# Then
        GoTo lbl_0
    End If
    If State.RState.Stage = 1# Then
        GoTo lbl_1
    End If
    If State.RState.Stage = 2# Then
        GoTo lbl_2
    End If
    If State.RState.Stage = 3# Then
        GoTo lbl_3
    End If
    
    '
    ' Routine body
    '
    
    '
    ' Prepare
    '
    N = State.N
    State.RepTerminationType = 0#
    State.RepIterationsCount = 0#
    State.RepNFEV = 0#
    State.DebugRestartsCount = 0#
    
    '
    ' Calculate F/G, initialize algorithm
    '
    Call ClearRequestFieldsCG(State)
    State.NeedFG = True
    State.RState.Stage = 0#
    GoTo lbl_rcomm
lbl_0:
    If Not State.XRep Then
        GoTo lbl_4
    End If
    Call ClearRequestFieldsCG(State)
    State.XUpdated = True
    State.RState.Stage = 1#
    GoTo lbl_rcomm
lbl_1:
lbl_4:
    V = 0#
    For i_ = 0# To N - 1# Step 1
        V = V + State.g(i_) * State.g(i_)
    Next i_
    V = Sqr(V)
    If V = 0# Then
        State.RepTerminationType = 4#
        Result = False
        MinCGIteration = Result
        Exit Function
    End If
    State.RepNFEV = 1#
    State.K = 0#
    State.Fold = State.f
    For i_ = 0# To N - 1# Step 1
        State.XK(i_) = State.x(i_)
    Next i_
    For i_ = 0# To N - 1# Step 1
        State.DK(i_) = -State.g(i_)
    Next i_
    
    '
    ' Main cycle
    '
lbl_6:
    If False Then
        GoTo lbl_7
    End If
    
    '
    ' Store G[k] for later calculation of Y[k]
    '
    For i_ = 0# To N - 1# Step 1
        State.YK(i_) = -State.g(i_)
    Next i_
    
    '
    ' Calculate X(k+1): minimize F(x+alpha*d)
    '
    For i_ = 0# To N - 1# Step 1
        State.d(i_) = State.DK(i_)
    Next i_
    For i_ = 0# To N - 1# Step 1
        State.x(i_) = State.XK(i_)
    Next i_
    State.MCStage = 0#
    State.Stp = 1#
    Call LinMinNormalizeD(State.d, State.Stp, N)
    Call MCSRCH(N, State.x, State.f, State.g, State.d, State.Stp, State.StpMax, MCINFO, State.NFEV, State.WORK, State.LState, State.MCStage)
lbl_8:
    If State.MCStage = 0# Then
        GoTo lbl_9
    End If
    Call ClearRequestFieldsCG(State)
    State.NeedFG = True
    State.RState.Stage = 2#
    GoTo lbl_rcomm
lbl_2:
    Call MCSRCH(N, State.x, State.f, State.g, State.d, State.Stp, State.StpMax, MCINFO, State.NFEV, State.WORK, State.LState, State.MCStage)
    GoTo lbl_8
lbl_9:
    If Not State.XRep Then
        GoTo lbl_10
    End If
    Call ClearRequestFieldsCG(State)
    State.XUpdated = True
    State.RState.Stage = 3#
    GoTo lbl_rcomm
lbl_3:
lbl_10:
    For i_ = 0# To N - 1# Step 1
        State.XN(i_) = State.x(i_)
    Next i_
    If MCINFO = 1# Then
        
        '
        ' Standard Wolfe conditions hold
        ' Calculate Y[K] and BetaK
        '
        For i_ = 0# To N - 1# Step 1
            State.YK(i_) = State.YK(i_) + State.g(i_)
        Next i_
        VV = 0#
        For i_ = 0# To N - 1# Step 1
            VV = VV + State.YK(i_) * State.DK(i_)
        Next i_
        V = 0#
        For i_ = 0# To N - 1# Step 1
            V = V + State.g(i_) * State.g(i_)
        Next i_
        State.BetaDY = V / VV
        V = 0#
        For i_ = 0# To N - 1# Step 1
            V = V + State.g(i_) * State.YK(i_)
        Next i_
        State.BetaHS = V / VV
        If State.CGType = 0# Then
            BetaK = State.BetaDY
        End If
        If State.CGType = 1# Then
            BetaK = MaxReal(0#, MinReal(State.BetaDY, State.BetaHS))
        End If
    Else
        
        '
        ' Something is wrong (may be function is too wild or too flat).
        '
        ' We'll set BetaK=0, which will restart CG algorithm.
        ' We can stop later (during normal checks) if stopping conditions are met.
        '
        BetaK = 0#
        State.DebugRestartsCount = State.DebugRestartsCount + 1#
    End If
    
    '
    ' Calculate D(k+1)
    '
    For i_ = 0# To N - 1# Step 1
        State.dn(i_) = -State.g(i_)
    Next i_
    For i_ = 0# To N - 1# Step 1
        State.dn(i_) = State.dn(i_) + BetaK * State.DK(i_)
    Next i_
    
    '
    ' Update information and Hessian.
    ' Check stopping conditions.
    '
    State.RepNFEV = State.RepNFEV + State.NFEV
    State.RepIterationsCount = State.RepIterationsCount + 1#
    If State.RepIterationsCount >= State.MaxIts And State.MaxIts > 0# Then
        
        '
        ' Too many iterations
        '
        State.RepTerminationType = 5#
        Result = False
        MinCGIteration = Result
        Exit Function
    End If
    V = 0#
    For i_ = 0# To N - 1# Step 1
        V = V + State.g(i_) * State.g(i_)
    Next i_
    If Sqr(V) <= State.EpsG Then
        
        '
        ' Gradient is small enough
        '
        State.RepTerminationType = 4#
        Result = False
        MinCGIteration = Result
        Exit Function
    End If
    If State.Fold - State.f <= State.EpsF * MaxReal(Abs(State.Fold), MaxReal(Abs(State.f), 1#)) Then
        
        '
        ' F(k+1)-F(k) is small enough
        '
        State.RepTerminationType = 1#
        Result = False
        MinCGIteration = Result
        Exit Function
    End If
    V = 0#
    For i_ = 0# To N - 1# Step 1
        V = V + State.d(i_) * State.d(i_)
    Next i_
    If Sqr(V) * State.Stp <= State.EpsX Then
        
        '
        ' X(k+1)-X(k) is small enough
        '
        State.RepTerminationType = 2#
        Result = False
        MinCGIteration = Result
        Exit Function
    End If
    
    '
    ' Shift Xk/Dk, update other information
    '
    For i_ = 0# To N - 1# Step 1
        State.XK(i_) = State.XN(i_)
    Next i_
    For i_ = 0# To N - 1# Step 1
        State.DK(i_) = State.dn(i_)
    Next i_
    State.Fold = State.f
    State.K = State.K + 1#
    GoTo lbl_6
lbl_7:
    Result = False
    MinCGIteration = Result
    Exit Function
    
    '
    ' Saving state
    '
lbl_rcomm:
    Result = True
    State.RState.IA(0#) = N
    State.RState.IA(1#) = i
    State.RState.IA(2#) = MCINFO
    State.RState.RA(0#) = BetaK
    State.RState.RA(1#) = V
    State.RState.RA(2#) = VV
    MinCGIteration = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Conjugate gradient results
'
'Called after MinCG returned False.
'
'INPUT PARAMETERS:
'    State   -   algorithm state (used by MinCGIteration).
'
'OUTPUT PARAMETERS:
'    X       -   array[0..N-1], solution
'    Rep     -   optimization report:
'                * Rep.TerminationType completetion code:
'                    * -2    rounding errors prevent further improvement.
'                            X contains best point found.
'                    * -1    incorrect parameters were specified
'                    *  1    relative function improvement is no more than
'                            EpsF.
'                    *  2    relative step is no more than EpsX.
'                    *  4    gradient norm is no more than EpsG
'                    *  5    MaxIts steps was taken
'                    *  7    stopping conditions are too stringent,
'                            further improvement is impossible
'                * Rep.IterationsCount contains iterations count
'                * NFEV countains number of function calculations
'
'  -- ALGLIB --
'     Copyright 20.04.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MinCGResults(ByRef State As MinCGState, _
         ByRef x() As Double, _
         ByRef Rep As MinCGReport)
    Dim i_ As Long
    ReDim x(0# To State.N - 1#)
    For i_ = 0# To State.N - 1# Step 1
        x(i_) = State.XN(i_)
    Next i_
    Rep.IterationsCount = State.RepIterationsCount
    Rep.NFEV = State.RepNFEV
    Rep.TerminationType = State.RepTerminationType
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Clears request fileds (to be sure that we don't forgot to clear something)
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub ClearRequestFieldsCG(ByRef State As MinCGState)
    State.NeedFG = False
    State.XUpdated = False
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2009, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'    LEVENBERG-MARQUARDT-LIKE METHOD FOR NON-LINEAR OPTIMIZATION
'
'Optimization using function gradient and Hessian.  Algorithm -  Levenberg-
'Marquardt   modification   with   L-BFGS   pre-optimization  and  internal
'pre-conditioned L-BFGS optimization after each Levenberg-Marquardt step.
'
'Function F has general form (not "sum-of-squares"):
'
'    F = F(x[0], ..., x[n-1])
'
'EXAMPLE
'
'See HTML-documentation.
'
'INPUT PARAMETERS:
'    N       -   dimension, N>1
'    X       -   initial solution, array[0..N-1]
'
'OUTPUT PARAMETERS:
'    State   -   structure which stores algorithm state between subsequent
'                calls of MinLMIteration. Used for reverse communication.
'                This structure should be passed to MinLMIteration subroutine.
'
'See also MinLMIteration, MinLMResults.
'
'NOTES:
'
'1. you may tune stopping conditions with MinLMSetCond() function
'2. if target function contains exp() or other fast growing functions,  and
'   optimization algorithm makes too large steps which leads  to  overflow,
'   use MinLMSetStpMax() function to bound algorithm's steps.
'
'  -- ALGLIB --
'     Copyright 30.03.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MinLMCreateFGH(ByRef N As Long, _
         ByRef x() As Double, _
         ByRef State As MinLMState)
    Dim i_ As Long
    
    '
    ' Prepare RComm
    '
    ReDim State.RState.IA(0# To 3#)
    ReDim State.RState.BA(0# To 0#)
    ReDim State.RState.RA(0# To 7#)
    State.RState.Stage = -1#
    
    '
    ' prepare internal structures
    '
    Call LMPrepare(N, 0#, True, State)
    
    '
    ' initialize, check parameters
    '
    Call MinLMSetCond(State, 0#, 0#, 0#, 0#)
    Call MinLMSetXRep(State, False)
    Call MinLMSetStpMax(State, 0#)
    State.N = N
    State.M = 0#
    State.Flags = 0#
    State.UserMode = LMModeFGH
    State.WrongParams = False
    If N < 1# Then
        State.WrongParams = True
        Exit Sub
    End If
    For i_ = 0# To N - 1# Step 1
        State.x(i_) = x(i_)
    Next i_
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'    LEVENBERG-MARQUARDT-LIKE METHOD FOR NON-LINEAR OPTIMIZATION
'
'Optimization using function gradient and Jacobian.  Algorithm -  Levenberg-
'Marquardt   modification   with   L-BFGS   pre-optimization  and  internal
'pre-conditioned L-BFGS optimization after each Levenberg-Marquardt step.
'
'Function F is represented as sum of squares:
'
'    F = f[0]^2(x[0],...,x[n-1]) + ... + f[m-1]^2(x[0],...,x[n-1])
'
'EXAMPLE
'
'See HTML-documentation.
'
'INPUT PARAMETERS:
'    N       -   dimension, N>1
'    M       -   number of functions f[i]
'    X       -   initial solution, array[0..N-1]
'
'OUTPUT PARAMETERS:
'    State   -   structure which stores algorithm state between subsequent
'                calls of MinLMIteration. Used for reverse communication.
'                This structure should be passed to MinLMIteration subroutine.
'
'See also MinLMIteration, MinLMResults.
'
'NOTES:
'
'1. you may tune stopping conditions with MinLMSetCond() function
'2. if target function contains exp() or other fast growing functions,  and
'   optimization algorithm makes too large steps which leads  to  overflow,
'   use MinLMSetStpMax() function to bound algorithm's steps.
'
'  -- ALGLIB --
'     Copyright 30.03.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MinLMCreateFGJ(ByRef N As Long, _
         ByRef M As Long, _
         ByRef x() As Double, _
         ByRef State As MinLMState)
    Dim i_ As Long
    
    '
    ' Prepare RComm
    '
    ReDim State.RState.IA(0# To 3#)
    ReDim State.RState.BA(0# To 0#)
    ReDim State.RState.RA(0# To 7#)
    State.RState.Stage = -1#
    
    '
    ' prepare internal structures
    '
    Call LMPrepare(N, M, True, State)
    
    '
    ' initialize, check parameters
    '
    Call MinLMSetCond(State, 0#, 0#, 0#, 0#)
    Call MinLMSetXRep(State, False)
    Call MinLMSetStpMax(State, 0#)
    State.N = N
    State.M = M
    State.Flags = 0#
    State.UserMode = LMModeFGJ
    State.WrongParams = False
    If N < 1# Then
        State.WrongParams = True
        Exit Sub
    End If
    For i_ = 0# To N - 1# Step 1
        State.x(i_) = x(i_)
    Next i_
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'    CLASSIC LEVENBERG-MARQUARDT METHOD FOR NON-LINEAR OPTIMIZATION
'
'Optimization using Jacobi matrix. Algorithm  -  classic Levenberg-Marquardt
'method.
'
'Function F is represented as sum of squares:
'
'    F = f[0]^2(x[0],...,x[n-1]) + ... + f[m-1]^2(x[0],...,x[n-1])
'
'EXAMPLE
'
'See HTML-documentation.
'
'INPUT PARAMETERS:
'    N       -   dimension, N>1
'    M       -   number of functions f[i]
'    X       -   initial solution, array[0..N-1]
'
'OUTPUT PARAMETERS:
'    State   -   structure which stores algorithm state between subsequent
'                calls of MinLMIteration. Used for reverse communication.
'                This structure should be passed to MinLMIteration subroutine.
'
'See also MinLMIteration, MinLMResults.
'
'NOTES:
'
'1. you may tune stopping conditions with MinLMSetCond() function
'2. if target function contains exp() or other fast growing functions,  and
'   optimization algorithm makes too large steps which leads  to  overflow,
'   use MinLMSetStpMax() function to bound algorithm's steps.
'
'  -- ALGLIB --
'     Copyright 30.03.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MinLMCreateFJ(ByRef N As Long, _
         ByRef M As Long, _
         ByRef x() As Double, _
         ByRef State As MinLMState)
    Dim i_ As Long
    
    '
    ' Prepare RComm
    '
    ReDim State.RState.IA(0# To 3#)
    ReDim State.RState.BA(0# To 0#)
    ReDim State.RState.RA(0# To 7#)
    State.RState.Stage = -1#
    
    '
    ' prepare internal structures
    '
    Call LMPrepare(N, M, True, State)
    
    '
    ' initialize, check parameters
    '
    Call MinLMSetCond(State, 0#, 0#, 0#, 0#)
    Call MinLMSetXRep(State, False)
    Call MinLMSetStpMax(State, 0#)
    State.N = N
    State.M = M
    State.Flags = 0#
    State.UserMode = LMModeFJ
    State.WrongParams = False
    If N < 1# Then
        State.WrongParams = True
        Exit Sub
    End If
    For i_ = 0# To N - 1# Step 1
        State.x(i_) = x(i_)
    Next i_
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function sets stopping conditions for Levenberg-Marquardt optimization
'algorithm.
'
'INPUT PARAMETERS:
'    State   -   structure which stores algorithm state between calls and
'                which is used for reverse communication. Must be initialized
'                with MinLMCreate???()
'    EpsG    -   >=0
'                The  subroutine  finishes  its  work   if   the  condition
'                ||G||<EpsG is satisfied, where ||.|| means Euclidian norm,
'                G - gradient.
'    EpsF    -   >=0
'                The  subroutine  finishes  its work if on k+1-th iteration
'                the  condition  |F(k+1)-F(k)|<=EpsF*max{|F(k)|,|F(k+1)|,1}
'                is satisfied.
'    EpsX    -   >=0
'                The subroutine finishes its work if  on  k+1-th  iteration
'                the condition |X(k+1)-X(k)| <= EpsX is fulfilled.
'    MaxIts  -   maximum number of iterations. If MaxIts=0, the  number  of
'                iterations   is    unlimited.   Only   Levenberg-Marquardt
'                iterations  are  counted  (L-BFGS/CG  iterations  are  NOT
'                counted  because their cost is very low copared to that of
'                LM).
'
'Passing EpsG=0, EpsF=0, EpsX=0 and MaxIts=0 (simultaneously) will lead to
'automatic stopping criterion selection (small EpsX).
'
'  -- ALGLIB --
'     Copyright 02.04.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MinLMSetCond(ByRef State As MinLMState, _
         ByVal EpsG As Double, _
         ByVal EpsF As Double, _
         ByVal EpsX As Double, _
         ByVal MaxIts As Long)
    If EpsG = 0# And EpsF = 0# And EpsX = 0# And MaxIts = 0# Then
        EpsX = 0.000001
    End If
    State.EpsG = EpsG
    State.EpsF = EpsF
    State.EpsX = EpsX
    State.MaxIts = MaxIts
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function turns on/off reporting.
'
'INPUT PARAMETERS:
'    State   -   structure which stores algorithm state between calls and
'                which is used for reverse communication. Must be
'                initialized with MinLMCreate???()
'    NeedXRep-   whether iteration reports are needed or not
'
'Usually  algorithm  returns  from  MinLMIteration()  only  when  it  needs
'function/gradient/Hessian. However, with this function we can let it  stop
'after  each  iteration  (one iteration may include  more than one function
'evaluation), which is indicated by XUpdated field.
'
'Both Levenberg-Marquardt and L-BFGS iterations are reported.
'
'
'  -- ALGLIB --
'     Copyright 02.04.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MinLMSetXRep(ByRef State As MinLMState, ByVal NeedXRep As Boolean)
    State.XRep = NeedXRep
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function sets maximum step length
'
'INPUT PARAMETERS:
'    State   -   structure which stores algorithm state between calls and
'                which is used for reverse communication. Must be
'                initialized with MinCGCreate???()
'    StpMax  -   maximum step length, >=0. Set StpMax to 0.0,  if you don't
'                want to limit step length.
'
'Use this subroutine when you optimize target function which contains exp()
'or  other  fast  growing  functions,  and optimization algorithm makes too
'large  steps  which  leads  to overflow. This function allows us to reject
'steps  that  are  too  large  (and  therefore  expose  us  to the possible
'overflow) without actually calculating function value at the x+stp*d.
'
'NOTE: non-zero StpMax leads to moderate  performance  degradation  because
'intermediate  step  of  preconditioned L-BFGS optimization is incompatible
'with limits on step size.
'
'  -- ALGLIB --
'     Copyright 02.04.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MinLMSetStpMax(ByRef State As MinLMState, ByVal StpMax As Double)
    State.StpMax = StpMax
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'One Levenberg-Marquardt iteration.
'
'Called after inialization of State structure with MinLMXXX subroutine.
'See HTML docs for examples.
'
'Input parameters:
'    State   -   structure which stores algorithm state between subsequent
'                calls and which is used for reverse communication. Must be
'                initialized with MinLMXXX call first.
'
'If subroutine returned False, iterative algorithm has converged.
'
'If subroutine returned True, then:
'* if State.NeedF=True,      -   function value F at State.X[0..N-1]
'                                is required
'* if State.NeedFG=True      -   function value F and gradient G
'                                are required
'* if State.NeedFiJ=True     -   function vector f[i] and Jacobi matrix J
'                                are required
'* if State.NeedFGH=True     -   function value F, gradient G and Hesian H
'                                are required
'* if State.XUpdated=True    -   algorithm reports about new iteration,
'                                State.X contains current point,
'                                State.F contains function value.
'
'One and only one of this fields can be set at time.
'
'Results are stored:
'* function value            -   in MinLMState.F
'* gradient                  -   in MinLMState.G[0..N-1]
'* Jacobi matrix             -   in MinLMState.J[0..M-1,0..N-1]
'* Hessian                   -   in MinLMState.H[0..N-1,0..N-1]
'
'  -- ALGLIB --
'     Copyright 10.03.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function MinLMIteration(ByRef State As MinLMState) As Boolean
    Dim Result As Boolean
    Dim N As Long
    Dim M As Long
    Dim i As Long
    Dim StepNorm As Double
    Dim SPD As Boolean
    Dim FBase As Double
    Dim FNew As Double
    Dim lambda As Double
    Dim Nu As Double
    Dim LambdaUp As Double
    Dim LambdaDown As Double
    Dim LBFGSFlags As Long
    Dim V As Double
    Dim i_ As Long
    
    '
    ' Reverse communication preparations
    ' I know it looks ugly, but it works the same way
    ' anywhere from C++ to Python.
    '
    ' This code initializes locals by:
    ' * random values determined during code
    '   generation - on first subroutine call
    ' * values from previous call - on subsequent calls
    '
    If State.RState.Stage >= 0# Then
        N = State.RState.IA(0#)
        M = State.RState.IA(1#)
        i = State.RState.IA(2#)
        LBFGSFlags = State.RState.IA(3#)
        SPD = State.RState.BA(0#)
        StepNorm = State.RState.RA(0#)
        FBase = State.RState.RA(1#)
        FNew = State.RState.RA(2#)
        lambda = State.RState.RA(3#)
        Nu = State.RState.RA(4#)
        LambdaUp = State.RState.RA(5#)
        LambdaDown = State.RState.RA(6#)
        V = State.RState.RA(7#)
    Else
        N = -983#
        M = -989#
        i = -834#
        LBFGSFlags = 900#
        SPD = True
        StepNorm = 364#
        FBase = 214#
        FNew = -338#
        lambda = -686#
        Nu = 912#
        LambdaUp = 585#
        LambdaDown = 497#
        V = -271#
    End If
    If State.RState.Stage = 0# Then
        GoTo lbl_0
    End If
    If State.RState.Stage = 1# Then
        GoTo lbl_1
    End If
    If State.RState.Stage = 2# Then
        GoTo lbl_2
    End If
    If State.RState.Stage = 3# Then
        GoTo lbl_3
    End If
    If State.RState.Stage = 4# Then
        GoTo lbl_4
    End If
    If State.RState.Stage = 5# Then
        GoTo lbl_5
    End If
    If State.RState.Stage = 6# Then
        GoTo lbl_6
    End If
    If State.RState.Stage = 7# Then
        GoTo lbl_7
    End If
    If State.RState.Stage = 8# Then
        GoTo lbl_8
    End If
    If State.RState.Stage = 9# Then
        GoTo lbl_9
    End If
    If State.RState.Stage = 10# Then
        GoTo lbl_10
    End If
    If State.RState.Stage = 11# Then
        GoTo lbl_11
    End If
    If State.RState.Stage = 12# Then
        GoTo lbl_12
    End If
    If State.RState.Stage = 13# Then
        GoTo lbl_13
    End If
    If State.RState.Stage = 14# Then
        GoTo lbl_14
    End If
    If State.RState.Stage = 15# Then
        GoTo lbl_15
    End If
    
    '
    ' Routine body
    '
    If State.WrongParams Then
        State.RepTerminationType = -1#
        Result = False
        MinLMIteration = Result
        Exit Function
    End If
    
    '
    ' prepare params
    '
    N = State.N
    M = State.M
    LambdaUp = 20#
    LambdaDown = 0.5
    Nu = 1#
    LBFGSFlags = 0#
    
    '
    ' if we have F and G
    '
    If Not ((State.UserMode = LMModeFGJ Or State.UserMode = LMModeFGH) And State.Flags \ LMFlagNoPreLBFGS Mod 2# = 0#) Then
        GoTo lbl_16
    End If
    
    '
    ' First stage of the hybrid algorithm: LBFGS
    '
    Call MinLBFGSCreate(N, MinInt(N, LMPreLBFGSM), State.x, State.InternalState)
    Call MinLBFGSSetCond(State.InternalState, 0#, 0#, 0#, MaxInt(5#, N))
    Call MinLBFGSSetXRep(State.InternalState, State.XRep)
    Call MinLBFGSSetStpMax(State.InternalState, State.StpMax)
lbl_18:
    If Not MinLBFGSIteration(State.InternalState) Then
        GoTo lbl_19
    End If
    If Not State.InternalState.NeedFG Then
        GoTo lbl_20
    End If
    
    '
    ' RComm
    '
    For i_ = 0# To N - 1# Step 1
        State.x(i_) = State.InternalState.x(i_)
    Next i_
    Call LMClearRequestFields(State)
    State.NeedFG = True
    State.RState.Stage = 0#
    GoTo lbl_rcomm
lbl_0:
    State.RepNFunc = State.RepNFunc + 1#
    State.RepNGrad = State.RepNGrad + 1#
    
    '
    ' Call LBFGS
    '
    State.InternalState.f = State.f
    For i_ = 0# To N - 1# Step 1
        State.InternalState.g(i_) = State.g(i_)
    Next i_
lbl_20:
    If Not (State.InternalState.XUpdated And State.XRep) Then
        GoTo lbl_22
    End If
    Call LMClearRequestFields(State)
    State.f = State.InternalState.f
    For i_ = 0# To N - 1# Step 1
        State.x(i_) = State.InternalState.x(i_)
    Next i_
    State.XUpdated = True
    State.RState.Stage = 1#
    GoTo lbl_rcomm
lbl_1:
lbl_22:
    GoTo lbl_18
lbl_19:
    Call MinLBFGSResults(State.InternalState, State.x, State.InternalRep)
    GoTo lbl_17
lbl_16:
    
    '
    ' No first stage.
    ' However, we may need to report initial point
    '
    If Not State.XRep Then
        GoTo lbl_24
    End If
    Call LMClearRequestFields(State)
    State.NeedF = True
    State.RState.Stage = 2#
    GoTo lbl_rcomm
lbl_2:
    Call LMClearRequestFields(State)
    State.XUpdated = True
    State.RState.Stage = 3#
    GoTo lbl_rcomm
lbl_3:
lbl_24:
lbl_17:
    
    '
    ' Second stage of the hybrid algorithm: LM
    ' Initialize quadratic model.
    '
    If State.UserMode <> LMModeFGH Then
        GoTo lbl_26
    End If
    
    '
    ' RComm
    '
    Call LMClearRequestFields(State)
    State.NeedFGH = True
    State.RState.Stage = 4#
    GoTo lbl_rcomm
lbl_4:
    State.RepNFunc = State.RepNFunc + 1#
    State.RepNGrad = State.RepNGrad + 1#
    State.RepNHess = State.RepNHess + 1#
    
    '
    ' generate raw quadratic model
    '
    Call RMatrixCopy(N, N, State.h, 0#, 0#, State.RawModel, 0#, 0#)
    For i_ = 0# To N - 1# Step 1
        State.GBase(i_) = State.g(i_)
    Next i_
    FBase = State.f
lbl_26:
    If Not (State.UserMode = LMModeFGJ Or State.UserMode = LMModeFJ) Then
        GoTo lbl_28
    End If
    
    '
    ' RComm
    '
    Call LMClearRequestFields(State)
    State.NeedFiJ = True
    State.RState.Stage = 5#
    GoTo lbl_rcomm
lbl_5:
    State.RepNFunc = State.RepNFunc + 1#
    State.RepNJac = State.RepNJac + 1#
    
    '
    ' generate raw quadratic model
    '
    Call RMatrixGEMM(N, N, M, 2#, State.j, 0#, 0#, 1#, State.j, 0#, 0#, 0#, 0#, State.RawModel, 0#, 0#)
    Call RMatrixMV(N, M, State.j, 0#, 0#, 1#, State.fi, 0#, State.GBase, 0#)
    For i_ = 0# To N - 1# Step 1
        State.GBase(i_) = 2 * State.GBase(i_)
    Next i_
    FBase = 0#
    For i_ = 0# To M - 1# Step 1
        FBase = FBase + State.fi(i_) * State.fi(i_)
    Next i_
lbl_28:
    lambda = 0.001
lbl_30:
    If False Then
        GoTo lbl_31
    End If
    
    '
    ' 1. Model = RawModel+lambda*I
    ' 2. Try to solve (RawModel+Lambda*I)*dx = -g.
    '    Increase lambda if left part is not positive definite.
    '
    For i = 0# To N - 1# Step 1
        For i_ = 0# To N - 1# Step 1
            State.Model(i, i_) = State.RawModel(i, i_)
        Next i_
        State.Model(i, i) = State.Model(i, i) + lambda
    Next i
    SPD = SPDMatrixCholesky(State.Model, N, True)
    State.RepNCholesky = State.RepNCholesky + 1#
    If SPD Then
        GoTo lbl_32
    End If
    If Not IncreaseLambda(lambda, Nu, LambdaUp) Then
        GoTo lbl_34
    End If
    GoTo lbl_30
    GoTo lbl_35
lbl_34:
    State.RepTerminationType = 7#
    Call LMClearRequestFields(State)
    State.NeedF = True
    State.RState.Stage = 6#
    GoTo lbl_rcomm
lbl_6:
    GoTo lbl_31
lbl_35:
lbl_32:
    Call SPDMatrixCholeskySolve(State.Model, N, True, State.GBase, State.SolverInfo, State.SolverRep, State.XDir)
    If State.SolverInfo >= 0# Then
        GoTo lbl_36
    End If
    If Not IncreaseLambda(lambda, Nu, LambdaUp) Then
        GoTo lbl_38
    End If
    GoTo lbl_30
    GoTo lbl_39
lbl_38:
    State.RepTerminationType = 7#
    Call LMClearRequestFields(State)
    State.NeedF = True
    State.RState.Stage = 7#
    GoTo lbl_rcomm
lbl_7:
    GoTo lbl_31
lbl_39:
lbl_36:
    For i_ = 0# To N - 1# Step 1
        State.XDir(i_) = -1 * State.XDir(i_)
    Next i_
    
    '
    ' Candidate lambda is found.
    ' 1. Save old w in WBase
    ' 1. Test some stopping criterions
    ' 2. If error(w+wdir)>error(w), increase lambda
    '
    For i_ = 0# To N - 1# Step 1
        State.XPrev(i_) = State.x(i_)
    Next i_
    State.FPrev = State.f
    For i_ = 0# To N - 1# Step 1
        State.XBase(i_) = State.x(i_)
    Next i_
    For i_ = 0# To N - 1# Step 1
        State.x(i_) = State.x(i_) + State.XDir(i_)
    Next i_
    StepNorm = 0#
    For i_ = 0# To N - 1# Step 1
        StepNorm = StepNorm + State.XDir(i_) * State.XDir(i_)
    Next i_
    StepNorm = Sqr(StepNorm)
    If Not (State.StpMax > 0# And StepNorm > State.StpMax) Then
        GoTo lbl_40
    End If
    
    '
    ' Step is larger than the limit,
    ' larger lambda is needed
    '
    For i_ = 0# To N - 1# Step 1
        State.x(i_) = State.XBase(i_)
    Next i_
    If Not IncreaseLambda(lambda, Nu, LambdaUp) Then
        GoTo lbl_42
    End If
    GoTo lbl_30
    GoTo lbl_43
lbl_42:
    State.RepTerminationType = 7#
    For i_ = 0# To N - 1# Step 1
        State.x(i_) = State.XPrev(i_)
    Next i_
    Call LMClearRequestFields(State)
    State.NeedF = True
    State.RState.Stage = 8#
    GoTo lbl_rcomm
lbl_8:
    GoTo lbl_31
lbl_43:
lbl_40:
    Call LMClearRequestFields(State)
    State.NeedF = True
    State.RState.Stage = 9#
    GoTo lbl_rcomm
lbl_9:
    State.RepNFunc = State.RepNFunc + 1#
    FNew = State.f
    If FNew <= FBase Then
        GoTo lbl_44
    End If
    
    '
    ' restore state and continue search for lambda
    '
    For i_ = 0# To N - 1# Step 1
        State.x(i_) = State.XBase(i_)
    Next i_
    If Not IncreaseLambda(lambda, Nu, LambdaUp) Then
        GoTo lbl_46
    End If
    GoTo lbl_30
    GoTo lbl_47
lbl_46:
    State.RepTerminationType = 7#
    For i_ = 0# To N - 1# Step 1
        State.x(i_) = State.XPrev(i_)
    Next i_
    Call LMClearRequestFields(State)
    State.NeedF = True
    State.RState.Stage = 10#
    GoTo lbl_rcomm
lbl_10:
    GoTo lbl_31
lbl_47:
lbl_44:
    If Not (State.StpMax = 0# And (State.UserMode = LMModeFGJ Or State.UserMode = LMModeFGH) And State.Flags \ LMFlagNoIntLBFGS Mod 2# = 0#) Then
        GoTo lbl_48
    End If
    
    '
    ' Optimize using LBFGS, with inv(cholesky(H)) as preconditioner.
    '
    ' It is possible only when StpMax=0, because we can't guarantee
    ' that step remains bounded when preconditioner is used (we need
    ' SVD decomposition to do that, which is too slow).
    '
    Call RMatrixTRInverse(State.Model, N, True, False, State.InvInfo, State.InvRep)
    If State.InvInfo <= 0# Then
        GoTo lbl_50
    End If
    
    '
    ' if matrix can be inverted, use it.
    ' just silently move to next iteration otherwise.
    ' (will be very, very rare, mostly for specially
    ' designed near-degenerate tasks)
    '
    For i_ = 0# To N - 1# Step 1
        State.XBase(i_) = State.x(i_)
    Next i_
    For i = 0# To N - 1# Step 1
        State.XPrec(i) = 0#
    Next i
    Call MinLBFGSCreateX(N, MinInt(N, LMIntLBFGSIts), State.XPrec, LBFGSFlags, State.InternalState)
    Call MinLBFGSSetCond(State.InternalState, 0#, 0#, 0#, LMIntLBFGSIts)
lbl_52:
    If Not MinLBFGSIteration(State.InternalState) Then
        GoTo lbl_53
    End If
    
    '
    ' convert XPrec to unpreconditioned form, then call RComm.
    '
    For i = 0# To N - 1# Step 1
        V = 0#
        For i_ = i To N - 1# Step 1
            V = V + State.InternalState.x(i_) * State.Model(i, i_)
        Next i_
        State.x(i) = State.XBase(i) + V
    Next i
    Call LMClearRequestFields(State)
    State.NeedFG = True
    State.RState.Stage = 11#
    GoTo lbl_rcomm
lbl_11:
    State.RepNFunc = State.RepNFunc + 1#
    State.RepNGrad = State.RepNGrad + 1#
    
    '
    ' 1. pass State.F to State.InternalState.F
    ' 2. convert gradient back to preconditioned form
    '
    State.InternalState.f = State.f
    For i = 0# To N - 1# Step 1
        State.InternalState.g(i) = 0#
    Next i
    For i = 0# To N - 1# Step 1
        V = State.g(i)
        For i_ = i To N - 1# Step 1
            State.InternalState.g(i_) = State.InternalState.g(i_) + V * State.Model(i, i_)
        Next i_
    Next i
    
    '
    ' next iteration
    '
    GoTo lbl_52
lbl_53:
    
    '
    ' change LBFGS flags to NoRealloc.
    ' L-BFGS subroutine will use memory allocated from previous run.
    ' it is possible since all subsequent calls will be with same N/M.
    '
    LBFGSFlags = LBFGSNoRealloc
    
    '
    ' back to unpreconditioned X
    '
    Call MinLBFGSResults(State.InternalState, State.XPrec, State.InternalRep)
    For i = 0# To N - 1# Step 1
        V = 0#
        For i_ = i To N - 1# Step 1
            V = V + State.XPrec(i_) * State.Model(i, i_)
        Next i_
        State.x(i) = State.XBase(i) + V
    Next i
lbl_50:
lbl_48:
    
    '
    ' Composite iteration is almost over:
    ' * accept new position.
    ' * rebuild quadratic model
    '
    State.RepIterationsCount = State.RepIterationsCount + 1#
    If State.UserMode <> LMModeFGH Then
        GoTo lbl_54
    End If
    Call LMClearRequestFields(State)
    State.NeedFGH = True
    State.RState.Stage = 12#
    GoTo lbl_rcomm
lbl_12:
    State.RepNFunc = State.RepNFunc + 1#
    State.RepNGrad = State.RepNGrad + 1#
    State.RepNHess = State.RepNHess + 1#
    Call RMatrixCopy(N, N, State.h, 0#, 0#, State.RawModel, 0#, 0#)
    For i_ = 0# To N - 1# Step 1
        State.GBase(i_) = State.g(i_)
    Next i_
    FNew = State.f
lbl_54:
    If Not (State.UserMode = LMModeFGJ Or State.UserMode = LMModeFJ) Then
        GoTo lbl_56
    End If
    Call LMClearRequestFields(State)
    State.NeedFiJ = True
    State.RState.Stage = 13#
    GoTo lbl_rcomm
lbl_13:
    State.RepNFunc = State.RepNFunc + 1#
    State.RepNJac = State.RepNJac + 1#
    Call RMatrixGEMM(N, N, M, 2#, State.j, 0#, 0#, 1#, State.j, 0#, 0#, 0#, 0#, State.RawModel, 0#, 0#)
    Call RMatrixMV(N, M, State.j, 0#, 0#, 1#, State.fi, 0#, State.GBase, 0#)
    For i_ = 0# To N - 1# Step 1
        State.GBase(i_) = 2 * State.GBase(i_)
    Next i_
    FNew = 0#
    For i_ = 0# To M - 1# Step 1
        FNew = FNew + State.fi(i_) * State.fi(i_)
    Next i_
lbl_56:
    
    '
    ' Stopping conditions
    '
    For i_ = 0# To N - 1# Step 1
        State.WORK(i_) = State.XPrev(i_)
    Next i_
    For i_ = 0# To N - 1# Step 1
        State.WORK(i_) = State.WORK(i_) - State.x(i_)
    Next i_
    StepNorm = 0#
    For i_ = 0# To N - 1# Step 1
        StepNorm = StepNorm + State.WORK(i_) * State.WORK(i_)
    Next i_
    StepNorm = Sqr(StepNorm)
    If StepNorm <= State.EpsX Then
        State.RepTerminationType = 2#
        GoTo lbl_31
    End If
    If State.RepIterationsCount >= State.MaxIts And State.MaxIts > 0# Then
        State.RepTerminationType = 5#
        GoTo lbl_31
    End If
    V = 0#
    For i_ = 0# To N - 1# Step 1
        V = V + State.GBase(i_) * State.GBase(i_)
    Next i_
    V = Sqr(V)
    If V <= State.EpsG Then
        State.RepTerminationType = 4#
        GoTo lbl_31
    End If
    If Abs(FNew - FBase) <= State.EpsF * MaxReal(1#, MaxReal(Abs(FNew), Abs(FBase))) Then
        State.RepTerminationType = 1#
        GoTo lbl_31
    End If
    
    '
    ' Now, iteration is finally over:
    ' * update FBase
    ' * decrease lambda
    ' * report new iteration
    '
    If Not State.XRep Then
        GoTo lbl_58
    End If
    Call LMClearRequestFields(State)
    State.XUpdated = True
    State.f = FNew
    State.RState.Stage = 14#
    GoTo lbl_rcomm
lbl_14:
lbl_58:
    FBase = FNew
    Call DecreaseLambda(lambda, Nu, LambdaDown)
    GoTo lbl_30
lbl_31:
    
    '
    ' final point is reported
    '
    If Not State.XRep Then
        GoTo lbl_60
    End If
    Call LMClearRequestFields(State)
    State.XUpdated = True
    State.f = FNew
    State.RState.Stage = 15#
    GoTo lbl_rcomm
lbl_15:
lbl_60:
    Result = False
    MinLMIteration = Result
    Exit Function
    
    '
    ' Saving state
    '
lbl_rcomm:
    Result = True
    State.RState.IA(0#) = N
    State.RState.IA(1#) = M
    State.RState.IA(2#) = i
    State.RState.IA(3#) = LBFGSFlags
    State.RState.BA(0#) = SPD
    State.RState.RA(0#) = StepNorm
    State.RState.RA(1#) = FBase
    State.RState.RA(2#) = FNew
    State.RState.RA(3#) = lambda
    State.RState.RA(4#) = Nu
    State.RState.RA(5#) = LambdaUp
    State.RState.RA(6#) = LambdaDown
    State.RState.RA(7#) = V
    MinLMIteration = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Levenberg-Marquardt algorithm results
'
'Called after MinLMIteration returned False.
'
'Input parameters:
'    State   -   algorithm state (used by MinLMIteration).
'
'Output parameters:
'    X       -   array[0..N-1], solution
'    Rep     -   optimization report:
'                * Rep.TerminationType completetion code:
'                    * -1    incorrect parameters were specified
'                    *  1    relative function improvement is no more than
'                            EpsF.
'                    *  2    relative step is no more than EpsX.
'                    *  4    gradient is no more than EpsG.
'                    *  5    MaxIts steps was taken
'                    *  7    stopping conditions are too stringent,
'                            further improvement is impossible
'                * Rep.IterationsCount contains iterations count
'                * Rep.NFunc     - number of function calculations
'                * Rep.NJac      - number of Jacobi matrix calculations
'                * Rep.NGrad     - number of gradient calculations
'                * Rep.NHess     - number of Hessian calculations
'                * Rep.NCholesky - number of Cholesky decomposition calculations
'
'  -- ALGLIB --
'     Copyright 10.03.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MinLMResults(ByRef State As MinLMState, _
         ByRef x() As Double, _
         ByRef Rep As MinLMReport)
    Dim i_ As Long
    ReDim x(0# To State.N - 1#)
    For i_ = 0# To State.N - 1# Step 1
        x(i_) = State.x(i_)
    Next i_
    Rep.IterationsCount = State.RepIterationsCount
    Rep.TerminationType = State.RepTerminationType
    Rep.NFunc = State.RepNFunc
    Rep.NJac = State.RepNJac
    Rep.NGrad = State.RepNGrad
    Rep.NHess = State.RepNHess
    Rep.NCholesky = State.RepNCholesky
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Prepare internal structures (except for RComm).
'
'Note: M must be zero for FGH mode, non-zero for FJ/FGJ mode.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub LMPrepare(ByVal N As Long, _
         ByVal M As Long, _
         ByVal HaveGrad As Boolean, _
         ByRef State As MinLMState)
    State.RepIterationsCount = 0#
    State.RepTerminationType = 0#
    State.RepNFunc = 0#
    State.RepNJac = 0#
    State.RepNGrad = 0#
    State.RepNHess = 0#
    State.RepNCholesky = 0#
    If N <= 0# Or M < 0# Then
        Exit Sub
    End If
    If HaveGrad Then
        ReDim State.g(0# To N - 1#)
    End If
    If M <> 0# Then
        ReDim State.j(0# To M - 1#, 0# To N - 1#)
        ReDim State.fi(0# To M - 1#)
        ReDim State.h(0# To 0#, 0# To 0#)
    Else
        ReDim State.j(0# To 0#, 0# To 0#)
        ReDim State.fi(0# To 0#)
        ReDim State.h(0# To N - 1#, 0# To N - 1#)
    End If
    ReDim State.x(0# To N - 1#)
    ReDim State.RawModel(0# To N - 1#, 0# To N - 1#)
    ReDim State.Model(0# To N - 1#, 0# To N - 1#)
    ReDim State.XBase(0# To N - 1#)
    ReDim State.XPrec(0# To N - 1#)
    ReDim State.GBase(0# To N - 1#)
    ReDim State.XDir(0# To N - 1#)
    ReDim State.XPrev(0# To N - 1#)
    ReDim State.WORK(0# To MaxInt(N, M))
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Clears request fileds (to be sure that we don't forgot to clear something)
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub LMClearRequestFields(ByRef State As MinLMState)
    State.NeedF = False
    State.NeedFG = False
    State.NeedFGH = False
    State.NeedFiJ = False
    State.XUpdated = False
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Increases lambda, returns False when there is a danger of overflow
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Function IncreaseLambda(ByRef lambda As Double, _
         ByRef Nu As Double, _
         ByVal LambdaUp As Double) As Boolean
    Dim Result As Boolean
    Dim LnLambda As Double
    Dim LnNu As Double
    Dim LnLambdaUp As Double
    Dim LnMax As Double
    Result = False
    LnLambda = Log(lambda)
    LnLambdaUp = Log(LambdaUp)
    LnNu = Log(Nu)
    LnMax = Log(MaxRealNumber)
    If LnLambda + LnLambdaUp + LnNu > LnMax Then
        IncreaseLambda = Result
        Exit Function
    End If
    If LnNu + Log(2#) > LnMax Then
        IncreaseLambda = Result
        Exit Function
    End If
    lambda = lambda * LambdaUp * Nu
    Nu = Nu * 2#
    Result = True
    IncreaseLambda = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Decreases lambda, but leaves it unchanged when there is danger of underflow.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub DecreaseLambda(ByRef lambda As Double, _
         ByRef Nu As Double, _
         ByVal LambdaDown As Double)
    Nu = 1#
    If Log(lambda) + Log(LambdaDown) < Log(MinRealNumber) Then
        lambda = MinRealNumber
    Else
        lambda = lambda * LambdaDown
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2007-2008, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'        LIMITED MEMORY BFGS METHOD FOR LARGE SCALE OPTIMIZATION
'
'The subroutine minimizes function F(x) of N arguments by  using  a  quasi-
'Newton method (LBFGS scheme) which is optimized to use  a  minimum  amount
'of memory.
'
'The subroutine generates the approximation of an inverse Hessian matrix by
'using information about the last M steps of the algorithm  (instead of N).
'It lessens a required amount of memory from a value  of  order  N^2  to  a
'value of order 2*N*M.
'
'INPUT PARAMETERS:
'    N       -   problem dimension. N>0
'    M       -   number of corrections in the BFGS scheme of Hessian
'                approximation update. Recommended value:  3<=M<=7. The smaller
'                value causes worse convergence, the bigger will  not  cause  a
'                considerably better convergence, but will cause a fall in  the
'                performance. M<=N.
'    X       -   initial solution approximation, array[0..N-1].
'
'OUTPUT PARAMETERS:
'    State   -   structure used for reverse communication.
'
'This function  initializes  State   structure  with  default  optimization
'parameters (stopping conditions, step size, etc.). Use MinLBFGSSet??????()
'functions to tune optimization parameters.
'
'After   all   optimization   parameters   are   tuned,   you   should  use
'MinLBFGSIteration() function to advance algorithm iterations.
'
'NOTES:
'
'1. you may tune stopping conditions with MinLBFGSSetCond() function
'2. if target function contains exp() or other fast growing functions,  and
'   optimization algorithm makes too large steps which leads  to  overflow,
'   use MinLBFGSSetStpMax() function to bound algorithm's  steps.  However,
'   L-BFGS rarely needs such a tuning.
'
'
'  -- ALGLIB --
'     Copyright 02.04.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MinLBFGSCreate(ByVal N As Long, _
         ByVal M As Long, _
         ByRef x() As Double, _
         ByRef State As MinLBFGSState)
    Call MinLBFGSCreateX(N, M, x, 0#, State)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function sets stopping conditions for L-BFGS optimization algorithm.
'
'INPUT PARAMETERS:
'    State   -   structure which stores algorithm state between calls and
'                which is used for reverse communication. Must be initialized
'                with MinLBFGSCreate()
'    EpsG    -   >=0
'                The  subroutine  finishes  its  work   if   the  condition
'                ||G||<EpsG is satisfied, where ||.|| means Euclidian norm,
'                G - gradient.
'    EpsF    -   >=0
'                The  subroutine  finishes  its work if on k+1-th iteration
'                the  condition  |F(k+1)-F(k)|<=EpsF*max{|F(k)|,|F(k+1)|,1}
'                is satisfied.
'    EpsX    -   >=0
'                The subroutine finishes its work if  on  k+1-th  iteration
'                the condition |X(k+1)-X(k)| <= EpsX is fulfilled.
'    MaxIts  -   maximum number of iterations. If MaxIts=0, the  number  of
'                iterations is unlimited.
'
'Passing EpsG=0, EpsF=0, EpsX=0 and MaxIts=0 (simultaneously) will lead to
'automatic stopping criterion selection (small EpsX).
'
'  -- ALGLIB --
'     Copyright 02.04.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MinLBFGSSetCond(ByRef State As MinLBFGSState, _
         ByVal EpsG As Double, _
         ByVal EpsF As Double, _
         ByVal EpsX As Double, _
         ByVal MaxIts As Long)
    If EpsG = 0# And EpsF = 0# And EpsX = 0# And MaxIts = 0# Then
        EpsX = 0.000001
    End If
    State.EpsG = EpsG
    State.EpsF = EpsF
    State.EpsX = EpsX
    State.MaxIts = MaxIts
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function turns on/off reporting.
'
'INPUT PARAMETERS:
'    State   -   structure which stores algorithm state between calls and
'                which is used for reverse communication. Must be
'                initialized with MinLBFGSCreate()
'    NeedXRep-   whether iteration reports are needed or not
'
'Usually algorithm returns  from  MinLBFGSIteration()  only when  it  needs
'function/gradient/ (which is indicated by NeedFG field. However, with this
'function we can let it  stop  after  each  iteration  (one  iteration  may
'include more than one function evaluation), which is indicated by XUpdated
'field.
'
'
'  -- ALGLIB --
'     Copyright 02.04.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MinLBFGSSetXRep(ByRef State As MinLBFGSState, _
         ByVal NeedXRep As Boolean)
    State.XRep = NeedXRep
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function sets maximum step length
'
'INPUT PARAMETERS:
'    State   -   structure which stores algorithm state between calls and
'                which is used for reverse communication. Must be
'                initialized with MinLBFGSCreate()
'    StpMax  -   maximum step length, >=0. Set StpMax to 0.0,  if you don't
'                want to limit step length.
'
'Use this subroutine when you optimize target function which contains exp()
'or  other  fast  growing  functions,  and optimization algorithm makes too
'large  steps  which  leads  to overflow. This function allows us to reject
'steps  that  are  too  large  (and  therefore  expose  us  to the possible
'overflow) without actually calculating function value at the x+stp*d.
'
'  -- ALGLIB --
'     Copyright 02.04.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MinLBFGSSetStpMax(ByRef State As MinLBFGSState, _
         ByVal StpMax As Double)
    State.StpMax = StpMax
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Extended subroutine for internal use only.
'
'Accepts additional parameters:
'
'    Flags - additional settings:
'            * Flags = 0     means no additional settings
'            * Flags = 1     "do not allocate memory". used when solving
'                            a many subsequent tasks with  same N/M  values.
'                            First  call MUST  be without this flag bit set,
'                            subsequent  calls   of   MinLBFGS   with   same
'                            MinLBFGSState structure can set Flags to 1.
'
'  -- ALGLIB --
'     Copyright 02.04.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MinLBFGSCreateX(ByVal N As Long, _
         ByVal M As Long, _
         ByRef x() As Double, _
         ByVal Flags As Long, _
         ByRef State As MinLBFGSState)
    Dim AllocateMem As Boolean
    Dim i_ As Long
    '
    ' Initialize
    '
    State.N = N
    State.M = M
    State.Flags = Flags
    AllocateMem = Flags Mod 2# = 0#
    Flags = Flags \ 2#
    If AllocateMem Then
        ReDim State.Rho(0# To M - 1#)
        ReDim State.THETA(0# To M - 1#)
        ReDim State.y(0# To M - 1#, 0# To N - 1#)
        ReDim State.s(0# To M - 1#, 0# To N - 1#)
        ReDim State.d(0# To N - 1#)
        ReDim State.x(0# To N - 1#)
        ReDim State.g(0# To N - 1#)
        ReDim State.WORK(0# To N - 1#)
    End If
    Call MinLBFGSSetCond(State, 0#, 0#, 0#, 0#)
    Call MinLBFGSSetXRep(State, False)
    Call MinLBFGSSetStpMax(State, 0#)
    '
    ' Prepare first run
    '
    State.K = 0#
    For i_ = 0# To N - 1# Step 1
        State.x(i_) = x(i_)
    Next i_
    ReDim State.RState.IA(0# To 6#)
    ReDim State.RState.RA(0# To 4#)
    State.RState.Stage = -1#
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'L-BFGS iterations
'
'Called after initialization with MinLBFGSCreate() function.
'
'INPUT PARAMETERS:
'    State   -   structure which stores algorithm state between calls and
'                which is used for reverse communication. Must be initialized
'                with MinLBFGSCreate()
'
'RESULT:
'* if function returned False, iterative proces has converged.
'  Use MinLBFGSResults() to obtain optimization results.
'* if subroutine returned True, then, depending on structure fields, we
'  have one of the following situations
'
'
'=== FUNC/GRAD REQUEST ===
'State.NeedFG is True => function value/gradient are needed.
'Caller should calculate function value State.F and gradient
'State.G[0..N-1] at State.X[0..N-1] and call MinLBFGSIteration() again.
'
'=== NEW INTERATION IS REPORTED ===
'State.XUpdated is True => one more iteration was made.
'State.X contains current position, State.F contains function value at X.
'You can read info from these fields, but never modify  them  because  they
'contain the only copy of optimization algorithm state.
'
'
'One and only one of these fields (NeedFG, XUpdated) is true on return. New
'iterations are reported only when reports  are  explicitly  turned  on  by
'MinLBFGSSetXRep() function, so if you never called it, you can expect that
'NeedFG is always True.
'
'
'  -- ALGLIB --
'     Copyright 20.03.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function MinLBFGSIteration(ByRef State As MinLBFGSState) As Boolean
    Dim Result As Boolean
    Dim N As Long
    Dim M As Long
    Dim MaxIts As Long
    Dim EpsF As Double
    Dim EpsG As Double
    Dim EpsX As Double
    Dim i As Long
    Dim j As Long
    Dim IC As Long
    Dim MCINFO As Long
    Dim V As Double
    Dim VV As Double
    Dim i_ As Long
    '
    ' Reverse communication preparations
    ' I know it looks ugly, but it works the same way
    ' anywhere from C++ to Python.
    '
    ' This code initializes locals by:
    ' * random values determined during code
    '   generation - on first subroutine call
    ' * values from previous call - on subsequent calls
    '
    If State.RState.Stage >= 0# Then
        N = State.RState.IA(0#)
        M = State.RState.IA(1#)
        MaxIts = State.RState.IA(2#)
        i = State.RState.IA(3#)
        j = State.RState.IA(4#)
        IC = State.RState.IA(5#)
        MCINFO = State.RState.IA(6#)
        EpsF = State.RState.RA(0#)
        EpsG = State.RState.RA(1#)
        EpsX = State.RState.RA(2#)
        V = State.RState.RA(3#)
        VV = State.RState.RA(4#)
    Else
        N = -983#
        M = -989#
        MaxIts = -834#
        i = 900#
        j = -287#
        IC = 364#
        MCINFO = 214#
        EpsF = -338#
        EpsG = -686#
        EpsX = 912#
        V = 585#
        VV = 497#
    End If
    If State.RState.Stage = 0# Then
        GoTo lbl_0
    End If
    If State.RState.Stage = 1# Then
        GoTo lbl_1
    End If
    If State.RState.Stage = 2# Then
        GoTo lbl_2
    End If
    If State.RState.Stage = 3# Then
        GoTo lbl_3
    End If
    '
    ' Routine body
    '
    '
    ' Unload frequently used variables from State structure
    ' (just for typing convinience)
    '
    N = State.N
    M = State.M
    EpsG = State.EpsG
    EpsF = State.EpsF
    EpsX = State.EpsX
    MaxIts = State.MaxIts
    State.RepTerminationType = 0#
    State.RepIterationsCount = 0#
    State.RepNFEV = 0#
    '
    ' Calculate F/G at the initial point
    '
    Call ClearRequestFieldsLBFGS(State)
    State.NeedFG = True
    State.RState.Stage = 0#
    GoTo lbl_rcomm
lbl_0:
    If Not State.XRep Then
        GoTo lbl_4
    End If
    Call ClearRequestFieldsLBFGS(State)
    State.XUpdated = True
    State.RState.Stage = 1#
    GoTo lbl_rcomm
lbl_1:
lbl_4:
    State.RepNFEV = 1#
    State.Fold = State.f
    V = 0#
    For i_ = 0# To N - 1# Step 1
        V = V + State.g(i_) * State.g(i_)
    Next i_
    V = Sqr(V)
    If V <= EpsG Then
        State.RepTerminationType = 4#
        Result = False
        MinLBFGSIteration = Result
        Exit Function
    End If
    '
    ' Choose initial step
    '
    If State.StpMax = 0# Then
        State.Stp = MinReal(1# / V, 1#)
    Else
        State.Stp = MinReal(1# / V, State.StpMax)
    End If
    For i_ = 0# To N - 1# Step 1
        State.d(i_) = -State.g(i_)
    Next i_
    '
    ' Main cycle
    '
lbl_6:
    If False Then
        GoTo lbl_7
    End If
    '
    ' Main cycle: prepare to 1-D line search
    '
    State.p = State.K Mod M
    State.q = MinInt(State.K, M - 1#)
    '
    ' Store X[k], G[k]
    '
    For i_ = 0# To N - 1# Step 1
        State.s(State.p, i_) = -State.x(i_)
    Next i_
    For i_ = 0# To N - 1# Step 1
        State.y(State.p, i_) = -State.g(i_)
    Next i_
    '
    ' Minimize F(x+alpha*d)
    ' Calculate S[k], Y[k]
    '
    State.MCStage = 0#
    If State.K <> 0# Then
        State.Stp = 1#
    End If
    Call LinMinNormalizeD(State.d, State.Stp, N)
    Call MCSRCH(N, State.x, State.f, State.g, State.d, State.Stp, State.StpMax, MCINFO, State.NFEV, State.WORK, State.LState, State.MCStage)
lbl_8:
    If State.MCStage = 0# Then
        GoTo lbl_9
    End If
    Call ClearRequestFieldsLBFGS(State)
    State.NeedFG = True
    State.RState.Stage = 2#
    GoTo lbl_rcomm
lbl_2:
    Call MCSRCH(N, State.x, State.f, State.g, State.d, State.Stp, State.StpMax, MCINFO, State.NFEV, State.WORK, State.LState, State.MCStage)
    GoTo lbl_8
lbl_9:
    If Not State.XRep Then
        GoTo lbl_10
    End If
    '
    ' report
    '
    Call ClearRequestFieldsLBFGS(State)
    State.XUpdated = True
    State.RState.Stage = 3#
    GoTo lbl_rcomm
lbl_3:
lbl_10:
    State.RepNFEV = State.RepNFEV + State.NFEV
    State.RepIterationsCount = State.RepIterationsCount + 1#
    For i_ = 0# To N - 1# Step 1
        State.s(State.p, i_) = State.s(State.p, i_) + State.x(i_)
    Next i_
    For i_ = 0# To N - 1# Step 1
        State.y(State.p, i_) = State.y(State.p, i_) + State.g(i_)
    Next i_
    '
    ' Stopping conditions
    '
    If State.RepIterationsCount >= MaxIts And MaxIts > 0# Then
        '
        ' Too many iterations
        '
        State.RepTerminationType = 5#
        Result = False
        MinLBFGSIteration = Result
        Exit Function
    End If
    V = 0#
    For i_ = 0# To N - 1# Step 1
        V = V + State.g(i_) * State.g(i_)
    Next i_
    If Sqr(V) <= EpsG Then
        '
        ' Gradient is small enough
        '
        State.RepTerminationType = 4#
        Result = False
        MinLBFGSIteration = Result
        Exit Function
    End If
    If State.Fold - State.f <= EpsF * MaxReal(Abs(State.Fold), MaxReal(Abs(State.f), 1#)) Then
        '
        ' F(k+1)-F(k) is small enough
        '
        State.RepTerminationType = 1#
        Result = False
        MinLBFGSIteration = Result
        Exit Function
    End If
    V = 0#
    For i_ = 0# To N - 1# Step 1
        V = V + State.s(State.p, i_) * State.s(State.p, i_)
    Next i_
    If Sqr(V) <= EpsX Then
        '
        ' X(k+1)-X(k) is small enough
        '
        State.RepTerminationType = 2#
        Result = False
        MinLBFGSIteration = Result
        Exit Function
    End If
    '
    ' If Wolfe conditions are satisfied, we can update
    ' limited memory model.
    '
    ' However, if conditions are not satisfied (NFEV limit is met,
    ' function is too wild, ...), we'll skip L-BFGS update
    '
    If MCINFO <> 1# Then
        '
        ' Skip update.
        '
        ' In such cases we'll initialize search direction by
        ' antigradient vector, because it  leads to more
        ' transparent code with less number of special cases
        '
        State.Fold = State.f
        For i_ = 0# To N - 1# Step 1
            State.d(i_) = -State.g(i_)
        Next i_
    Else
        '
        ' Calculate Rho[k], GammaK
        '
        V = 0#
        For i_ = 0# To N - 1# Step 1
            V = V + State.y(State.p, i_) * State.s(State.p, i_)
        Next i_
        VV = 0#
        For i_ = 0# To N - 1# Step 1
            VV = VV + State.y(State.p, i_) * State.y(State.p, i_)
        Next i_
        If V = 0# Or VV = 0# Then
            '
            ' Rounding errors make further iterations impossible.
            '
            State.RepTerminationType = -2#
            Result = False
            MinLBFGSIteration = Result
            Exit Function
        End If
        State.Rho(State.p) = 1# / V
        State.GammaK = V / VV
        '
        '  Calculate d(k+1) = -H(k+1)*g(k+1)
        '
        '  for I:=K downto K-Q do
        '      V = s(i)^T * work(iteration:I)
        '      theta(i) = V
        '      work(iteration:I+1) = work(iteration:I) - V*Rho(i)*y(i)
        '  work(last iteration) = H0*work(last iteration)
        '  for I:=K-Q to K do
        '      V = y(i)^T*work(iteration:I)
        '      work(iteration:I+1) = work(iteration:I) +(-V+theta(i))*Rho(i)*s(i)
        '
        '  NOW WORK CONTAINS d(k+1)
        '
        For i_ = 0# To N - 1# Step 1
            State.WORK(i_) = State.g(i_)
        Next i_
        For i = State.K To State.K - State.q Step -1
            IC = i Mod M
            V = 0#
            For i_ = 0# To N - 1# Step 1
                V = V + State.s(IC, i_) * State.WORK(i_)
            Next i_
            State.THETA(IC) = V
            VV = V * State.Rho(IC)
            For i_ = 0# To N - 1# Step 1
                State.WORK(i_) = State.WORK(i_) - VV * State.y(IC, i_)
            Next i_
        Next i
        V = State.GammaK
        For i_ = 0# To N - 1# Step 1
            State.WORK(i_) = V * State.WORK(i_)
        Next i_
        For i = State.K - State.q To State.K Step 1
            IC = i Mod M
            V = 0#
            For i_ = 0# To N - 1# Step 1
                V = V + State.y(IC, i_) * State.WORK(i_)
            Next i_
            VV = State.Rho(IC) * (-V + State.THETA(IC))
            For i_ = 0# To N - 1# Step 1
                State.WORK(i_) = State.WORK(i_) + VV * State.s(IC, i_)
            Next i_
        Next i
        For i_ = 0# To N - 1# Step 1
            State.d(i_) = -State.WORK(i_)
        Next i_
        '
        ' Next step
        '
        State.Fold = State.f
        State.K = State.K + 1#
    End If
    GoTo lbl_6
lbl_7:
    Result = False
    MinLBFGSIteration = Result
    Exit Function
    '
    ' Saving state
    '
lbl_rcomm:
    Result = True
    State.RState.IA(0#) = N
    State.RState.IA(1#) = M
    State.RState.IA(2#) = MaxIts
    State.RState.IA(3#) = i
    State.RState.IA(4#) = j
    State.RState.IA(5#) = IC
    State.RState.IA(6#) = MCINFO
    State.RState.RA(0#) = EpsF
    State.RState.RA(1#) = EpsG
    State.RState.RA(2#) = EpsX
    State.RState.RA(3#) = V
    State.RState.RA(4#) = VV
    MinLBFGSIteration = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'L-BFGS algorithm results
'
'Called after MinLBFGSIteration() returned False.
'
'INPUT PARAMETERS:
'    State   -   algorithm state (used by MinLBFGSIteration).
'
'OUTPUT PARAMETERS:
'    X       -   array[0..N-1], solution
'    Rep     -   optimization report:
'                * Rep.TerminationType completetion code:
'                    * -2    rounding errors prevent further improvement.
'                            X contains best point found.
'                    * -1    incorrect parameters were specified
'                    *  1    relative function improvement is no more than
'                            EpsF.
'                    *  2    relative step is no more than EpsX.
'                    *  4    gradient norm is no more than EpsG
'                    *  5    MaxIts steps was taken
'                    *  7    stopping conditions are too stringent,
'                            further improvement is impossible
'                * Rep.IterationsCount contains iterations count
'                * NFEV countains number of function calculations
'
'  -- ALGLIB --
'     Copyright 02.04.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MinLBFGSResults(ByRef State As MinLBFGSState, _
         ByRef x() As Double, _
         ByRef Rep As MinLBFGSReport)
    Dim i_ As Long
    ReDim x(0# To State.N - 1#)
    For i_ = 0# To State.N - 1# Step 1
        x(i_) = State.x(i_)
    Next i_
    Rep.IterationsCount = State.RepIterationsCount
    Rep.NFEV = State.RepNFEV
    Rep.TerminationType = State.RepTerminationType
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Clears request fileds (to be sure that we don't forgot to clear something)
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub ClearRequestFieldsLBFGS(ByRef State As MinLBFGSState)
    State.NeedFG = False
    State.XUpdated = False
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2006-2009, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Data types
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Weighted linear least squares fitting.
'
'QR decomposition is used to reduce task to MxM, then triangular solver  or
'SVD-based solver is used depending on condition number of the  system.  It
'allows to maximize speed and retain decent accuracy.
'
'INPUT PARAMETERS:
'    Y       -   array[0..N-1] Function values in  N  points.
'    W       -   array[0..N-1]  Weights  corresponding to function  values.
'                Each summand in square  sum  of  approximation  deviations
'                from  given  values  is  multiplied  by  the   square   of
'                corresponding weight.
'    FMatrix -   a table of basis functions values, array[0..N-1, 0..M-1].
'                FMatrix[I, J] - value of J-th basis function in I-th point.
'    N       -   number of points used. N>=1.
'    M       -   number of basis functions, M>=1.
'
'OUTPUT PARAMETERS:
'    Info    -   error code:
'                * -4    internal SVD decomposition subroutine failed (very
'                        rare and for degenerate systems only)
'                * -1    incorrect N/M were specified
'                *  1    task is solved
'    C       -   decomposition coefficients, array[0..M-1]
'    Rep     -   fitting report. Following fields are set:
'                * Rep.TaskRCond     reciprocal of condition number
'                * RMSError          rms error on the (X,Y).
'                * AvgError          average error on the (X,Y).
'                * AvgRelError       average relative error on the non-zero Y
'                * MaxError          maximum error
'                                    NON-WEIGHTED ERRORS ARE CALCULATED
'
'SEE ALSO
'    LSFitLinear
'    LSFitLinearC
'    LSFitLinearWC
'
'  -- ALGLIB --
'     Copyright 17.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub LSFitLinearW(ByRef y() As Double, _
         ByRef w() As Double, _
         ByRef FMatrix() As Double, _
         ByVal N As Long, _
         ByVal M As Long, _
         ByRef Info As Long, _
         ByRef C() As Double, _
         ByRef Rep As LSFitReport)
    Call LSFitLinearInternal(y, w, FMatrix, N, M, Info, C, Rep)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Weighted constained linear least squares fitting.
'
'This  is  variation  of LSFitLinearW(), which searchs for min|A*x=b| given
'that  K  additional  constaints  C*x=bc are satisfied. It reduces original
'task to modified one: min|B*y-d| WITHOUT constraints,  then LSFitLinearW()
'is called.
'
'INPUT PARAMETERS:
'    Y       -   array[0..N-1] Function values in  N  points.
'    W       -   array[0..N-1]  Weights  corresponding to function  values.
'                Each summand in square  sum  of  approximation  deviations
'                from  given  values  is  multiplied  by  the   square   of
'                corresponding weight.
'    FMatrix -   a table of basis functions values, array[0..N-1, 0..M-1].
'                FMatrix[I,J] - value of J-th basis function in I-th point.
'    CMatrix -   a table of constaints, array[0..K-1,0..M].
'                I-th row of CMatrix corresponds to I-th linear constraint:
'                CMatrix[I,0]*C[0] + ... + CMatrix[I,M-1]*C[M-1] = CMatrix[I,M]
'    N       -   number of points used. N>=1.
'    M       -   number of basis functions, M>=1.
'    K       -   number of constraints, 0 <= K < M
'                K=0 corresponds to absence of constraints.
'
'OUTPUT PARAMETERS:
'    Info    -   error code:
'                * -4    internal SVD decomposition subroutine failed (very
'                        rare and for degenerate systems only)
'                * -3    either   too   many  constraints  (M   or   more),
'                        degenerate  constraints   (some   constraints  are
'                        repetead twice) or inconsistent  constraints  were
'                        specified.
'                * -1    incorrect N/M/K were specified
'                *  1    task is solved
'    C       -   decomposition coefficients, array[0..M-1]
'    Rep     -   fitting report. Following fields are set:
'                * RMSError          rms error on the (X,Y).
'                * AvgError          average error on the (X,Y).
'                * AvgRelError       average relative error on the non-zero Y
'                * MaxError          maximum error
'                                    NON-WEIGHTED ERRORS ARE CALCULATED
'
'IMPORTANT:
'    this subroitine doesn't calculate task's condition number for K<>0.
'
'SEE ALSO
'    LSFitLinear
'    LSFitLinearC
'    LSFitLinearWC
'
'  -- ALGLIB --
'     Copyright 07.09.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub LSFitLinearWC(ByRef y_() As Double, _
         ByRef w() As Double, _
         ByRef FMatrix() As Double, _
         ByRef CMatrix_() As Double, _
         ByVal N As Long, _
         ByVal M As Long, _
         ByVal K As Long, _
         ByRef Info As Long, _
         ByRef C() As Double, _
         ByRef Rep As LSFitReport)
    Dim y() As Double
    Dim CMatrix() As Double
    Dim i As Long
    Dim j As Long
    Dim Tau() As Double
    Dim q() As Double
    Dim F2() As Double
    Dim tmp() As Double
    Dim C0() As Double
    Dim V As Double
    Dim i_ As Long
    y = y_
    CMatrix = CMatrix_
    If N < 1# Or M < 1# Or K < 0# Then
        Info = -1#
        Exit Sub
    End If
    If K >= M Then
        Info = -3#
        Exit Sub
    End If
    
    '
    ' Solve
    '
    If K = 0# Then
        
        '
        ' no constraints
        '
        Call LSFitLinearInternal(y, w, FMatrix, N, M, Info, C, Rep)
    Else
        
        '
        ' First, find general form solution of constraints system:
        ' * factorize C = L*Q
        ' * unpack Q
        ' * fill upper part of C with zeros (for RCond)
        '
        ' We got C=C0+Q2'*y where Q2 is lower M-K rows of Q.
        '
        Call RMatrixLQ(CMatrix, K, M, Tau)
        Call RMatrixLQUnpackQ(CMatrix, K, M, Tau, M, q)
        For i = 0# To K - 1# Step 1
            For j = i + 1# To M - 1# Step 1
                CMatrix(i, j) = 0#
            Next j
        Next i
        If RMatrixLURCondInf(CMatrix, K) < 1000# * MachineEpsilon Then
            Info = -3#
            Exit Sub
        End If
        ReDim tmp(0 To K - 1)
        For i = 0# To K - 1# Step 1
            If i > 0# Then
                V = 0#
                For i_ = 0# To i - 1# Step 1
                    V = V + CMatrix(i, i_) * tmp(i_)
                Next i_
            Else
                V = 0#
            End If
            tmp(i) = (CMatrix(i, M) - V) / CMatrix(i, i)
        Next i
        ReDim C0(0 To M - 1)
        For i = 0# To M - 1# Step 1
            C0(i) = 0#
        Next i
        For i = 0# To K - 1# Step 1
            V = tmp(i)
            For i_ = 0# To M - 1# Step 1
                C0(i_) = C0(i_) + V * q(i, i_)
            Next i_
        Next i
        
        '
        ' Second, prepare modified matrix F2 = F*Q2' and solve modified task
        '
        ReDim tmp(0 To MaxInt(N, M) + 1# - 1)
        ReDim F2(0 To N - 1, 0 To M - K - 1)
        Call MatrixVectorMultiply(FMatrix, 0#, N - 1#, 0#, M - 1#, False, C0, 0#, M - 1#, -1#, y, 0#, N - 1#, 1#)
        Call MatrixMatrixMultiply(FMatrix, 0#, N - 1#, 0#, M - 1#, False, q, K, M - 1#, 0#, M - 1#, True, 1#, F2, 0#, N - 1#, 0#, M - K - 1#, 0#, tmp)
        Call LSFitLinearInternal(y, w, F2, N, M - K, Info, tmp, Rep)
        Rep.TaskRCond = -1#
        If Info <= 0# Then
            Exit Sub
        End If
        
        '
        ' then, convert back to original answer: C = C0 + Q2'*Y0
        '
        ReDim C(0 To M - 1)
        For i_ = 0# To M - 1# Step 1
            C(i_) = C0(i_)
        Next i_
        Call MatrixVectorMultiply(q, K, M - 1#, 0#, M - 1#, True, tmp, 0#, M - K - 1#, 1#, C, 0#, M - 1#, 1#)
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Linear least squares fitting, without weights.
'
'See LSFitLinearW for more information.
'
'  -- ALGLIB --
'     Copyright 17.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub LSFitLinear(ByRef y() As Double, _
         ByRef FMatrix() As Double, _
         ByVal N As Long, _
         ByVal M As Long, _
         ByRef Info As Long, _
         ByRef C() As Double, _
         ByRef Rep As LSFitReport)
    Dim w() As Double
    Dim i As Long
    If N < 1# Then
        Info = -1#
        Exit Sub
    End If
    ReDim w(0 To N - 1)
    For i = 0# To N - 1# Step 1
        w(i) = 1#
    Next i
    Call LSFitLinearInternal(y, w, FMatrix, N, M, Info, C, Rep)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Constained linear least squares fitting, without weights.
'
'See LSFitLinearWC() for more information.
'
'  -- ALGLIB --
'     Copyright 07.09.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub LSFitLinearC(ByRef y_() As Double, _
         ByRef FMatrix() As Double, _
         ByRef CMatrix() As Double, _
         ByVal N As Long, _
         ByVal M As Long, _
         ByVal K As Long, _
         ByRef Info As Long, _
         ByRef C() As Double, _
         ByRef Rep As LSFitReport)
    Dim y() As Double
    Dim w() As Double
    Dim i As Long
    y = y_
    If N < 1# Then
        Info = -1#
        Exit Sub
    End If
    ReDim w(0 To N - 1)
    For i = 0# To N - 1# Step 1
        w(i) = 1#
    Next i
    Call LSFitLinearWC(y, w, FMatrix, CMatrix, N, M, K, Info, C, Rep)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Weighted nonlinear least squares fitting using gradient and Hessian.
'
'Nonlinear task min(F(c)) is solved, where
'
'    F(c) = (w[0]*(f(x[0],c)-y[0]))^2 + ... + (w[n-1]*(f(x[n-1],c)-y[n-1]))^2,
'
'    * N is a number of points,
'    * M is a dimension of a space points belong to,
'    * K is a dimension of a space of parameters being fitted,
'    * w is an N-dimensional vector of weight coefficients,
'    * x is a set of N points, each of them is an M-dimensional vector,
'    * c is a K-dimensional vector of parameters being fitted
'
'This subroutine uses only f(x[i],c) and its gradient.
'
'INPUT PARAMETERS:
'    X       -   array[0..N-1,0..M-1], points (one row = one point)
'    Y       -   array[0..N-1], function values.
'    W       -   weights, array[0..N-1]
'    C       -   array[0..K-1], initial approximation to the solution,
'    N       -   number of points, N>1
'    M       -   dimension of space
'    K       -   number of parameters being fitted
'    CheapFG -   boolean flag, which is:
'                * True  if both function and gradient calculation complexity
'                        are less than O(M^2).  An improved  algorithm  can
'                        be  used  which corresponds  to  FGJ  scheme  from
'                        MINLM unit.
'                * False otherwise.
'                        Standard Jacibian-bases  Levenberg-Marquardt  algo
'                        will be used (FJ scheme).
'
'OUTPUT PARAMETERS:
'    State   -   structure which stores algorithm state between subsequent
'                calls  of   LSFitNonlinearIteration.   Used  for  reverse
'                communication.  This  structure   should   be  passed  to
'                LSFitNonlinearIteration subroutine.
'
'See also:
'    LSFitNonlinearIteration
'    LSFitNonlinearResults
'    LSFitNonlinearFG (fitting without weights)
'    LSFitNonlinearWFGH (fitting using Hessian)
'    LSFitNonlinearFGH (fitting using Hessian, without weights)
'
'
'  -- ALGLIB --
'     Copyright 17.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub LSFitNonlinearWFG(ByRef x() As Double, _
         ByRef y() As Double, _
         ByRef w() As Double, _
         ByRef C() As Double, _
         ByVal N As Long, _
         ByVal M As Long, _
         ByVal K As Long, _
         ByVal CheapFG As Boolean, _
         ByRef State As LSFitState)
    Dim i As Long
    Dim i_ As Long
    State.N = N
    State.M = M
    State.K = K
    Call LSFitNonlinearSetCond(State, 0#, 0#, 0#)
    Call LSFitNonlinearSetStpMax(State, 0#)
    State.CheapFG = CheapFG
    State.HaveHess = False
    If N >= 1# And M >= 1# And K >= 1# Then
        ReDim State.TaskX(0 To N - 1, 0 To M - 1)
        ReDim State.TaskY(0 To N - 1)
        ReDim State.w(0 To N - 1)
        ReDim State.C(0 To K - 1)
        For i_ = 0# To K - 1# Step 1
            State.C(i_) = C(i_)
        Next i_
        For i_ = 0# To N - 1# Step 1
            State.w(i_) = w(i_)
        Next i_
        For i = 0# To N - 1# Step 1
            For i_ = 0# To M - 1# Step 1
                State.TaskX(i, i_) = x(i, i_)
            Next i_
            State.TaskY(i) = y(i)
        Next i
    End If
    ReDim State.RState.IA(0# To 4#)
    ReDim State.RState.RA(0# To 1#)
    State.RState.Stage = -1#
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Nonlinear least squares fitting, no individual weights.
'See LSFitNonlinearWFG for more information.
'
'  -- ALGLIB --
'     Copyright 17.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub LSFitNonlinearFG(ByRef x() As Double, _
         ByRef y() As Double, _
         ByRef C() As Double, _
         ByVal N As Long, _
         ByVal M As Long, _
         ByVal K As Long, _
         ByVal CheapFG As Boolean, _
         ByRef State As LSFitState)
    Dim i As Long
    Dim i_ As Long
    State.N = N
    State.M = M
    State.K = K
    Call LSFitNonlinearSetCond(State, 0#, 0#, 0#)
    Call LSFitNonlinearSetStpMax(State, 0#)
    State.CheapFG = CheapFG
    State.HaveHess = False
    If N >= 1# And M >= 1# And K >= 1# Then
        ReDim State.TaskX(0 To N - 1, 0 To M - 1)
        ReDim State.TaskY(0 To N - 1)
        ReDim State.w(0 To N - 1)
        ReDim State.C(0 To K - 1)
        For i_ = 0# To K - 1# Step 1
            State.C(i_) = C(i_)
        Next i_
        For i = 0# To N - 1# Step 1
            For i_ = 0# To M - 1# Step 1
                State.TaskX(i, i_) = x(i, i_)
            Next i_
            State.TaskY(i) = y(i)
            State.w(i) = 1#
        Next i
    End If
    ReDim State.RState.IA(0# To 4#)
    ReDim State.RState.RA(0# To 1#)
    State.RState.Stage = -1#
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Weighted nonlinear least squares fitting using gradient/Hessian.
'
'Nonlinear task min(F(c)) is solved, where
'
'    F(c) = (w[0]*(f(x[0],c)-y[0]))^2 + ... + (w[n-1]*(f(x[n-1],c)-y[n-1]))^2,
'
'    * N is a number of points,
'    * M is a dimension of a space points belong to,
'    * K is a dimension of a space of parameters being fitted,
'    * w is an N-dimensional vector of weight coefficients,
'    * x is a set of N points, each of them is an M-dimensional vector,
'    * c is a K-dimensional vector of parameters being fitted
'
'This subroutine uses f(x[i],c), its gradient and its Hessian.
'
'See LSFitNonlinearWFG() subroutine for information about function
'parameters.
'
'  -- ALGLIB --
'     Copyright 17.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub LSFitNonlinearWFGH(ByRef x() As Double, _
         ByRef y() As Double, _
         ByRef w() As Double, _
         ByRef C() As Double, _
         ByVal N As Long, _
         ByVal M As Long, _
         ByVal K As Long, _
         ByRef State As LSFitState)
    Dim i As Long
    Dim i_ As Long
    State.N = N
    State.M = M
    State.K = K
    Call LSFitNonlinearSetCond(State, 0#, 0#, 0#)
    Call LSFitNonlinearSetStpMax(State, 0#)
    State.CheapFG = True
    State.HaveHess = True
    If N >= 1# And M >= 1# And K >= 1# Then
        ReDim State.TaskX(0 To N - 1, 0 To M - 1)
        ReDim State.TaskY(0 To N - 1)
        ReDim State.w(0 To N - 1)
        ReDim State.C(0 To K - 1)
        For i_ = 0# To K - 1# Step 1
            State.C(i_) = C(i_)
        Next i_
        For i_ = 0# To N - 1# Step 1
            State.w(i_) = w(i_)
        Next i_
        For i = 0# To N - 1# Step 1
            For i_ = 0# To M - 1# Step 1
                State.TaskX(i, i_) = x(i, i_)
            Next i_
            State.TaskY(i) = y(i)
        Next i
    End If
    ReDim State.RState.IA(0# To 4#)
    ReDim State.RState.RA(0# To 1#)
    State.RState.Stage = -1#
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Nonlinear least squares fitting using gradient/Hessian without  individual
'weights. See LSFitNonlinearWFGH() for more information.
'
'
'  -- ALGLIB --
'     Copyright 17.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub LSFitNonlinearFGH(ByRef x() As Double, _
         ByRef y() As Double, _
         ByRef C() As Double, _
         ByVal N As Long, _
         ByVal M As Long, _
         ByVal K As Long, _
         ByRef State As LSFitState)
    Dim i As Long
    Dim i_ As Long
    State.N = N
    State.M = M
    State.K = K
    Call LSFitNonlinearSetCond(State, 0#, 0#, 0#)
    Call LSFitNonlinearSetStpMax(State, 0#)
    State.CheapFG = True
    State.HaveHess = True
    If N >= 1# And M >= 1# And K >= 1# Then
        ReDim State.TaskX(0 To N - 1, 0 To M - 1)
        ReDim State.TaskY(0 To N - 1)
        ReDim State.w(0 To N - 1)
        ReDim State.C(0 To K - 1)
        For i_ = 0# To K - 1# Step 1
            State.C(i_) = C(i_)
        Next i_
        For i = 0# To N - 1# Step 1
            For i_ = 0# To M - 1# Step 1
                State.TaskX(i, i_) = x(i, i_)
            Next i_
            State.TaskY(i) = y(i)
            State.w(i) = 1#
        Next i
    End If
    ReDim State.RState.IA(0# To 4#)
    ReDim State.RState.RA(0# To 1#)
    State.RState.Stage = -1#
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Stopping conditions for nonlinear least squares fitting.
'
'INPUT PARAMETERS:
'    State   -   structure which stores algorithm state between calls and
'                which is used for reverse communication. Must be initialized
'                with LSFitNonLinearCreate???()
'    EpsF    -   stopping criterion. Algorithm stops if
'                |F(k+1)-F(k)| <= EpsF*max{|F(k)|, |F(k+1)|, 1}
'    EpsX    -   stopping criterion. Algorithm stops if
'                |X(k+1)-X(k)| <= EpsX*(1+|X(k)|)
'    MaxIts  -   stopping criterion. Algorithm stops after MaxIts iterations.
'                MaxIts=0 means no stopping criterion.
'
'NOTE
'
'Passing EpsF=0, EpsX=0 and MaxIts=0 (simultaneously) will lead to automatic
'stopping criterion selection (according to the scheme used by MINLM unit).
'
'
'  -- ALGLIB --
'     Copyright 17.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub LSFitNonlinearSetCond(ByRef State As LSFitState, _
         ByVal EpsF As Double, _
         ByVal EpsX As Double, _
         ByVal MaxIts As Long)
    State.EpsF = EpsF
    State.EpsX = EpsX
    State.MaxIts = MaxIts
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function sets maximum step length
'
'INPUT PARAMETERS:
'    State   -   structure which stores algorithm state between calls and
'                which is used for reverse communication. Must be
'                initialized with LSFitNonLinearCreate???()
'    StpMax  -   maximum step length, >=0. Set StpMax to 0.0,  if you don't
'                want to limit step length.
'
'Use this subroutine when you optimize target function which contains exp()
'or  other  fast  growing  functions,  and optimization algorithm makes too
'large  steps  which  leads  to overflow. This function allows us to reject
'steps  that  are  too  large  (and  therefore  expose  us  to the possible
'overflow) without actually calculating function value at the x+stp*d.
'
'NOTE: non-zero StpMax leads to moderate  performance  degradation  because
'intermediate  step  of  preconditioned L-BFGS optimization is incompatible
'with limits on step size.
'
'  -- ALGLIB --
'     Copyright 02.04.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub LSFitNonlinearSetStpMax(ByRef State As LSFitState, _
         ByVal StpMax As Double)
    State.StpMax = StpMax
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Nonlinear least squares fitting. Algorithm iteration.
'
'Called after inialization of the State structure with  LSFitNonlinearXXX()
'subroutine. See HTML docs for examples.
'
'INPUT PARAMETERS:
'    State   -   structure which stores algorithm state between  subsequent
'                calls and which is used for reverse communication. Must be
'                initialized with LSFitNonlinearXXX() call first.
'
'RESULT
'1. If subroutine returned False, iterative algorithm has converged.
'2. If subroutine returned True, then if:
'* if State.NeedF=True,      function value F(X,C) is required
'* if State.NeedFG=True,     function value F(X,C) and gradient  dF/dC(X,C)
'                            are required
'* if State.NeedFGH=True     function value F(X,C), gradient dF/dC(X,C) and
'                            Hessian are required
'
'One and only one of this fields can be set at time.
'
'Function, its gradient and Hessian are calculated at  (X,C),  where  X  is
'stored in State.X[0..M-1] and C is stored in State.C[0..K-1].
'
'Results are stored:
'* function value            -   in State.F
'* gradient                  -   in State.G[0..K-1]
'* Hessian                   -   in State.H[0..K-1,0..K-1]
'
'  -- ALGLIB --
'     Copyright 17.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function LSFitNonlinearIteration(ByRef State As LSFitState) As Boolean
    Dim Result As Boolean
    Dim N As Long
    Dim M As Long
    Dim K As Long
    Dim i As Long
    Dim j As Long
    Dim V As Double
    Dim RelCnt As Double
    Dim i_ As Long
    
    '
    ' Reverse communication preparations
    ' I know it looks ugly, but it works the same way
    ' anywhere from C++ to Python.
    '
    ' This code initializes locals by:
    ' * random values determined during code
    '   generation - on first subroutine call
    ' * values from previous call - on subsequent calls
    '
    If State.RState.Stage >= 0# Then
        N = State.RState.IA(0#)
        M = State.RState.IA(1#)
        K = State.RState.IA(2#)
        i = State.RState.IA(3#)
        j = State.RState.IA(4#)
        V = State.RState.RA(0#)
        RelCnt = State.RState.RA(1#)
    Else
        N = -983#
        M = -989#
        K = -834#
        i = 900#
        j = -287#
        V = 364#
        RelCnt = 214#
    End If
    If State.RState.Stage = 0# Then
        GoTo lbl_0
    End If
    If State.RState.Stage = 1# Then
        GoTo lbl_1
    End If
    If State.RState.Stage = 2# Then
        GoTo lbl_2
    End If
    If State.RState.Stage = 3# Then
        GoTo lbl_3
    End If
    If State.RState.Stage = 4# Then
        GoTo lbl_4
    End If
    
    '
    ' Routine body
    '
    
    '
    ' check params
    '
    If State.N < 1# Or State.M < 1# Or State.K < 1# Or State.EpsF < 0# Or State.EpsX < 0# Or State.MaxIts < 0# Then
        State.RepTerminationType = -1#
        Result = False
        LSFitNonlinearIteration = Result
        Exit Function
    End If
    
    '
    ' init
    '
    N = State.N
    M = State.M
    K = State.K
    ReDim State.x(0 To M - 1)
    ReDim State.g(0 To K - 1)
    If State.HaveHess Then
        ReDim State.h(0 To K - 1, 0 To K - 1)
    End If
    
    '
    ' initialize LM optimizer
    '
    If State.HaveHess Then
        
        '
        ' use Hessian.
        ' transform stopping conditions.
        '
        Call MinLMCreateFGH(K, State.C, State.OptState)
    Else
        
        '
        ' use one of gradient-based schemes (depending on gradient cost).
        ' transform stopping conditions.
        '
        If State.CheapFG Then
            Call MinLMCreateFGJ(K, N, State.C, State.OptState)
        Else
            Call MinLMCreateFJ(K, N, State.C, State.OptState)
        End If
    End If
    Call MinLMSetCond(State.OptState, 0#, State.EpsF, State.EpsX, State.MaxIts)
    Call MinLMSetStpMax(State.OptState, State.StpMax)
    
    '
    ' Optimize
    '
lbl_5:
    If Not MinLMIteration(State.OptState) Then
        GoTo lbl_6
    End If
    If Not State.OptState.NeedF Then
        GoTo lbl_7
    End If
    
    '
    ' calculate F = sum (wi*(f(xi,c)-yi))^2
    '
    State.OptState.f = 0#
    i = 0#
lbl_9:
    If i > N - 1# Then
        GoTo lbl_11
    End If
    For i_ = 0# To K - 1# Step 1
        State.C(i_) = State.OptState.x(i_)
    Next i_
    For i_ = 0# To M - 1# Step 1
        State.x(i_) = State.TaskX(i, i_)
    Next i_
    State.PointIndex = i
    Call LSFitClearRequestFields(State)
    State.NeedF = True
    State.RState.Stage = 0#
    GoTo lbl_rcomm
lbl_0:
    State.OptState.f = State.OptState.f + Square(State.w(i) * (State.f - State.TaskY(i)))
    i = i + 1#
    GoTo lbl_9
lbl_11:
    GoTo lbl_5
lbl_7:
    If Not State.OptState.NeedFG Then
        GoTo lbl_12
    End If
    
    '
    ' calculate F/gradF
    '
    State.OptState.f = 0#
    For i = 0# To K - 1# Step 1
        State.OptState.g(i) = 0#
    Next i
    i = 0#
lbl_14:
    If i > N - 1# Then
        GoTo lbl_16
    End If
    For i_ = 0# To K - 1# Step 1
        State.C(i_) = State.OptState.x(i_)
    Next i_
    For i_ = 0# To M - 1# Step 1
        State.x(i_) = State.TaskX(i, i_)
    Next i_
    State.PointIndex = i
    Call LSFitClearRequestFields(State)
    State.NeedFG = True
    State.RState.Stage = 1#
    GoTo lbl_rcomm
lbl_1:
    State.OptState.f = State.OptState.f + Square(State.w(i) * (State.f - State.TaskY(i)))
    V = Square(State.w(i)) * 2# * (State.f - State.TaskY(i))
    For i_ = 0# To K - 1# Step 1
        State.OptState.g(i_) = State.OptState.g(i_) + V * State.g(i_)
    Next i_
    i = i + 1#
    GoTo lbl_14
lbl_16:
    GoTo lbl_5
lbl_12:
    If Not State.OptState.NeedFiJ Then
        GoTo lbl_17
    End If
    
    '
    ' calculate Fi/jac(Fi)
    '
    i = 0#
lbl_19:
    If i > N - 1# Then
        GoTo lbl_21
    End If
    For i_ = 0# To K - 1# Step 1
        State.C(i_) = State.OptState.x(i_)
    Next i_
    For i_ = 0# To M - 1# Step 1
        State.x(i_) = State.TaskX(i, i_)
    Next i_
    State.PointIndex = i
    Call LSFitClearRequestFields(State)
    State.NeedFG = True
    State.RState.Stage = 2#
    GoTo lbl_rcomm
lbl_2:
    State.OptState.fi(i) = State.w(i) * (State.f - State.TaskY(i))
    V = State.w(i)
    For i_ = 0# To K - 1# Step 1
        State.OptState.j(i, i_) = V * State.g(i_)
    Next i_
    i = i + 1#
    GoTo lbl_19
lbl_21:
    GoTo lbl_5
lbl_17:
    If Not State.OptState.NeedFGH Then
        GoTo lbl_22
    End If
    
    '
    ' calculate F/grad(F)/hess(F)
    '
    State.OptState.f = 0#
    For i = 0# To K - 1# Step 1
        State.OptState.g(i) = 0#
    Next i
    For i = 0# To K - 1# Step 1
        For j = 0# To K - 1# Step 1
            State.OptState.h(i, j) = 0#
        Next j
    Next i
    i = 0#
lbl_24:
    If i > N - 1# Then
        GoTo lbl_26
    End If
    For i_ = 0# To K - 1# Step 1
        State.C(i_) = State.OptState.x(i_)
    Next i_
    For i_ = 0# To M - 1# Step 1
        State.x(i_) = State.TaskX(i, i_)
    Next i_
    State.PointIndex = i
    Call LSFitClearRequestFields(State)
    State.NeedFGH = True
    State.RState.Stage = 3#
    GoTo lbl_rcomm
lbl_3:
    State.OptState.f = State.OptState.f + Square(State.w(i) * (State.f - State.TaskY(i)))
    V = Square(State.w(i)) * 2# * (State.f - State.TaskY(i))
    For i_ = 0# To K - 1# Step 1
        State.OptState.g(i_) = State.OptState.g(i_) + V * State.g(i_)
    Next i_
    For j = 0# To K - 1# Step 1
        V = 2# * Square(State.w(i)) * State.g(j)
        For i_ = 0# To K - 1# Step 1
            State.OptState.h(j, i_) = State.OptState.h(j, i_) + V * State.g(i_)
        Next i_
        V = 2# * Square(State.w(i)) * (State.f - State.TaskY(i))
        For i_ = 0# To K - 1# Step 1
            State.OptState.h(j, i_) = State.OptState.h(j, i_) + V * State.h(j, i_)
        Next i_
    Next j
    i = i + 1#
    GoTo lbl_24
lbl_26:
    GoTo lbl_5
lbl_22:
    GoTo lbl_5
lbl_6:
    Call MinLMResults(State.OptState, State.C, State.OptRep)
    State.RepTerminationType = State.OptRep.TerminationType
    
    '
    ' calculate errors
    '
    If State.RepTerminationType <= 0# Then
        GoTo lbl_27
    End If
    State.RepRMSError = 0#
    State.RepAvgError = 0#
    State.RepAvgRelError = 0#
    State.RepMaxError = 0#
    RelCnt = 0#
    i = 0#
lbl_29:
    If i > N - 1# Then
        GoTo lbl_31
    End If
    For i_ = 0# To K - 1# Step 1
        State.C(i_) = State.C(i_)
    Next i_
    For i_ = 0# To M - 1# Step 1
        State.x(i_) = State.TaskX(i, i_)
    Next i_
    State.PointIndex = i
    Call LSFitClearRequestFields(State)
    State.NeedF = True
    State.RState.Stage = 4#
    GoTo lbl_rcomm
lbl_4:
    V = State.f
    State.RepRMSError = State.RepRMSError + Square(V - State.TaskY(i))
    State.RepAvgError = State.RepAvgError + Abs(V - State.TaskY(i))
    If State.TaskY(i) <> 0# Then
        State.RepAvgRelError = State.RepAvgRelError + Abs(V - State.TaskY(i)) / Abs(State.TaskY(i))
        RelCnt = RelCnt + 1#
    End If
    State.RepMaxError = MaxReal(State.RepMaxError, Abs(V - State.TaskY(i)))
    i = i + 1#
    GoTo lbl_29
lbl_31:
    State.RepRMSError = Sqr(State.RepRMSError / N)
    State.RepAvgError = State.RepAvgError / N
    If RelCnt <> 0# Then
        State.RepAvgRelError = State.RepAvgRelError / RelCnt
    End If
lbl_27:
    Result = False
    LSFitNonlinearIteration = Result
    Exit Function
    
    '
    ' Saving state
    '
lbl_rcomm:
    Result = True
    State.RState.IA(0#) = N
    State.RState.IA(1#) = M
    State.RState.IA(2#) = K
    State.RState.IA(3#) = i
    State.RState.IA(4#) = j
    State.RState.RA(0#) = V
    State.RState.RA(1#) = RelCnt
    LSFitNonlinearIteration = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Nonlinear least squares fitting results.
'
'Called after LSFitNonlinearIteration() returned False.
'
'INPUT PARAMETERS:
'    State   -   algorithm state (used by LSFitNonlinearIteration).
'
'OUTPUT PARAMETERS:
'    Info    -   completetion code:
'                    * -1    incorrect parameters were specified
'                    *  1    relative function improvement is no more than
'                            EpsF.
'                    *  2    relative step is no more than EpsX.
'                    *  4    gradient norm is no more than EpsG
'                    *  5    MaxIts steps was taken
'    C       -   array[0..K-1], solution
'    Rep     -   optimization report. Following fields are set:
'                * Rep.TerminationType completetion code:
'                * RMSError          rms error on the (X,Y).
'                * AvgError          average error on the (X,Y).
'                * AvgRelError       average relative error on the non-zero Y
'                * MaxError          maximum error
'                                    NON-WEIGHTED ERRORS ARE CALCULATED
'
'
'  -- ALGLIB --
'     Copyright 17.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub LSFitNonlinearResults(ByRef State As LSFitState, _
         ByRef Info As Long, _
         ByRef C() As Double, _
         ByRef Rep As LSFitReport)
    Dim i_ As Long
    Info = State.RepTerminationType
    If Info > 0# Then
        ReDim C(0 To State.K - 1)
        For i_ = 0# To State.K - 1# Step 1
            C(i_) = State.C(i_)
        Next i_
        Rep.RMSError = State.RepRMSError
        Rep.AvgError = State.RepAvgError
        Rep.AvgRelError = State.RepAvgRelError
        Rep.MaxError = State.RepMaxError
    End If
End Sub
Public Sub LSFitScaleXY(ByRef x() As Double, _
         ByRef y() As Double, _
         ByVal N As Long, _
         ByRef XC() As Double, _
         ByRef YC() As Double, _
         ByRef DC() As Long, _
         ByVal K As Long, _
         ByRef XA As Double, _
         ByRef XB As Double, _
         ByRef SA As Double, _
         ByRef SB As Double, _
         ByRef XOriginal() As Double, _
         ByRef YOriginal() As Double)
    Dim XMin As Double
    Dim XMAX As Double
    Dim i As Long
    Dim i_ As Long
    
    '
    ' Calculate xmin/xmax.
    ' Force xmin<>xmax.
    '
    XMin = x(0#)
    XMAX = x(0#)
    For i = 1# To N - 1# Step 1
        XMin = MinReal(XMin, x(i))
        XMAX = MaxReal(XMAX, x(i))
    Next i
    For i = 0# To K - 1# Step 1
        XMin = MinReal(XMin, XC(i))
        XMAX = MaxReal(XMAX, XC(i))
    Next i
    If XMin = XMAX Then
        If XMin = 0# Then
            XMin = -1#
            XMAX = 1#
        Else
            XMin = 0.5 * XMin
        End If
    End If
    
    '
    ' Transform abscissas: map [XA,XB] to [0,1]
    '
    ' Store old X[] in XOriginal[] (it will be used
    ' to calculate relative error).
    '
    ReDim XOriginal(0 To N - 1)
    For i_ = 0# To N - 1# Step 1
        XOriginal(i_) = x(i_)
    Next i_
    XA = XMin
    XB = XMAX
    For i = 0# To N - 1# Step 1
        x(i) = 2# * (x(i) - 0.5 * (XA + XB)) / (XB - XA)
    Next i
    For i = 0# To K - 1# Step 1
        XC(i) = 2# * (XC(i) - 0.5 * (XA + XB)) / (XB - XA)
        YC(i) = YC(i) * Power(0.5 * (XB - XA), DC(i))
    Next i
    
    '
    ' Transform function values: map [SA,SB] to [0,1]
    ' SA = mean(Y),
    ' SB = SA+stddev(Y).
    '
    ' Store old Y[] in YOriginal[] (it will be used
    ' to calculate relative error).
    '
    ReDim YOriginal(0 To N - 1)
    For i_ = 0# To N - 1# Step 1
        YOriginal(i_) = y(i_)
    Next i_
    SA = 0#
    For i = 0# To N - 1# Step 1
        SA = SA + y(i)
    Next i
    SA = SA / N
    SB = 0#
    For i = 0# To N - 1# Step 1
        SB = SB + Square(y(i) - SA)
    Next i
    SB = Sqr(SB / N) + SA
    If SB = SA Then
        SB = 2# * SA
    End If
    If SB = SA Then
        SB = SA + 1#
    End If
    For i = 0# To N - 1# Step 1
        y(i) = (y(i) - SA) / (SB - SA)
    Next i
    For i = 0# To K - 1# Step 1
        If DC(i) = 0# Then
            YC(i) = (YC(i) - SA) / (SB - SA)
        Else
            YC(i) = YC(i) / (SB - SA)
        End If
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal fitting subroutine
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub LSFitLinearInternal(ByRef y() As Double, _
         ByRef w() As Double, _
         ByRef FMatrix() As Double, _
         ByVal N As Long, _
         ByVal M As Long, _
         ByRef Info As Long, _
         ByRef C() As Double, _
         ByRef Rep As LSFitReport)
    Dim Threshold As Double
    Dim FT() As Double
    Dim q() As Double
    Dim L() As Double
    Dim R() As Double
    Dim B() As Double
    Dim WMod() As Double
    Dim Tau() As Double
    Dim i As Long
    Dim j As Long
    Dim V As Double
    Dim SV() As Double
    Dim U() As Double
    Dim VT() As Double
    Dim tmp() As Double
    Dim UTB() As Double
    Dim SUTB() As Double
    Dim RelCnt As Long
    Dim i_ As Long
    If N < 1# Or M < 1# Then
        Info = -1#
        Exit Sub
    End If
    Info = 1#
    Threshold = Sqr(MachineEpsilon)
    
    '
    ' Degenerate case, needs special handling
    '
    If N < M Then
        
        '
        ' Create design matrix.
        '
        ReDim FT(0 To N - 1, 0 To M - 1)
        ReDim B(0 To N - 1)
        ReDim WMod(0 To N - 1)
        For j = 0# To N - 1# Step 1
            V = w(j)
            For i_ = 0# To M - 1# Step 1
                FT(j, i_) = V * FMatrix(j, i_)
            Next i_
            B(j) = w(j) * y(j)
            WMod(j) = 1#
        Next j
        
        '
        ' LQ decomposition and reduction to M=N
        '
        ReDim C(0 To M - 1)
        For i = 0# To M - 1# Step 1
            C(i) = 0#
        Next i
        Rep.TaskRCond = 0#
        Call RMatrixLQ(FT, N, M, Tau)
        Call RMatrixLQUnpackQ(FT, N, M, Tau, N, q)
        Call RMatrixLQUnpackL(FT, N, M, L)
        Call LSFitLinearInternal(B, WMod, L, N, N, Info, tmp, Rep)
        If Info <= 0# Then
            Exit Sub
        End If
        For i = 0# To N - 1# Step 1
            V = tmp(i)
            For i_ = 0# To M - 1# Step 1
                C(i_) = C(i_) + V * q(i, i_)
            Next i_
        Next i
        Exit Sub
    End If
    
    '
    ' N>=M. Generate design matrix and reduce to N=M using
    ' QR decomposition.
    '
    ReDim FT(0 To N - 1, 0 To M - 1)
    ReDim B(0 To N - 1)
    For j = 0# To N - 1# Step 1
        V = w(j)
        For i_ = 0# To M - 1# Step 1
            FT(j, i_) = V * FMatrix(j, i_)
        Next i_
        B(j) = w(j) * y(j)
    Next j
    Call RMatrixQR(FT, N, M, Tau)
    Call RMatrixQRUnpackQ(FT, N, M, Tau, M, q)
    Call RMatrixQRUnpackR(FT, N, M, R)
    ReDim tmp(0 To M - 1)
    For i = 0# To M - 1# Step 1
        tmp(i) = 0#
    Next i
    For i = 0# To N - 1# Step 1
        V = B(i)
        For i_ = 0# To M - 1# Step 1
            tmp(i_) = tmp(i_) + V * q(i, i_)
        Next i_
    Next i
    ReDim B(0 To M - 1)
    For i_ = 0# To M - 1# Step 1
        B(i_) = tmp(i_)
    Next i_
    
    '
    ' R contains reduced MxM design upper triangular matrix,
    ' B contains reduced Mx1 right part.
    '
    ' Determine system condition number and decide
    ' should we use triangular solver (faster) or
    ' SVD-based solver (more stable).
    '
    ' We can use LU-based RCond estimator for this task.
    '
    Rep.TaskRCond = RMatrixLURCondInf(R, M)
    If Rep.TaskRCond > Threshold Then
        
        '
        ' use QR-based solver
        '
        ReDim C(0 To M - 1)
        C(M - 1#) = B(M - 1#) / R(M - 1#, M - 1#)
        For i = M - 2# To 0# Step -1
            V = 0#
            For i_ = i + 1# To M - 1# Step 1
                V = V + R(i, i_) * C(i_)
            Next i_
            C(i) = (B(i) - V) / R(i, i)
        Next i
    Else
        
        '
        ' use SVD-based solver
        '
        If Not RMatrixSVD(R, M, M, 1#, 1#, 2#, SV, U, VT) Then
            Info = -4#
            Exit Sub
        End If
        ReDim UTB(0 To M - 1)
        ReDim SUTB(0 To M - 1)
        For i = 0# To M - 1# Step 1
            UTB(i) = 0#
        Next i
        For i = 0# To M - 1# Step 1
            V = B(i)
            For i_ = 0# To M - 1# Step 1
                UTB(i_) = UTB(i_) + V * U(i, i_)
            Next i_
        Next i
        If SV(0#) > 0# Then
            Rep.TaskRCond = SV(M - 1#) / SV(0#)
            For i = 0# To M - 1# Step 1
                If SV(i) > Threshold * SV(0#) Then
                    SUTB(i) = UTB(i) / SV(i)
                Else
                    SUTB(i) = 0#
                End If
            Next i
        Else
            Rep.TaskRCond = 0#
            For i = 0# To M - 1# Step 1
                SUTB(i) = 0#
            Next i
        End If
        ReDim C(0 To M - 1)
        For i = 0# To M - 1# Step 1
            C(i) = 0#
        Next i
        For i = 0# To M - 1# Step 1
            V = SUTB(i)
            For i_ = 0# To M - 1# Step 1
                C(i_) = C(i_) + V * VT(i, i_)
            Next i_
        Next i
    End If
    
    '
    ' calculate errors
    '
    Rep.RMSError = 0#
    Rep.AvgError = 0#
    Rep.AvgRelError = 0#
    Rep.MaxError = 0#
    RelCnt = 0#
    For i = 0# To N - 1# Step 1
        V = 0#
        For i_ = 0# To M - 1# Step 1
            V = V + FMatrix(i, i_) * C(i_)
        Next i_
        Rep.RMSError = Rep.RMSError + Square(V - y(i))
        Rep.AvgError = Rep.AvgError + Abs(V - y(i))
        If y(i) <> 0# Then
            Rep.AvgRelError = Rep.AvgRelError + Abs(V - y(i)) / Abs(y(i))
            RelCnt = RelCnt + 1#
        End If
        Rep.MaxError = MaxReal(Rep.MaxError, Abs(V - y(i)))
    Next i
    Rep.RMSError = Sqr(Rep.RMSError / N)
    Rep.AvgError = Rep.AvgError / N
    If RelCnt <> 0# Then
        Rep.AvgRelError = Rep.AvgRelError / RelCnt
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal subroutine
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub LSFitClearRequestFields(ByRef State As LSFitState)
    State.NeedF = False
    State.NeedFG = False
    State.NeedFGH = False
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2006-2009, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Lagrange intepolant: generation of the model on the general grid.
'This function has O(N^2) complexity.
'
'INPUT PARAMETERS:
'    X   -   abscissas, array[0..N-1]
'    Y   -   function values, array[0..N-1]
'    N   -   number of points, N>=1
'
'OIYTPUT PARAMETERS
'    P   -   barycentric model which represents Lagrange interpolant
'            (see ratint unit info and BarycentricCalc() description for
'            more information).
'
'  -- ALGLIB --
'     Copyright 02.12.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub PolynomialBuild(ByRef x() As Double, _
         ByRef y() As Double, _
         ByVal N As Long, _
         ByRef p As BarycentricInterpolant)
    Dim j As Long
    Dim K As Long
    Dim w() As Double
    Dim B As Double
    Dim a As Double
    Dim V As Double
    Dim MX As Double
    Dim i_ As Long
    
    '
    ' calculate W[j]
    ' multi-pass algorithm is used to avoid overflow
    '
    ReDim w(0 To N - 1)
    a = x(0#)
    B = x(0#)
    For j = 0# To N - 1# Step 1
        w(j) = 1#
        a = MinReal(a, x(j))
        B = MaxReal(B, x(j))
    Next j
    For K = 0# To N - 1# Step 1
        
        '
        ' W[K] is used instead of 0.0 because
        ' cycle on J does not touch K-th element
        ' and we MUST get maximum from ALL elements
        '
        MX = Abs(w(K))
        For j = 0# To N - 1# Step 1
            If j <> K Then
                V = (B - a) / (x(j) - x(K))
                w(j) = w(j) * V
                MX = MaxReal(MX, Abs(w(j)))
            End If
        Next j
        If K Mod 5# = 0# Then
            
            '
            ' every 5-th run we renormalize W[]
            '
            V = 1# / MX
            For i_ = 0# To N - 1# Step 1
                w(i_) = V * w(i_)
            Next i_
        End If
    Next K
    Call BarycentricBuildXYW(x, y, w, N, p)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Lagrange intepolant: generation of the model on equidistant grid.
'This function has O(N) complexity.
'
'INPUT PARAMETERS:
'    A   -   left boundary of [A,B]
'    B   -   right boundary of [A,B]
'    Y   -   function values at the nodes, array[0..N-1]
'    N   -   number of points, N>=1
'            for N=1 a constant model is constructed.
'
'OIYTPUT PARAMETERS
'    P   -   barycentric model which represents Lagrange interpolant
'            (see ratint unit info and BarycentricCalc() description for
'            more information).
'
'  -- ALGLIB --
'     Copyright 03.12.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub PolynomialBuildEqDist(ByVal a As Double, _
         ByVal B As Double, _
         ByRef y() As Double, _
         ByVal N As Long, _
         ByRef p As BarycentricInterpolant)
    Dim i As Long
    Dim w() As Double
    Dim x() As Double
    Dim V As Double
    
    '
    ' Special case: N=1
    '
    If N = 1# Then
        ReDim x(0 To 1# - 1)
        ReDim w(0 To 1# - 1)
        x(0#) = 0.5 * (B + a)
        w(0#) = 1#
        Call BarycentricBuildXYW(x, y, w, 1#, p)
        Exit Sub
    End If
    
    '
    ' general case
    '
    ReDim x(0 To N - 1)
    ReDim w(0 To N - 1)
    V = 1#
    For i = 0# To N - 1# Step 1
        w(i) = V
        x(i) = a + (B - a) * i / (N - 1#)
        V = -(V * (N - 1# - i))
        V = V / (i + 1#)
    Next i
    Call BarycentricBuildXYW(x, y, w, N, p)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Lagrange intepolant on Chebyshev grid (first kind).
'This function has O(N) complexity.
'
'INPUT PARAMETERS:
'    A   -   left boundary of [A,B]
'    B   -   right boundary of [A,B]
'    Y   -   function values at the nodes, array[0..N-1],
'            Y[I] = Y(0.5*(B+A) + 0.5*(B-A)*Cos(PI*(2*i+1)/(2*n)))
'    N   -   number of points, N>=1
'            for N=1 a constant model is constructed.
'
'OIYTPUT PARAMETERS
'    P   -   barycentric model which represents Lagrange interpolant
'            (see ratint unit info and BarycentricCalc() description for
'            more information).
'
'  -- ALGLIB --
'     Copyright 03.12.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub PolynomialBuildCheb1(ByVal a As Double, _
         ByVal B As Double, _
         ByRef y() As Double, _
         ByVal N As Long, _
         ByRef p As BarycentricInterpolant)
    Dim i As Long
    Dim w() As Double
    Dim x() As Double
    Dim V As Double
    Dim t As Double
    
    '
    ' Special case: N=1
    '
    If N = 1# Then
        ReDim x(0 To 1# - 1)
        ReDim w(0 To 1# - 1)
        x(0#) = 0.5 * (B + a)
        w(0#) = 1#
        Call BarycentricBuildXYW(x, y, w, 1#, p)
        Exit Sub
    End If
    
    '
    ' general case
    '
    ReDim x(0 To N - 1)
    ReDim w(0 To N - 1)
    V = 1#
    For i = 0# To N - 1# Step 1
        t = Tan(0.5 * pi() * (2# * i + 1#) / (2# * N))
        w(i) = 2# * V * t / (1# + Square(t))
        x(i) = 0.5 * (B + a) + 0.5 * (B - a) * (1# - Square(t)) / (1# + Square(t))
        V = -V
    Next i
    Call BarycentricBuildXYW(x, y, w, N, p)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Lagrange intepolant on Chebyshev grid (second kind).
'This function has O(N) complexity.
'
'INPUT PARAMETERS:
'    A   -   left boundary of [A,B]
'    B   -   right boundary of [A,B]
'    Y   -   function values at the nodes, array[0..N-1],
'            Y[I] = Y(0.5*(B+A) + 0.5*(B-A)*Cos(PI*i/(n-1)))
'    N   -   number of points, N>=1
'            for N=1 a constant model is constructed.
'
'OIYTPUT PARAMETERS
'    P   -   barycentric model which represents Lagrange interpolant
'            (see ratint unit info and BarycentricCalc() description for
'            more information).
'
'  -- ALGLIB --
'     Copyright 03.12.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub PolynomialBuildCheb2(ByVal a As Double, _
         ByVal B As Double, _
         ByRef y() As Double, _
         ByVal N As Long, _
         ByRef p As BarycentricInterpolant)
    Dim i As Long
    Dim w() As Double
    Dim x() As Double
    Dim V As Double
    
    '
    ' Special case: N=1
    '
    If N = 1# Then
        ReDim x(0 To 1# - 1)
        ReDim w(0 To 1# - 1)
        x(0#) = 0.5 * (B + a)
        w(0#) = 1#
        Call BarycentricBuildXYW(x, y, w, 1#, p)
        Exit Sub
    End If
    
    '
    ' general case
    '
    ReDim x(0 To N - 1)
    ReDim w(0 To N - 1)
    V = 1#
    For i = 0# To N - 1# Step 1
        If i = 0# Or i = N - 1# Then
            w(i) = V * 0.5
        Else
            w(i) = V
        End If
        x(i) = 0.5 * (B + a) + 0.5 * (B - a) * Cos(pi() * i / (N - 1#))
        V = -V
    Next i
    Call BarycentricBuildXYW(x, y, w, N, p)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Fast equidistant polynomial interpolation function with O(N) complexity
'
'INPUT PARAMETERS:
'    A   -   left boundary of [A,B]
'    B   -   right boundary of [A,B]
'    F   -   function values, array[0..N-1]
'    N   -   number of points on equidistant grid, N>=1
'            for N=1 a constant model is constructed.
'    T   -   position where P(x) is calculated
'
'RESULT
'    value of the Lagrange interpolant at T
'
'IMPORTANT
'    this function provides fast interface which is not overflow-safe
'    nor it is very precise.
'    the best option is to use  PolynomialBuildEqDist()/BarycentricCalc()
'    subroutines unless you are pretty sure that your data will not result
'    in overflow.
'
'  -- ALGLIB --
'     Copyright 02.12.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function PolynomialCalcEqDist(ByVal a As Double, _
         ByVal B As Double, _
         ByRef f() As Double, _
         ByVal N As Long, _
         ByVal t As Double) As Double
    Dim Result As Double
    Dim S1 As Double
    Dim S2 As Double
    Dim V As Double
    Dim Threshold As Double
    Dim s As Double
    Dim h As Double
    Dim i As Long
    Dim j As Long
    Dim w As Double
    Dim x As Double
    Threshold = Sqr(MinRealNumber)
    
    '
    ' Special case: N=1
    '
    If N = 1# Then
        Result = f(0#)
        PolynomialCalcEqDist = Result
        Exit Function
    End If
    
    '
    ' First, decide: should we use "safe" formula (guarded
    ' against overflow) or fast one?
    '
    j = 0#
    s = t - a
    For i = 1# To N - 1# Step 1
        x = a + i / (N - 1#) * (B - a)
        If Abs(t - x) < Abs(s) Then
            s = t - x
            j = i
        End If
    Next i
    If s = 0# Then
        Result = f(j)
        PolynomialCalcEqDist = Result
        Exit Function
    End If
    If Abs(s) > Threshold Then
        
        '
        ' use fast formula
        '
        j = -1#
        s = 1#
    End If
    
    '
    ' Calculate using safe or fast barycentric formula
    '
    S1 = 0#
    S2 = 0#
    w = 1#
    h = (B - a) / (N - 1#)
    For i = 0# To N - 1# Step 1
        If i <> j Then
            V = s * w / (t - (a + i * h))
            S1 = S1 + V * f(i)
            S2 = S2 + V
        Else
            V = w
            S1 = S1 + V * f(i)
            S2 = S2 + V
        End If
        w = -(w * (N - 1# - i))
        w = w / (i + 1#)
    Next i
    Result = S1 / S2
    PolynomialCalcEqDist = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Fast polynomial interpolation function on Chebyshev points (first kind)
'with O(N) complexity.
'
'INPUT PARAMETERS:
'    A   -   left boundary of [A,B]
'    B   -   right boundary of [A,B]
'    F   -   function values, array[0..N-1]
'    N   -   number of points on Chebyshev grid (first kind),
'            X[i] = 0.5*(B+A) + 0.5*(B-A)*Cos(PI*(2*i+1)/(2*n))
'            for N=1 a constant model is constructed.
'    T   -   position where P(x) is calculated
'
'RESULT
'    value of the Lagrange interpolant at T
'
'IMPORTANT
'    this function provides fast interface which is not overflow-safe
'    nor it is very precise.
'    the best option is to use  PolIntBuildCheb1()/BarycentricCalc()
'    subroutines unless you are pretty sure that your data will not result
'    in overflow.
'
'  -- ALGLIB --
'     Copyright 02.12.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function PolynomialCalcCheb1(ByVal a As Double, _
         ByVal B As Double, _
         ByRef f() As Double, _
         ByVal N As Long, _
         ByVal t As Double) As Double
    Dim Result As Double
    Dim S1 As Double
    Dim S2 As Double
    Dim V As Double
    Dim Threshold As Double
    Dim s As Double
    Dim i As Long
    Dim j As Long
    Dim a0 As Double
    Dim Delta As Double
    Dim alpha As Double
    Dim beta As Double
    Dim CA As Double
    Dim SA As Double
    Dim TempC As Double
    Dim TempS As Double
    Dim x As Double
    Dim w As Double
    Dim p1 As Double
    Threshold = Sqr(MinRealNumber)
    t = (t - 0.5 * (a + B)) / (0.5 * (B - a))
    
    '
    ' Fast exit
    '
    If N = 1# Then
        Result = f(0#)
        PolynomialCalcCheb1 = Result
        Exit Function
    End If
    
    '
    ' Prepare information for the recurrence formula
    ' used to calculate sin(pi*(2j+1)/(2n+2)) and
    ' cos(pi*(2j+1)/(2n+2)):
    '
    ' A0    = pi/(2n+2)
    ' Delta = pi/(n+1)
    ' Alpha = 2 sin^2 (Delta/2)
    ' Beta  = sin(Delta)
    '
    ' so that sin(..) = sin(A0+j*delta) and cos(..) = cos(A0+j*delta).
    ' Then we use
    '
    ' sin(x+delta) = sin(x) - (alpha*sin(x) - beta*cos(x))
    ' cos(x+delta) = cos(x) - (alpha*cos(x) - beta*sin(x))
    '
    ' to repeatedly calculate sin(..) and cos(..).
    '
    a0 = pi() / (2# * (N - 1#) + 2#)
    Delta = 2# * pi() / (2# * (N - 1#) + 2#)
    alpha = 2# * Square(Sin(Delta / 2#))
    beta = Sin(Delta)
    
    '
    ' First, decide: should we use "safe" formula (guarded
    ' against overflow) or fast one?
    '
    CA = Cos(a0)
    SA = Sin(a0)
    j = 0#
    x = CA
    s = t - x
    For i = 1# To N - 1# Step 1
        
        '
        ' Next X[i]
        '
        TempS = SA - (alpha * SA - beta * CA)
        TempC = CA - (alpha * CA + beta * SA)
        SA = TempS
        CA = TempC
        x = CA
        
        '
        ' Use X[i]
        '
        If Abs(t - x) < Abs(s) Then
            s = t - x
            j = i
        End If
    Next i
    If s = 0# Then
        Result = f(j)
        PolynomialCalcCheb1 = Result
        Exit Function
    End If
    If Abs(s) > Threshold Then
        
        '
        ' use fast formula
        '
        j = -1#
        s = 1#
    End If
    
    '
    ' Calculate using safe or fast barycentric formula
    '
    S1 = 0#
    S2 = 0#
    CA = Cos(a0)
    SA = Sin(a0)
    p1 = 1#
    For i = 0# To N - 1# Step 1
        
        '
        ' Calculate X[i], W[i]
        '
        x = CA
        w = p1 * SA
        
        '
        ' Proceed
        '
        If i <> j Then
            V = s * w / (t - x)
            S1 = S1 + V * f(i)
            S2 = S2 + V
        Else
            V = w
            S1 = S1 + V * f(i)
            S2 = S2 + V
        End If
        
        '
        ' Next CA, SA, P1
        '
        TempS = SA - (alpha * SA - beta * CA)
        TempC = CA - (alpha * CA + beta * SA)
        SA = TempS
        CA = TempC
        p1 = -p1
    Next i
    Result = S1 / S2
    PolynomialCalcCheb1 = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Fast polynomial interpolation function on Chebyshev points (second kind)
'with O(N) complexity.
'
'INPUT PARAMETERS:
'    A   -   left boundary of [A,B]
'    B   -   right boundary of [A,B]
'    F   -   function values, array[0..N-1]
'    N   -   number of points on Chebyshev grid (second kind),
'            X[i] = 0.5*(B+A) + 0.5*(B-A)*Cos(PI*i/(n-1))
'            for N=1 a constant model is constructed.
'    T   -   position where P(x) is calculated
'
'RESULT
'    value of the Lagrange interpolant at T
'
'IMPORTANT
'    this function provides fast interface which is not overflow-safe
'    nor it is very precise.
'    the best option is to use PolIntBuildCheb2()/BarycentricCalc()
'    subroutines unless you are pretty sure that your data will not result
'    in overflow.
'
'  -- ALGLIB --
'     Copyright 02.12.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function PolynomialCalcCheb2(ByVal a As Double, _
         ByVal B As Double, _
         ByRef f() As Double, _
         ByVal N As Long, _
         ByVal t As Double) As Double
    Dim Result As Double
    Dim S1 As Double
    Dim S2 As Double
    Dim V As Double
    Dim Threshold As Double
    Dim s As Double
    Dim i As Long
    Dim j As Long
    Dim a0 As Double
    Dim Delta As Double
    Dim alpha As Double
    Dim beta As Double
    Dim CA As Double
    Dim SA As Double
    Dim TempC As Double
    Dim TempS As Double
    Dim x As Double
    Dim w As Double
    Dim p1 As Double
    Threshold = Sqr(MinRealNumber)
    t = (t - 0.5 * (a + B)) / (0.5 * (B - a))
    
    '
    ' Fast exit
    '
    If N = 1# Then
        Result = f(0#)
        PolynomialCalcCheb2 = Result
        Exit Function
    End If
    
    '
    ' Prepare information for the recurrence formula
    ' used to calculate sin(pi*i/n) and
    ' cos(pi*i/n):
    '
    ' A0    = 0
    ' Delta = pi/n
    ' Alpha = 2 sin^2 (Delta/2)
    ' Beta  = sin(Delta)
    '
    ' so that sin(..) = sin(A0+j*delta) and cos(..) = cos(A0+j*delta).
    ' Then we use
    '
    ' sin(x+delta) = sin(x) - (alpha*sin(x) - beta*cos(x))
    ' cos(x+delta) = cos(x) - (alpha*cos(x) - beta*sin(x))
    '
    ' to repeatedly calculate sin(..) and cos(..).
    '
    a0 = 0#
    Delta = pi() / (N - 1#)
    alpha = 2# * Square(Sin(Delta / 2#))
    beta = Sin(Delta)
    
    '
    ' First, decide: should we use "safe" formula (guarded
    ' against overflow) or fast one?
    '
    CA = Cos(a0)
    SA = Sin(a0)
    j = 0#
    x = CA
    s = t - x
    For i = 1# To N - 1# Step 1
        
        '
        ' Next X[i]
        '
        TempS = SA - (alpha * SA - beta * CA)
        TempC = CA - (alpha * CA + beta * SA)
        SA = TempS
        CA = TempC
        x = CA
        
        '
        ' Use X[i]
        '
        If Abs(t - x) < Abs(s) Then
            s = t - x
            j = i
        End If
    Next i
    If s = 0# Then
        Result = f(j)
        PolynomialCalcCheb2 = Result
        Exit Function
    End If
    If Abs(s) > Threshold Then
        
        '
        ' use fast formula
        '
        j = -1#
        s = 1#
    End If
    
    '
    ' Calculate using safe or fast barycentric formula
    '
    S1 = 0#
    S2 = 0#
    CA = Cos(a0)
    SA = Sin(a0)
    p1 = 1#
    For i = 0# To N - 1# Step 1
        
        '
        ' Calculate X[i], W[i]
        '
        x = CA
        If i = 0# Or i = N - 1# Then
            w = 0.5 * p1
        Else
            w = 1# * p1
        End If
        
        '
        ' Proceed
        '
        If i <> j Then
            V = s * w / (t - x)
            S1 = S1 + V * f(i)
            S2 = S2 + V
        Else
            V = w
            S1 = S1 + V * f(i)
            S2 = S2 + V
        End If
        
        '
        ' Next CA, SA, P1
        '
        TempS = SA - (alpha * SA - beta * CA)
        TempC = CA - (alpha * CA + beta * SA)
        SA = TempS
        CA = TempC
        p1 = -p1
    Next i
    Result = S1 / S2
    PolynomialCalcCheb2 = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Least squares fitting by polynomial.
'
'This subroutine is "lightweight" alternative for more complex and feature-
'rich PolynomialFitWC().  See  PolynomialFitWC() for more information about
'subroutine parameters (we don't duplicate it here because of length)
'
'  -- ALGLIB PROJECT --
'     Copyright 12.10.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub PolynomialFit(ByRef x() As Double, _
         ByRef y() As Double, _
         ByVal N As Long, _
         ByVal M As Long, _
         ByRef Info As Long, _
         ByRef p As BarycentricInterpolant, _
         ByRef Rep As PolynomialFitReport)
    Dim i As Long
    Dim w() As Double
    Dim XC() As Double
    Dim YC() As Double
    Dim DC() As Long
    If N > 0# Then
        ReDim w(0 To N - 1)
        For i = 0# To N - 1# Step 1
            w(i) = 1#
        Next i
    End If
    Call PolynomialFitWC(x, y, w, N, XC, YC, DC, 0#, M, Info, p, Rep)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Weighted  fitting  by  Chebyshev  polynomial  in  barycentric  form,  with
'constraints on function values or first derivatives.
'
'Small regularizing term is used when solving constrained tasks (to improve
'stability).
'
'Task is linear, so linear least squares solver is used. Complexity of this
'computational scheme is O(N*M^2), mostly dominated by least squares solver
'
'SEE ALSO:
'    PolynomialFit()
'
'INPUT PARAMETERS:
'    X   -   points, array[0..N-1].
'    Y   -   function values, array[0..N-1].
'    W   -   weights, array[0..N-1]
'            Each summand in square  sum  of  approximation deviations from
'            given  values  is  multiplied  by  the square of corresponding
'            weight. Fill it by 1's if you don't  want  to  solve  weighted
'            task.
'    N   -   number of points, N>0.
'    XC  -   points where polynomial values/derivatives are constrained,
'            array[0..K-1].
'    YC  -   values of constraints, array[0..K-1]
'    DC  -   array[0..K-1], types of constraints:
'            * DC[i]=0   means that P(XC[i])=YC[i]
'            * DC[i]=1   means that P'(XC[i])=YC[i]
'            SEE BELOW FOR IMPORTANT INFORMATION ON CONSTRAINTS
'    K   -   number of constraints, 0<=K<M.
'            K=0 means no constraints (XC/YC/DC are not used in such cases)
'    M   -   number of basis functions (= polynomial_degree + 1), M>=1
'
'OUTPUT PARAMETERS:
'    Info-   same format as in LSFitLinearW() subroutine:
'            * Info>0    task is solved
'            * Info<=0   an error occured:
'                        -4 means inconvergence of internal SVD
'                        -3 means inconsistent constraints
'                        -1 means another errors in parameters passed
'                           (N<=0, for example)
'    P   -   interpolant in barycentric form.
'    Rep -   report, same format as in LSFitLinearW() subroutine.
'            Following fields are set:
'            * RMSError      rms error on the (X,Y).
'            * AvgError      average error on the (X,Y).
'            * AvgRelError   average relative error on the non-zero Y
'            * MaxError      maximum error
'                            NON-WEIGHTED ERRORS ARE CALCULATED
'
'IMPORTANT:
'    this subroitine doesn't calculate task's condition number for K<>0.
'
'SETTING CONSTRAINTS - DANGERS AND OPPORTUNITIES:
'
'Setting constraints can lead  to undesired  results,  like ill-conditioned
'behavior, or inconsistency being detected. From the other side,  it allows
'us to improve quality of the fit. Here we summarize  our  experience  with
'constrained regression splines:
'* even simple constraints can be inconsistent, see  Wikipedia  article  on
'  this subject: http://en.wikipedia.org/wiki/Birkhoff_interpolation
'* the  greater  is  M (given  fixed  constraints),  the  more chances that
'  constraints will be consistent
'* in the general case, consistency of constraints is NOT GUARANTEED.
'* in the one special cases, however, we can  guarantee  consistency.  This
'  case  is:  M>1  and constraints on the function values (NOT DERIVATIVES)
'
'Our final recommendation is to use constraints  WHEN  AND  ONLY  when  you
'can't solve your task without them. Anything beyond  special  cases  given
'above is not guaranteed and may result in inconsistency.
'
'  -- ALGLIB PROJECT --
'     Copyright 10.12.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub PolynomialFitWC(ByRef x_() As Double, _
         ByRef y_() As Double, _
         ByRef w() As Double, _
         ByVal N As Long, _
         ByRef XC_() As Double, _
         ByRef YC_() As Double, _
         ByRef DC() As Long, _
         ByVal K As Long, _
         ByVal M As Long, _
         ByRef Info As Long, _
         ByRef p As BarycentricInterpolant, _
         ByRef Rep As PolynomialFitReport)
    Dim x() As Double
    Dim y() As Double
    Dim XC() As Double
    Dim YC() As Double
    Dim XA As Double
    Dim XB As Double
    Dim SA As Double
    Dim SB As Double
    Dim XOriginal() As Double
    Dim YOriginal() As Double
    Dim Y2() As Double
    Dim W2() As Double
    Dim tmp() As Double
    Dim Tmp2() As Double
    Dim TmpDiff() As Double
    Dim BX() As Double
    Dim BY() As Double
    Dim BW() As Double
    Dim FMatrix() As Double
    Dim CMatrix() As Double
    Dim i As Long
    Dim j As Long
    Dim MX As Double
    Dim Decay As Double
    Dim U As Double
    Dim V As Double
    Dim s As Double
    Dim RelCnt As Long
    Dim LRep As LSFitReport
    Dim i_ As Long
    x = x_
    y = y_
    XC = XC_
    YC = YC_
    If M < 1# Or N < 1# Or K < 0# Or K >= M Then
        Info = -1#
        Exit Sub
    End If
    For i = 0# To K - 1# Step 1
        Info = 0#
        If DC(i) < 0# Then
            Info = -1#
        End If
        If DC(i) > 1# Then
            Info = -1#
        End If
        If Info < 0# Then
            Exit Sub
        End If
    Next i
    
    '
    ' weight decay for correct handling of task which becomes
    ' degenerate after constraints are applied
    '
    Decay = 10000# * MachineEpsilon
    
    '
    ' Scale X, Y, XC, YC
    '
    Call LSFitScaleXY(x, y, N, XC, YC, DC, K, XA, XB, SA, SB, XOriginal, YOriginal)
    
    '
    ' allocate space, initialize/fill:
    ' * FMatrix-   values of basis functions at X[]
    ' * CMatrix-   values (derivatives) of basis functions at XC[]
    ' * fill constraints matrix
    ' * fill first N rows of design matrix with values
    ' * fill next M rows of design matrix with regularizing term
    ' * append M zeros to Y
    ' * append M elements, mean(abs(W)) each, to W
    '
    ReDim Y2(0 To N + M - 1)
    ReDim W2(0 To N + M - 1)
    ReDim tmp(0 To M - 1)
    ReDim TmpDiff(0 To M - 1)
    ReDim FMatrix(0 To N + M - 1, 0 To M - 1)
    If K > 0# Then
        ReDim CMatrix(0 To K - 1, 0 To M + 1# - 1)
    End If
    
    '
    ' Fill design matrix, Y2, W2:
    ' * first N rows with basis functions for original points
    ' * next M rows with decay terms
    '
    For i = 0# To N - 1# Step 1
        
        '
        ' prepare Ith row
        ' use Tmp for calculations to avoid multidimensional arrays overhead
        '
        For j = 0# To M - 1# Step 1
            If j = 0# Then
                tmp(j) = 1#
            Else
                If j = 1# Then
                    tmp(j) = x(i)
                Else
                    tmp(j) = 2# * x(i) * tmp(j - 1#) - tmp(j - 2#)
                End If
            End If
        Next j
        For i_ = 0# To M - 1# Step 1
            FMatrix(i, i_) = tmp(i_)
        Next i_
    Next i
    For i = 0# To M - 1# Step 1
        For j = 0# To M - 1# Step 1
            If i = j Then
                FMatrix(N + i, j) = Decay
            Else
                FMatrix(N + i, j) = 0#
            End If
        Next j
    Next i
    For i_ = 0# To N - 1# Step 1
        Y2(i_) = y(i_)
    Next i_
    For i_ = 0# To N - 1# Step 1
        W2(i_) = w(i_)
    Next i_
    MX = 0#
    For i = 0# To N - 1# Step 1
        MX = MX + Abs(w(i))
    Next i
    MX = MX / N
    For i = 0# To M - 1# Step 1
        Y2(N + i) = 0#
        W2(N + i) = MX
    Next i
    
    '
    ' fill constraints matrix
    '
    For i = 0# To K - 1# Step 1
        
        '
        ' prepare Ith row
        ' use Tmp for basis function values,
        ' TmpDiff for basos function derivatives
        '
        For j = 0# To M - 1# Step 1
            If j = 0# Then
                tmp(j) = 1#
                TmpDiff(j) = 0#
            Else
                If j = 1# Then
                    tmp(j) = XC(i)
                    TmpDiff(j) = 1#
                Else
                    tmp(j) = 2# * XC(i) * tmp(j - 1#) - tmp(j - 2#)
                    TmpDiff(j) = 2# * (tmp(j - 1#) + XC(i) * TmpDiff(j - 1#)) - TmpDiff(j - 2#)
                End If
            End If
        Next j
        If DC(i) = 0# Then
            For i_ = 0# To M - 1# Step 1
                CMatrix(i, i_) = tmp(i_)
            Next i_
        End If
        If DC(i) = 1# Then
            For i_ = 0# To M - 1# Step 1
                CMatrix(i, i_) = TmpDiff(i_)
            Next i_
        End If
        CMatrix(i, M) = YC(i)
    Next i
    
    '
    ' Solve constrained task
    '
    If K > 0# Then
        
        '
        ' solve using regularization
        '
        Call LSFitLinearWC(Y2, W2, FMatrix, CMatrix, N + M, M, K, Info, tmp, LRep)
    Else
        
        '
        ' no constraints, no regularization needed
        '
        Call LSFitLinearWC(y, w, FMatrix, CMatrix, N, M, 0#, Info, tmp, LRep)
    End If
    If Info < 0# Then
        Exit Sub
    End If
    
    '
    ' Generate barycentric model and scale it
    ' * BX, BY store barycentric model nodes
    ' * FMatrix is reused (remember - it is at least MxM, what we need)
    '
    ' Model intialization is done in O(M^2). In principle, it can be
    ' done in O(M*log(M)), but before it we solved task with O(N*M^2)
    ' complexity, so it is only a small amount of total time spent.
    '
    ReDim BX(0 To M - 1)
    ReDim BY(0 To M - 1)
    ReDim BW(0 To M - 1)
    ReDim Tmp2(0 To M - 1)
    s = 1#
    For i = 0# To M - 1# Step 1
        If M <> 1# Then
            U = Cos(pi() * i / (M - 1#))
        Else
            U = 0#
        End If
        V = 0#
        For j = 0# To M - 1# Step 1
            If j = 0# Then
                Tmp2(j) = 1#
            Else
                If j = 1# Then
                    Tmp2(j) = U
                Else
                    Tmp2(j) = 2# * U * Tmp2(j - 1#) - Tmp2(j - 2#)
                End If
            End If
            V = V + tmp(j) * Tmp2(j)
        Next j
        BX(i) = U
        BY(i) = V
        BW(i) = s
        If i = 0# Or i = M - 1# Then
            BW(i) = 0.5 * BW(i)
        End If
        s = -s
    Next i
    Call BarycentricBuildXYW(BX, BY, BW, M, p)
    Call BarycentricLinTransX(p, 2# / (XB - XA), -((XA + XB) / (XB - XA)))
    Call BarycentricLinTransY(p, SB - SA, SA)
    
    '
    ' Scale absolute errors obtained from LSFitLinearW.
    ' Relative error should be calculated separately
    ' (because of shifting/scaling of the task)
    '
    Rep.TaskRCond = LRep.TaskRCond
    Rep.RMSError = LRep.RMSError * (SB - SA)
    Rep.AvgError = LRep.AvgError * (SB - SA)
    Rep.MaxError = LRep.MaxError * (SB - SA)
    Rep.AvgRelError = 0#
    RelCnt = 0#
    For i = 0# To N - 1# Step 1
        If YOriginal(i) <> 0# Then
            Rep.AvgRelError = Rep.AvgRelError + Abs(BarycentricCalc(p, XOriginal(i)) - YOriginal(i)) / Abs(YOriginal(i))
            RelCnt = RelCnt + 1#
        End If
    Next i
    If RelCnt <> 0# Then
        Rep.AvgRelError = Rep.AvgRelError / RelCnt
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2007-2009, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Rational interpolation using barycentric formula
'
'F(t) = SUM(i=0,n-1,w[i]*f[i]/(t-x[i])) / SUM(i=0,n-1,w[i]/(t-x[i]))
'
'Input parameters:
'    B   -   barycentric interpolant built with one of model building
'            subroutines.
'    T   -   interpolation point
'
'Result:
'    barycentric interpolant F(t)
'
'  -- ALGLIB --
'     Copyright 17.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function BarycentricCalc(ByRef B As BarycentricInterpolant, _
         ByVal t As Double) As Double
    Dim Result As Double
    Dim S1 As Double
    Dim S2 As Double
    Dim s As Double
    Dim V As Double
    Dim i As Long
    '
    ' special case: N=1
    '
    If B.N = 1# Then
        Result = B.SY * B.y(0#)
        BarycentricCalc = Result
        Exit Function
    End If
    '
    ' Here we assume that task is normalized, i.e.:
    ' 1. abs(Y[i])<=1
    ' 2. abs(W[i])<=1
    ' 3. X[] is ordered
    '
    s = Abs(t - B.x(0#))
    For i = 0# To B.N - 1# Step 1
        V = B.x(i)
        If V = t Then
            Result = B.SY * B.y(i)
            BarycentricCalc = Result
            Exit Function
        End If
        V = Abs(t - V)
        If V < s Then
            s = V
        End If
    Next i
    S1 = 0#
    S2 = 0#
    For i = 0# To B.N - 1# Step 1
        V = s / (t - B.x(i))
        V = V * B.w(i)
        S1 = S1 + V * B.y(i)
        S2 = S2 + V
    Next i
    Result = B.SY * S1 / S2
    BarycentricCalc = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Differentiation of barycentric interpolant: first derivative.
'
'Algorithm used in this subroutine is very robust and should not fail until
'provided with values too close to MaxRealNumber  (usually  MaxRealNumber/N
'or greater will overflow).
'
'INPUT PARAMETERS:
'    B   -   barycentric interpolant built with one of model building
'            subroutines.
'    T   -   interpolation point
'
'OUTPUT PARAMETERS:
'    F   -   barycentric interpolant at T
'    DF  -   first derivative
'
'NOTE
'
'
'  -- ALGLIB --
'     Copyright 17.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub BarycentricDiff1(ByRef B As BarycentricInterpolant, _
         ByVal t As Double, _
         ByRef f As Double, _
         ByRef DF As Double)
    Dim V As Double
    Dim VV As Double
    Dim i As Long
    Dim K As Long
    Dim N0 As Double
    Dim N1 As Double
    Dim D0 As Double
    Dim d1 As Double
    Dim S0 As Double
    Dim S1 As Double
    Dim XK As Double
    Dim XI As Double
    Dim XMin As Double
    Dim XMAX As Double
    Dim XScale1 As Double
    Dim XOffs1 As Double
    Dim XScale2 As Double
    Dim XOffs2 As Double
    Dim XPrev As Double
    '
    ' special case: N=1
    '
    If B.N = 1# Then
        f = B.SY * B.y(0#)
        DF = 0#
        Exit Sub
    End If
    If B.SY = 0# Then
        f = 0#
        DF = 0#
        Exit Sub
    End If
    '
    ' We assume than N>1 and B.SY>0. Find:
    ' 1. pivot point (X[i] closest to T)
    ' 2. width of interval containing X[i]
    '
    V = Abs(B.x(0#) - t)
    K = 0#
    XMin = B.x(0#)
    XMAX = B.x(0#)
    For i = 1# To B.N - 1# Step 1
        VV = B.x(i)
        If Abs(VV - t) < V Then
            V = Abs(VV - t)
            K = i
        End If
        XMin = MinReal(XMin, VV)
        XMAX = MaxReal(XMAX, VV)
    Next i
    '
    ' pivot point found, calculate dNumerator and dDenominator
    '
    XScale1 = 1# / (XMAX - XMin)
    XOffs1 = -(XMin / (XMAX - XMin)) + 1#
    XScale2 = 2#
    XOffs2 = -3#
    t = t * XScale1 + XOffs1
    t = t * XScale2 + XOffs2
    XK = B.x(K)
    XK = XK * XScale1 + XOffs1
    XK = XK * XScale2 + XOffs2
    V = t - XK
    N0 = 0#
    N1 = 0#
    D0 = 0#
    d1 = 0#
    XPrev = -2#
    For i = 0# To B.N - 1# Step 1
        XI = B.x(i)
        XI = XI * XScale1 + XOffs1
        XI = XI * XScale2 + XOffs2
        XPrev = XI
        If i <> K Then
            VV = Square(t - XI)
            S0 = (t - XK) / (t - XI)
            S1 = (XK - XI) / VV
        Else
            S0 = 1#
            S1 = 0#
        End If
        VV = B.w(i) * B.y(i)
        N0 = N0 + S0 * VV
        N1 = N1 + S1 * VV
        VV = B.w(i)
        D0 = D0 + S0 * VV
        d1 = d1 + S1 * VV
    Next i
    f = B.SY * N0 / D0
    DF = (N1 * D0 - N0 * d1) / Square(D0)
    If DF <> 0# Then
        DF = Sgn(DF) * Exp(Log(Abs(DF)) + Log(B.SY) + Log(XScale1) + Log(XScale2))
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Differentiation of barycentric interpolant: first/second derivatives.
'
'INPUT PARAMETERS:
'    B   -   barycentric interpolant built with one of model building
'            subroutines.
'    T   -   interpolation point
'
'OUTPUT PARAMETERS:
'    F   -   barycentric interpolant at T
'    DF  -   first derivative
'    D2F -   second derivative
'
'NOTE: this algorithm may fail due to overflow/underflor if  used  on  data
'whose values are close to MaxRealNumber or MinRealNumber.  Use more robust
'BarycentricDiff1() subroutine in such cases.
'
'
'  -- ALGLIB --
'     Copyright 17.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub BarycentricDiff2(ByRef B As BarycentricInterpolant, _
         ByVal t As Double, _
         ByRef f As Double, _
         ByRef DF As Double, _
         ByRef D2F As Double)
    Dim V As Double
    Dim VV As Double
    Dim i As Long
    Dim K As Long
    Dim N0 As Double
    Dim N1 As Double
    Dim N2 As Double
    Dim D0 As Double
    Dim d1 As Double
    Dim D2 As Double
    Dim S0 As Double
    Dim S1 As Double
    Dim S2 As Double
    Dim XK As Double
    Dim XI As Double
    f = 0#
    DF = 0#
    D2F = 0#
    '
    ' special case: N=1
    '
    If B.N = 1# Then
        f = B.SY * B.y(0#)
        DF = 0#
        D2F = 0#
        Exit Sub
    End If
    If B.SY = 0# Then
        f = 0#
        DF = 0#
        D2F = 0#
        Exit Sub
    End If
    '
    ' We assume than N>1 and B.SY>0. Find:
    ' 1. pivot point (X[i] closest to T)
    ' 2. width of interval containing X[i]
    '
    V = Abs(B.x(0#) - t)
    K = 0#
    For i = 1# To B.N - 1# Step 1
        VV = B.x(i)
        If Abs(VV - t) < V Then
            V = Abs(VV - t)
            K = i
        End If
    Next i
    '
    ' pivot point found, calculate dNumerator and dDenominator
    '
    XK = B.x(K)
    V = t - XK
    N0 = 0#
    N1 = 0#
    N2 = 0#
    D0 = 0#
    d1 = 0#
    D2 = 0#
    For i = 0# To B.N - 1# Step 1
        If i <> K Then
            XI = B.x(i)
            VV = Square(t - XI)
            S0 = (t - XK) / (t - XI)
            S1 = (XK - XI) / VV
            S2 = -(2# * (XK - XI) / (VV * (t - XI)))
        Else
            S0 = 1#
            S1 = 0#
            S2 = 0#
        End If
        VV = B.w(i) * B.y(i)
        N0 = N0 + S0 * VV
        N1 = N1 + S1 * VV
        N2 = N2 + S2 * VV
        VV = B.w(i)
        D0 = D0 + S0 * VV
        d1 = d1 + S1 * VV
        D2 = D2 + S2 * VV
    Next i
    f = B.SY * N0 / D0
    DF = B.SY * (N1 * D0 - N0 * d1) / Square(D0)
    D2F = B.SY * ((N2 * D0 - N0 * D2) * Square(D0) - (N1 * D0 - N0 * d1) * 2# * D0 * d1) / Square(Square(D0))
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This subroutine performs linear transformation of the argument.
'
'INPUT PARAMETERS:
'    B       -   rational interpolant in barycentric form
'    CA, CB  -   transformation coefficients: x = CA*t + CB
'
'OUTPUT PARAMETERS:
'    B       -   transformed interpolant with X replaced by T
'
'  -- ALGLIB PROJECT --
'     Copyright 19.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub BarycentricLinTransX(ByRef B As BarycentricInterpolant, _
         ByVal CA As Double, _
         ByVal CB As Double)
    Dim i As Long
    Dim j As Long
    Dim V As Double
    '
    ' special case, replace by constant F(CB)
    '
    If CA = 0# Then
        B.SY = BarycentricCalc(B, CB)
        V = 1#
        For i = 0# To B.N - 1# Step 1
            B.y(i) = 1#
            B.w(i) = V
            V = -V
        Next i
        Exit Sub
    End If
    '
    ' general case: CA<>0
    '
    For i = 0# To B.N - 1# Step 1
        B.x(i) = (B.x(i) - CB) / CA
    Next i
    If CA < 0# Then
        For i = 0# To B.N - 1# Step 1
            If i < B.N - 1# - i Then
                j = B.N - 1# - i
                V = B.x(i)
                B.x(i) = B.x(j)
                B.x(j) = V
                V = B.y(i)
                B.y(i) = B.y(j)
                B.y(j) = V
                V = B.w(i)
                B.w(i) = B.w(j)
                B.w(j) = V
            Else
                Exit For
            End If
        Next i
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This  subroutine   performs   linear  transformation  of  the  barycentric
'interpolant.
'
'INPUT PARAMETERS:
'    B       -   rational interpolant in barycentric form
'    CA, CB  -   transformation coefficients: B2(x) = CA*B(x) + CB
'
'OUTPUT PARAMETERS:
'    B       -   transformed interpolant
'
'  -- ALGLIB PROJECT --
'     Copyright 19.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub BarycentricLinTransY(ByRef B As BarycentricInterpolant, _
         ByVal CA As Double, _
         ByVal CB As Double)
    Dim i As Long
    Dim V As Double
    Dim i_ As Long
    For i = 0# To B.N - 1# Step 1
        B.y(i) = CA * B.SY * B.y(i) + CB
    Next i
    B.SY = 0#
    For i = 0# To B.N - 1# Step 1
        B.SY = MaxReal(B.SY, Abs(B.y(i)))
    Next i
    If B.SY > 0# Then
        V = 1# / B.SY
        For i_ = 0# To B.N - 1# Step 1
            B.y(i_) = V * B.y(i_)
        Next i_
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Extracts X/Y/W arrays from rational interpolant
'
'INPUT PARAMETERS:
'    B   -   barycentric interpolant
'
'OUTPUT PARAMETERS:
'    N   -   nodes count, N>0
'    X   -   interpolation nodes, array[0..N-1]
'    F   -   function values, array[0..N-1]
'    W   -   barycentric weights, array[0..N-1]
'
'  -- ALGLIB --
'     Copyright 17.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub BarycentricUnpack(ByRef B As BarycentricInterpolant, _
         ByRef N As Long, _
         ByRef x() As Double, _
         ByRef y() As Double, _
         ByRef w() As Double)
    Dim V As Double
    Dim i_ As Long
    N = B.N
    ReDim x(0 To N - 1)
    ReDim y(0 To N - 1)
    ReDim w(0 To N - 1)
    V = B.SY
    For i_ = 0# To N - 1# Step 1
        x(i_) = B.x(i_)
    Next i_
    For i_ = 0# To N - 1# Step 1
        y(i_) = V * B.y(i_)
    Next i_
    For i_ = 0# To N - 1# Step 1
        w(i_) = B.w(i_)
    Next i_
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Serialization of the barycentric interpolant
'
'INPUT PARAMETERS:
'    B   -   barycentric interpolant
'
'OUTPUT PARAMETERS:
'    RA      -   array of real numbers which contains interpolant,
'                array[0..RLen-1]
'    RLen    -   RA lenght
'
'  -- ALGLIB --
'     Copyright 17.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub BarycentricSerialize(ByRef B As BarycentricInterpolant, _
         ByRef RA() As Double, _
         ByRef RALen As Long)
    Dim i_ As Long
    Dim i1_ As Long
    RALen = 2# + 2# + 3# * B.N
    ReDim RA(0 To RALen - 1)
    RA(0#) = RALen
    RA(1#) = BRCVNum
    RA(2#) = B.N
    RA(3#) = B.SY
    i1_ = (0#) - (4#)
    For i_ = 4# To 4# + B.N - 1# Step 1
        RA(i_) = B.x(i_ + i1_)
    Next i_
    i1_ = (0#) - (4# + B.N)
    For i_ = 4# + B.N To 4# + 2# * B.N - 1# Step 1
        RA(i_) = B.y(i_ + i1_)
    Next i_
    i1_ = (0#) - (4# + 2# * B.N)
    For i_ = 4# + 2# * B.N To 4# + 3# * B.N - 1# Step 1
        RA(i_) = B.w(i_ + i1_)
    Next i_
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Unserialization of the barycentric interpolant
'
'INPUT PARAMETERS:
'    RA  -   array of real numbers which contains interpolant,
'
'OUTPUT PARAMETERS:
'    B   -   barycentric interpolant
'
'  -- ALGLIB --
'     Copyright 17.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub BarycentricUnserialize(ByRef RA() As Double, _
         ByRef B As BarycentricInterpolant)
    Dim i_ As Long
    Dim i1_ As Long
    B.N = Round(RA(2#))
    B.SY = RA(3#)
    ReDim B.x(0 To B.N - 1)
    ReDim B.y(0 To B.N - 1)
    ReDim B.w(0 To B.N - 1)
    i1_ = (4#) - (0#)
    For i_ = 0# To B.N - 1# Step 1
        B.x(i_) = RA(i_ + i1_)
    Next i_
    i1_ = (4# + B.N) - (0#)
    For i_ = 0# To B.N - 1# Step 1
        B.y(i_) = RA(i_ + i1_)
    Next i_
    i1_ = (4# + 2# * B.N) - (0#)
    For i_ = 0# To B.N - 1# Step 1
        B.w(i_) = RA(i_ + i1_)
    Next i_
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copying of the barycentric interpolant
'
'INPUT PARAMETERS:
'    B   -   barycentric interpolant
'
'OUTPUT PARAMETERS:
'    B2  -   copy(B1)
'
'  -- ALGLIB --
'     Copyright 17.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub BarycentricCopy(ByRef B As BarycentricInterpolant, _
         ByRef b2 As BarycentricInterpolant)
    Dim i_ As Long
    b2.N = B.N
    b2.SY = B.SY
    ReDim b2.x(0 To b2.N - 1)
    ReDim b2.y(0 To b2.N - 1)
    ReDim b2.w(0 To b2.N - 1)
    For i_ = 0# To b2.N - 1# Step 1
        b2.x(i_) = B.x(i_)
    Next i_
    For i_ = 0# To b2.N - 1# Step 1
        b2.y(i_) = B.y(i_)
    Next i_
    For i_ = 0# To b2.N - 1# Step 1
        b2.w(i_) = B.w(i_)
    Next i_
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Rational interpolant from X/Y/W arrays
'
'F(t) = SUM(i=0,n-1,w[i]*f[i]/(t-x[i])) / SUM(i=0,n-1,w[i]/(t-x[i]))
'
'INPUT PARAMETERS:
'    X   -   interpolation nodes, array[0..N-1]
'    F   -   function values, array[0..N-1]
'    W   -   barycentric weights, array[0..N-1]
'    N   -   nodes count, N>0
'
'OUTPUT PARAMETERS:
'    B   -   barycentric interpolant built from (X, Y, W)
'
'  -- ALGLIB --
'     Copyright 17.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub BarycentricBuildXYW(ByRef x() As Double, _
         ByRef y() As Double, _
         ByRef w() As Double, _
         ByVal N As Long, _
         ByRef B As BarycentricInterpolant)
    Dim i_ As Long
    '
    ' fill X/Y/W
    '
    ReDim B.x(0 To N - 1)
    ReDim B.y(0 To N - 1)
    ReDim B.w(0 To N - 1)
    For i_ = 0# To N - 1# Step 1
        B.x(i_) = x(i_)
    Next i_
    For i_ = 0# To N - 1# Step 1
        B.y(i_) = y(i_)
    Next i_
    For i_ = 0# To N - 1# Step 1
        B.w(i_) = w(i_)
    Next i_
    B.N = N
    '
    ' Normalize
    '
    Call BarycentricNormalize(B)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Rational interpolant without poles
'
'The subroutine constructs the rational interpolating function without real
'poles  (see  'Barycentric rational interpolation with no  poles  and  high
'rates of approximation', Michael S. Floater. and  Kai  Hormann,  for  more
'information on this subject).
'
'Input parameters:
'    X   -   interpolation nodes, array[0..N-1].
'    Y   -   function values, array[0..N-1].
'    N   -   number of nodes, N>0.
'    D   -   order of the interpolation scheme, 0 <= D <= N-1.
'            D<0 will cause an error.
'            D>=N it will be replaced with D=N-1.
'            if you don't know what D to choose, use small value about 3-5.
'
'Output parameters:
'    B   -   barycentric interpolant.
'
'Note:
'    this algorithm always succeeds and calculates the weights  with  close
'    to machine precision.
'
'  -- ALGLIB PROJECT --
'     Copyright 17.06.2007 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub BarycentricBuildFloaterHormann(ByRef x() As Double, _
         ByRef y() As Double, _
         ByVal N As Long, _
         ByVal d As Long, _
         ByRef B As BarycentricInterpolant)
    Dim S0 As Double
    Dim s As Double
    Dim V As Double
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim Perm() As Long
    Dim WTemp() As Double
    Dim i_ As Long
    '
    ' Prepare
    '
    If d > N - 1# Then
        d = N - 1#
    End If
    B.N = N
    '
    ' special case: N=1
    '
    If N = 1# Then
        ReDim B.x(0 To N - 1)
        ReDim B.y(0 To N - 1)
        ReDim B.w(0 To N - 1)
        B.x(0#) = x(0#)
        B.y(0#) = y(0#)
        B.w(0#) = 1#
        Call BarycentricNormalize(B)
        Exit Sub
    End If
    '
    ' Fill X/Y
    '
    ReDim B.x(0 To N - 1)
    ReDim B.y(0 To N - 1)
    For i_ = 0# To N - 1# Step 1
        B.x(i_) = x(i_)
    Next i_
    For i_ = 0# To N - 1# Step 1
        B.y(i_) = y(i_)
    Next i_
    Call TagSortFastR(B.x, B.y, N)
    '
    ' Calculate Wk
    '
    ReDim B.w(0 To N - 1)
    S0 = 1#
    For K = 1# To d Step 1
        S0 = -S0
    Next K
    For K = 0# To N - 1# Step 1
        '
        ' Wk
        '
        s = 0#
        For i = MaxInt(K - d, 0#) To MinInt(K, N - 1# - d) Step 1
            V = 1#
            For j = i To i + d Step 1
                If j <> K Then
                    V = V / Abs(B.x(K) - B.x(j))
                End If
            Next j
            s = s + V
        Next i
        B.w(K) = S0 * s
        '
        ' Next S0
        '
        S0 = -S0
    Next K
    '
    ' Normalize
    '
    Call BarycentricNormalize(B)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Weghted rational least  squares  fitting  using  Floater-Hormann  rational
'functions  with  optimal  D  chosen  from  [0,9],  with  constraints   and
'individual weights.
'
'Equidistant  grid  with M node on [min(x),max(x)]  is  used to build basis
'functions. Different values of D are tried, optimal D (least WEIGHTED root
'mean square error) is chosen.  Task  is  linear,  so  linear least squares
'solver  is  used.  Complexity  of  this  computational  scheme is O(N*M^2)
'(mostly dominated by the least squares solver).
'
'SEE ALSO
'* BarycentricFitFloaterHormann(), "lightweight" fitting without invididual
'  weights and constraints.
'
'INPUT PARAMETERS:
'    X   -   points, array[0..N-1].
'    Y   -   function values, array[0..N-1].
'    W   -   weights, array[0..N-1]
'            Each summand in square  sum  of  approximation deviations from
'            given  values  is  multiplied  by  the square of corresponding
'            weight. Fill it by 1's if you don't  want  to  solve  weighted
'            task.
'    N   -   number of points, N>0.
'    XC  -   points where function values/derivatives are constrained,
'            array[0..K-1].
'    YC  -   values of constraints, array[0..K-1]
'    DC  -   array[0..K-1], types of constraints:
'            * DC[i]=0   means that S(XC[i])=YC[i]
'            * DC[i]=1   means that S'(XC[i])=YC[i]
'            SEE BELOW FOR IMPORTANT INFORMATION ON CONSTRAINTS
'    K   -   number of constraints, 0<=K<M.
'            K=0 means no constraints (XC/YC/DC are not used in such cases)
'    M   -   number of basis functions ( = number_of_nodes), M>=2.
'
'OUTPUT PARAMETERS:
'    Info-   same format as in LSFitLinearWC() subroutine.
'            * Info>0    task is solved
'            * Info<=0   an error occured:
'                        -4 means inconvergence of internal SVD
'                        -3 means inconsistent constraints
'                        -1 means another errors in parameters passed
'                           (N<=0, for example)
'    B   -   barycentric interpolant.
'    Rep -   report, same format as in LSFitLinearWC() subroutine.
'            Following fields are set:
'            * DBest         best value of the D parameter
'            * RMSError      rms error on the (X,Y).
'            * AvgError      average error on the (X,Y).
'            * AvgRelError   average relative error on the non-zero Y
'            * MaxError      maximum error
'                            NON-WEIGHTED ERRORS ARE CALCULATED
'
'IMPORTANT:
'    this subroitine doesn't calculate task's condition number for K<>0.
'
'SETTING CONSTRAINTS - DANGERS AND OPPORTUNITIES:
'
'Setting constraints can lead  to undesired  results,  like ill-conditioned
'behavior, or inconsistency being detected. From the other side,  it allows
'us to improve quality of the fit. Here we summarize  our  experience  with
'constrained barycentric interpolants:
'* excessive  constraints  can  be  inconsistent.   Floater-Hormann   basis
'  functions aren't as flexible as splines (although they are very smooth).
'* the more evenly constraints are spread across [min(x),max(x)],  the more
'  chances that they will be consistent
'* the  greater  is  M (given  fixed  constraints),  the  more chances that
'  constraints will be consistent
'* in the general case, consistency of constraints IS NOT GUARANTEED.
'* in the several special cases, however, we CAN guarantee consistency.
'* one of this cases is constraints on the function  VALUES at the interval
'  boundaries. Note that consustency of the  constraints  on  the  function
'  DERIVATIVES is NOT guaranteed (you can use in such cases  cubic  splines
'  which are more flexible).
'* another  special  case  is ONE constraint on the function value (OR, but
'  not AND, derivative) anywhere in the interval
'
'Our final recommendation is to use constraints  WHEN  AND  ONLY  WHEN  you
'can't solve your task without them. Anything beyond  special  cases  given
'above is not guaranteed and may result in inconsistency.
'
'  -- ALGLIB PROJECT --
'     Copyright 18.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub BarycentricFitFloaterHormannWC(ByRef x() As Double, _
         ByRef y() As Double, _
         ByRef w() As Double, _
         ByVal N As Long, _
         ByRef XC() As Double, _
         ByRef YC() As Double, _
         ByRef DC() As Long, _
         ByVal K As Long, _
         ByVal M As Long, _
         ByRef Info As Long, _
         ByRef B As BarycentricInterpolant, _
         ByRef Rep As BarycentricFitReport)
    Dim d As Long
    Dim i As Long
    Dim WRMSCur As Double
    Dim WRMSBest As Double
    Dim LocB As BarycentricInterpolant
    Dim LocRep As BarycentricFitReport
    Dim LocInfo As Long
    If N < 1# Or M < 2# Or K < 0# Or K >= M Then
        Info = -1#
        Exit Sub
    End If
    '
    ' Find optimal D
    '
    ' Info is -3 by default (degenerate constraints).
    ' If LocInfo will always be equal to -3, Info will remain equal to -3.
    ' If at least once LocInfo will be -4, Info will be -4.
    '
    WRMSBest = MaxRealNumber
    Rep.DBest = -1#
    Info = -3#
    For d = 0# To MinInt(9#, N - 1#) Step 1
        Call BarycentricFitWCFixedD(x, y, w, N, XC, YC, DC, K, M, d, LocInfo, LocB, LocRep)
        If LocInfo > 0# Then
            '
            ' Calculate weghted RMS
            '
            WRMSCur = 0#
            For i = 0# To N - 1# Step 1
                WRMSCur = WRMSCur + Square(w(i) * (y(i) - BarycentricCalc(LocB, x(i))))
            Next i
            WRMSCur = Sqr(WRMSCur / N)
            If WRMSCur < WRMSBest Or Rep.DBest < 0# Then
                Call BarycentricCopy(LocB, B)
                Rep.DBest = d
                Info = 1#
                Rep.RMSError = LocRep.RMSError
                Rep.AvgError = LocRep.AvgError
                Rep.AvgRelError = LocRep.AvgRelError
                Rep.MaxError = LocRep.MaxError
                Rep.TaskRCond = LocRep.TaskRCond
                WRMSBest = WRMSCur
            End If
        Else
            If LocInfo <> -3# And Info < 0# Then
                Info = LocInfo
            End If
        End If
    Next d
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Rational least squares fitting, without weights and constraints.
'
'See BarycentricFitFloaterHormannWC() for more information.
'
'  -- ALGLIB PROJECT --
'     Copyright 18.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub BarycentricFitFloaterHormann(ByRef x() As Double, _
         ByRef y() As Double, _
         ByVal N As Long, _
         ByVal M As Long, _
         ByRef Info As Long, _
         ByRef B As BarycentricInterpolant, _
         ByRef Rep As BarycentricFitReport)
    Dim w() As Double
    Dim XC() As Double
    Dim YC() As Double
    Dim DC() As Long
    Dim i As Long
    If N < 1# Then
        Info = -1#
        Exit Sub
    End If
    ReDim w(0 To N - 1)
    For i = 0# To N - 1# Step 1
        w(i) = 1#
    Next i
    Call BarycentricFitFloaterHormannWC(x, y, w, N, XC, YC, DC, 0#, M, Info, B, Rep)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Normalization of barycentric interpolant:
'* B.N, B.X, B.Y and B.W are initialized
'* B.SY is NOT initialized
'* Y[] is normalized, scaling coefficient is stored in B.SY
'* W[] is normalized, no scaling coefficient is stored
'* X[] is sorted
'
'Internal subroutine.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub BarycentricNormalize(ByRef B As BarycentricInterpolant)
    Dim p1() As Long
    Dim p2() As Long
    Dim i As Long
    Dim j As Long
    Dim J2 As Long
    Dim V As Double
    Dim i_ As Long
    '
    ' Normalize task: |Y|<=1, |W|<=1, sort X[]
    '
    B.SY = 0#
    For i = 0# To B.N - 1# Step 1
        B.SY = MaxReal(B.SY, Abs(B.y(i)))
    Next i
    If B.SY > 0# And Abs(B.SY - 1#) > 10# * MachineEpsilon Then
        V = 1# / B.SY
        For i_ = 0# To B.N - 1# Step 1
            B.y(i_) = V * B.y(i_)
        Next i_
    End If
    V = 0#
    For i = 0# To B.N - 1# Step 1
        V = MaxReal(V, Abs(B.w(i)))
    Next i
    If V > 0# And Abs(V - 1#) > 10# * MachineEpsilon Then
        V = 1# / V
        For i_ = 0# To B.N - 1# Step 1
            B.w(i_) = V * B.w(i_)
        Next i_
    End If
    For i = 0# To B.N - 2# Step 1
        If B.x(i + 1#) < B.x(i) Then
            Call TagSort(B.x, B.N, p1, p2)
            For j = 0# To B.N - 1# Step 1
                J2 = p2(j)
                V = B.y(j)
                B.y(j) = B.y(J2)
                B.y(J2) = V
                V = B.w(j)
                B.w(j) = B.w(J2)
                B.w(J2) = V
            Next j
            Exit For
        End If
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal subroutine, calculates barycentric basis functions.
'Used for efficient simultaneous calculation of N basis functions.
'
'  -- ALGLIB --
'     Copyright 17.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub BarycentricCalcBasis(ByRef B As BarycentricInterpolant, _
         ByVal t As Double, _
         ByRef y() As Double)
    Dim S2 As Double
    Dim s As Double
    Dim V As Double
    Dim i As Long
    Dim j As Long
    Dim i_ As Long
    '
    ' special case: N=1
    '
    If B.N = 1# Then
        y(0#) = 1#
        Exit Sub
    End If
    '
    ' Here we assume that task is normalized, i.e.:
    ' 1. abs(Y[i])<=1
    ' 2. abs(W[i])<=1
    ' 3. X[] is ordered
    '
    ' First, we decide: should we use "safe" formula (guarded
    ' against overflow) or fast one?
    '
    s = Abs(t - B.x(0#))
    For i = 0# To B.N - 1# Step 1
        V = B.x(i)
        If V = t Then
            For j = 0# To B.N - 1# Step 1
                y(j) = 0#
            Next j
            y(i) = 1#
            Exit Sub
        End If
        V = Abs(t - V)
        If V < s Then
            s = V
        End If
    Next i
    S2 = 0#
    For i = 0# To B.N - 1# Step 1
        V = s / (t - B.x(i))
        V = V * B.w(i)
        y(i) = V
        S2 = S2 + V
    Next i
    V = 1# / S2
    For i_ = 0# To B.N - 1# Step 1
        y(i_) = V * y(i_)
    Next i_
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal Floater-Hormann fitting subroutine for fixed D
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub BarycentricFitWCFixedD(ByRef x_() As Double, _
         ByRef y_() As Double, _
         ByRef w() As Double, _
         ByVal N As Long, _
         ByRef XC_() As Double, _
         ByRef YC_() As Double, _
         ByRef DC() As Long, _
         ByVal K As Long, _
         ByVal M As Long, _
         ByVal d As Long, _
         ByRef Info As Long, _
         ByRef B As BarycentricInterpolant, _
         ByRef Rep As BarycentricFitReport)
    Dim x() As Double
    Dim y() As Double
    Dim XC() As Double
    Dim YC() As Double
    Dim FMatrix() As Double
    Dim CMatrix() As Double
    Dim Y2() As Double
    Dim W2() As Double
    Dim SX() As Double
    Dim SY() As Double
    Dim SBF() As Double
    Dim XOriginal() As Double
    Dim YOriginal() As Double
    Dim tmp() As Double
    Dim LRep As LSFitReport
    Dim V0 As Double
    Dim V1 As Double
    Dim MX As Double
    Dim b2 As BarycentricInterpolant
    Dim i As Long
    Dim j As Long
    Dim RelCnt As Long
    Dim XA As Double
    Dim XB As Double
    Dim SA As Double
    Dim SB As Double
    Dim Decay As Double
    Dim i_ As Long
    x = x_
    y = y_
    XC = XC_
    YC = YC_
    If N < 1# Or M < 2# Or K < 0# Or K >= M Then
        Info = -1#
        Exit Sub
    End If
    For i = 0# To K - 1# Step 1
        Info = 0#
        If DC(i) < 0# Then
            Info = -1#
        End If
        If DC(i) > 1# Then
            Info = -1#
        End If
        If Info < 0# Then
            Exit Sub
        End If
    Next i
    '
    ' weight decay for correct handling of task which becomes
    ' degenerate after constraints are applied
    '
    Decay = 10000# * MachineEpsilon
    '
    ' Scale X, Y, XC, YC
    '
    Call LSFitScaleXY(x, y, N, XC, YC, DC, K, XA, XB, SA, SB, XOriginal, YOriginal)
    '
    ' allocate space, initialize:
    ' * FMatrix-   values of basis functions at X[]
    ' * CMatrix-   values (derivatives) of basis functions at XC[]
    '
    ReDim Y2(0 To N + M - 1)
    ReDim W2(0 To N + M - 1)
    ReDim FMatrix(0 To N + M - 1, 0 To M - 1)
    If K > 0# Then
        ReDim CMatrix(0 To K - 1, 0 To M + 1# - 1)
    End If
    ReDim Y2(0 To N + M - 1)
    ReDim W2(0 To N + M - 1)
    '
    ' Prepare design and constraints matrices:
    ' * fill constraints matrix
    ' * fill first N rows of design matrix with values
    ' * fill next M rows of design matrix with regularizing term
    ' * append M zeros to Y
    ' * append M elements, mean(abs(W)) each, to W
    '
    ReDim SX(0 To M - 1)
    ReDim SY(0 To M - 1)
    ReDim SBF(0 To M - 1)
    For j = 0# To M - 1# Step 1
        SX(j) = 2# * j / (M - 1#) - 1#
    Next j
    For i = 0# To M - 1# Step 1
        SY(i) = 1#
    Next i
    Call BarycentricBuildFloaterHormann(SX, SY, M, d, b2)
    MX = 0#
    For i = 0# To N - 1# Step 1
        Call BarycentricCalcBasis(b2, x(i), SBF)
        For i_ = 0# To M - 1# Step 1
            FMatrix(i, i_) = SBF(i_)
        Next i_
        Y2(i) = y(i)
        W2(i) = w(i)
        MX = MX + Abs(w(i)) / N
    Next i
    For i = 0# To M - 1# Step 1
        For j = 0# To M - 1# Step 1
            If i = j Then
                FMatrix(N + i, j) = Decay
            Else
                FMatrix(N + i, j) = 0#
            End If
        Next j
        Y2(N + i) = 0#
        W2(N + i) = MX
    Next i
    If K > 0# Then
        For j = 0# To M - 1# Step 1
            For i = 0# To M - 1# Step 1
                SY(i) = 0#
            Next i
            SY(j) = 1#
            Call BarycentricBuildFloaterHormann(SX, SY, M, d, b2)
            For i = 0# To K - 1# Step 1
                Call BarycentricDiff1(b2, XC(i), V0, V1)
                If DC(i) = 0# Then
                    CMatrix(i, j) = V0
                End If
                If DC(i) = 1# Then
                    CMatrix(i, j) = V1
                End If
            Next i
        Next j
        For i = 0# To K - 1# Step 1
            CMatrix(i, M) = YC(i)
        Next i
    End If
    '
    ' Solve constrained task
    '
    If K > 0# Then
        '
        ' solve using regularization
        '
        Call LSFitLinearWC(Y2, W2, FMatrix, CMatrix, N + M, M, K, Info, tmp, LRep)
    Else
        '
        ' no constraints, no regularization needed
        '
        Call LSFitLinearWC(y, w, FMatrix, CMatrix, N, M, K, Info, tmp, LRep)
    End If
    If Info < 0# Then
        Exit Sub
    End If
    '
    ' Generate interpolant and scale it
    '
    For i_ = 0# To M - 1# Step 1
        SY(i_) = tmp(i_)
    Next i_
    Call BarycentricBuildFloaterHormann(SX, SY, M, d, B)
    Call BarycentricLinTransX(B, 2# / (XB - XA), -((XA + XB) / (XB - XA)))
    Call BarycentricLinTransY(B, SB - SA, SA)
    '
    ' Scale absolute errors obtained from LSFitLinearW.
    ' Relative error should be calculated separately
    ' (because of shifting/scaling of the task)
    '
    Rep.TaskRCond = LRep.TaskRCond
    Rep.RMSError = LRep.RMSError * (SB - SA)
    Rep.AvgError = LRep.AvgError * (SB - SA)
    Rep.MaxError = LRep.MaxError * (SB - SA)
    Rep.AvgRelError = 0#
    RelCnt = 0#
    For i = 0# To N - 1# Step 1
        If YOriginal(i) <> 0# Then
            Rep.AvgRelError = Rep.AvgRelError + Abs(BarycentricCalc(B, XOriginal(i)) - YOriginal(i)) / Abs(YOriginal(i))
            RelCnt = RelCnt + 1#
        End If
    Next i
    If RelCnt <> 0# Then
        Rep.AvgRelError = Rep.AvgRelError / RelCnt
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Cephes Math Library Release 2.8:  June, 2000
'Copyright by Stephen L. Moshier
'
'Contributors:
'    * Sergey Bochkanov (ALGLIB project). Translation from C to
'      pseudocode.
'
'See subroutines comments for additional copyrights.
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Bessel function of order zero
'
'Returns Bessel function of order zero of the argument.
'
'The domain is divided into the intervals [0, 5] and
'(5, infinity). In the first interval the following rational
'approximation is used:
'
'
'       2         2
'(w - r  ) (w - r  ) P (w) / Q (w)
'      1         2    3       8
'
'           2
'where w = x  and the two r's are zeros of the function.
'
'In the second interval, the Hankel asymptotic expansion
'is employed with two rational functions of degree 6/6
'and 7/7.
'
'ACCURACY:
'
'                     Absolute error:
'arithmetic   domain     # trials      peak         rms
'   IEEE      0, 30       60000       4.2e-16     1.1e-16
'
'Cephes Math Library Release 2.8:  June, 2000
'Copyright 1984, 1987, 1989, 2000 by Stephen L. Moshier
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function BesselJ0(ByVal x As Double) As Double
    Dim Result As Double
    Dim XSq As Double
    Dim NN As Double
    Dim PZero As Double
    Dim QZero As Double
    Dim p1 As Double
    Dim Q1 As Double
    If x < 0# Then
        x = -x
    End If
    If x > 8# Then
        Call BesselAsympt0(x, PZero, QZero)
        NN = x - pi() / 4#
        Result = Sqr(2# / pi() / x) * (PZero * Cos(NN) - QZero * Sin(NN))
        BesselJ0 = Result
        Exit Function
    End If
    XSq = Square(x)
    p1 = 26857.8685698001
    p1 = -40504123.7183313 + XSq * p1
    p1 = 25071582855.3688 + XSq * p1
    p1 = -8085222034853.79 + XSq * p1
    p1 = 1.43435493914034E+15 + XSq * p1
    p1 = -1.36762035308817E+17 + XSq * p1
    p1 = 6.38205934107236E+18 + XSq * p1
    p1 = -1.17915762910761E+20 + XSq * p1
    p1 = 4.93378725179413E+20 + XSq * p1
    Q1 = 1#
    Q1 = 1363.06365232897 + XSq * Q1
    Q1 = 1114636.09846299 + XSq * Q1
    Q1 = 669998767.298224 + XSq * Q1
    Q1 = 312304311494.121 + XSq * Q1
    Q1 = 112775673967980# + XSq * Q1
    Q1 = 3.02463561670946E+16 + XSq * Q1
    Q1 = 5.42891838409228E+18 + XSq * Q1
    Q1 = 4.93378725179413E+20 + XSq * Q1
    Result = p1 / Q1
    BesselJ0 = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Bessel function of order one
'
'Returns Bessel function of order one of the argument.
'
'The domain is divided into the intervals [0, 8] and
'(8, infinity). In the first interval a 24 term Chebyshev
'expansion is used. In the second, the asymptotic
'trigonometric representation is employed using two
'rational functions of degree 5/5.
'
'ACCURACY:
'
'                     Absolute error:
'arithmetic   domain      # trials      peak         rms
'   IEEE      0, 30       30000       2.6e-16     1.1e-16
'
'Cephes Math Library Release 2.8:  June, 2000
'Copyright 1984, 1987, 1989, 2000 by Stephen L. Moshier
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function BesselJ1(ByVal x As Double) As Double
    Dim Result As Double
    Dim s As Double
    Dim XSq As Double
    Dim NN As Double
    Dim PZero As Double
    Dim QZero As Double
    Dim p1 As Double
    Dim Q1 As Double
    s = Sgn(x)
    If x < 0# Then
        x = -x
    End If
    If x > 8# Then
        Call BesselAsympt1(x, PZero, QZero)
        NN = x - 3# * pi() / 4#
        Result = Sqr(2# / pi() / x) * (PZero * Cos(NN) - QZero * Sin(NN))
        If s < 0# Then
            Result = -Result
        End If
        BesselJ1 = Result
        Exit Function
    End If
    XSq = Square(x)
    p1 = 2701.12271089232
    p1 = -4695753.530643 + XSq * p1
    p1 = 3413234182.3017 + XSq * p1
    p1 = -1322983480332.13 + XSq * p1
    p1 = 290879526383478# + XSq * p1
    p1 = -3.58881756991011E+16 + XSq * p1
    p1 = 2.316433580634E+18 + XSq * p1
    p1 = -6.67210656892492E+19 + XSq * p1
    p1 = 5.81199354001606E+20 + XSq * p1
    Q1 = 1#
    Q1 = 1606.93157348149 + XSq * Q1
    Q1 = 1501793.59499859 + XSq * Q1
    Q1 = 1013863514.35867 + XSq * Q1
    Q1 = 524371026216.765 + XSq * Q1
    Q1 = 208166122130761# + XSq * Q1
    Q1 = 6.09206139891752E+16 + XSq * Q1
    Q1 = 1.18577071219032E+19 + XSq * Q1
    Q1 = 1.16239870800321E+21 + XSq * Q1
    Result = s * x * p1 / Q1
    BesselJ1 = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Bessel function of integer order
'
'Returns Bessel function of order n, where n is a
'(possibly negative) integer.
'
'The ratio of jn(x) to j0(x) is computed by backward
'recurrence.  First the ratio jn/jn-1 is found by a
'continued fraction expansion.  Then the recurrence
'relating successive orders is applied until j0 or j1 is
'reached.
'
'If n = 0 or 1 the routine for j0 or j1 is called
'directly.
'
'ACCURACY:
'
'                     Absolute error:
'arithmetic   range      # trials      peak         rms
'   IEEE      0, 30        5000       4.4e-16     7.9e-17
'
'
'Not suitable for large n or x. Use jv() (fractional order) instead.
'
'Cephes Math Library Release 2.8:  June, 2000
'Copyright 1984, 1987, 2000 by Stephen L. Moshier
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function BesselJN(ByVal N As Long, ByVal x As Double) As Double
    Dim Result As Double
    Dim pkm2 As Double
    Dim pkm1 As Double
    Dim pk As Double
    Dim XK As Double
    Dim R As Double
    Dim ans As Double
    Dim K As Long
    Dim sg As Long
    If N < 0# Then
        N = -N
        If N Mod 2# = 0# Then
            sg = 1#
        Else
            sg = -1#
        End If
    Else
        sg = 1#
    End If
    If x < 0# Then
        If N Mod 2# <> 0# Then
            sg = -sg
        End If
        x = -x
    End If
    If N = 0# Then
        Result = sg * BesselJ0(x)
        BesselJN = Result
        Exit Function
    End If
    If N = 1# Then
        Result = sg * BesselJ1(x)
        BesselJN = Result
        Exit Function
    End If
    If N = 2# Then
        If x = 0# Then
            Result = 0#
        Else
            Result = sg * (2# * BesselJ1(x) / x - BesselJ0(x))
        End If
        BesselJN = Result
        Exit Function
    End If
    If x < MachineEpsilon Then
        Result = 0#
        BesselJN = Result
        Exit Function
    End If
    K = 53#
    pk = 2# * (N + K)
    ans = pk
    XK = x * x
    Do
        pk = pk - 2#
        ans = pk - XK / ans
        K = K - 1#
    Loop Until K = 0#
    ans = x / ans
    pk = 1#
    pkm1 = 1# / ans
    K = N - 1#
    R = 2# * K
    Do
        pkm2 = (pkm1 * R - pk * x) / x
        pk = pkm1
        pkm1 = pkm2
        R = R - 2#
        K = K - 1#
    Loop Until K = 0#
    If Abs(pk) > Abs(pkm1) Then
        ans = BesselJ1(x) / pk
    Else
        ans = BesselJ0(x) / pkm1
    End If
    Result = sg * ans
    BesselJN = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Bessel function of the second kind, order zero
'
'Returns Bessel function of the second kind, of order
'zero, of the argument.
'
'The domain is divided into the intervals [0, 5] and
'(5, infinity). In the first interval a rational approximation
'R(x) is employed to compute
'  y0(x)  = R(x)  +   2 * log(x) * j0(x) / PI.
'Thus a call to j0() is required.
'
'In the second interval, the Hankel asymptotic expansion
'is employed with two rational functions of degree 6/6
'and 7/7.
'
'
'
'ACCURACY:
'
' Absolute error, when y0(x) < 1; else relative error:
'
'arithmetic   domain     # trials      peak         rms
'   IEEE      0, 30       30000       1.3e-15     1.6e-16
'
'Cephes Math Library Release 2.8:  June, 2000
'Copyright 1984, 1987, 1989, 2000 by Stephen L. Moshier
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function BesselY0(ByVal x As Double) As Double
    Dim Result As Double
    Dim NN As Double
    Dim XSq As Double
    Dim PZero As Double
    Dim QZero As Double
    Dim P4 As Double
    Dim Q4 As Double
    If x > 8# Then
        Call BesselAsympt0(x, PZero, QZero)
        NN = x - pi() / 4#
        Result = Sqr(2# / pi() / x) * (PZero * Sin(NN) + QZero * Cos(NN))
        BesselY0 = Result
        Exit Function
    End If
    XSq = Square(x)
    P4 = -41370.3549793315
    P4 = 59152134.6568689 + XSq * P4
    P4 = -34363712229.7904 + XSq * P4
    P4 = 10255208596863.9 + XSq * P4
    P4 = -1.64860581718573E+15 + XSq * P4
    P4 = 1.37562431639934E+17 + XSq * P4
    P4 = -5.24706558111277E+18 + XSq * P4
    P4 = 6.58747327571955E+19 + XSq * P4
    P4 = -2.75028667862911E+19 + XSq * P4
    Q4 = 1#
    Q4 = 1282.45277247899 + XSq * Q4
    Q4 = 1001702.64128891 + XSq * Q4
    Q4 = 579512264.070073 + XSq * Q4
    Q4 = 261306575504.108 + XSq * Q4
    Q4 = 91620380340751.9 + XSq * Q4
    Q4 = 2.39288304349978E+16 + XSq * Q4
    Q4 = 4.19241704341084E+18 + XSq * Q4
    Q4 = 3.72645883898617E+20 + XSq * Q4
    Result = P4 / Q4 + 2# / pi() * BesselJ0(x) * Log(x)
    BesselY0 = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Bessel function of second kind of order one
'
'Returns Bessel function of the second kind of order one
'of the argument.
'
'The domain is divided into the intervals [0, 8] and
'(8, infinity). In the first interval a 25 term Chebyshev
'expansion is used, and a call to j1() is required.
'In the second, the asymptotic trigonometric representation
'is employed using two rational functions of degree 5/5.
'
'ACCURACY:
'
'                     Absolute error:
'arithmetic   domain      # trials      peak         rms
'   IEEE      0, 30       30000       1.0e-15     1.3e-16
'
'Cephes Math Library Release 2.8:  June, 2000
'Copyright 1984, 1987, 1989, 2000 by Stephen L. Moshier
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function BesselY1(ByVal x As Double) As Double
    Dim Result As Double
    Dim NN As Double
    Dim XSq As Double
    Dim PZero As Double
    Dim QZero As Double
    Dim P4 As Double
    Dim Q4 As Double
    If x > 8# Then
        Call BesselAsympt1(x, PZero, QZero)
        NN = x - 3# * pi() / 4#
        Result = Sqr(2# / pi() / x) * (PZero * Sin(NN) + QZero * Cos(NN))
        BesselY1 = Result
        Exit Function
    End If
    XSq = Square(x)
    P4 = -2108847.54013312
    P4 = 3639488548.124 + XSq * P4
    P4 = -2580681702194.45 + XSq * P4
    P4 = 956993023992168# + XSq * P4
    P4 = -1.96588746272214E+17 + XSq * P4
    P4 = 2.1931073399178E+19 + XSq * P4
    P4 = -1.21229755541451E+21 + XSq * P4
    P4 = 2.65547383143485E+22 + XSq * P4
    P4 = -9.96375342430692E+22 + XSq * P4
    Q4 = 1#
    Q4 = 1612.361029677 + XSq * Q4
    Q4 = 1563282.75489958 + XSq * Q4
    Q4 = 1128686837.16944 + XSq * Q4
    Q4 = 646534088126.528 + XSq * Q4
    Q4 = 297663212564728# + XSq * Q4
    Q4 = 1.08225825940882E+17 + XSq * Q4
    Q4 = 2.95498793589715E+19 + XSq * Q4
    Q4 = 5.43531037718885E+21 + XSq * Q4
    Q4 = 5.08206736694124E+23 + XSq * Q4
    Result = x * P4 / Q4 + 2# / pi() * (BesselJ1(x) * Log(x) - 1# / x)
    BesselY1 = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Bessel function of second kind of integer order
'
'Returns Bessel function of order n, where n is a
'(possibly negative) integer.
'
'The function is evaluated by forward recurrence on
'n, starting with values computed by the routines
'y0() and y1().
'
'If n = 0 or 1 the routine for y0 or y1 is called
'directly.
'
'ACCURACY:
'                     Absolute error, except relative
'                     when y > 1:
'arithmetic   domain     # trials      peak         rms
'   IEEE      0, 30       30000       3.4e-15     4.3e-16
'
'Cephes Math Library Release 2.8:  June, 2000
'Copyright 1984, 1987, 2000 by Stephen L. Moshier
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function BesselYN(ByVal N As Long, ByVal x As Double) As Double
    Dim Result As Double
    Dim i As Long
    Dim a As Double
    Dim B As Double
    Dim tmp As Double
    Dim s As Double
    s = 1#
    If N < 0# Then
        N = -N
        If N Mod 2# <> 0# Then
            s = -1#
        End If
    End If
    If N = 0# Then
        Result = BesselY0(x)
        BesselYN = Result
        Exit Function
    End If
    If N = 1# Then
        Result = s * BesselY1(x)
        BesselYN = Result
        Exit Function
    End If
    a = BesselY0(x)
    B = BesselY1(x)
    For i = 1# To N - 1# Step 1
        tmp = B
        B = 2# * i / x * B - a
        a = tmp
    Next i
    Result = s * B
    BesselYN = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Modified Bessel function of order zero
'
'Returns modified Bessel function of order zero of the
'argument.
'
'The function is defined as i0(x) = j0( ix ).
'
'The range is partitioned into the two intervals [0,8] and
'(8, infinity).  Chebyshev polynomial expansions are employed
'in each interval.
'
'ACCURACY:
'
'                     Relative error:
'arithmetic   domain     # trials      peak         rms
'   IEEE      0,30        30000       5.8e-16     1.4e-16
'
'Cephes Math Library Release 2.8:  June, 2000
'Copyright 1984, 1987, 2000 by Stephen L. Moshier
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function BesselI0(ByVal x As Double) As Double
    Dim Result As Double
    Dim y As Double
    Dim V As Double
    Dim z As Double
    Dim b0 As Double
    Dim b1 As Double
    Dim b2 As Double
    If x < 0# Then
        x = -x
    End If
    If x <= 8# Then
        y = x / 2# - 2#
        Call BesselMFirstCheb(-4.41534164647934E-18, b0, b1, b2)
        Call BesselMNextCheb(y, 3.33079451882224E-17, b0, b1, b2)
        Call BesselMNextCheb(y, -2.43127984654795E-16, b0, b1, b2)
        Call BesselMNextCheb(y, 1.71539128555513E-15, b0, b1, b2)
        Call BesselMNextCheb(y, -1.16853328779935E-14, b0, b1, b2)
        Call BesselMNextCheb(y, 7.67618549860494E-14, b0, b1, b2)
        Call BesselMNextCheb(y, -4.85644678311193E-13, b0, b1, b2)
        Call BesselMNextCheb(y, 2.95505266312964E-12, b0, b1, b2)
        Call BesselMNextCheb(y, -1.72682629144156E-11, b0, b1, b2)
        Call BesselMNextCheb(y, 9.67580903537324E-11, b0, b1, b2)
        Call BesselMNextCheb(y, -5.18979560163526E-10, b0, b1, b2)
        Call BesselMNextCheb(y, 2.65982372468239E-09, b0, b1, b2)
        Call BesselMNextCheb(y, -1.30002500998625E-08, b0, b1, b2)
        Call BesselMNextCheb(y, 6.04699502254192E-08, b0, b1, b2)
        Call BesselMNextCheb(y, -2.67079385394061E-07, b0, b1, b2)
        Call BesselMNextCheb(y, 1.1173875391201E-06, b0, b1, b2)
        Call BesselMNextCheb(y, -4.41673835845875E-06, b0, b1, b2)
        Call BesselMNextCheb(y, 1.64484480707289E-05, b0, b1, b2)
        Call BesselMNextCheb(y, -5.7541950100821E-05, b0, b1, b2)
        Call BesselMNextCheb(y, 1.88502885095842E-04, b0, b1, b2)
        Call BesselMNextCheb(y, -5.76375574538582E-04, b0, b1, b2)
        Call BesselMNextCheb(y, 1.63947561694134E-03, b0, b1, b2)
        Call BesselMNextCheb(y, -4.32430999505058E-03, b0, b1, b2)
        Call BesselMNextCheb(y, 0.010546460394595, b0, b1, b2)
        Call BesselMNextCheb(y, -2.37374148058995E-02, b0, b1, b2)
        Call BesselMNextCheb(y, 4.93052842396707E-02, b0, b1, b2)
        Call BesselMNextCheb(y, -9.49010970480476E-02, b0, b1, b2)
        Call BesselMNextCheb(y, 0.171620901522209, b0, b1, b2)
        Call BesselMNextCheb(y, -0.304682672343198, b0, b1, b2)
        Call BesselMNextCheb(y, 0.676795274409476, b0, b1, b2)
        V = 0.5 * (b0 - b2)
        Result = Exp(x) * V
        BesselI0 = Result
        Exit Function
    End If
    z = 32# / x - 2#
    Call BesselMFirstCheb(-7.23318048787475E-18, b0, b1, b2)
    Call BesselMNextCheb(z, -4.83050448594418E-18, b0, b1, b2)
    Call BesselMNextCheb(z, 4.46562142029676E-17, b0, b1, b2)
    Call BesselMNextCheb(z, 3.46122286769746E-17, b0, b1, b2)
    Call BesselMNextCheb(z, -2.82762398051658E-16, b0, b1, b2)
    Call BesselMNextCheb(z, -3.42548561967722E-16, b0, b1, b2)
    Call BesselMNextCheb(z, 1.77256013305653E-15, b0, b1, b2)
    Call BesselMNextCheb(z, 3.81168066935262E-15, b0, b1, b2)
    Call BesselMNextCheb(z, -9.55484669882831E-15, b0, b1, b2)
    Call BesselMNextCheb(z, -4.15056934728722E-14, b0, b1, b2)
    Call BesselMNextCheb(z, 1.54008621752141E-14, b0, b1, b2)
    Call BesselMNextCheb(z, 3.85277838274214E-13, b0, b1, b2)
    Call BesselMNextCheb(z, 7.18012445138367E-13, b0, b1, b2)
    Call BesselMNextCheb(z, -1.79417853150681E-12, b0, b1, b2)
    Call BesselMNextCheb(z, -1.32158118404477E-11, b0, b1, b2)
    Call BesselMNextCheb(z, -3.14991652796324E-11, b0, b1, b2)
    Call BesselMNextCheb(z, 1.18891471078464E-11, b0, b1, b2)
    Call BesselMNextCheb(z, 4.94060238822497E-10, b0, b1, b2)
    Call BesselMNextCheb(z, 3.39623202570839E-09, b0, b1, b2)
    Call BesselMNextCheb(z, 2.26666899049818E-08, b0, b1, b2)
    Call BesselMNextCheb(z, 2.04891858946906E-07, b0, b1, b2)
    Call BesselMNextCheb(z, 2.89137052083476E-06, b0, b1, b2)
    Call BesselMNextCheb(z, 6.88975834691682E-05, b0, b1, b2)
    Call BesselMNextCheb(z, 3.36911647825569E-03, b0, b1, b2)
    Call BesselMNextCheb(z, 0.804490411014109, b0, b1, b2)
    V = 0.5 * (b0 - b2)
    Result = Exp(x) * V / Sqr(x)
    BesselI0 = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Modified Bessel function of order one
'
'Returns modified Bessel function of order one of the
'argument.
'
'The function is defined as i1(x) = -i j1( ix ).
'
'The range is partitioned into the two intervals [0,8] and
'(8, infinity).  Chebyshev polynomial expansions are employed
'in each interval.
'
'ACCURACY:
'
'                     Relative error:
'arithmetic   domain     # trials      peak         rms
'   IEEE      0, 30       30000       1.9e-15     2.1e-16
'
'Cephes Math Library Release 2.8:  June, 2000
'Copyright 1985, 1987, 2000 by Stephen L. Moshier
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function BesselI1(ByVal x As Double) As Double
    Dim Result As Double
    Dim y As Double
    Dim z As Double
    Dim V As Double
    Dim b0 As Double
    Dim b1 As Double
    Dim b2 As Double
    z = Abs(x)
    If z <= 8# Then
        y = z / 2# - 2#
        Call BesselM1FirstCheb(2.77791411276105E-18, b0, b1, b2)
        Call BesselM1NextCheb(y, -2.11142121435817E-17, b0, b1, b2)
        Call BesselM1NextCheb(y, 1.5536319577362E-16, b0, b1, b2)
        Call BesselM1NextCheb(y, -1.10559694773539E-15, b0, b1, b2)
        Call BesselM1NextCheb(y, 7.60068429473541E-15, b0, b1, b2)
        Call BesselM1NextCheb(y, -5.04218550472791E-14, b0, b1, b2)
        Call BesselM1NextCheb(y, 3.22379336594557E-13, b0, b1, b2)
        Call BesselM1NextCheb(y, -1.98397439776494E-12, b0, b1, b2)
        Call BesselM1NextCheb(y, 1.17361862988909E-11, b0, b1, b2)
        Call BesselM1NextCheb(y, -6.66348972350203E-11, b0, b1, b2)
        Call BesselM1NextCheb(y, 3.62559028155212E-10, b0, b1, b2)
        Call BesselM1NextCheb(y, -1.88724975172283E-09, b0, b1, b2)
        Call BesselM1NextCheb(y, 9.38153738649577E-09, b0, b1, b2)
        Call BesselM1NextCheb(y, -4.44505912879633E-08, b0, b1, b2)
        Call BesselM1NextCheb(y, 2.00329475355214E-07, b0, b1, b2)
        Call BesselM1NextCheb(y, -8.56872026469545E-07, b0, b1, b2)
        Call BesselM1NextCheb(y, 3.47025130813768E-06, b0, b1, b2)
        Call BesselM1NextCheb(y, -1.32731636560394E-05, b0, b1, b2)
        Call BesselM1NextCheb(y, 4.78156510755005E-05, b0, b1, b2)
        Call BesselM1NextCheb(y, -1.61760815825897E-04, b0, b1, b2)
        Call BesselM1NextCheb(y, 5.12285956168576E-04, b0, b1, b2)
        Call BesselM1NextCheb(y, -1.51357245063125E-03, b0, b1, b2)
        Call BesselM1NextCheb(y, 4.15642294431289E-03, b0, b1, b2)
        Call BesselM1NextCheb(y, -1.05640848946262E-02, b0, b1, b2)
        Call BesselM1NextCheb(y, 2.47264490306265E-02, b0, b1, b2)
        Call BesselM1NextCheb(y, -0.052945981208095, b0, b1, b2)
        Call BesselM1NextCheb(y, 0.102643658689847, b0, b1, b2)
        Call BesselM1NextCheb(y, -0.176416518357834, b0, b1, b2)
        Call BesselM1NextCheb(y, 0.252587186443634, b0, b1, b2)
        V = 0.5 * (b0 - b2)
        z = V * z * Exp(z)
    Else
        y = 32# / z - 2#
        Call BesselM1FirstCheb(7.51729631084211E-18, b0, b1, b2)
        Call BesselM1NextCheb(y, 4.41434832307171E-18, b0, b1, b2)
        Call BesselM1NextCheb(y, -4.65030536848936E-17, b0, b1, b2)
        Call BesselM1NextCheb(y, -3.20952592199342E-17, b0, b1, b2)
        Call BesselM1NextCheb(y, 2.96262899764595E-16, b0, b1, b2)
        Call BesselM1NextCheb(y, 3.30820231092093E-16, b0, b1, b2)
        Call BesselM1NextCheb(y, -1.88035477551078E-15, b0, b1, b2)
        Call BesselM1NextCheb(y, -3.81440307243701E-15, b0, b1, b2)
        Call BesselM1NextCheb(y, 1.04202769841288E-14, b0, b1, b2)
        Call BesselM1NextCheb(y, 4.27244001671195E-14, b0, b1, b2)
        Call BesselM1NextCheb(y, -2.10154184277266E-14, b0, b1, b2)
        Call BesselM1NextCheb(y, -4.0835511110922E-13, b0, b1, b2)
        Call BesselM1NextCheb(y, -7.19855177624591E-13, b0, b1, b2)
        Call BesselM1NextCheb(y, 2.03562854414709E-12, b0, b1, b2)
        Call BesselM1NextCheb(y, 1.41258074366138E-11, b0, b1, b2)
        Call BesselM1NextCheb(y, 3.25260358301549E-11, b0, b1, b2)
        Call BesselM1NextCheb(y, -1.89749581235054E-11, b0, b1, b2)
        Call BesselM1NextCheb(y, -5.58974346219658E-10, b0, b1, b2)
        Call BesselM1NextCheb(y, -3.83538038596424E-09, b0, b1, b2)
        Call BesselM1NextCheb(y, -2.63146884688952E-08, b0, b1, b2)
        Call BesselM1NextCheb(y, -2.51223623787021E-07, b0, b1, b2)
        Call BesselM1NextCheb(y, -3.88256480887769E-06, b0, b1, b2)
        Call BesselM1NextCheb(y, -1.10588938762624E-04, b0, b1, b2)
        Call BesselM1NextCheb(y, -9.76109749136147E-03, b0, b1, b2)
        Call BesselM1NextCheb(y, 0.77857623501828, b0, b1, b2)
        V = 0.5 * (b0 - b2)
        z = V * Exp(z) / Sqr(z)
    End If
    If x < 0# Then
        z = -z
    End If
    Result = z
    BesselI1 = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Modified Bessel function, second kind, order zero
'
'Returns modified Bessel function of the second kind
'of order zero of the argument.
'
'The range is partitioned into the two intervals [0,8] and
'(8, infinity).  Chebyshev polynomial expansions are employed
'in each interval.
'
'ACCURACY:
'
'Tested at 2000 random points between 0 and 8.  Peak absolute
'error (relative when K0 > 1) was 1.46e-14; rms, 4.26e-15.
'                     Relative error:
'arithmetic   domain     # trials      peak         rms
'   IEEE      0, 30       30000       1.2e-15     1.6e-16
'
'Cephes Math Library Release 2.8:  June, 2000
'Copyright 1984, 1987, 2000 by Stephen L. Moshier
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function BesselK0(ByVal x As Double) As Double
    Dim Result As Double
    Dim y As Double
    Dim z As Double
    Dim V As Double
    Dim b0 As Double
    Dim b1 As Double
    Dim b2 As Double
    If x <= 2# Then
        y = x * x - 2#
        Call BesselMFirstCheb(1.37446543561352E-16, b0, b1, b2)
        Call BesselMNextCheb(y, 4.25981614279661E-14, b0, b1, b2)
        Call BesselMNextCheb(y, 1.03496952576338E-11, b0, b1, b2)
        Call BesselMNextCheb(y, 1.90451637722021E-09, b0, b1, b2)
        Call BesselMNextCheb(y, 2.53479107902615E-07, b0, b1, b2)
        Call BesselMNextCheb(y, 2.28621210311945E-05, b0, b1, b2)
        Call BesselMNextCheb(y, 1.26461541144693E-03, b0, b1, b2)
        Call BesselMNextCheb(y, 3.59799365153615E-02, b0, b1, b2)
        Call BesselMNextCheb(y, 0.344289899924628, b0, b1, b2)
        Call BesselMNextCheb(y, -0.535327393233903, b0, b1, b2)
        V = 0.5 * (b0 - b2)
        V = V - Log(0.5 * x) * BesselI0(x)
    Else
        z = 8# / x - 2#
        Call BesselMFirstCheb(5.30043377268626E-18, b0, b1, b2)
        Call BesselMNextCheb(z, -1.64758043015242E-17, b0, b1, b2)
        Call BesselMNextCheb(z, 5.21039150503903E-17, b0, b1, b2)
        Call BesselMNextCheb(z, -1.67823109680541E-16, b0, b1, b2)
        Call BesselMNextCheb(z, 5.51205597852432E-16, b0, b1, b2)
        Call BesselMNextCheb(z, -1.84859337734378E-15, b0, b1, b2)
        Call BesselMNextCheb(z, 6.34007647740507E-15, b0, b1, b2)
        Call BesselMNextCheb(z, -2.22751332699167E-14, b0, b1, b2)
        Call BesselMNextCheb(z, 8.03289077536358E-14, b0, b1, b2)
        Call BesselMNextCheb(z, -2.98009692317273E-13, b0, b1, b2)
        Call BesselMNextCheb(z, 1.14034058820848E-12, b0, b1, b2)
        Call BesselMNextCheb(z, -4.51459788337394E-12, b0, b1, b2)
        Call BesselMNextCheb(z, 1.85594911495472E-11, b0, b1, b2)
        Call BesselMNextCheb(z, -7.95748924447711E-11, b0, b1, b2)
        Call BesselMNextCheb(z, 3.5773972814003E-10, b0, b1, b2)
        Call BesselMNextCheb(z, -1.69753450938906E-09, b0, b1, b2)
        Call BesselMNextCheb(z, 8.57403401741423E-09, b0, b1, b2)
        Call BesselMNextCheb(z, -4.66048989768795E-08, b0, b1, b2)
        Call BesselMNextCheb(z, 2.76681363944501E-07, b0, b1, b2)
        Call BesselMNextCheb(z, -1.83175552271912E-06, b0, b1, b2)
        Call BesselMNextCheb(z, 1.39498137188765E-05, b0, b1, b2)
        Call BesselMNextCheb(z, -1.28495495816278E-04, b0, b1, b2)
        Call BesselMNextCheb(z, 1.56988388573005E-03, b0, b1, b2)
        Call BesselMNextCheb(z, -3.14481013119645E-02, b0, b1, b2)
        Call BesselMNextCheb(z, 2.44030308206596, b0, b1, b2)
        V = 0.5 * (b0 - b2)
        V = V * Exp(-x) / Sqr(x)
    End If
    Result = V
    BesselK0 = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Modified Bessel function, second kind, order one
'
'Computes the modified Bessel function of the second kind
'of order one of the argument.
'
'The range is partitioned into the two intervals [0,2] and
'(2, infinity).  Chebyshev polynomial expansions are employed
'in each interval.
'
'ACCURACY:
'
'                     Relative error:
'arithmetic   domain     # trials      peak         rms
'   IEEE      0, 30       30000       1.2e-15     1.6e-16
'
'Cephes Math Library Release 2.8:  June, 2000
'Copyright 1984, 1987, 2000 by Stephen L. Moshier
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function BesselK1(ByVal x As Double) As Double
    Dim Result As Double
    Dim y As Double
    Dim z As Double
    Dim V As Double
    Dim b0 As Double
    Dim b1 As Double
    Dim b2 As Double
    z = 0.5 * x
    If x <= 2# Then
        y = x * x - 2#
        Call BesselM1FirstCheb(-7.02386347938629E-18, b0, b1, b2)
        Call BesselM1NextCheb(y, -2.42744985051937E-15, b0, b1, b2)
        Call BesselM1NextCheb(y, -6.66690169419933E-13, b0, b1, b2)
        Call BesselM1NextCheb(y, -1.41148839263353E-10, b0, b1, b2)
        Call BesselM1NextCheb(y, -2.21338763073473E-08, b0, b1, b2)
        Call BesselM1NextCheb(y, -2.43340614156597E-06, b0, b1, b2)
        Call BesselM1NextCheb(y, -1.73028895751305E-04, b0, b1, b2)
        Call BesselM1NextCheb(y, -6.97572385963986E-03, b0, b1, b2)
        Call BesselM1NextCheb(y, -0.122611180822657, b0, b1, b2)
        Call BesselM1NextCheb(y, -0.353155960776545, b0, b1, b2)
        Call BesselM1NextCheb(y, 1.52530022733895, b0, b1, b2)
        V = 0.5 * (b0 - b2)
        Result = Log(z) * BesselI1(x) + V / x
    Else
        y = 8# / x - 2#
        Call BesselM1FirstCheb(-5.75674448366502E-18, b0, b1, b2)
        Call BesselM1NextCheb(y, 1.79405087314756E-17, b0, b1, b2)
        Call BesselM1NextCheb(y, -5.68946255844286E-17, b0, b1, b2)
        Call BesselM1NextCheb(y, 1.83809354436664E-16, b0, b1, b2)
        Call BesselM1NextCheb(y, -6.05704724837332E-16, b0, b1, b2)
        Call BesselM1NextCheb(y, 2.03870316562433E-15, b0, b1, b2)
        Call BesselM1NextCheb(y, -7.01983709041831E-15, b0, b1, b2)
        Call BesselM1NextCheb(y, 2.4771544244813E-14, b0, b1, b2)
        Call BesselM1NextCheb(y, -8.97670518232499E-14, b0, b1, b2)
        Call BesselM1NextCheb(y, 3.34841966607843E-13, b0, b1, b2)
        Call BesselM1NextCheb(y, -1.28917396095103E-12, b0, b1, b2)
        Call BesselM1NextCheb(y, 5.13963967348173E-12, b0, b1, b2)
        Call BesselM1NextCheb(y, -2.12996783842757E-11, b0, b1, b2)
        Call BesselM1NextCheb(y, 9.21831518760501E-11, b0, b1, b2)
        Call BesselM1NextCheb(y, -4.1903547593419E-10, b0, b1, b2)
        Call BesselM1NextCheb(y, 2.01504975519703E-09, b0, b1, b2)
        Call BesselM1NextCheb(y, -1.03457624656781E-08, b0, b1, b2)
        Call BesselM1NextCheb(y, 5.74108412545005E-08, b0, b1, b2)
        Call BesselM1NextCheb(y, -3.50196060308781E-07, b0, b1, b2)
        Call BesselM1NextCheb(y, 2.40648494783722E-06, b0, b1, b2)
        Call BesselM1NextCheb(y, -1.93619797416608E-05, b0, b1, b2)
        Call BesselM1NextCheb(y, 1.95215518471352E-04, b0, b1, b2)
        Call BesselM1NextCheb(y, -2.85781685962278E-03, b0, b1, b2)
        Call BesselM1NextCheb(y, 0.103923736576817, b0, b1, b2)
        Call BesselM1NextCheb(y, 2.72062619048444, b0, b1, b2)
        V = 0.5 * (b0 - b2)
        Result = Exp(-x) * V / Sqr(x)
    End If
    BesselK1 = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Modified Bessel function, second kind, integer order
'
'Returns modified Bessel function of the second kind
'of order n of the argument.
'
'The range is partitioned into the two intervals [0,9.55] and
'(9.55, infinity).  An ascending power series is used in the
'low range, and an asymptotic expansion in the high range.
'
'ACCURACY:
'
'                     Relative error:
'arithmetic   domain     # trials      peak         rms
'   IEEE      0,30        90000       1.8e-8      3.0e-10
'
'Error is high only near the crossover point x = 9.55
'between the two expansions used.
'
'Cephes Math Library Release 2.8:  June, 2000
'Copyright 1984, 1987, 1988, 2000 by Stephen L. Moshier
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function BesselKN(ByVal NN As Long, ByVal x As Double) As Double
    Dim Result As Double
    Dim K As Double
    Dim KF As Double
    Dim nk1f As Double
    Dim nkf As Double
    Dim zn As Double
    Dim t As Double
    Dim s As Double
    Dim z0 As Double
    Dim z As Double
    Dim ans As Double
    Dim FN As Double
    Dim pn As Double
    Dim pk As Double
    Dim zmn As Double
    Dim tlg As Double
    Dim tox As Double
    Dim i As Long
    Dim N As Long
    Dim EUL As Double
    EUL = 0.577215664901533
    If NN < 0# Then
        N = -NN
    Else
        N = NN
    End If
    If x <= 9.55 Then
        ans = 0#
        z0 = 0.25 * x * x
        FN = 1#
        pn = 0#
        zmn = 1#
        tox = 2# / x
        If N > 0# Then
            pn = -EUL
            K = 1#
            For i = 1# To N - 1# Step 1
                pn = pn + 1# / K
                K = K + 1#
                FN = FN * K
            Next i
            zmn = tox
            If N = 1# Then
                ans = 1# / x
            Else
                nk1f = FN / N
                KF = 1#
                s = nk1f
                z = -z0
                zn = 1#
                For i = 1# To N - 1# Step 1
                    nk1f = nk1f / (N - i)
                    KF = KF * i
                    zn = zn * z
                    t = nk1f * zn / KF
                    s = s + t
                    zmn = zmn * tox
                Next i
                s = s * 0.5
                t = Abs(s)
                ans = s * zmn
            End If
        End If
        tlg = 2# * Log(0.5 * x)
        pk = -EUL
        If N = 0# Then
            pn = pk
            t = 1#
        Else
            pn = pn + 1# / N
            t = 1# / FN
        End If
        s = (pk + pn - tlg) * t
        K = 1#
        Do
            t = t * (z0 / (K * (K + N)))
            pk = pk + 1# / K
            pn = pn + 1# / (K + N)
            s = s + (pk + pn - tlg) * t
            K = K + 1#
        Loop Until Abs(t / s) <= MachineEpsilon
        s = 0.5 * s / zmn
        If N Mod 2# <> 0# Then
            s = -s
        End If
        ans = ans + s
        Result = ans
        BesselKN = Result
        Exit Function
    End If
    If x > Log(MaxRealNumber) Then
        Result = 0#
        BesselKN = Result
        Exit Function
    End If
    K = N
    pn = 4# * K * K
    pk = 1#
    z0 = 8# * x
    FN = 1#
    t = 1#
    s = t
    nkf = MaxRealNumber
    i = 0#
    Do
        z = pn - pk * pk
        t = t * z / (FN * z0)
        nk1f = Abs(t)
        If i >= N And nk1f > nkf Then
            Exit Do
        End If
        nkf = nk1f
        s = s + t
        FN = FN + 1#
        pk = pk + 2#
        i = i + 1#
    Loop Until Abs(t / s) <= MachineEpsilon
    Result = Exp(-x) * Sqr(pi() / (2# * x)) * s
    BesselKN = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal subroutine
'
'Cephes Math Library Release 2.8:  June, 2000
'Copyright 1984, 1987, 2000 by Stephen L. Moshier
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub BesselMFirstCheb(ByVal C As Double, _
         ByRef b0 As Double, _
         ByRef b1 As Double, _
         ByRef b2 As Double)
    b0 = C
    b1 = 0#
    b2 = 0#
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal subroutine
'
'Cephes Math Library Release 2.8:  June, 2000
'Copyright 1984, 1987, 2000 by Stephen L. Moshier
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub BesselMNextCheb(ByVal x As Double, _
         ByVal C As Double, _
         ByRef b0 As Double, _
         ByRef b1 As Double, _
         ByRef b2 As Double)
    b2 = b1
    b1 = b0
    b0 = x * b1 - b2 + C
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal subroutine
'
'Cephes Math Library Release 2.8:  June, 2000
'Copyright 1984, 1987, 2000 by Stephen L. Moshier
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub BesselM1FirstCheb(ByVal C As Double, _
         ByRef b0 As Double, _
         ByRef b1 As Double, _
         ByRef b2 As Double)
    b0 = C
    b1 = 0#
    b2 = 0#
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal subroutine
'
'Cephes Math Library Release 2.8:  June, 2000
'Copyright 1984, 1987, 2000 by Stephen L. Moshier
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub BesselM1NextCheb(ByVal x As Double, _
         ByVal C As Double, _
         ByRef b0 As Double, _
         ByRef b1 As Double, _
         ByRef b2 As Double)
    b2 = b1
    b1 = b0
    b0 = x * b1 - b2 + C
End Sub
Private Sub BesselAsympt0(ByVal x As Double, _
         ByRef PZero As Double, _
         ByRef QZero As Double)
    Dim XSq As Double
    Dim p2 As Double
    Dim Q2 As Double
    Dim P3 As Double
    Dim Q3 As Double
    XSq = 64# / (x * x)
    p2 = 0#
    p2 = 2485.2719289574 + XSq * p2
    p2 = 153982.653262391 + XSq * p2
    p2 = 2016135.28304998 + XSq * p2
    p2 = 8413041.45655044 + XSq * p2
    p2 = 12332384.7681764 + XSq * p2
    p2 = 5393485.08386944 + XSq * p2
    Q2 = 1#
    Q2 = 2615.70073692084 + XSq * Q2
    Q2 = 156001.727694003 + XSq * Q2
    Q2 = 2025066.80157013 + XSq * Q2
    Q2 = 8426449.0506298 + XSq * Q2
    Q2 = 12338310.2278633 + XSq * Q2
    Q2 = 5393485.08386944 + XSq * Q2
    P3 = -0#
    P3 = -4.88719939584126 + XSq * P3
    P3 = -226.26306419337 + XSq * P3
    P3 = -2365.95617077911 + XSq * P3
    P3 = -8239.06631348561 + XSq * P3
    P3 = -10381.4169874846 + XSq * P3
    P3 = -3984.61735759522 + XSq * P3
    Q3 = 1#
    Q3 = 408.77146739835 + XSq * Q3
    Q3 = 15704.891915154 + XSq * Q3
    Q3 = 156021.320667929 + XSq * Q3
    Q3 = 533291.36342169 + XSq * Q3
    Q3 = 666745.423931983 + XSq * Q3
    Q3 = 255015.510886094 + XSq * Q3
    PZero = p2 / Q2
    QZero = 8# * P3 / Q3 / x
End Sub
Private Sub BesselAsympt1(ByVal x As Double, _
         ByRef PZero As Double, _
         ByRef QZero As Double)
    Dim XSq As Double
    Dim p2 As Double
    Dim Q2 As Double
    Dim P3 As Double
    Dim Q3 As Double
    XSq = 64# / (x * x)
    p2 = -1611.61664432461
    p2 = -109824.055434593 + XSq * p2
    p2 = -1523529.35118114 + XSq * p2
    p2 = -6603373.24836494 + XSq * p2
    p2 = -9942246.50507764 + XSq * p2
    p2 = -4435757.81679413 + XSq * p2
    Q2 = 1#
    Q2 = -1455.0094401905 + XSq * Q2
    Q2 = -107263.859911038 + XSq * Q2
    Q2 = -1511809.50663416 + XSq * Q2
    Q2 = -6585339.47972309 + XSq * Q2
    Q2 = -9934124.38993459 + XSq * Q2
    Q2 = -4435757.81679413 + XSq * Q2
    P3 = 35.265133846636
    P3 = 1706.37542902077 + XSq * P3
    P3 = 18494.2628732239 + XSq * P3
    P3 = 66178.8365812708 + XSq * P3
    P3 = 85145.1606753357 + XSq * P3
    P3 = 33220.9134098572 + XSq * P3
    Q3 = 1#
    Q3 = 863.836776960499 + XSq * Q3
    Q3 = 37890.2297457722 + XSq * Q3
    Q3 = 400294.43582267 + XSq * Q3
    Q3 = 1419460.66960372 + XSq * Q3
    Q3 = 1819458.042244 + XSq * Q3
    Q3 = 708712.819410287 + XSq * Q3
    PZero = p2 / Q2
    QZero = 8# * P3 / Q3 / x
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Cephes Math Library Release 2.8:  June, 2000
'Copyright by Stephen L. Moshier
'
'Contributors:
'    * Sergey Bochkanov (ALGLIB project). Translation from C to
'      pseudocode.
'
'See subroutines comments for additional copyrights.
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Beta function
'
'
'                  -     -
'                 | (a) | (b)
'beta( a, b )  =  -----------.
'                    -
'                   | (a+b)
'
'For large arguments the logarithm of the function is
'evaluated using lgam(), then exponentiated.
'
'ACCURACY:
'
'                     Relative error:
'arithmetic   domain     # trials      peak         rms
'   IEEE       0,30       30000       8.1e-14     1.1e-14
'
'Cephes Math Library Release 2.0:  April, 1987
'Copyright 1984, 1987 by Stephen L. Moshier
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function beta(ByVal a As Double, ByVal B As Double) As Double
    Dim Result As Double
    Dim y As Double
    Dim sg As Double
    Dim s As Double
    sg = 1#
    y = a + B
    If Abs(y) > 171.624376956303 Then
        y = LnGamma(y, s)
        sg = sg * s
        y = LnGamma(B, s) - y
        sg = sg * s
        y = LnGamma(a, s) + y
        sg = sg * s
        Result = sg * Exp(y)
        beta = Result
        Exit Function
    End If
    y = Gamma(y)
    If a > B Then
        y = Gamma(a) / y
        y = y * Gamma(B)
    Else
        y = Gamma(B) / y
        y = y * Gamma(a)
    End If
    Result = y
    beta = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Cephes Math Library Release 2.8:  June, 2000
'Copyright by Stephen L. Moshier
'
'Contributors:
'    * Sergey Bochkanov (ALGLIB project). Translation from C to
'      pseudocode.
'
'See subroutines comments for additional copyrights.
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Gamma function
'
'Input parameters:
'    X   -   argument
'
'Domain:
'    0 < X < 171.6
'    -170 < X < 0, X is not an integer.
'
'Relative error:
' arithmetic   domain     # trials      peak         rms
'    IEEE    -170,-33      20000       2.3e-15     3.3e-16
'    IEEE     -33,  33     20000       9.4e-16     2.2e-16
'    IEEE      33, 171.6   20000       2.3e-15     3.2e-16
'
'Cephes Math Library Release 2.8:  June, 2000
'Original copyright 1984, 1987, 1989, 1992, 2000 by Stephen L. Moshier
'Translated to AlgoPascal by Bochkanov Sergey (2005, 2006, 2007).
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function Gamma(ByVal x As Double) As Double
    Dim Result As Double
    Dim p As Double
    Dim PP As Double
    Dim q As Double
    Dim QQ As Double
    Dim z As Double
    Dim i As Long
    Dim SgnGam As Double
    SgnGam = 1#
    q = Abs(x)
    If q > 33# Then
        If x < 0# Then
            p = Int(q)
            i = Round(p)
            If i Mod 2# = 0# Then
                SgnGam = -1#
            End If
            z = q - p
            If z > 0.5 Then
                p = p + 1#
                z = q - p
            End If
            z = q * Sin(pi() * z)
            z = Abs(z)
            z = pi() / (z * GammaStirF(q))
        Else
            z = GammaStirF(x)
        End If
        Result = SgnGam * z
        Gamma = Result
        Exit Function
    End If
    z = 1#
    Do While x >= 3#
        x = x - 1#
        z = z * x
    Loop
    Do While x < 0#
        If x > -0.000000001 Then
            Result = z / ((1# + 0.577215664901533 * x) * x)
            Gamma = Result
            Exit Function
        End If
        z = z / x
        x = x + 1#
    Loop
    Do While x < 2#
        If x < 0.000000001 Then
            Result = z / ((1# + 0.577215664901533 * x) * x)
            Gamma = Result
            Exit Function
        End If
        z = z / x
        x = x + 1#
    Loop
    If x = 2# Then
        Result = z
        Gamma = Result
        Exit Function
    End If
    x = x - 2#
    PP = 1.60119522476752E-04
    PP = 1.19135147006586E-03 + x * PP
    PP = 1.04213797561762E-02 + x * PP
    PP = 4.76367800457137E-02 + x * PP
    PP = 0.207448227648436 + x * PP
    PP = 0.494214826801497 + x * PP
    PP = 1# + x * PP
    QQ = -2.3158187332412E-05
    QQ = 5.39605580493303E-04 + x * QQ
    QQ = -4.45641913851797E-03 + x * QQ
    QQ = 0.011813978522206 + x * QQ
    QQ = 3.58236398605499E-02 + x * QQ
    QQ = -0.234591795718243 + x * QQ
    QQ = 7.14304917030273E-02 + x * QQ
    QQ = 1# + x * QQ
    Result = z * PP / QQ
    Gamma = Result
    Exit Function
    Gamma = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Natural logarithm of gamma function
'
'Input parameters:
'    X       -   argument
'
'Result:
'    logarithm of the absolute value of the Gamma(X).
'
'Output parameters:
'    SgnGam  -   sign(Gamma(X))
'
'Domain:
'    0 < X < 2.55e305
'    -2.55e305 < X < 0, X is not an integer.
'
'ACCURACY:
'arithmetic      domain        # trials     peak         rms
'   IEEE    0, 3                 28000     5.4e-16     1.1e-16
'   IEEE    2.718, 2.556e305     40000     3.5e-16     8.3e-17
'The error criterion was relative when the function magnitude
'was greater than one but absolute when it was less than one.
'
'The following test used the relative error criterion, though
'at certain points the relative error could be much higher than
'indicated.
'   IEEE    -200, -4             10000     4.8e-16     1.3e-16
'
'Cephes Math Library Release 2.8:  June, 2000
'Copyright 1984, 1987, 1989, 1992, 2000 by Stephen L. Moshier
'Translated to AlgoPascal by Bochkanov Sergey (2005, 2006, 2007).
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function LnGamma(ByVal x As Double, ByRef SgnGam As Double) As Double
    Dim Result As Double
    Dim a As Double
    Dim B As Double
    Dim C As Double
    Dim p As Double
    Dim q As Double
    Dim U As Double
    Dim w As Double
    Dim z As Double
    Dim i As Long
    Dim LogPi As Double
    Dim LS2PI As Double
    Dim tmp As Double
    SgnGam = 1#
    LogPi = 1.1447298858494
    LS2PI = 0.918938533204673
    If x < -34# Then
        q = -x
        w = LnGamma(q, tmp)
        p = Int(q)
        i = Round(p)
        If i Mod 2# = 0# Then
            SgnGam = -1#
        Else
            SgnGam = 1#
        End If
        z = q - p
        If z > 0.5 Then
            p = p + 1#
            z = p - q
        End If
        z = q * Sin(pi() * z)
        Result = LogPi - Log(z) - w
        LnGamma = Result
        Exit Function
    End If
    If x < 13# Then
        z = 1#
        p = 0#
        U = x
        Do While U >= 3#
            p = p - 1#
            U = x + p
            z = z * U
        Loop
        Do While U < 2#
            z = z / U
            p = p + 1#
            U = x + p
        Loop
        If z < 0# Then
            SgnGam = -1#
            z = -z
        Else
            SgnGam = 1#
        End If
        If U = 2# Then
            Result = Log(z)
            LnGamma = Result
            Exit Function
        End If
        p = p - 2#
        x = x + p
        B = -1378.25152569121
        B = -38801.6315134638 + x * B
        B = -331612.992738871 + x * B
        B = -1162370.97492762 + x * B
        B = -1721737.0082084 + x * B
        B = -853555.664245765 + x * B
        C = 1#
        C = -351.815701436523 + x * C
        C = -17064.2106651881 + x * C
        C = -220528.590553854 + x * C
        C = -1139334.44367983 + x * C
        C = -2532523.07177583 + x * C
        C = -2018891.41433533 + x * C
        p = x * B / C
        Result = Log(z) + p
        LnGamma = Result
        Exit Function
    End If
    q = (x - 0.5) * Log(x) - x + LS2PI
    If x > 100000000# Then
        Result = q
        LnGamma = Result
        Exit Function
    End If
    p = 1# / (x * x)
    If x >= 1000# Then
        q = q + ((7.93650793650794 * 0.0001 * p - 2.77777777777778 * 0.001) * p + 8.33333333333333E-02) / x
    Else
        a = 8.11614167470508 * 0.0001
        a = -(5.95061904284301 * 0.0001) + p * a
        a = 7.93650340457717 * 0.0001 + p * a
        a = -(2.777777777301 * 0.001) + p * a
        a = 8.33333333333332 * 0.01 + p * a
        q = q + a / x
    End If
    Result = q
    LnGamma = Result
End Function
Private Function GammaStirF(ByVal x As Double) As Double
    Dim Result As Double
    Dim y As Double
    Dim w As Double
    Dim V As Double
    Dim Stir As Double
    w = 1# / x
    Stir = 7.87311395793094E-04
    Stir = -2.29549961613378E-04 + w * Stir
    Stir = -2.68132617805781E-03 + w * Stir
    Stir = 3.47222221605459E-03 + w * Stir
    Stir = 8.33333333333482E-02 + w * Stir
    w = 1# + w * Stir
    y = Exp(x)
    If x > 143.01608 Then
        V = Power(x, 0.5 * x - 0.25)
        y = V * (V / y)
    Else
        y = Power(x, x - 0.5) / y
    End If
    Result = 2.506628274631 * y * w
    GammaStirF = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Cephes Math Library Release 2.8:  June, 2000
'Copyright by Stephen L. Moshier
'
'Contributors:
'    * Sergey Bochkanov (ALGLIB project). Translation from C to
'      pseudocode.
'
'See subroutines comments for additional copyrights.
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Exponential integral Ei(x)
'
'              x
'               -     t
'              | |   e
'   Ei(x) =   -|-   ---  dt .
'            | |     t
'             -
'            -inf
'
'Not defined for x <= 0.
'See also expn.c.
'
'
'
'ACCURACY:
'
'                     Relative error:
'arithmetic   domain     # trials      peak         rms
'   IEEE       0,100       50000      8.6e-16     1.3e-16
'
'Cephes Math Library Release 2.8:  May, 1999
'Copyright 1999 by Stephen L. Moshier
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function ExponentialIntegralEI(ByVal x As Double) As Double
    Dim Result As Double
    Dim EUL As Double
    Dim f As Double
    Dim F1 As Double
    Dim F2 As Double
    Dim w As Double
    EUL = 0.577215664901533
    If x <= 0# Then
        Result = 0#
        ExponentialIntegralEI = Result
        Exit Function
    End If
    If x < 2# Then
        F1 = -5.35044735781254
        F1 = F1 * x + 218.504916881661
        F1 = F1 * x - 4176.57238482669
        F1 = F1 * x + 55411.7675639356
        F1 = F1 * x - 331338.133117814
        F1 = F1 * x + 1592627.16338495
        F2 = 1#
        F2 = F2 * x - 52.5054795911286
        F2 = F2 * x + 1259.61618678679
        F2 = F2 * x - 17565.4958197353
        F2 = F2 * x + 149306.211700273
        F2 = F2 * x - 729494.923964053
        F2 = F2 * x + 1592627.16338495
        f = F1 / F2
        Result = EUL + Log(x) + x * f
        ExponentialIntegralEI = Result
        Exit Function
    End If
    If x < 4# Then
        w = 1# / x
        F1 = 1.98180850325969E-02
        F1 = F1 * w - 1.27164562598492
        F1 = F1 * w - 2.08816033568123
        F1 = F1 * w + 2.75554450918794
        F1 = F1 * w - 0.44095070487016
        F1 = F1 * w + 4.66562380593589E-02
        F1 = F1 * w - 1.54504267967349E-03
        F1 = F1 * w + 7.05998060529962E-05
        F2 = 1#
        F2 = F2 * w + 1.47649867091492
        F2 = F2 * w + 0.562917717482244
        F2 = F2 * w + 0.169901789787931
        F2 = F2 * w + 2.29164717903421E-02
        F2 = F2 * w + 4.45015043972875E-03
        F2 = F2 * w + 1.72743961220652E-04
        F2 = F2 * w + 3.95316719554967E-05
        f = F1 / F2
        Result = Exp(x) * w * (1# + w * f)
        ExponentialIntegralEI = Result
        Exit Function
    End If
    If x < 8# Then
        w = 1# / x
        F1 = -1.37321537587121
        F1 = F1 * w - 0.708455913374084
        F1 = F1 * w + 1.58080685554794
        F1 = F1 * w - 0.260150042742562
        F1 = F1 * w + 2.99467469411371E-02
        F1 = F1 * w - 1.03808604018874E-03
        F1 = F1 * w + 4.37106442075301E-05
        F1 = F1 * w + 2.1417836795226E-06
        F2 = 1#
        F2 = F2 * w + 0.858523142362203
        F2 = F2 * w + 0.4483285822874
        F2 = F2 * w + 7.68793215812448E-02
        F2 = F2 * w + 2.44986824102189E-02
        F2 = F2 * w + 8.8321659419278E-04
        F2 = F2 * w + 4.59095229951135E-04
        F2 = F2 * w + -4.72984835186652E-06
        F2 = F2 * w + 2.66519553739071E-06
        f = F1 / F2
        Result = Exp(x) * w * (1# + w * f)
        ExponentialIntegralEI = Result
        Exit Function
    End If
    If x < 16# Then
        w = 1# / x
        F1 = -2.10693460169192
        F1 = F1 * w + 1.73273386966469
        F1 = F1 * w - 0.242361917893584
        F1 = F1 * w + 2.32272418093757E-02
        F1 = F1 * w + 2.37288044049318E-04
        F1 = F1 * w - 8.34321956119255E-05
        F1 = F1 * w + 1.36340879560525E-05
        F1 = F1 * w - 3.65541232199925E-07
        F1 = F1 * w + 1.46494173397596E-08
        F1 = F1 * w + 6.17640786371036E-10
        F2 = 1#
        F2 = F2 * w - 0.229806223990168
        F2 = F2 * w + 0.110507704147404
        F2 = F2 * w - 1.56654296663079E-02
        F2 = F2 * w + 2.76110685081735E-03
        F2 = F2 * w - 2.08914801228405E-04
        F2 = F2 * w + 1.70852893880768E-05
        F2 = F2 * w - 4.45931179635669E-07
        F2 = F2 * w + 1.39463493035385E-08
        F2 = F2 * w + 6.15086593397734E-10
        f = F1 / F2
        Result = Exp(x) * w * (1# + w * f)
        ExponentialIntegralEI = Result
        Exit Function
    End If
    If x < 32# Then
        w = 1# / x
        F1 = -0.245811936767402
        F1 = F1 * w - 0.148338225332208
        F1 = F1 * w + 7.24829179573555E-02
        F1 = F1 * w - 1.34831568738094E-02
        F1 = F1 * w + 1.34277506978864E-03
        F1 = F1 * w - 7.94246563715971E-05
        F1 = F1 * w + 2.64417951898424E-06
        F1 = F1 * w - 4.23947365931377E-08
        F2 = 1#
        F2 = F2 * w - 0.104422590844387
        F2 = F2 * w - 0.26764531281014
        F2 = F2 * w + 9.69500025462198E-02
        F2 = F2 * w - 1.60174569271299E-02
        F2 = F2 * w + 1.49641489920591E-03
        F2 = F2 * w - 8.46245256377849E-05
        F2 = F2 * w + 2.72893840347673E-06
        F2 = F2 * w - 4.23946243181954E-08
        f = F1 / F2
        Result = Exp(x) * w * (1# + w * f)
        ExponentialIntegralEI = Result
        Exit Function
    End If
    If x < 64# Then
        w = 1# / x
        F1 = 0.121256111810546
        F1 = F1 * w - 0.582313317904389
        F1 = F1 * w + 0.234888731455702
        F1 = F1 * w - 3.04003431811325E-02
        F1 = F1 * w + 1.51008214686519E-03
        F1 = F1 * w - 2.52313709549957E-05
        F2 = 1#
        F2 = F2 * w - 1.00225215036585
        F2 = F2 * w + 0.292870969487222
        F2 = F2 * w - 3.33700433867401E-02
        F2 = F2 * w + 1.56054488112739E-03
        F2 = F2 * w - 2.52313709360323E-05
        f = F1 / F2
        Result = Exp(x) * w * (1# + w * f)
        ExponentialIntegralEI = Result
        Exit Function
    End If
    w = 1# / x
    F1 = -0.765784707828613
    F1 = F1 * w + 0.688619241556671
    F1 = F1 * w - 0.213259811354521
    F1 = F1 * w + 3.34610755238419E-02
    F1 = F1 * w - 3.07654147734476E-03
    F1 = F1 * w + 1.74711931645491E-04
    F1 = F1 * w - 6.10371168227417E-06
    F1 = F1 * w + 1.21803276542865E-07
    F1 = F1 * w - 1.08607610279329E-09
    F2 = 1#
    F2 = F2 * w - 1.88880286866231
    F2 = F2 * w + 1.06669168721141
    F2 = F2 * w - 0.275191598230638
    F2 = F2 * w + 3.93085268823382E-02
    F2 = F2 * w - 3.41468455860237E-03
    F2 = F2 * w + 1.86684437070356E-04
    F2 = F2 * w - 6.34514608313052E-06
    F2 = F2 * w + 1.23975428748321E-07
    F2 = F2 * w - 1.08607610279313E-09
    f = F1 / F2
    Result = Exp(x) * w * (1# + w * f)
    ExponentialIntegralEI = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Exponential integral En(x)
'
'Evaluates the exponential integral
'
'                inf.
'                  -
'                 | |   -xt
'                 |    e
'     E (x)  =    |    ----  dt.
'      n          |      n
'               | |     t
'                -
'                 1
'
'
'Both n and x must be nonnegative.
'
'The routine employs either a power series, a continued
'fraction, or an asymptotic formula depending on the
'relative values of n and x.
'
'ACCURACY:
'
'                     Relative error:
'arithmetic   domain     # trials      peak         rms
'   IEEE      0, 30       10000       1.7e-15     3.6e-16
'
'Cephes Math Library Release 2.8:  June, 2000
'Copyright 1985, 2000 by Stephen L. Moshier
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function ExponentialIntegralEN(ByVal x As Double, _
         ByVal N As Long) As Double
    Dim Result As Double
    Dim R As Double
    Dim t As Double
    Dim YK As Double
    Dim XK As Double
    Dim pk As Double
    Dim pkm1 As Double
    Dim pkm2 As Double
    Dim qk As Double
    Dim qkm1 As Double
    Dim qkm2 As Double
    Dim Psi As Double
    Dim z As Double
    Dim i As Long
    Dim K As Long
    Dim big As Double
    Dim EUL As Double
    EUL = 0.577215664901533
    big = 1.44115188075856 * Power(10#, 17#)
    If N < 0# Or x < 0# Or x > 170# Or x = 0# And N < 2# Then
        Result = -1#
        ExponentialIntegralEN = Result
        Exit Function
    End If
    If x = 0# Then
        Result = 1# / (N - 1#)
        ExponentialIntegralEN = Result
        Exit Function
    End If
    If N = 0# Then
        Result = Exp(-x) / x
        ExponentialIntegralEN = Result
        Exit Function
    End If
    If N > 5000# Then
        XK = x + N
        YK = 1# / (XK * XK)
        t = N
        Result = YK * t * (6# * x * x - 8# * t * x + t * t)
        Result = YK * (Result + t * (t - 2# * x))
        Result = YK * (Result + t)
        Result = (Result + 1#) * Exp(-x) / XK
        ExponentialIntegralEN = Result
        Exit Function
    End If
    If x <= 1# Then
        Psi = -EUL - Log(x)
        For i = 1# To N - 1# Step 1
            Psi = Psi + 1# / i
        Next i
        z = -x
        XK = 0#
        YK = 1#
        pk = 1# - N
        If N = 1# Then
            Result = 0#
        Else
            Result = 1# / pk
        End If
        Do
            XK = XK + 1#
            YK = YK * z / XK
            pk = pk + 1#
            If pk <> 0# Then
                Result = Result + YK / pk
            End If
            If Result <> 0# Then
                t = Abs(YK / Result)
            Else
                t = 1#
            End If
        Loop Until t < MachineEpsilon
        t = 1#
        For i = 1# To N - 1# Step 1
            t = t * z / i
        Next i
        Result = Psi * t - Result
        ExponentialIntegralEN = Result
        Exit Function
    Else
        K = 1#
        pkm2 = 1#
        qkm2 = x
        pkm1 = 1#
        qkm1 = x + N
        Result = pkm1 / qkm1
        Do
            K = K + 1#
            If K Mod 2# = 1# Then
                YK = 1#
                XK = N + (K - 1#) / 2#
            Else
                YK = x
                XK = K / 2#
            End If
            pk = pkm1 * YK + pkm2 * XK
            qk = qkm1 * YK + qkm2 * XK
            If qk <> 0# Then
                R = pk / qk
                t = Abs((Result - R) / R)
                Result = R
            Else
                t = 1#
            End If
            pkm2 = pkm1
            pkm1 = pk
            qkm2 = qkm1
            qkm1 = qk
            If Abs(pk) > big Then
                pkm2 = pkm2 / big
                pkm1 = pkm1 / big
                qkm2 = qkm2 / big
                qkm1 = qkm1 / big
            End If
        Loop Until t < MachineEpsilon
        Result = Result * Exp(-x)
    End If
    ExponentialIntegralEN = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Cephes Math Library Release 2.8:  June, 2000
'Copyright 1984, 1987, 1988, 1992, 2000 by Stephen L. Moshier
'
'Contributors:
'    * Sergey Bochkanov (ALGLIB project). Translation from C to
'      pseudocode.
'
'See subroutines comments for additional copyrights.
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Error function
'
'The integral is
'
'                          x
'                           -
'                2         | |          2
'  erf(x)  =  --------     |    exp( - t  ) dt.
'             sqrt(pi)   | |
'                         -
'                          0
'
'For 0 <= |x| < 1, erf(x) = x * P4(x**2)/Q5(x**2); otherwise
'erf(x) = 1 - erfc(x).
'
'
'ACCURACY:
'
'                     Relative error:
'arithmetic   domain     # trials      peak         rms
'   IEEE      0,1         30000       3.7e-16     1.0e-16
'
'Cephes Math Library Release 2.8:  June, 2000
'Copyright 1984, 1987, 1988, 1992, 2000 by Stephen L. Moshier
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function Erf(ByVal x As Double) As Double
    Dim Result As Double
    Dim XSq As Double
    Dim s As Double
    Dim p As Double
    Dim q As Double
    s = Sgn(x)
    x = Abs(x)
    If x < 0.5 Then
        XSq = x * x
        p = 7.54772803341863E-03
        p = 0.288805137207594 + XSq * p
        p = 14.3383842191748 + XSq * p
        p = 38.0140318123903 + XSq * p
        p = 3017.82788536508 + XSq * p
        p = 7404.07142710151 + XSq * p
        p = 80437.363096084 + XSq * p
        q = 0#
        q = 1# + XSq * q
        q = 38.0190713951939 + XSq * q
        q = 658.07015545924 + XSq * q
        q = 6379.60017324428 + XSq * q
        q = 34216.5257924629 + XSq * q
        q = 80437.363096084 + XSq * q
        Result = s * 1.12837916709551 * x * p / q
        Erf = Result
        Exit Function
    End If
    If x >= 10# Then
        Result = s
        Erf = Result
        Exit Function
    End If
    Result = s * (1# - ErfC(x))
    Erf = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Complementary error function
'
' 1 - erf(x) =
'
'                          inf.
'                            -
'                 2         | |          2
'  erfc(x)  =  --------     |    exp( - t  ) dt
'              sqrt(pi)   | |
'                          -
'                           x
'
'
'For small x, erfc(x) = 1 - erf(x); otherwise rational
'approximations are computed.
'
'
'ACCURACY:
'
'                     Relative error:
'arithmetic   domain     # trials      peak         rms
'   IEEE      0,26.6417   30000       5.7e-14     1.5e-14
'
'Cephes Math Library Release 2.8:  June, 2000
'Copyright 1984, 1987, 1988, 1992, 2000 by Stephen L. Moshier
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function ErfC(ByVal x As Double) As Double
    Dim Result As Double
    Dim p As Double
    Dim q As Double
    If x < 0# Then
        Result = 2# - ErfC(-x)
        ErfC = Result
        Exit Function
    End If
    If x < 0.5 Then
        Result = 1# - Erf(x)
        ErfC = Result
        Exit Function
    End If
    If x >= 10# Then
        Result = 0#
        ErfC = Result
        Exit Function
    End If
    p = 0#
    p = 0.56418778255074 + x * p
    p = 9.67580788298727 + x * p
    p = 77.0816173036843 + x * p
    p = 368.519615471001 + x * p
    p = 1143.26207070389 + x * p
    p = 2320.43959025164 + x * p
    p = 2898.02932921677 + x * p
    p = 1826.33488422951 + x * p
    q = 1#
    q = 17.1498094362761 + x * q
    q = 137.125596050062 + x * q
    q = 661.736120710765 + x * q
    q = 2094.38436778954 + x * q
    q = 4429.61280388368 + x * q
    q = 6089.54242327244 + x * q
    q = 4958.82756472114 + x * q
    q = 1826.33488422951 + x * q
    Result = Exp(-Square(x)) * p / q
    ErfC = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Normal distribution function
'
'Returns the area under the Gaussian probability density
'function, integrated from minus infinity to x:
'
'                           x
'                            -
'                  1        | |          2
'   ndtr(x)  = ---------    |    exp( - t /2 ) dt
'              sqrt(2pi)  | |
'                          -
'                         -inf.
'
'            =  ( 1 + erf(z) ) / 2
'            =  erfc(z) / 2
'
'where z = x/sqrt(2). Computation is via the functions
'erf and erfc.
'
'
'ACCURACY:
'
'                     Relative error:
'arithmetic   domain     # trials      peak         rms
'   IEEE     -13,0        30000       3.4e-14     6.7e-15
'
'Cephes Math Library Release 2.8:  June, 2000
'Copyright 1984, 1987, 1988, 1992, 2000 by Stephen L. Moshier
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function NormalDistribution(ByVal x As Double) As Double
    Dim Result As Double
    Result = 0.5 * (Erf(x / 1.4142135623731) + 1#)
    NormalDistribution = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Inverse of the error function
'
'Cephes Math Library Release 2.8:  June, 2000
'Copyright 1984, 1987, 1988, 1992, 2000 by Stephen L. Moshier
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function InvErf(ByVal e As Double) As Double
    Dim Result As Double
    Result = InvNormalDistribution(0.5 * (e + 1#)) / Sqr(2#)
    InvErf = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Inverse of Normal distribution function
'
'Returns the argument, x, for which the area under the
'Gaussian probability density function (integrated from
'minus infinity to x) is equal to y.
'
'
'For small arguments 0 < y < exp(-2), the program computes
'z = sqrt( -2.0 * log(y) );  then the approximation is
'x = z - log(z)/z  - (1/z) P(1/z) / Q(1/z).
'There are two rational functions P/Q, one for 0 < y < exp(-32)
'and the other for y up to exp(-2).  For larger arguments,
'w = y - 0.5, and  x/sqrt(2pi) = w + w**3 R(w**2)/S(w**2)).
'
'ACCURACY:
'
'                     Relative error:
'arithmetic   domain        # trials      peak         rms
'   IEEE     0.125, 1        20000       7.2e-16     1.3e-16
'   IEEE     3e-308, 0.135   50000       4.6e-16     9.8e-17
'
'Cephes Math Library Release 2.8:  June, 2000
'Copyright 1984, 1987, 1988, 1992, 2000 by Stephen L. Moshier
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function InvNormalDistribution(ByVal y0 As Double) As Double
    Dim Result As Double
    Dim Expm2 As Double
    Dim S2Pi As Double
    Dim x As Double
    Dim y As Double
    Dim z As Double
    Dim Y2 As Double
    Dim X0 As Double
    Dim X1 As Double
    Dim code As Long
    Dim P0 As Double
    Dim Q0 As Double
    Dim p1 As Double
    Dim Q1 As Double
    Dim p2 As Double
    Dim Q2 As Double
    Expm2 = 0.135335283236613
    S2Pi = 2.506628274631
    If y0 <= 0# Then
        Result = -MaxRealNumber
        InvNormalDistribution = Result
        Exit Function
    End If
    If y0 >= 1# Then
        Result = MaxRealNumber
        InvNormalDistribution = Result
        Exit Function
    End If
    code = 1#
    y = y0
    If y > 1# - Expm2 Then
        y = 1# - y
        code = 0#
    End If
    If y > Expm2 Then
        y = y - 0.5
        Y2 = y * y
        P0 = -59.9633501014108
        P0 = 98.0010754186 + Y2 * P0
        P0 = -56.676285746907 + Y2 * P0
        P0 = 13.931260938728 + Y2 * P0
        P0 = -1.23916583867381 + Y2 * P0
        Q0 = 1#
        Q0 = 1.95448858338142 + Y2 * Q0
        Q0 = 4.67627912898882 + Y2 * Q0
        Q0 = 86.3602421390891 + Y2 * Q0
        Q0 = -225.462687854119 + Y2 * Q0
        Q0 = 200.260212380061 + Y2 * Q0
        Q0 = -82.0372256168333 + Y2 * Q0
        Q0 = 15.9056225126212 + Y2 * Q0
        Q0 = -1.1833162112133 + Y2 * Q0
        x = y + y * Y2 * P0 / Q0
        x = x * S2Pi
        Result = x
        InvNormalDistribution = Result
        Exit Function
    End If
    x = Sqr(-(2# * Log(y)))
    X0 = x - Log(x) / x
    z = 1# / x
    If x < 8# Then
        p1 = 4.05544892305962
        p1 = 31.5251094599894 + z * p1
        p1 = 57.1628192246421 + z * p1
        p1 = 44.0805073893201 + z * p1
        p1 = 14.6849561928858 + z * p1
        p1 = 2.1866330685079 + z * p1
        p1 = -(1.40256079171354 * 0.1) + z * p1
        p1 = -(3.50424626827848 * 0.01) + z * p1
        p1 = -(8.57456785154685 * 0.0001) + z * p1
        Q1 = 1#
        Q1 = 15.7799883256467 + z * Q1
        Q1 = 45.3907635128879 + z * Q1
        Q1 = 41.3172038254672 + z * Q1
        Q1 = 15.0425385692908 + z * Q1
        Q1 = 2.50464946208309 + z * Q1
        Q1 = -(1.42182922854788 * 0.1) + z * Q1
        Q1 = -(3.80806407691578 * 0.01) + z * Q1
        Q1 = -(9.33259480895457 * 0.0001) + z * Q1
        X1 = z * p1 / Q1
    Else
        p2 = 3.23774891776946
        p2 = 6.91522889068984 + z * p2
        p2 = 3.93881025292474 + z * p2
        p2 = 1.33303460815808 + z * p2
        p2 = 2.01485389549179 * 0.1 + z * p2
        p2 = 1.2371663481782 * 0.01 + z * p2
        p2 = 3.01581553508235 * 0.0001 + z * p2
        p2 = 2.65806974686738 * 0.000001 + z * p2
        p2 = 6.23974539184983 * 0.000000001 + z * p2
        Q2 = 1#
        Q2 = 6.02427039364742 + z * Q2
        Q2 = 3.67983563856161 + z * Q2
        Q2 = 1.37702099489081 + z * Q2
        Q2 = 2.16236993594497 * 0.1 + z * Q2
        Q2 = 1.34204006088543 * 0.01 + z * Q2
        Q2 = 3.28014464682128 * 0.0001 + z * Q2
        Q2 = 2.89247864745381 * 0.000001 + z * Q2
        Q2 = 6.79019408009981 * 0.000000001 + z * Q2
        X1 = z * p2 / Q2
    End If
    x = X0 - X1
    If code <> 0# Then
        x = -x
    End If
    Result = x
    InvNormalDistribution = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Calculation of the value of the Hermite polynomial.
'
'Parameters:
'    n   -   degree, n>=0
'    x   -   argument
'
'Result:
'    the value of the Hermite polynomial Hn at x
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function HermiteCalculate(ByRef N As Long, ByRef x As Double) As Double
    Dim Result As Double
    Dim i As Long
    Dim a As Double
    Dim B As Double
    '
    ' Prepare A and B
    '
    a = 1#
    B = 2# * x
    '
    ' Special cases: N=0 or N=1
    '
    If N = 0# Then
        Result = a
        HermiteCalculate = Result
        Exit Function
    End If
    If N = 1# Then
        Result = B
        HermiteCalculate = Result
        Exit Function
    End If
    '
    ' General case: N>=2
    '
    For i = 2# To N Step 1
        Result = 2# * x * B - 2# * (i - 1#) * a
        a = B
        B = Result
    Next i
    HermiteCalculate = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Summation of Hermite polynomials using Clenshaws recurrence formula.
'
'This routine calculates
'    c[0]*H0(x) + c[1]*H1(x) + ... + c[N]*HN(x)
'
'Parameters:
'    n   -   degree, n>=0
'    x   -   argument
'
'Result:
'    the value of the Hermite polynomial at x
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function HermiteSum(ByRef C() As Double, _
         ByRef N As Long, _
         ByRef x As Double) As Double
    Dim Result As Double
    Dim b1 As Double
    Dim b2 As Double
    Dim i As Long
    b1 = 0#
    b2 = 0#
    For i = N To 0# Step -1
        Result = 2# * (x * b1 - (i + 1#) * b2) + C(i)
        b2 = b1
        b1 = Result
    Next i
    HermiteSum = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Representation of Hn as C[0] + C[1]*X + ... + C[N]*X^N
'
'Input parameters:
'    N   -   polynomial degree, n>=0
'
'Output parameters:
'    C   -   coefficients
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub HermiteCoefficients(ByRef N As Long, ByRef C() As Double)
    Dim i As Long
    ReDim C(0# To N)
    For i = 0# To N Step 1
        C(i) = 0#
    Next i
    C(N) = Exp(N * Log(2#))
    For i = 0# To N \ 2# - 1# Step 1
        C(N - 2# * (i + 1#)) = -(C(N - 2# * i) * (N - 2# * i) * (N - 2# * i - 1#) / 4# / (i + 1#))
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c)
'    2007, Sergey Bochkanov (ALGLIB project).
'    1988, Pierre L'Ecuyer
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'HQRNDState  initialization  with  random  values  which come from standard
'RNG.
'
'  -- ALGLIB --
'     Copyright 02.12.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub HQRNDRandomize(ByRef State As HQRNDState)
    Call HQRNDSeed(RandomInteger(HQRNDM1), RandomInteger(HQRNDM2), State)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'HQRNDState initialization with seed values
'
'  -- ALGLIB --
'     Copyright 02.12.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub HQRNDSeed(ByVal S1 As Long, _
         ByVal S2 As Long, _
         ByRef State As HQRNDState)
    State.S1 = S1 Mod (HQRNDM1 - 1#) + 1#
    State.S2 = S2 Mod (HQRNDM2 - 1#) + 1#
    State.V = 1# / HQRNDMax
    State.MagicV = HQRNDMagic
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function generates random real number in (0,1),
'not including interval boundaries
'
'State structure must be initialized with HQRNDRandomize() or HQRNDSeed().
'
'  -- ALGLIB --
'     Copyright 02.12.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function HQRNDUniformR(ByRef State As HQRNDState) As Double
    Dim Result As Double
    Result = State.V * HQRNDIntegerBase(State)
    HQRNDUniformR = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function generates random integer number in [0, N)
'
'1. N must be less than HQRNDMax-1.
'2. State structure must be initialized with HQRNDRandomize() or HQRNDSeed()
'
'  -- ALGLIB --
'     Copyright 02.12.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function HQRNDUniformI(ByVal N As Long, _
         ByRef State As HQRNDState) As Long
    Dim Result As Long
    Dim MX As Long
    '
    ' Correct handling of N's close to RNDBaseMax
    ' (avoiding skewed distributions for RNDBaseMax<>K*N)
    '
    MX = HQRNDMax - 1# - (HQRNDMax - 1#) Mod N
    Do
        Result = HQRNDIntegerBase(State) - 1#
    Loop Until Result < MX
    Result = Result Mod N
    HQRNDUniformI = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Random number generator: normal numbers
'
'This function generates one random number from normal distribution.
'Its performance is equal to that of HQRNDNormal2()
'
'State structure must be initialized with HQRNDRandomize() or HQRNDSeed().
'
'  -- ALGLIB --
'     Copyright 02.12.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function HQRNDNormal(ByRef State As HQRNDState) As Double
    Dim Result As Double
    Dim V1 As Double
    Dim V2 As Double
    Call HQRNDNormal2(State, V1, V2)
    Result = V1
    HQRNDNormal = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Random number generator: random X and Y such that X^2+Y^2=1
'
'State structure must be initialized with HQRNDRandomize() or HQRNDSeed().
'
'  -- ALGLIB --
'     Copyright 02.12.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub HQRNDUnit2(ByRef State As HQRNDState, _
         ByRef x As Double, _
         ByRef y As Double)
    Dim V As Double
    Dim MX As Double
    Dim MN As Double
    Do
        Call HQRNDNormal2(State, x, y)
    Loop Until x <> 0# Or y <> 0#
    MX = MaxReal(Abs(x), Abs(y))
    MN = MinReal(Abs(x), Abs(y))
    V = MX * Sqr(1# + Square(MN / MX))
    x = x / V
    y = y / V
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Random number generator: normal numbers
'
'This function generates two independent random numbers from normal
'distribution. Its performance is equal to that of HQRNDNormal()
'
'State structure must be initialized with HQRNDRandomize() or HQRNDSeed().
'
'  -- ALGLIB --
'     Copyright 02.12.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub HQRNDNormal2(ByRef State As HQRNDState, _
         ByRef X1 As Double, _
         ByRef X2 As Double)
    Dim U As Double
    Dim V As Double
    Dim s As Double
    Do While True
        U = 2# * HQRNDUniformR(State) - 1#
        V = 2# * HQRNDUniformR(State) - 1#
        s = Square(U) + Square(V)
        If s > 0# And s < 1# Then
            '
            ' two Sqrt's instead of one to
            ' avoid overflow when S is too small
            '
            s = Sqr(-(2# * Log(s))) / Sqr(s)
            X1 = U * s
            X2 = V * s
            Exit Sub
        End If
    Loop
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Random number generator: exponential distribution
'
'State structure must be initialized with HQRNDRandomize() or HQRNDSeed().
'
'  -- ALGLIB --
'     Copyright 11.08.2007 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function HQRNDExponential(ByVal lambda As Double, _
         ByRef State As HQRNDState) As Double
    Dim Result As Double
    Result = -(Log(HQRNDUniformR(State)) / lambda)
    HQRNDExponential = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
'L'Ecuyer, Efficient and portable combined random number generators
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Function HQRNDIntegerBase(ByRef State As HQRNDState) As Long
    Dim Result As Long
    Dim K As Long
    K = State.S1 \ 53668#
    State.S1 = 40014# * (State.S1 - K * 53668#) - K * 12211#
    If State.S1 < 0# Then
        State.S1 = State.S1 + 2147483563#
    End If
    K = State.S2 \ 52774#
    State.S2 = 40692# * (State.S2 - K * 52774#) - K * 3791#
    If State.S2 < 0# Then
        State.S2 = State.S2 + 2147483399#
    End If
    '
    ' Result
    '
    Result = State.S1 - State.S2
    If Result < 1# Then
        Result = Result + 2147483562#
    End If
    HQRNDIntegerBase = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2005-2009, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Integration of a smooth function F(x) on a finite interval [a,b].
'
'Fast-convergent algorithm based on a Gauss-Kronrod formula is used. Result
'is calculated with accuracy close to the machine precision.
'
'Algorithm works well only with smooth integrands.  It  may  be  used  with
'continuous non-smooth integrands, but with  less  performance.
'
'It should never be used with integrands which have integrable singularities
'at lower or upper limits - algorithm may crash. Use AutoGKSingular in such
'cases.
'
'INPUT PARAMETERS:
'    A, B    -   interval boundaries (A<B, A=B or A>B)
'
'OUTPUT PARAMETERS
'    State   -   structure which stores algorithm state between  subsequent
'                calls of AutoGKIteration.  Used for reverse communication.
'                This structure should be  passed  to  the  AutoGKIteration
'                subroutine.
'
'SEE ALSO
'    AutoGKSmoothW, AutoGKSingular, AutoGKIteration, AutoGKResults.
'
'
'  -- ALGLIB --
'     Copyright 06.05.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub AutoGKSmooth(ByVal a As Double, _
         ByVal B As Double, _
         ByRef State As AutoGKState)
    Call AutoGKSmoothW(a, B, 0#, State)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Integration of a smooth function F(x) on a finite interval [a,b].
'
'This subroutine is same as AutoGKSmooth(), but it guarantees that interval
'[a,b] is partitioned into subintervals which have width at most XWidth.
'
'Subroutine  can  be  used  when  integrating nearly-constant function with
'narrow "bumps" (about XWidth wide). If "bumps" are too narrow, AutoGKSmooth
'subroutine can overlook them.
'
'INPUT PARAMETERS:
'    A, B    -   interval boundaries (A<B, A=B or A>B)
'
'OUTPUT PARAMETERS
'    State   -   structure which stores algorithm state between  subsequent
'                calls of AutoGKIteration.  Used for reverse communication.
'                This structure should be  passed  to  the  AutoGKIteration
'                subroutine.
'
'SEE ALSO
'    AutoGKSmooth, AutoGKSingular, AutoGKIteration, AutoGKResults.
'
'
'  -- ALGLIB --
'     Copyright 06.05.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub AutoGKSmoothW(ByVal a As Double, _
         ByVal B As Double, _
         ByVal XWidth As Double, _
         ByRef State As AutoGKState)
    State.WrapperMode = 0#
    State.a = a
    State.B = B
    State.XWidth = XWidth
    ReDim State.RState.RA(0# To 10#)
    State.RState.Stage = -1#
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Integration on a finite interval [A,B].
'Integrand have integrable singularities at A/B.
'
'F(X) must diverge as "(x-A)^alpha" at A, as "(B-x)^beta" at B,  with known
'alpha/beta (alpha>-1, beta>-1).  If alpha/beta  are  not known,  estimates
'from below can be used (but these estimates should be greater than -1 too).
'
'One  of  alpha/beta variables (or even both alpha/beta) may be equal to 0,
'which means than function F(x) is non-singular at A/B. Anyway (singular at
'bounds or not), function F(x) is supposed to be continuous on (A,B).
'
'Fast-convergent algorithm based on a Gauss-Kronrod formula is used. Result
'is calculated with accuracy close to the machine precision.
'
'INPUT PARAMETERS:
'    A, B    -   interval boundaries (A<B, A=B or A>B)
'    Alpha   -   power-law coefficient of the F(x) at A,
'                Alpha>-1
'    Beta    -   power-law coefficient of the F(x) at B,
'                Beta>-1
'
'OUTPUT PARAMETERS
'    State   -   structure which stores algorithm state between  subsequent
'                calls of AutoGKIteration.  Used for reverse communication.
'                This structure should be  passed  to  the  AutoGKIteration
'                subroutine.
'
'SEE ALSO
'    AutoGKSmooth, AutoGKSmoothW, AutoGKIteration, AutoGKResults.
'
'
'  -- ALGLIB --
'     Copyright 06.05.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub AutoGKSingular(ByVal a As Double, _
         ByVal B As Double, _
         ByVal alpha As Double, _
         ByVal beta As Double, _
         ByRef State As AutoGKState)
    State.WrapperMode = 1#
    State.a = a
    State.B = B
    State.alpha = alpha
    State.beta = beta
    State.XWidth = 0#
    ReDim State.RState.RA(0# To 10#)
    State.RState.Stage = -1#
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'One step of adaptive integration process.
'
'Called after initialization with one of AutoGKXXX subroutines.
'See HTML documentation for examples.
'
'Input parameters:
'    State   -   structure which stores algorithm state between  calls  and
'                which  is  used  for   reverse   communication.   Must  be
'                initialized with one of AutoGKXXX subroutines.
'
'If suborutine returned False, iterative proces has converged. If subroutine
'returned True, caller should calculate function value State.F  at  State.X
'and call AutoGKIteration again.
'
'NOTE:
'
'When integrating "difficult" functions with integrable singularities like
'
'    F(x) = (x-A)^alpha * (B-x)^beta
'
'subroutine may require the value of F at points which are too close to A/B.
'Sometimes to calculate integral with high enough precision we  may need to
'calculate F(A+delta) when delta is less than machine  epsilon.  In  finite
'precision arithmetics A+delta will be effectively equal to A,  so  we  may
'find us in situation when  we  are  trying  to  calculate  something  like
'1/sqrt(1-1).
'
'To avoid  such  situations,  AutoGKIteration  subroutine  fills  not  only
'State.X  field,  but  also   State.XMinusA   (which  equals  to  X-A)  and
'State.BMinusX  (which  equals to B-X) fields.  If X is too close to A or B
'(X-A<0.001*A, or B-X<0.001*B, for example) use  these  fields  instead  of
'State.X
'
'
'  -- ALGLIB --
'     Copyright 07.05.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function AutoGKIteration(ByRef State As AutoGKState) As Boolean
    Dim Result As Boolean
    Dim s As Double
    Dim tmp As Double
    Dim eps As Double
    Dim a As Double
    Dim B As Double
    Dim x As Double
    Dim t As Double
    Dim alpha As Double
    Dim beta As Double
    Dim V1 As Double
    Dim V2 As Double
    '
    ' Reverse communication preparations
    ' I know it looks ugly, but it works the same way
    ' anywhere from C++ to Python.
    '
    ' This code initializes locals by:
    ' * random values determined during code
    '   generation - on first subroutine call
    ' * values from previous call - on subsequent calls
    '
    If State.RState.Stage >= 0# Then
        s = State.RState.RA(0#)
        tmp = State.RState.RA(1#)
        eps = State.RState.RA(2#)
        a = State.RState.RA(3#)
        B = State.RState.RA(4#)
        x = State.RState.RA(5#)
        t = State.RState.RA(6#)
        alpha = State.RState.RA(7#)
        beta = State.RState.RA(8#)
        V1 = State.RState.RA(9#)
        V2 = State.RState.RA(10#)
    Else
        s = -983#
        tmp = -989#
        eps = -834#
        a = 900#
        B = -287#
        x = 364#
        t = 214#
        alpha = -338#
        beta = -686#
        V1 = 912#
        V2 = 585#
    End If
    If State.RState.Stage = 0# Then
        GoTo lbl_0
    End If
    If State.RState.Stage = 1# Then
        GoTo lbl_1
    End If
    If State.RState.Stage = 2# Then
        GoTo lbl_2
    End If
    '
    ' Routine body
    '
    eps = 0#
    a = State.a
    B = State.B
    alpha = State.alpha
    beta = State.beta
    State.TerminationType = -1#
    State.NFEV = 0#
    State.NIntervals = 0#
    '
    ' smooth function  at a finite interval
    '
    If State.WrapperMode <> 0# Then
        GoTo lbl_3
    End If
    '
    ' special case
    '
    If a = B Then
        State.TerminationType = 1#
        State.V = 0#
        Result = False
        AutoGKIteration = Result
        Exit Function
    End If
    '
    ' general case
    '
    Call AutoGKInternalPrepare(a, B, eps, State.XWidth, State.InternalState)
lbl_5:
    If Not AutoGKInternalIteration(State.InternalState) Then
        GoTo lbl_6
    End If
    x = State.InternalState.x
    State.x = x
    State.XMinusA = x - a
    State.BMinusX = B - x
    State.RState.Stage = 0#
    GoTo lbl_rcomm
lbl_0:
    State.NFEV = State.NFEV + 1#
    State.InternalState.f = State.f
    GoTo lbl_5
lbl_6:
    State.V = State.InternalState.R
    State.TerminationType = State.InternalState.Info
    State.NIntervals = State.InternalState.HeapUsed
    Result = False
    AutoGKIteration = Result
    Exit Function
lbl_3:
    '
    ' function with power-law singularities at the ends of a finite interval
    '
    If State.WrapperMode <> 1# Then
        GoTo lbl_7
    End If
    '
    ' test coefficients
    '
    If alpha <= -1# Or beta <= -1# Then
        State.TerminationType = -1#
        State.V = 0#
        Result = False
        AutoGKIteration = Result
        Exit Function
    End If
    '
    ' special cases
    '
    If a = B Then
        State.TerminationType = 1#
        State.V = 0#
        Result = False
        AutoGKIteration = Result
        Exit Function
    End If
    '
    ' reduction to general form
    '
    If a < B Then
        s = 1#
    Else
        s = -1#
        tmp = a
        a = B
        B = tmp
        tmp = alpha
        alpha = beta
        beta = tmp
    End If
    alpha = MinReal(alpha, 0#)
    beta = MinReal(beta, 0#)
    '
    ' first, integrate left half of [a,b]:
    '     integral(f(x)dx, a, (b+a)/2) =
    '     = 1/(1+alpha) * integral(t^(-alpha/(1+alpha))*f(a+t^(1/(1+alpha)))dt, 0, (0.5*(b-a))^(1+alpha))
    '
    Call AutoGKInternalPrepare(0#, Power(0.5 * (B - a), 1# + alpha), eps, State.XWidth, State.InternalState)
lbl_9:
    If Not AutoGKInternalIteration(State.InternalState) Then
        GoTo lbl_10
    End If
    '
    ' Fill State.X, State.XMinusA, State.BMinusX.
    ' Latter two are filled correctly even if B<A.
    '
    x = State.InternalState.x
    t = Power(x, 1# / (1# + alpha))
    State.x = a + t
    If s > 0# Then
        State.XMinusA = t
        State.BMinusX = B - (a + t)
    Else
        State.XMinusA = a + t - B
        State.BMinusX = -t
    End If
    State.RState.Stage = 1#
    GoTo lbl_rcomm
lbl_1:
    If alpha <> 0# Then
        State.InternalState.f = State.f * Power(x, -(alpha / (1# + alpha))) / (1# + alpha)
    Else
        State.InternalState.f = State.f
    End If
    State.NFEV = State.NFEV + 1#
    GoTo lbl_9
lbl_10:
    V1 = State.InternalState.R
    State.NIntervals = State.NIntervals + State.InternalState.HeapUsed
    '
    ' then, integrate right half of [a,b]:
    '     integral(f(x)dx, (b+a)/2, b) =
    '     = 1/(1+beta) * integral(t^(-beta/(1+beta))*f(b-t^(1/(1+beta)))dt, 0, (0.5*(b-a))^(1+beta))
    '
    Call AutoGKInternalPrepare(0#, Power(0.5 * (B - a), 1# + beta), eps, State.XWidth, State.InternalState)
lbl_11:
    If Not AutoGKInternalIteration(State.InternalState) Then
        GoTo lbl_12
    End If
    '
    ' Fill State.X, State.XMinusA, State.BMinusX.
    ' Latter two are filled correctly (X-A, B-X) even if B<A.
    '
    x = State.InternalState.x
    t = Power(x, 1# / (1# + beta))
    State.x = B - t
    If s > 0# Then
        State.XMinusA = B - t - a
        State.BMinusX = t
    Else
        State.XMinusA = -t
        State.BMinusX = a - (B - t)
    End If
    State.RState.Stage = 2#
    GoTo lbl_rcomm
lbl_2:
    If beta <> 0# Then
        State.InternalState.f = State.f * Power(x, -(beta / (1# + beta))) / (1# + beta)
    Else
        State.InternalState.f = State.f
    End If
    State.NFEV = State.NFEV + 1#
    GoTo lbl_11
lbl_12:
    V2 = State.InternalState.R
    State.NIntervals = State.NIntervals + State.InternalState.HeapUsed
    '
    ' final result
    '
    State.V = s * (V1 + V2)
    State.TerminationType = 1#
    Result = False
    AutoGKIteration = Result
    Exit Function
lbl_7:
    Result = False
    AutoGKIteration = Result
    Exit Function
    '
    ' Saving state
    '
lbl_rcomm:
    Result = True
    State.RState.RA(0#) = s
    State.RState.RA(1#) = tmp
    State.RState.RA(2#) = eps
    State.RState.RA(3#) = a
    State.RState.RA(4#) = B
    State.RState.RA(5#) = x
    State.RState.RA(6#) = t
    State.RState.RA(7#) = alpha
    State.RState.RA(8#) = beta
    State.RState.RA(9#) = V1
    State.RState.RA(10#) = V2
    AutoGKIteration = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Adaptive integration results
'
'Called after AutoGKIteration returned False.
'
'Input parameters:
'    State   -   algorithm state (used by AutoGKIteration).
'
'Output parameters:
'    V       -   integral(f(x)dx,a,b)
'    Rep     -   optimization report (see AutoGKReport description)
'
'  -- ALGLIB --
'     Copyright 14.11.2007 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub AutoGKResults(ByRef State As AutoGKState, _
         ByRef V As Double, _
         ByRef Rep As AutoGKReport)
    V = State.V
    Rep.TerminationType = State.TerminationType
    Rep.NFEV = State.NFEV
    Rep.NIntervals = State.NIntervals
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal AutoGK subroutine
'eps<0   - error
'eps=0   - automatic eps selection
'
'width<0 -   error
'width=0 -   no width requirements
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub AutoGKInternalPrepare(ByVal a As Double, _
         ByVal B As Double, _
         ByVal eps As Double, _
         ByVal XWidth As Double, _
         ByRef State As AutoGKInternalState)
    '
    ' Save settings
    '
    State.a = a
    State.B = B
    State.eps = eps
    State.XWidth = XWidth
    '
    ' Prepare RComm structure
    '
    ReDim State.RState.IA(0# To 3#)
    ReDim State.RState.RA(0# To 8#)
    State.RState.Stage = -1#
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal AutoGK subroutine
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Function AutoGKInternalIteration(ByRef State As AutoGKInternalState) As Boolean
    Dim Result As Boolean
    Dim C1 As Double
    Dim C2 As Double
    Dim i As Long
    Dim j As Long
    Dim IntG As Double
    Dim IntK As Double
    Dim IntA As Double
    Dim V As Double
    Dim TA As Double
    Dim TB As Double
    Dim NS As Long
    Dim QEps As Double
    Dim Info As Long
    '
    ' Reverse communication preparations
    ' I know it looks ugly, but it works the same way
    ' anywhere from C++ to Python.
    '
    ' This code initializes locals by:
    ' * random values determined during code
    '   generation - on first subroutine call
    ' * values from previous call - on subsequent calls
    '
    If State.RState.Stage >= 0# Then
        i = State.RState.IA(0#)
        j = State.RState.IA(1#)
        NS = State.RState.IA(2#)
        Info = State.RState.IA(3#)
        C1 = State.RState.RA(0#)
        C2 = State.RState.RA(1#)
        IntG = State.RState.RA(2#)
        IntK = State.RState.RA(3#)
        IntA = State.RState.RA(4#)
        V = State.RState.RA(5#)
        TA = State.RState.RA(6#)
        TB = State.RState.RA(7#)
        QEps = State.RState.RA(8#)
    Else
        i = 497#
        j = -271#
        NS = -581#
        Info = 745#
        C1 = -533#
        C2 = -77#
        IntG = 678#
        IntK = -293#
        IntA = 316#
        V = 647#
        TA = -756#
        TB = 830#
        QEps = -871#
    End If
    If State.RState.Stage = 0# Then
        GoTo lbl_0
    End If
    If State.RState.Stage = 1# Then
        GoTo lbl_1
    End If
    If State.RState.Stage = 2# Then
        GoTo lbl_2
    End If
    '
    ' Routine body
    '
    '
    ' initialize quadratures.
    ' use 15-point Gauss-Kronrod formula.
    '
    State.N = 15#
    Call GKQGenerateGaussLegendre(State.N, Info, State.QN, State.WK, State.WG)
    If Info < 0# Then
        State.Info = -5#
        State.R = 0#
        Result = False
        AutoGKInternalIteration = Result
        Exit Function
    End If
    ReDim State.WR(0 To State.N - 1)
    For i = 0# To State.N - 1# Step 1
        If i = 0# Then
            State.WR(i) = 0.5 * Abs(State.QN(1#) - State.QN(0#))
            GoTo Cont_1
        End If
        If i = State.N - 1# Then
            State.WR(State.N - 1#) = 0.5 * Abs(State.QN(State.N - 1#) - State.QN(State.N - 2#))
            GoTo Cont_1
        End If
        State.WR(i) = 0.5 * Abs(State.QN(i - 1#) - State.QN(i + 1#))
Cont_1:
    Next i
    '
    ' special case
    '
    If State.a = State.B Then
        State.Info = 1#
        State.R = 0#
        Result = False
        AutoGKInternalIteration = Result
        Exit Function
    End If
    '
    ' test parameters
    '
    If State.eps < 0# Or State.XWidth < 0# Then
        State.Info = -1#
        State.R = 0#
        Result = False
        AutoGKInternalIteration = Result
        Exit Function
    End If
    State.Info = 1#
    If State.eps = 0# Then
        State.eps = 1000# * MachineEpsilon
    End If
    '
    ' First, prepare heap
    ' * column 0   -   absolute error
    ' * column 1   -   integral of a F(x) (calculated using Kronrod extension nodes)
    ' * column 2   -   integral of a |F(x)| (calculated using modified rect. method)
    ' * column 3   -   left boundary of a subinterval
    ' * column 4   -   right boundary of a subinterval
    '
    If State.XWidth <> 0# Then
        GoTo lbl_3
    End If
    '
    ' no maximum width requirements
    ' start from one big subinterval
    '
    State.HeapWidth = 5#
    State.HeapSize = 1#
    State.HeapUsed = 1#
    ReDim State.Heap(0 To State.HeapSize - 1, 0 To State.HeapWidth - 1)
    C1 = 0.5 * (State.B - State.a)
    C2 = 0.5 * (State.B + State.a)
    IntG = 0#
    IntK = 0#
    IntA = 0#
    i = 0#
lbl_5:
    If i > State.N - 1# Then
        GoTo lbl_7
    End If
    '
    ' obtain F
    '
    State.x = C1 * State.QN(i) + C2
    State.RState.Stage = 0#
    GoTo lbl_rcomm
lbl_0:
    V = State.f
    '
    ' Gauss-Kronrod formula
    '
    IntK = IntK + V * State.WK(i)
    If i Mod 2# = 1# Then
        IntG = IntG + V * State.WG(i)
    End If
    '
    ' Integral |F(x)|
    ' Use rectangles method
    '
    IntA = IntA + Abs(V) * State.WR(i)
    i = i + 1#
    GoTo lbl_5
lbl_7:
    IntK = IntK * (State.B - State.a) * 0.5
    IntG = IntG * (State.B - State.a) * 0.5
    IntA = IntA * (State.B - State.a) * 0.5
    State.Heap(0#, 0#) = Abs(IntG - IntK)
    State.Heap(0#, 1#) = IntK
    State.Heap(0#, 2#) = IntA
    State.Heap(0#, 3#) = State.a
    State.Heap(0#, 4#) = State.B
    State.SumErr = State.Heap(0#, 0#)
    State.SumAbs = Abs(IntA)
    GoTo lbl_4
lbl_3:
    '
    ' maximum subinterval should be no more than XWidth.
    ' so we create Ceil((B-A)/XWidth)+1 small subintervals
    '
    NS = Ceil(Abs(State.B - State.a) / State.XWidth) + 1#
    State.HeapSize = NS
    State.HeapUsed = NS
    State.HeapWidth = 5#
    ReDim State.Heap(0 To State.HeapSize - 1, 0 To State.HeapWidth - 1)
    State.SumErr = 0#
    State.SumAbs = 0#
    j = 0#
lbl_8:
    If j > NS - 1# Then
        GoTo lbl_10
    End If
    TA = State.a + j * (State.B - State.a) / NS
    TB = State.a + (j + 1#) * (State.B - State.a) / NS
    C1 = 0.5 * (TB - TA)
    C2 = 0.5 * (TB + TA)
    IntG = 0#
    IntK = 0#
    IntA = 0#
    i = 0#
lbl_11:
    If i > State.N - 1# Then
        GoTo lbl_13
    End If
    '
    ' obtain F
    '
    State.x = C1 * State.QN(i) + C2
    State.RState.Stage = 1#
    GoTo lbl_rcomm
lbl_1:
    V = State.f
    '
    ' Gauss-Kronrod formula
    '
    IntK = IntK + V * State.WK(i)
    If i Mod 2# = 1# Then
        IntG = IntG + V * State.WG(i)
    End If
    '
    ' Integral |F(x)|
    ' Use rectangles method
    '
    IntA = IntA + Abs(V) * State.WR(i)
    i = i + 1#
    GoTo lbl_11
lbl_13:
    IntK = IntK * (TB - TA) * 0.5
    IntG = IntG * (TB - TA) * 0.5
    IntA = IntA * (TB - TA) * 0.5
    State.Heap(j, 0#) = Abs(IntG - IntK)
    State.Heap(j, 1#) = IntK
    State.Heap(j, 2#) = IntA
    State.Heap(j, 3#) = TA
    State.Heap(j, 4#) = TB
    State.SumErr = State.SumErr + State.Heap(j, 0#)
    State.SumAbs = State.SumAbs + Abs(IntA)
    j = j + 1#
    GoTo lbl_8
lbl_10:
lbl_4:
    '
    ' method iterations
    '
lbl_14:
    If False Then
        GoTo lbl_15
    End If
    '
    ' additional memory if needed
    '
    If State.HeapUsed = State.HeapSize Then
        Call MHeapResize(State.Heap, State.HeapSize, 4# * State.HeapSize, State.HeapWidth)
    End If
    '
    ' TODO: every 20 iterations recalculate errors/sums
    ' TODO: one more criterion to prevent infinite loops with too strict Eps
    '
    If State.SumErr <= State.eps * State.SumAbs Then
        State.R = 0#
        For j = 0# To State.HeapUsed - 1# Step 1
            State.R = State.R + State.Heap(j, 1#)
        Next j
        Result = False
        AutoGKInternalIteration = Result
        Exit Function
    End If
    '
    ' Exclude interval with maximum absolute error
    '
    Call MHeapPop(State.Heap, State.HeapUsed, State.HeapWidth)
    State.SumErr = State.SumErr - State.Heap(State.HeapUsed - 1#, 0#)
    State.SumAbs = State.SumAbs - State.Heap(State.HeapUsed - 1#, 2#)
    '
    ' Divide interval, create subintervals
    '
    TA = State.Heap(State.HeapUsed - 1#, 3#)
    TB = State.Heap(State.HeapUsed - 1#, 4#)
    State.Heap(State.HeapUsed - 1#, 3#) = TA
    State.Heap(State.HeapUsed - 1#, 4#) = 0.5 * (TA + TB)
    State.Heap(State.HeapUsed, 3#) = 0.5 * (TA + TB)
    State.Heap(State.HeapUsed, 4#) = TB
    j = State.HeapUsed - 1#
lbl_16:
    If j > State.HeapUsed Then
        GoTo lbl_18
    End If
    C1 = 0.5 * (State.Heap(j, 4#) - State.Heap(j, 3#))
    C2 = 0.5 * (State.Heap(j, 4#) + State.Heap(j, 3#))
    IntG = 0#
    IntK = 0#
    IntA = 0#
    i = 0#
lbl_19:
    If i > State.N - 1# Then
        GoTo lbl_21
    End If
    '
    ' F(x)
    '
    State.x = C1 * State.QN(i) + C2
    State.RState.Stage = 2#
    GoTo lbl_rcomm
lbl_2:
    V = State.f
    '
    ' Gauss-Kronrod formula
    '
    IntK = IntK + V * State.WK(i)
    If i Mod 2# = 1# Then
        IntG = IntG + V * State.WG(i)
    End If
    '
    ' Integral |F(x)|
    ' Use rectangles method
    '
    IntA = IntA + Abs(V) * State.WR(i)
    i = i + 1#
    GoTo lbl_19
lbl_21:
    IntK = IntK * (State.Heap(j, 4#) - State.Heap(j, 3#)) * 0.5
    IntG = IntG * (State.Heap(j, 4#) - State.Heap(j, 3#)) * 0.5
    IntA = IntA * (State.Heap(j, 4#) - State.Heap(j, 3#)) * 0.5
    State.Heap(j, 0#) = Abs(IntG - IntK)
    State.Heap(j, 1#) = IntK
    State.Heap(j, 2#) = IntA
    State.SumErr = State.SumErr + State.Heap(j, 0#)
    State.SumAbs = State.SumAbs + State.Heap(j, 2#)
    j = j + 1#
    GoTo lbl_16
lbl_18:
    Call MHeapPush(State.Heap, State.HeapUsed - 1#, State.HeapWidth)
    Call MHeapPush(State.Heap, State.HeapUsed, State.HeapWidth)
    State.HeapUsed = State.HeapUsed + 1#
    GoTo lbl_14
lbl_15:
    Result = False
    AutoGKInternalIteration = Result
    Exit Function
    '
    ' Saving state
    '
lbl_rcomm:
    Result = True
    State.RState.IA(0#) = i
    State.RState.IA(1#) = j
    State.RState.IA(2#) = NS
    State.RState.IA(3#) = Info
    State.RState.RA(0#) = C1
    State.RState.RA(1#) = C2
    State.RState.RA(2#) = IntG
    State.RState.RA(3#) = IntK
    State.RState.RA(4#) = IntA
    State.RState.RA(5#) = V
    State.RState.RA(6#) = TA
    State.RState.RA(7#) = TB
    State.RState.RA(8#) = QEps
    AutoGKInternalIteration = Result
End Function
Private Sub MHeapPop(ByRef Heap() As Double, _
         ByVal HeapSize As Long, _
         ByVal HeapWidth As Long)
    Dim i As Long
    Dim p As Long
    Dim t As Double
    Dim MaxCP As Long
    If HeapSize = 1# Then
        Exit Sub
    End If
    For i = 0# To HeapWidth - 1# Step 1
        t = Heap(HeapSize - 1#, i)
        Heap(HeapSize - 1#, i) = Heap(0#, i)
        Heap(0#, i) = t
    Next i
    p = 0#
    Do While 2# * p + 1# < HeapSize - 1#
        MaxCP = 2# * p + 1#
        If 2# * p + 2# < HeapSize - 1# Then
            If Heap(2# * p + 2#, 0#) > Heap(2# * p + 1#, 0#) Then
                MaxCP = 2# * p + 2#
            End If
        End If
        If Heap(p, 0#) < Heap(MaxCP, 0#) Then
            For i = 0# To HeapWidth - 1# Step 1
                t = Heap(p, i)
                Heap(p, i) = Heap(MaxCP, i)
                Heap(MaxCP, i) = t
            Next i
            p = MaxCP
        Else
            Exit Do
        End If
    Loop
End Sub
Private Sub MHeapPush(ByRef Heap() As Double, _
         ByVal HeapSize As Long, _
         ByVal HeapWidth As Long)
    Dim i As Long
    Dim p As Long
    Dim t As Double
    Dim Parent As Long
    If HeapSize = 0# Then
        Exit Sub
    End If
    p = HeapSize
    Do While p <> 0#
        Parent = (p - 1#) \ 2#
        If Heap(p, 0#) > Heap(Parent, 0#) Then
            For i = 0# To HeapWidth - 1# Step 1
                t = Heap(p, i)
                Heap(p, i) = Heap(Parent, i)
                Heap(Parent, i) = t
            Next i
            p = Parent
        Else
            Exit Do
        End If
    Loop
End Sub
Private Sub MHeapResize(ByRef Heap() As Double, _
         ByRef HeapSize As Long, _
         ByVal NewHeapSize As Long, _
         ByVal HeapWidth As Long)
    Dim tmp() As Double
    Dim i As Long
    Dim i_ As Long
    ReDim tmp(0 To HeapSize - 1, 0 To HeapWidth - 1)
    For i = 0# To HeapSize - 1# Step 1
        For i_ = 0# To HeapWidth - 1# Step 1
            tmp(i, i_) = Heap(i, i_)
        Next i_
    Next i
    ReDim Heap(0 To NewHeapSize - 1, 0 To HeapWidth - 1)
    For i = 0# To HeapSize - 1# Step 1
        For i_ = 0# To HeapWidth - 1# Step 1
            Heap(i, i_) = tmp(i, i_)
        Next i_
    Next i
    HeapSize = NewHeapSize
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2005-2009, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Computation of nodes and weights of a Gauss-Kronrod quadrature formula
'
'The algorithm generates the N-point Gauss-Kronrod quadrature formula  with
'weight  function  given  by  coefficients  alpha  and beta of a recurrence
'relation which generates a system of orthogonal polynomials:
'
'    P-1(x)   =  0
'    P0(x)    =  1
'    Pn+1(x)  =  (x-alpha(n))*Pn(x)  -  beta(n)*Pn-1(x)
'
'and zero moment Mu0
'
'    Mu0 = integral(W(x)dx,a,b)
'
'
'INPUT PARAMETERS:
'    Alpha          alpha coefficients, array[0..floor(3*K/2)].
'    Beta           beta coefficients,  array[0..ceil(3*K/2)].
'                    Beta[0] is not used and may be arbitrary.
'                    Beta[I]>0.
'    Mu0            zeroth moment of the weight function.
'    N              number of nodes of the Gauss-Kronrod quadrature formula,
'                    N >= 3,
'                    N =  2*K+1.
'
'OUTPUT PARAMETERS:
'    Info        -   error code:
'                    * -5    no real and positive Gauss-Kronrod formula can
'                            be created for such a weight function  with  a
'                            given number of nodes.
'                    * -4    N is too large, task may be ill  conditioned -
'                            x[i]=x[i+1] found.
'                    * -3    internal eigenproblem solver hasn't converged
'                    * -2    Beta[i]<=0
'                    * -1    incorrect N was passed
'                    * +1    OK
'    X           -   array[0..N-1] - array of quadrature nodes,
'                    in ascending order.
'    WKronrod    -   array[0..N-1] - Kronrod weights
'    WGauss      -   array[0..N-1] - Gauss weights (interleaved with zeros
'                    corresponding to extended Kronrod nodes).
'
'  -- ALGLIB --
'     Copyright 08.05.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub GKQGenerateRec(ByRef Alpha_() As Double, _
         ByRef Beta_() As Double, _
         ByVal Mu0 As Double, _
         ByVal N As Long, _
         ByRef Info As Long, _
         ByRef x() As Double, _
         ByRef WKronrod() As Double, _
         ByRef WGauss() As Double)
    Dim alpha() As Double
    Dim beta() As Double
    Dim TA() As Double
    Dim i As Long
    Dim j As Long
    Dim t() As Double
    Dim s() As Double
    Dim WLen As Long
    Dim WOffs As Long
    Dim U As Double
    Dim M As Long
    Dim L As Long
    Dim K As Long
    Dim XGTmp() As Double
    Dim WGTmp() As Double
    Dim i_ As Long
    alpha = Alpha_
    beta = Beta_
    If N Mod 2# <> 1# Or N < 3# Then
        Info = -1#
        Exit Sub
    End If
    For i = 0# To Ceil(3# * (N \ 2#) / 2#) Step 1
        If beta(i) <= 0# Then
            Info = -2#
            Exit Sub
        End If
    Next i
    Info = 1#
    '
    ' from external conventions about N/Beta/Mu0 to internal
    '
    N = N \ 2#
    beta(0#) = Mu0
    '
    ' Calculate Gauss nodes/weights, save them for later processing
    '
    Call GQGenerateRec(alpha, beta, Mu0, N, Info, XGTmp, WGTmp)
    If Info < 0# Then
        Exit Sub
    End If
    '
    ' Resize:
    ' * A from 0..floor(3*n/2) to 0..2*n
    ' * B from 0..ceil(3*n/2)  to 0..2*n
    '
    ReDim TA(0 To Int(3# * N / 2#) + 1# - 1)
    For i_ = 0# To Int(3# * N / 2#) Step 1
        TA(i_) = alpha(i_)
    Next i_
    ReDim alpha(0 To 2# * N + 1# - 1)
    For i_ = 0# To Int(3# * N / 2#) Step 1
        alpha(i_) = TA(i_)
    Next i_
    For i = Int(3# * N / 2#) + 1# To 2# * N Step 1
        alpha(i) = 0#
    Next i
    ReDim TA(0 To Ceil(3# * N / 2#) + 1# - 1)
    For i_ = 0# To Ceil(3# * N / 2#) Step 1
        TA(i_) = beta(i_)
    Next i_
    ReDim beta(0 To 2# * N + 1# - 1)
    For i_ = 0# To Ceil(3# * N / 2#) Step 1
        beta(i_) = TA(i_)
    Next i_
    For i = Ceil(3# * N / 2#) + 1# To 2# * N Step 1
        beta(i) = 0#
    Next i
    '
    ' Initialize T, S
    '
    WLen = 2# + N \ 2#
    ReDim t(0 To WLen - 1)
    ReDim s(0 To WLen - 1)
    ReDim TA(0 To WLen - 1)
    WOffs = 1#
    For i = 0# To WLen - 1# Step 1
        t(i) = 0#
        s(i) = 0#
    Next i
    '
    ' Algorithm from Dirk P. Laurie, "Calculation of Gauss-Kronrod quadrature rules", 1997.
    '
    t(WOffs + 0#) = beta(N + 1#)
    For M = 0# To N - 2# Step 1
        U = 0#
        For K = (M + 1#) \ 2# To 0# Step -1
            L = M - K
            U = U + (alpha(K + N + 1#) - alpha(L)) * t(WOffs + K) + beta(K + N + 1#) * s(WOffs + K - 1#) - beta(L) * s(WOffs + K)
            s(WOffs + K) = U
        Next K
        For i_ = 0# To WLen - 1# Step 1
            TA(i_) = t(i_)
        Next i_
        For i_ = 0# To WLen - 1# Step 1
            t(i_) = s(i_)
        Next i_
        For i_ = 0# To WLen - 1# Step 1
            s(i_) = TA(i_)
        Next i_
    Next M
    For j = N \ 2# To 0# Step -1
        s(WOffs + j) = s(WOffs + j - 1#)
    Next j
    For M = N - 1# To 2# * N - 3# Step 1
        U = 0#
        For K = M + 1# - N To (M - 1#) \ 2# Step 1
            L = M - K
            j = N - 1# - L
            U = U - (alpha(K + N + 1#) - alpha(L)) * t(WOffs + j) - beta(K + N + 1#) * s(WOffs + j) + beta(L) * s(WOffs + j + 1#)
            s(WOffs + j) = U
        Next K
        If M Mod 2# = 0# Then
            K = M \ 2#
            alpha(K + N + 1#) = alpha(K) + (s(WOffs + j) - beta(K + N + 1#) * s(WOffs + j + 1#)) / t(WOffs + j + 1#)
        Else
            K = (M + 1#) \ 2#
            beta(K + N + 1#) = s(WOffs + j) / s(WOffs + j + 1#)
        End If
        For i_ = 0# To WLen - 1# Step 1
            TA(i_) = t(i_)
        Next i_
        For i_ = 0# To WLen - 1# Step 1
            t(i_) = s(i_)
        Next i_
        For i_ = 0# To WLen - 1# Step 1
            s(i_) = TA(i_)
        Next i_
    Next M
    alpha(2# * N) = alpha(N - 1#) - beta(2# * N) * s(WOffs + 0#) / t(WOffs + 0#)
    '
    ' calculation of Kronrod nodes and weights, unpacking of Gauss weights
    '
    Call GQGenerateRec(alpha, beta, Mu0, 2# * N + 1#, Info, x, WKronrod)
    If Info = -2# Then
        Info = -5#
    End If
    If Info < 0# Then
        Exit Sub
    End If
    For i = 0# To 2# * N - 1# Step 1
        If x(i) >= x(i + 1#) Then
            Info = -4#
        End If
    Next i
    If Info < 0# Then
        Exit Sub
    End If
    ReDim WGauss(0 To 2# * N + 1# - 1)
    For i = 0# To 2# * N Step 1
        WGauss(i) = 0#
    Next i
    For i = 0# To N - 1# Step 1
        WGauss(2# * i + 1#) = WGTmp(i)
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Returns   Gauss   and   Gauss-Kronrod   nodes/weights  for  Gauss-Legendre
'quadrature with N points.
'
'GKQLegendreCalc (calculation) or  GKQLegendreTbl  (precomputed  table)  is
'used depending on machine precision and number of nodes.
'
'INPUT PARAMETERS:
'    N           -   number of Kronrod nodes, must be odd number, >=3.
'
'OUTPUT PARAMETERS:
'    Info        -   error code:
'                    * -4    an  error   was   detected   when  calculating
'                            weights/nodes.  N  is  too  large   to  obtain
'                            weights/nodes  with  high   enough   accuracy.
'                            Try  to   use   multiple   precision  version.
'                    * -3    internal eigenproblem solver hasn't converged
'                    * -1    incorrect N was passed
'                    * +1    OK
'    X           -   array[0..N-1] - array of quadrature nodes, ordered in
'                    ascending order.
'    WKronrod    -   array[0..N-1] - Kronrod weights
'    WGauss      -   array[0..N-1] - Gauss weights (interleaved with zeros
'                    corresponding to extended Kronrod nodes).
'
'
'  -- ALGLIB --
'     Copyright 12.05.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub GKQGenerateGaussLegendre(ByVal N As Long, _
         ByRef Info As Long, _
         ByRef x() As Double, _
         ByRef WKronrod() As Double, _
         ByRef WGauss() As Double)
    Dim eps As Double
    If MachineEpsilon > 1E-32 And (N = 15# Or N = 21# Or N = 31# Or N = 41# Or N = 51# Or N = 61#) Then
        Info = 1#
        Call GKQLegendreTbl(N, x, WKronrod, WGauss, eps)
    Else
        Call GKQLegendreCalc(N, Info, x, WKronrod, WGauss)
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Returns   Gauss   and   Gauss-Kronrod   nodes/weights   for   Gauss-Jacobi
'quadrature on [-1,1] with weight function
'
'    W(x)=Power(1-x,Alpha)*Power(1+x,Beta).
'
'INPUT PARAMETERS:
'    N           -   number of Kronrod nodes, must be odd number, >=3.
'    Alpha       -   power-law coefficient, Alpha>-1
'    Beta        -   power-law coefficient, Beta>-1
'
'OUTPUT PARAMETERS:
'    Info        -   error code:
'                    * -5    no real and positive Gauss-Kronrod formula can
'                            be created for such a weight function  with  a
'                            given number of nodes.
'                    * -4    an  error  was   detected   when   calculating
'                            weights/nodes. Alpha or  Beta  are  too  close
'                            to -1 to obtain weights/nodes with high enough
'                            accuracy, or, may be, N is too large.  Try  to
'                            use multiple precision version.
'                    * -3    internal eigenproblem solver hasn't converged
'                    * -1    incorrect N was passed
'                    * +1    OK
'                    * +2    OK, but quadrature rule have exterior  nodes,
'                            x[0]<-1 or x[n-1]>+1
'    X           -   array[0..N-1] - array of quadrature nodes, ordered in
'                    ascending order.
'    WKronrod    -   array[0..N-1] - Kronrod weights
'    WGauss      -   array[0..N-1] - Gauss weights (interleaved with zeros
'                    corresponding to extended Kronrod nodes).
'
'
'  -- ALGLIB --
'     Copyright 12.05.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub GKQGenerateGaussJacobi(ByVal N As Long, _
         ByVal alpha As Double, _
         ByVal beta As Double, _
         ByRef Info As Long, _
         ByRef x() As Double, _
         ByRef WKronrod() As Double, _
         ByRef WGauss() As Double)
    Dim CLen As Long
    Dim a() As Double
    Dim B() As Double
    Dim Alpha2 As Double
    Dim Beta2 As Double
    Dim APB As Double
    Dim t As Double
    Dim i As Long
    Dim s As Double
    If N Mod 2# <> 1# Or N < 3# Then
        Info = -1#
        Exit Sub
    End If
    If alpha <= -1# Or beta <= -1# Then
        Info = -1#
        Exit Sub
    End If
    CLen = Ceil(3# * (N \ 2#) / 2#) + 1#
    ReDim a(0 To CLen - 1)
    ReDim B(0 To CLen - 1)
    For i = 0# To CLen - 1# Step 1
        a(i) = 0#
    Next i
    APB = alpha + beta
    a(0#) = (beta - alpha) / (APB + 2#)
    t = (APB + 1#) * Log(2#) + LnGamma(alpha + 1#, s) + LnGamma(beta + 1#, s) - LnGamma(APB + 2#, s)
    If t > Log(MaxRealNumber) Then
        Info = -4#
        Exit Sub
    End If
    B(0#) = Exp(t)
    If CLen > 1# Then
        Alpha2 = Square(alpha)
        Beta2 = Square(beta)
        a(1#) = (Beta2 - Alpha2) / ((APB + 2#) * (APB + 4#))
        B(1#) = 4# * (alpha + 1#) * (beta + 1#) / ((APB + 3#) * Square(APB + 2#))
        For i = 2# To CLen - 1# Step 1
            a(i) = 0.25 * (Beta2 - Alpha2) / (i * i * (1# + 0.5 * APB / i) * (1# + 0.5 * (APB + 2#) / i))
            B(i) = 0.25 * (1# + alpha / i) * (1# + beta / i) * (1# + APB / i) / ((1# + 0.5 * (APB + 1#) / i) * (1# + 0.5 * (APB - 1#) / i) * Square(1# + 0.5 * APB / i))
        Next i
    End If
    Call GKQGenerateRec(a, B, B(0#), N, Info, x, WKronrod, WGauss)
    '
    ' test basic properties to detect errors
    '
    If Info > 0# Then
        If x(0#) < -1# Or x(N - 1#) > 1# Then
            Info = 2#
        End If
        For i = 0# To N - 2# Step 1
            If x(i) >= x(i + 1#) Then
                Info = -4#
            End If
        Next i
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Returns Gauss and Gauss-Kronrod nodes for quadrature with N points.
'
'Reduction to tridiagonal eigenproblem is used.
'
'INPUT PARAMETERS:
'    N           -   number of Kronrod nodes, must be odd number, >=3.
'
'OUTPUT PARAMETERS:
'    Info        -   error code:
'                    * -4    an  error   was   detected   when  calculating
'                            weights/nodes.  N  is  too  large   to  obtain
'                            weights/nodes  with  high   enough   accuracy.
'                            Try  to   use   multiple   precision  version.
'                    * -3    internal eigenproblem solver hasn't converged
'                    * -1    incorrect N was passed
'                    * +1    OK
'    X           -   array[0..N-1] - array of quadrature nodes, ordered in
'                    ascending order.
'    WKronrod    -   array[0..N-1] - Kronrod weights
'    WGauss      -   array[0..N-1] - Gauss weights (interleaved with zeros
'                    corresponding to extended Kronrod nodes).
'
'  -- ALGLIB --
'     Copyright 12.05.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub GKQLegendreCalc(ByVal N As Long, _
         ByRef Info As Long, _
         ByRef x() As Double, _
         ByRef WKronrod() As Double, _
         ByRef WGauss() As Double)
    Dim alpha() As Double
    Dim beta() As Double
    Dim ALen As Long
    Dim BLen As Long
    Dim Mu0 As Double
    Dim K As Long
    Dim i As Long
    If N Mod 2# <> 1# Or N < 3# Then
        Info = -1#
        Exit Sub
    End If
    Mu0 = 2#
    ALen = Int(3# * (N \ 2#) / 2#) + 1#
    BLen = Ceil(3# * (N \ 2#) / 2#) + 1#
    ReDim alpha(0 To ALen - 1)
    ReDim beta(0 To BLen - 1)
    For K = 0# To ALen - 1# Step 1
        alpha(K) = 0#
    Next K
    beta(0#) = 2#
    For K = 1# To BLen - 1# Step 1
        beta(K) = 1# / (4# - 1# / Square(K))
    Next K
    Call GKQGenerateRec(alpha, beta, Mu0, N, Info, x, WKronrod, WGauss)
    '
    ' test basic properties to detect errors
    '
    If Info > 0# Then
        If x(0#) < -1# Or x(N - 1#) > 1# Then
            Info = -4#
        End If
        For i = 0# To N - 2# Step 1
            If x(i) >= x(i + 1#) Then
                Info = -4#
            End If
        Next i
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Returns Gauss and Gauss-Kronrod nodes for quadrature with N  points  using
'pre-calculated table. Nodes/weights were  computed  with  accuracy  up  to
'1.0E-32 (if MPFR version of ALGLIB is used). In standard double  precision
'accuracy reduces to something about 2.0E-16 (depending  on your compiler's
'handling of long floating point constants).
'
'INPUT PARAMETERS:
'    N           -   number of Kronrod nodes.
'                    N can be 15, 21, 31, 41, 51, 61.
'
'OUTPUT PARAMETERS:
'    X           -   array[0..N-1] - array of quadrature nodes, ordered in
'                    ascending order.
'    WKronrod    -   array[0..N-1] - Kronrod weights
'    WGauss      -   array[0..N-1] - Gauss weights (interleaved with zeros
'                    corresponding to extended Kronrod nodes).
'
'
'  -- ALGLIB --
'     Copyright 12.05.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub GKQLegendreTbl(ByVal N As Long, _
         ByRef x() As Double, _
         ByRef WKronrod() As Double, _
         ByRef WGauss() As Double, _
         ByRef eps As Double)
    Dim i As Long
    Dim NG As Long
    Dim p1() As Long
    Dim p2() As Long
    Dim tmp As Double
    ReDim x(0# To N - 1#)
    ReDim WKronrod(0# To N - 1#)
    ReDim WGauss(0# To N - 1#)
    For i = 0# To N - 1# Step 1
        x(i) = 0#
        WKronrod(i) = 0#
        WGauss(i) = 0#
    Next i
    eps = MaxReal(MachineEpsilon, 1E-32)
    If N = 15# Then
        NG = 4#
        WGauss(0#) = 0.12948496616887
        WGauss(1#) = 0.279705391489277
        WGauss(2#) = 0.381830050505119
        WGauss(3#) = 0.417959183673469
        x(0#) = 0.991455371120813
        x(1#) = 0.949107912342758
        x(2#) = 0.864864423359769
        x(3#) = 0.741531185599394
        x(4#) = 0.586087235467691
        x(5#) = 0.405845151377397
        x(6#) = 0.207784955007898
        x(7#) = 0#
        WKronrod(0#) = 2.29353220105292E-02
        WKronrod(1#) = 6.30920926299786E-02
        WKronrod(2#) = 0.10479001032225
        WKronrod(3#) = 0.140653259715526
        WKronrod(4#) = 0.169004726639268
        WKronrod(5#) = 0.190350578064785
        WKronrod(6#) = 0.204432940075299
        WKronrod(7#) = 0.209482141084728
    End If
    If N = 21# Then
        NG = 5#
        WGauss(0#) = 6.66713443086881E-02
        WGauss(1#) = 0.149451349150581
        WGauss(2#) = 0.219086362515982
        WGauss(3#) = 0.269266719309996
        WGauss(4#) = 0.295524224714753
        x(0#) = 0.995657163025808
        x(1#) = 0.973906528517172
        x(2#) = 0.930157491355708
        x(3#) = 0.865063366688985
        x(4#) = 0.780817726586417
        x(5#) = 0.679409568299024
        x(6#) = 0.562757134668605
        x(7#) = 0.433395394129247
        x(8#) = 0.29439286270146
        x(9#) = 0.148874338981631
        x(10#) = 0#
        WKronrod(0#) = 1.16946388673719E-02
        WKronrod(1#) = 3.25581623079647E-02
        WKronrod(2#) = 0.054755896574352
        WKronrod(3#) = 0.07503967481092
        WKronrod(4#) = 9.31254545836976E-02
        WKronrod(5#) = 0.109387158802298
        WKronrod(6#) = 0.123491976262066
        WKronrod(7#) = 0.134709217311473
        WKronrod(8#) = 0.14277593857706
        WKronrod(9#) = 0.147739104901338
        WKronrod(10#) = 0.149445554002917
    End If
    If N = 31# Then
        NG = 8#
        WGauss(0#) = 3.07532419961173E-02
        WGauss(1#) = 7.03660474881081E-02
        WGauss(2#) = 0.107159220467172
        WGauss(3#) = 0.139570677926154
        WGauss(4#) = 0.166269205816994
        WGauss(5#) = 0.186161000015562
        WGauss(6#) = 0.198431485327112
        WGauss(7#) = 0.202578241925561
        x(0#) = 0.998002298693397
        x(1#) = 0.987992518020485
        x(2#) = 0.967739075679139
        x(3#) = 0.937273392400706
        x(4#) = 0.897264532344082
        x(5#) = 0.848206583410427
        x(6#) = 0.790418501442466
        x(7#) = 0.72441773136017
        x(8#) = 0.650996741297417
        x(9#) = 0.570972172608539
        x(10#) = 0.48508186364024
        x(11#) = 0.394151347077563
        x(12#) = 0.299180007153169
        x(13#) = 0.201194093997435
        x(14#) = 0.101142066918717
        x(15#) = 0#
        WKronrod(0#) = 5.37747987292335E-03
        WKronrod(1#) = 1.50079473293161E-02
        WKronrod(2#) = 2.54608473267153E-02
        WKronrod(3#) = 3.53463607913758E-02
        WKronrod(4#) = 4.45897513247649E-02
        WKronrod(5#) = 5.34815246909281E-02
        WKronrod(6#) = 6.20095678006706E-02
        WKronrod(7#) = 6.98541213187283E-02
        WKronrod(8#) = 7.68496807577204E-02
        WKronrod(9#) = 0.083080502823133
        WKronrod(10#) = 8.85644430562118E-02
        WKronrod(11#) = 9.31265981708253E-02
        WKronrod(12#) = 9.66427269836237E-02
        WKronrod(13#) = 0.099173598721792
        WKronrod(14#) = 0.100769845523876
        WKronrod(15#) = 0.101330007014792
    End If
    If N = 41# Then
        NG = 10#
        WGauss(0#) = 1.76140071391521E-02
        WGauss(1#) = 4.06014298003869E-02
        WGauss(2#) = 6.26720483341091E-02
        WGauss(3#) = 8.32767415767048E-02
        WGauss(4#) = 0.10193011981724
        WGauss(5#) = 0.118194531961518
        WGauss(6#) = 0.131688638449177
        WGauss(7#) = 0.142096109318382
        WGauss(8#) = 0.149172986472604
        WGauss(9#) = 0.152753387130726
        x(0#) = 0.998859031588278
        x(1#) = 0.993128599185095
        x(2#) = 0.98150787745025
        x(3#) = 0.963971927277914
        x(4#) = 0.940822633831755
        x(5#) = 0.912234428251326
        x(6#) = 0.878276811252282
        x(7#) = 0.839116971822219
        x(8#) = 0.795041428837551
        x(9#) = 0.746331906460151
        x(10#) = 0.693237656334751
        x(11#) = 0.636053680726515
        x(12#) = 0.57514044681971
        x(13#) = 0.510867001950827
        x(14#) = 0.443593175238725
        x(15#) = 0.37370608871542
        x(16#) = 0.301627868114913
        x(17#) = 0.227785851141645
        x(18#) = 0.152605465240923
        x(19#) = 7.65265211334973E-02
        x(20#) = 0#
        WKronrod(0#) = 3.07358371852053E-03
        WKronrod(1#) = 8.60026985564294E-03
        WKronrod(2#) = 1.46261692569713E-02
        WKronrod(3#) = 2.03883734612665E-02
        WKronrod(4#) = 2.58821336049512E-02
        WKronrod(5#) = 3.12873067770328E-02
        WKronrod(6#) = 3.66001697582008E-02
        WKronrod(7#) = 4.16688733279737E-02
        WKronrod(8#) = 4.64348218674977E-02
        WKronrod(9#) = 5.09445739237287E-02
        WKronrod(10#) = 0.055195105348286
        WKronrod(11#) = 5.91114008806396E-02
        WKronrod(12#) = 6.26532375547812E-02
        WKronrod(13#) = 6.58345971336184E-02
        WKronrod(14#) = 6.86486729285216E-02
        WKronrod(15#) = 7.10544235534441E-02
        WKronrod(16#) = 7.30306903327867E-02
        WKronrod(17#) = 7.45828754004992E-02
        WKronrod(18#) = 7.57044976845567E-02
        WKronrod(19#) = 7.63778676720807E-02
        WKronrod(20#) = 7.66007119179997E-02
    End If
    If N = 51# Then
        NG = 13#
        WGauss(0#) = 1.13937985010263E-02
        WGauss(1#) = 2.63549866150321E-02
        WGauss(2#) = 4.09391567013063E-02
        WGauss(3#) = 5.49046959758352E-02
        WGauss(4#) = 6.80383338123569E-02
        WGauss(5#) = 0.080140700335001
        WGauss(6#) = 9.10282619829637E-02
        WGauss(7#) = 0.100535949067051
        WGauss(8#) = 0.108519624474264
        WGauss(9#) = 0.114858259145712
        WGauss(10#) = 0.119455763535785
        WGauss(11#) = 0.12224244299031
        WGauss(12#) = 0.123176053726715
        x(0#) = 0.99926210499261
        x(1#) = 0.995556969790498
        x(2#) = 0.988035794534077
        x(3#) = 0.976663921459518
        x(4#) = 0.961614986425843
        x(5#) = 0.942974571228974
        x(6#) = 0.920747115281702
        x(7#) = 0.894991997878275
        x(8#) = 0.865847065293276
        x(9#) = 0.833442628760834
        x(10#) = 0.7978737979985
        x(11#) = 0.759259263037358
        x(12#) = 0.717766406813084
        x(13#) = 0.673566368473468
        x(14#) = 0.626810099010317
        x(15#) = 0.577662930241223
        x(16#) = 0.526325284334719
        x(17#) = 0.473002731445715
        x(18#) = 0.417885382193038
        x(19#) = 0.361172305809388
        x(20#) = 0.303089538931108
        x(21#) = 0.243866883720988
        x(22#) = 0.183718939421049
        x(23#) = 0.12286469261071
        x(24#) = 6.15444830056851E-02
        x(25#) = 0#
        WKronrod(0#) = 1.98738389233032E-03
        WKronrod(1#) = 5.56193213535671E-03
        WKronrod(2#) = 9.47397338617415E-03
        WKronrod(3#) = 1.32362291955717E-02
        WKronrod(4#) = 1.68478177091283E-02
        WKronrod(5#) = 2.04353711458828E-02
        WKronrod(6#) = 2.40099456069532E-02
        WKronrod(7#) = 2.74753175878517E-02
        WKronrod(8#) = 3.07923001673875E-02
        WKronrod(9#) = 3.40021302743293E-02
        WKronrod(10#) = 3.71162714834155E-02
        WKronrod(11#) = 4.00838255040324E-02
        WKronrod(12#) = 4.28728450201701E-02
        WKronrod(13#) = 4.55029130499218E-02
        WKronrod(14#) = 4.79825371388367E-02
        WKronrod(15#) = 5.02776790807157E-02
        WKronrod(16#) = 5.23628858064075E-02
        WKronrod(17#) = 5.42511298885455E-02
        WKronrod(18#) = 5.59508112204123E-02
        WKronrod(19#) = 5.74371163615678E-02
        WKronrod(20#) = 5.86896800223942E-02
        WKronrod(21#) = 5.97203403241741E-02
        WKronrod(22#) = 6.05394553760459E-02
        WKronrod(23#) = 0.061128509717053
        WKronrod(24#) = 6.14711898714253E-02
        WKronrod(25#) = 6.15808180678329E-02
    End If
    If N = 61# Then
        NG = 15#
        WGauss(0#) = 7.96819249616661E-03
        WGauss(1#) = 0.018466468311091
        WGauss(2#) = 2.87847078833234E-02
        WGauss(3#) = 3.87991925696271E-02
        WGauss(4#) = 4.84026728305941E-02
        WGauss(5#) = 5.74931562176191E-02
        WGauss(6#) = 6.59742298821805E-02
        WGauss(7#) = 7.37559747377052E-02
        WGauss(8#) = 8.07558952294202E-02
        WGauss(9#) = 0.086899787201083
        WGauss(10#) = 9.21225222377861E-02
        WGauss(11#) = 9.63687371746443E-02
        WGauss(12#) = 9.95934205867953E-02
        WGauss(13#) = 0.101762389748405
        WGauss(14#) = 0.102852652893559
        x(0#) = 0.999484410050491
        x(1#) = 0.99689348407465
        x(2#) = 0.991630996870405
        x(3#) = 0.983668123279747
        x(4#) = 0.973116322501126
        x(5#) = 0.960021864968308
        x(6#) = 0.94437444474856
        x(7#) = 0.926200047429274
        x(8#) = 0.905573307699908
        x(9#) = 0.882560535792053
        x(10#) = 0.857205233546061
        x(11#) = 0.829565762382768
        x(12#) = 0.799727835821839
        x(13#) = 0.767777432104826
        x(14#) = 0.733790062453227
        x(15#) = 0.697850494793316
        x(16#) = 0.660061064126627
        x(17#) = 0.620526182989243
        x(18#) = 0.579345235826362
        x(19#) = 0.53662414814202
        x(20#) = 0.492480467861779
        x(21#) = 0.447033769538089
        x(22#) = 0.400401254830394
        x(23#) = 0.352704725530878
        x(24#) = 0.304073202273625
        x(25#) = 0.25463692616789
        x(26#) = 0.20452511668231
        x(27#) = 0.153869913608584
        x(28#) = 0.102806937966737
        x(29#) = 5.14718425553177E-02
        x(30#) = 0#
        WKronrod(0#) = 1.38901369867701E-03
        WKronrod(1#) = 3.89046112709988E-03
        WKronrod(2#) = 6.63070391593129E-03
        WKronrod(3#) = 9.27327965951776E-03
        WKronrod(4#) = 1.18230152534963E-02
        WKronrod(5#) = 1.43697295070458E-02
        WKronrod(6#) = 1.69208891890533E-02
        WKronrod(7#) = 1.94141411939424E-02
        WKronrod(8#) = 2.18280358216092E-02
        WKronrod(9#) = 2.41911620780806E-02
        WKronrod(10#) = 2.65099548823331E-02
        WKronrod(11#) = 2.87540487650413E-02
        WKronrod(12#) = 3.09072575623878E-02
        WKronrod(13#) = 3.29814470574837E-02
        WKronrod(14#) = 0.03497933802806
        WKronrod(15#) = 3.68823646518212E-02
        WKronrod(16#) = 3.86789456247276E-02
        WKronrod(17#) = 0.040374538951536
        WKronrod(18#) = 4.19698102151642E-02
        WKronrod(19#) = 4.34525397013561E-02
        WKronrod(20#) = 4.48148001331627E-02
        WKronrod(21#) = 0.046059238271007
        WKronrod(22#) = 4.71855465692992E-02
        WKronrod(23#) = 4.81858617570871E-02
        WKronrod(24#) = 4.90554345550298E-02
        WKronrod(25#) = 4.97956834270742E-02
        WKronrod(26#) = 5.04059214027823E-02
        WKronrod(27#) = 5.08817958987496E-02
        WKronrod(28#) = 5.12215478492588E-02
        WKronrod(29#) = 0.051426128537459
        WKronrod(30#) = 5.14947294294516E-02
    End If
    '
    ' copy nodes
    '
    For i = N - 1# To N \ 2# Step -1
        x(i) = -x(N - 1# - i)
    Next i
    '
    ' copy Kronrod weights
    '
    For i = N - 1# To N \ 2# Step -1
        WKronrod(i) = WKronrod(N - 1# - i)
    Next i
    '
    ' copy Gauss weights
    '
    For i = NG - 1# To 0# Step -1
        WGauss(N - 2# - 2# * i) = WGauss(i)
        WGauss(1# + 2# * i) = WGauss(i)
    Next i
    For i = 0# To N \ 2# Step 1
        WGauss(2# * i) = 0#
    Next i
    '
    ' reorder
    '
    Call TagSort(x, N, p1, p2)
    For i = 0# To N - 1# Step 1
        tmp = WKronrod(i)
        WKronrod(i) = WKronrod(p2(i))
        WKronrod(p2(i)) = tmp
        tmp = WGauss(i)
        WGauss(i) = WGauss(p2(i))
        WGauss(p2(i)) = tmp
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2005-2007, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Computation of nodes and weights for a Gauss quadrature formula
'
'The algorithm generates the N-point Gauss quadrature formula  with  weight
'function given by coefficients alpha and beta  of  a  recurrence  relation
'which generates a system of orthogonal polynomials:
'
'P-1(x)   =  0
'P0(x)    =  1
'Pn+1(x)  =  (x-alpha(n))*Pn(x)  -  beta(n)*Pn-1(x)
'
'and zeroth moment Mu0
'
'Mu0 = integral(W(x)dx,a,b)
'
'INPUT PARAMETERS:
'    Alpha      array[0..N-1], alpha coefficients
'    Beta       array[0..N-1], beta coefficients
'                Zero-indexed element is not used and may be arbitrary.
'                Beta[I]>0.
'    Mu0        zeroth moment of the weight function.
'    N          number of nodes of the quadrature formula, N>=1
'
'OUTPUT PARAMETERS:
'    Info    -   error code:
'                * -3    internal eigenproblem solver hasn't converged
'                * -2    Beta[i]<=0
'                * -1    incorrect N was passed
'                *  1    OK
'    X       -   array[0..N-1] - array of quadrature nodes,
'                in ascending order.
'    W       -   array[0..N-1] - array of quadrature weights.
'
'  -- ALGLIB --
'     Copyright 2005-2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub GQGenerateRec(ByRef alpha() As Double, _
         ByRef beta() As Double, _
         ByVal Mu0 As Double, _
         ByVal N As Long, _
         ByRef Info As Long, _
         ByRef x() As Double, _
         ByRef w() As Double)
    Dim i As Long
    Dim d() As Double
    Dim e() As Double
    Dim z() As Double
    If N < 1# Then
        Info = -1#
        Exit Sub
    End If
    Info = 1#
    '
    ' Initialize
    '
    ReDim d(0 To N - 1)
    ReDim e(0 To N - 1)
    For i = 1# To N - 1# Step 1
        d(i - 1#) = alpha(i - 1#)
        If beta(i) <= 0# Then
            Info = -2#
            Exit Sub
        End If
        e(i - 1#) = Sqr(beta(i))
    Next i
    d(N - 1#) = alpha(N - 1#)
    '
    ' EVD
    '
    If Not SMatrixTDEVD(d, e, N, 3#, z) Then
        Info = -3#
        Exit Sub
    End If
    '
    ' Generate
    '
    ReDim x(0 To N - 1)
    ReDim w(0 To N - 1)
    For i = 1# To N Step 1
        x(i - 1#) = d(i - 1#)
        w(i - 1#) = Mu0 * Square(z(0#, i - 1#))
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Computation of nodes and weights for a Gauss-Lobatto quadrature formula
'
'The algorithm generates the N-point Gauss-Lobatto quadrature formula  with
'weight function given by coefficients alpha and beta of a recurrence which
'generates a system of orthogonal polynomials.
'
'P-1(x)   =  0
'P0(x)    =  1
'Pn+1(x)  =  (x-alpha(n))*Pn(x)  -  beta(n)*Pn-1(x)
'
'and zeroth moment Mu0
'
'Mu0 = integral(W(x)dx,a,b)
'
'INPUT PARAMETERS:
'    Alpha      array[0..N-2], alpha coefficients
'    Beta       array[0..N-2], beta coefficients.
'                Zero-indexed element is not used, may be arbitrary.
'                Beta[I]>0
'    Mu0        zeroth moment of the weighting function.
'    A          left boundary of the integration interval.
'    B          right boundary of the integration interval.
'    N          number of nodes of the quadrature formula, N>=3
'                (including the left and right boundary nodes).
'
'OUTPUT PARAMETERS:
'    Info    -   error code:
'                * -3    internal eigenproblem solver hasn't converged
'                * -2    Beta[i]<=0
'                * -1    incorrect N was passed
'                *  1    OK
'    X       -   array[0..N-1] - array of quadrature nodes,
'                in ascending order.
'    W       -   array[0..N-1] - array of quadrature weights.
'
'  -- ALGLIB --
'     Copyright 2005-2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub GQGenerateGaussLobattoRec(ByRef Alpha_() As Double, _
         ByRef Beta_() As Double, _
         ByVal Mu0 As Double, _
         ByVal a As Double, _
         ByVal B As Double, _
         ByVal N As Long, _
         ByRef Info As Long, _
         ByRef x() As Double, _
         ByRef w() As Double)
    Dim alpha() As Double
    Dim beta() As Double
    Dim i As Long
    Dim d() As Double
    Dim e() As Double
    Dim z() As Double
    Dim PIM1A As Double
    Dim PIA As Double
    Dim PIM1B As Double
    Dim PIB As Double
    Dim t As Double
    Dim A11 As Double
    Dim A12 As Double
    Dim A21 As Double
    Dim A22 As Double
    Dim b1 As Double
    Dim b2 As Double
    Dim Alph As Double
    Dim Bet As Double
    alpha = Alpha_
    beta = Beta_
    If N <= 2# Then
        Info = -1#
        Exit Sub
    End If
    Info = 1#
    '
    ' Initialize, D[1:N+1], E[1:N]
    '
    N = N - 2#
    ReDim d(0 To N + 2# - 1)
    ReDim e(0 To N + 1# - 1)
    For i = 1# To N + 1# Step 1
        d(i - 1#) = alpha(i - 1#)
    Next i
    For i = 1# To N Step 1
        If beta(i) <= 0# Then
            Info = -2#
            Exit Sub
        End If
        e(i - 1#) = Sqr(beta(i))
    Next i
    '
    ' Caclulate Pn(a), Pn+1(a), Pn(b), Pn+1(b)
    '
    beta(0#) = 0#
    PIM1A = 0#
    PIA = 1#
    PIM1B = 0#
    PIB = 1#
    For i = 1# To N + 1# Step 1
        '
        ' Pi(a)
        '
        t = (a - alpha(i - 1#)) * PIA - beta(i - 1#) * PIM1A
        PIM1A = PIA
        PIA = t
        '
        ' Pi(b)
        '
        t = (B - alpha(i - 1#)) * PIB - beta(i - 1#) * PIM1B
        PIM1B = PIB
        PIB = t
    Next i
    '
    ' Calculate alpha'(n+1), beta'(n+1)
    '
    A11 = PIA
    A12 = PIM1A
    A21 = PIB
    A22 = PIM1B
    b1 = a * PIA
    b2 = B * PIB
    If Abs(A11) > Abs(A21) Then
        A22 = A22 - A12 * A21 / A11
        b2 = b2 - b1 * A21 / A11
        Bet = b2 / A22
        Alph = (b1 - Bet * A12) / A11
    Else
        A12 = A12 - A22 * A11 / A21
        b1 = b1 - b2 * A11 / A21
        Bet = b1 / A12
        Alph = (b2 - Bet * A22) / A21
    End If
    If Bet < 0# Then
        Info = -3#
        Exit Sub
    End If
    d(N + 1#) = Alph
    e(N) = Sqr(Bet)
    '
    ' EVD
    '
    If Not SMatrixTDEVD(d, e, N + 2#, 3#, z) Then
        Info = -3#
        Exit Sub
    End If
    '
    ' Generate
    '
    ReDim x(0 To N + 2# - 1)
    ReDim w(0 To N + 2# - 1)
    For i = 1# To N + 2# Step 1
        x(i - 1#) = d(i - 1#)
        w(i - 1#) = Mu0 * Square(z(0#, i - 1#))
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Computation of nodes and weights for a Gauss-Radau quadrature formula
'
'The algorithm generates the N-point Gauss-Radau  quadrature  formula  with
'weight function given by the coefficients alpha and  beta  of a recurrence
'which generates a system of orthogonal polynomials.
'
'P-1(x)   =  0
'P0(x)    =  1
'Pn+1(x)  =  (x-alpha(n))*Pn(x)  -  beta(n)*Pn-1(x)
'
'and zeroth moment Mu0
'
'Mu0 = integral(W(x)dx,a,b)
'
'INPUT PARAMETERS:
'    Alpha      array[0..N-2], alpha coefficients.
'    Beta       array[0..N-1], beta coefficients
'                Zero-indexed element is not used.
'                Beta[I]>0
'    Mu0        zeroth moment of the weighting function.
'    A          left boundary of the integration interval.
'    N          number of nodes of the quadrature formula, N>=2
'                (including the left boundary node).
'
'OUTPUT PARAMETERS:
'    Info    -   error code:
'                * -3    internal eigenproblem solver hasn't converged
'                * -2    Beta[i]<=0
'                * -1    incorrect N was passed
'                *  1    OK
'    X       -   array[0..N-1] - array of quadrature nodes,
'                in ascending order.
'    W       -   array[0..N-1] - array of quadrature weights.
'
'
'  -- ALGLIB --
'     Copyright 2005-2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub GQGenerateGaussRadauRec(ByRef Alpha_() As Double, _
         ByRef Beta_() As Double, _
         ByVal Mu0 As Double, _
         ByVal a As Double, _
         ByVal N As Long, _
         ByRef Info As Long, _
         ByRef x() As Double, _
         ByRef w() As Double)
    Dim alpha() As Double
    Dim beta() As Double
    Dim i As Long
    Dim d() As Double
    Dim e() As Double
    Dim z() As Double
    Dim PolIM1 As Double
    Dim PolI As Double
    Dim t As Double
    alpha = Alpha_
    beta = Beta_
    If N < 2# Then
        Info = -1#
        Exit Sub
    End If
    Info = 1#
    '
    ' Initialize, D[1:N], E[1:N]
    '
    N = N - 1#
    ReDim d(0 To N + 1# - 1)
    ReDim e(0 To N - 1)
    For i = 1# To N Step 1
        d(i - 1#) = alpha(i - 1#)
        If beta(i) <= 0# Then
            Info = -2#
            Exit Sub
        End If
        e(i - 1#) = Sqr(beta(i))
    Next i
    '
    ' Caclulate Pn(a), Pn-1(a), and D[N+1]
    '
    beta(0#) = 0#
    PolIM1 = 0#
    PolI = 1#
    For i = 1# To N Step 1
        t = (a - alpha(i - 1#)) * PolI - beta(i - 1#) * PolIM1
        PolIM1 = PolI
        PolI = t
    Next i
    d(N) = a - beta(N) * PolIM1 / PolI
    '
    ' EVD
    '
    If Not SMatrixTDEVD(d, e, N + 1#, 3#, z) Then
        Info = -3#
        Exit Sub
    End If
    '
    ' Generate
    '
    ReDim x(0# To N)
    ReDim w(0# To N)
    For i = 1# To N + 1# Step 1
        x(i - 1#) = d(i - 1#)
        w(i - 1#) = Mu0 * Square(z(0#, i - 1#))
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Returns nodes/weights for Gauss-Legendre quadrature on [-1,1] with N
'nodes.
'
'INPUT PARAMETERS:
'    N           -   number of nodes, >=1
'
'OUTPUT PARAMETERS:
'    Info        -   error code:
'                    * -4    an  error   was   detected   when  calculating
'                            weights/nodes.  N  is  too  large   to  obtain
'                            weights/nodes  with  high   enough   accuracy.
'                            Try  to   use   multiple   precision  version.
'                    * -3    internal eigenproblem solver hasn't  converged
'                    * -1    incorrect N was passed
'                    * +1    OK
'    X           -   array[0..N-1] - array of quadrature nodes,
'                    in ascending order.
'    W           -   array[0..N-1] - array of quadrature weights.
'
'
'  -- ALGLIB --
'     Copyright 12.05.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub GQGenerateGaussLegendre(ByVal N As Long, _
         ByRef Info As Long, _
         ByRef x() As Double, _
         ByRef w() As Double)
    Dim alpha() As Double
    Dim beta() As Double
    Dim i As Long
    If N < 1# Then
        Info = -1#
        Exit Sub
    End If
    ReDim alpha(0 To N - 1)
    ReDim beta(0 To N - 1)
    For i = 0# To N - 1# Step 1
        alpha(i) = 0#
    Next i
    beta(0#) = 2#
    For i = 1# To N - 1# Step 1
        beta(i) = 1# / (4# - 1# / Square(i))
    Next i
    Call GQGenerateRec(alpha, beta, beta(0#), N, Info, x, w)
    '
    ' test basic properties to detect errors
    '
    If Info > 0# Then
        If x(0#) < -1# Or x(N - 1#) > 1# Then
            Info = -4#
        End If
        For i = 0# To N - 2# Step 1
            If x(i) >= x(i + 1#) Then
                Info = -4#
            End If
        Next i
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Returns  nodes/weights  for  Gauss-Jacobi quadrature on [-1,1] with weight
'function W(x)=Power(1-x,Alpha)*Power(1+x,Beta).
'
'INPUT PARAMETERS:
'    N           -   number of nodes, >=1
'    Alpha       -   power-law coefficient, Alpha>-1
'    Beta        -   power-law coefficient, Beta>-1
'
'OUTPUT PARAMETERS:
'    Info        -   error code:
'                    * -4    an  error  was   detected   when   calculating
'                            weights/nodes. Alpha or  Beta  are  too  close
'                            to -1 to obtain weights/nodes with high enough
'                            accuracy, or, may be, N is too large.  Try  to
'                            use multiple precision version.
'                    * -3    internal eigenproblem solver hasn't converged
'                    * -1    incorrect N/Alpha/Beta was passed
'                    * +1    OK
'    X           -   array[0..N-1] - array of quadrature nodes,
'                    in ascending order.
'    W           -   array[0..N-1] - array of quadrature weights.
'
'
'  -- ALGLIB --
'     Copyright 12.05.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub GQGenerateGaussJacobi(ByVal N As Long, _
         ByVal alpha As Double, _
         ByVal beta As Double, _
         ByRef Info As Long, _
         ByRef x() As Double, _
         ByRef w() As Double)
    Dim a() As Double
    Dim B() As Double
    Dim Alpha2 As Double
    Dim Beta2 As Double
    Dim APB As Double
    Dim t As Double
    Dim i As Long
    Dim s As Double
    If N < 1# Or alpha <= -1# Or beta <= -1# Then
        Info = -1#
        Exit Sub
    End If
    ReDim a(0 To N - 1)
    ReDim B(0 To N - 1)
    APB = alpha + beta
    a(0#) = (beta - alpha) / (APB + 2#)
    t = (APB + 1#) * Log(2#) + LnGamma(alpha + 1#, s) + LnGamma(beta + 1#, s) - LnGamma(APB + 2#, s)
    If t > Log(MaxRealNumber) Then
        Info = -4#
        Exit Sub
    End If
    B(0#) = Exp(t)
    If N > 1# Then
        Alpha2 = Square(alpha)
        Beta2 = Square(beta)
        a(1#) = (Beta2 - Alpha2) / ((APB + 2#) * (APB + 4#))
        B(1#) = 4# * (alpha + 1#) * (beta + 1#) / ((APB + 3#) * Square(APB + 2#))
        For i = 2# To N - 1# Step 1
            a(i) = 0.25 * (Beta2 - Alpha2) / (i * i * (1# + 0.5 * APB / i) * (1# + 0.5 * (APB + 2#) / i))
            B(i) = 0.25 * (1# + alpha / i) * (1# + beta / i) * (1# + APB / i) / ((1# + 0.5 * (APB + 1#) / i) * (1# + 0.5 * (APB - 1#) / i) * Square(1# + 0.5 * APB / i))
        Next i
    End If
    Call GQGenerateRec(a, B, B(0#), N, Info, x, w)
    '
    ' test basic properties to detect errors
    '
    If Info > 0# Then
        If x(0#) < -1# Or x(N - 1#) > 1# Then
            Info = -4#
        End If
        For i = 0# To N - 2# Step 1
            If x(i) >= x(i + 1#) Then
                Info = -4#
            End If
        Next i
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Returns  nodes/weights  for  Gauss-Laguerre  quadrature  on  [0,+inf) with
'weight function W(x)=Power(x,Alpha)*Exp(-x)
'
'INPUT PARAMETERS:
'    N           -   number of nodes, >=1
'    Alpha       -   power-law coefficient, Alpha>-1
'
'OUTPUT PARAMETERS:
'    Info        -   error code:
'                    * -4    an  error  was   detected   when   calculating
'                            weights/nodes. Alpha is too  close  to  -1  to
'                            obtain weights/nodes with high enough accuracy
'                            or, may  be,  N  is  too  large.  Try  to  use
'                            multiple precision version.
'                    * -3    internal eigenproblem solver hasn't converged
'                    * -1    incorrect N/Alpha was passed
'                    * +1    OK
'    X           -   array[0..N-1] - array of quadrature nodes,
'                    in ascending order.
'    W           -   array[0..N-1] - array of quadrature weights.
'
'
'  -- ALGLIB --
'     Copyright 12.05.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub GQGenerateGaussLaguerre(ByVal N As Long, _
         ByVal alpha As Double, _
         ByRef Info As Long, _
         ByRef x() As Double, _
         ByRef w() As Double)
    Dim a() As Double
    Dim B() As Double
    Dim t As Double
    Dim i As Long
    Dim s As Double
    If N < 1# Or alpha <= -1# Then
        Info = -1#
        Exit Sub
    End If
    ReDim a(0 To N - 1)
    ReDim B(0 To N - 1)
    a(0#) = alpha + 1#
    t = LnGamma(alpha + 1#, s)
    If t >= Log(MaxRealNumber) Then
        Info = -4#
        Exit Sub
    End If
    B(0#) = Exp(t)
    If N > 1# Then
        For i = 1# To N - 1# Step 1
            a(i) = 2# * i + alpha + 1#
            B(i) = i * (i + alpha)
        Next i
    End If
    Call GQGenerateRec(a, B, B(0#), N, Info, x, w)
    '
    ' test basic properties to detect errors
    '
    If Info > 0# Then
        If x(0#) < 0# Then
            Info = -4#
        End If
        For i = 0# To N - 2# Step 1
            If x(i) >= x(i + 1#) Then
                Info = -4#
            End If
        Next i
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Returns  nodes/weights  for  Gauss-Hermite  quadrature on (-inf,+inf) with
'weight function W(x)=Exp(-x*x)
'
'INPUT PARAMETERS:
'    N           -   number of nodes, >=1
'
'OUTPUT PARAMETERS:
'    Info        -   error code:
'                    * -4    an  error  was   detected   when   calculating
'                            weights/nodes.  May be, N is too large. Try to
'                            use multiple precision version.
'                    * -3    internal eigenproblem solver hasn't converged
'                    * -1    incorrect N/Alpha was passed
'                    * +1    OK
'    X           -   array[0..N-1] - array of quadrature nodes,
'                    in ascending order.
'    W           -   array[0..N-1] - array of quadrature weights.
'
'
'  -- ALGLIB --
'     Copyright 12.05.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub GQGenerateGaussHermite(ByVal N As Long, _
         ByRef Info As Long, _
         ByRef x() As Double, _
         ByRef w() As Double)
    Dim a() As Double
    Dim B() As Double
    Dim i As Long
    If N < 1# Then
        Info = -1#
        Exit Sub
    End If
    ReDim a(0 To N - 1)
    ReDim B(0 To N - 1)
    For i = 0# To N - 1# Step 1
        a(i) = 0#
    Next i
    B(0#) = Sqr(4# * Atn(1#))
    If N > 1# Then
        For i = 1# To N - 1# Step 1
            B(i) = 0.5 * i
        Next i
    End If
    Call GQGenerateRec(a, B, B(0#), N, Info, x, w)
    '
    ' test basic properties to detect errors
    '
    If Info > 0# Then
        For i = 0# To N - 2# Step 1
            If x(i) >= x(i + 1#) Then
                Info = -4#
            End If
        Next i
    End If
End Sub
Public Function FormatInteger(i As Long, w As Long) As String
    If w <= 1 Then
        FormatInteger = Format(i, "0")
    Else
        tmp = Format(i, String(w - 1, "#") & "0")
        Do While Len(tmp) < w
            tmp = " " & tmp
        Loop
        FormatInteger = tmp
    End If
End Function
Public Function FormatFReal(R As Double, w As Long, p As Long) As String
    tmp = Format(R, "0." & String(p, "0"))
    Do While Len(tmp) < w
        tmp = " " & tmp
    Loop
    FormatFReal = tmp
End Function
Public Function FormatEReal(R As Double, w As Long, p As Long) As String
    tmp = Format(R, "0." & String(p, "0") & "E+0")
    Do While Len(tmp) < w
        tmp = " " & tmp
    Loop
    FormatEReal = tmp
End Function
Public Sub ConsoleOutputString(s As String)
End Sub
Public Function MaxReal(ByVal M1 As Double, ByVal M2 As Double) As Double
    If M1 > M2 Then
        MaxReal = M1
    Else
        MaxReal = M2
    End If
End Function
Public Function MinReal(ByVal M1 As Double, ByVal M2 As Double) As Double
    If M1 < M2 Then
        MinReal = M1
    Else
        MinReal = M2
    End If
End Function
Public Function MaxInt(ByVal M1 As Long, ByVal M2 As Long) As Long
    If M1 > M2 Then
        MaxInt = M1
    Else
        MaxInt = M2
    End If
End Function
Public Function MinInt(ByVal M1 As Long, ByVal M2 As Long) As Long
    If M1 < M2 Then
        MinInt = M1
    Else
        MinInt = M2
    End If
End Function
Public Function ArcSin(ByVal x As Double) As Double
    Dim t As Double
    t = Sqr(1 - x * x)
    If t < SmallNumber Then
        ArcSin = Atn(BigNumber * Sgn(x))
    Else
        ArcSin = Atn(x / t)
    End If
End Function
Public Function ArcCos(ByVal x As Double) As Double
    Dim t As Double
    t = Sqr(1 - x * x)
    If t < SmallNumber Then
        ArcCos = Atn(BigNumber * Sgn(-x)) + 2 * Atn(1)
    Else
        ArcCos = Atn(-x / t) + 2 * Atn(1)
    End If
End Function
Public Function SinH(ByVal x As Double) As Double
    SinH = (Exp(x) - Exp(-x)) / 2
End Function
Public Function CosH(ByVal x As Double) As Double
    CosH = (Exp(x) + Exp(-x)) / 2
End Function
Public Function TanH(ByVal x As Double) As Double
    Dim t As Double
    If x > 0 Then
        t = Exp(-x)
        t = t * t
        TanH = (1 - t) / (1 + t)
    Else
        t = Exp(x)
        t = t * t
        TanH = (t - 1) / (t + 1)
    End If
End Function
Public Function pi() As Double
    'Pi = PiNumber
    pi = ArcCos(-1)
End Function
Public Function Power(ByVal Base As Double, ByVal Exponent As Double) As Double
    Power = Base ^ Exponent
End Function
Public Function Square(ByVal x As Double) As Double
    Square = x * x
End Function
Public Function Log10(ByVal x As Double) As Double
    Log10 = Log(x) / Log(10)
End Function
Public Function Ceil(ByVal x As Double) As Double
    Ceil = -Int(-x)
End Function
Public Function RandomInteger(ByVal x As Long) As Long
    RandomInteger = Int(Rnd() * x)
End Function
Public Function Atn2(ByVal y As Double, ByVal x As Double) As Double
    If SmallNumber * Abs(y) < Abs(x) Then
        If x < 0 Then
            If y = 0 Then
                Atn2 = pi()
            Else
                Atn2 = Atn(y / x) + pi() * Sgn(y)
            End If
        Else
            Atn2 = Atn(y / x)
        End If
    Else
        Atn2 = Sgn(y) * pi() / 2
    End If
End Function
Public Function C_Complex(ByVal x As Double) As Complex
    Dim Result As Complex
    Result.x = x
    Result.y = 0
    C_Complex = Result
End Function
Public Function AbsComplex(ByRef z As Complex) As Double
    Dim Result As Double
    Dim w As Double
    Dim XABS As Double
    Dim YABS As Double
    Dim V As Double
    XABS = Abs(z.x)
    YABS = Abs(z.y)
    w = MaxReal(XABS, YABS)
    V = MinReal(XABS, YABS)
    If V = 0 Then
        Result = w
    Else
        Result = w * Sqr(1 + Square(V / w))
    End If
    AbsComplex = Result
End Function
Public Function C_Opposite(ByRef z As Complex) As Complex
    Dim Result As Complex
    Result.x = -z.x
    Result.y = -z.y
    C_Opposite = Result
End Function
Public Function Conj(ByRef z As Complex) As Complex
    Dim Result As Complex
    Result.x = z.x
    Result.y = -z.y
    Conj = Result
End Function
Public Function CSqr(ByRef z As Complex) As Complex
    Dim Result As Complex
    Result.x = Square(z.x) - Square(z.y)
    Result.y = 2 * z.x * z.y
    CSqr = Result
End Function
Public Function C_Add(ByRef Z1 As Complex, ByRef Z2 As Complex) As Complex
    Dim Result As Complex
    Result.x = Z1.x + Z2.x
    Result.y = Z1.y + Z2.y
    C_Add = Result
End Function
Public Function C_Mul(ByRef Z1 As Complex, ByRef Z2 As Complex) As Complex
    Dim Result As Complex
    Result.x = Z1.x * Z2.x - Z1.y * Z2.y
    Result.y = Z1.x * Z2.y + Z1.y * Z2.x
    C_Mul = Result
End Function
Public Function C_AddR(ByRef Z1 As Complex, ByVal R As Double) As Complex
    Dim Result As Complex
    Result.x = Z1.x + R
    Result.y = Z1.y
    C_AddR = Result
End Function
Public Function C_MulR(ByRef Z1 As Complex, ByVal R As Double) As Complex
    Dim Result As Complex
    Result.x = Z1.x * R
    Result.y = Z1.y * R
    C_MulR = Result
End Function
Public Function C_Sub(ByRef Z1 As Complex, ByRef Z2 As Complex) As Complex
    Dim Result As Complex
    Result.x = Z1.x - Z2.x
    Result.y = Z1.y - Z2.y
    C_Sub = Result
End Function
Public Function C_SubR(ByRef Z1 As Complex, ByVal R As Double) As Complex
    Dim Result As Complex
    Result.x = Z1.x - R
    Result.y = Z1.y
    C_SubR = Result
End Function
Public Function C_RSub(ByVal R As Double, ByRef Z1 As Complex) As Complex
    Dim Result As Complex
    Result.x = R - Z1.x
    Result.y = -Z1.y
    C_RSub = Result
End Function
Public Function C_Div(ByRef Z1 As Complex, ByRef Z2 As Complex) As Complex
    Dim Result As Complex
    Dim a As Double
    Dim B As Double
    Dim C As Double
    Dim d As Double
    Dim e As Double
    Dim f As Double
    a = Z1.x
    B = Z1.y
    C = Z2.x
    d = Z2.y
    If Abs(d) < Abs(C) Then
        e = d / C
        f = C + d * e
        Result.x = (a + B * e) / f
        Result.y = (B - a * e) / f
    Else
        e = C / d
        f = d + C * e
        Result.x = (B + a * e) / f
        Result.y = (-a + B * e) / f
    End If
    C_Div = Result
End Function
Public Function C_DivR(ByRef Z1 As Complex, ByVal R As Double) As Complex
    Dim Result As Complex
    Result.x = Z1.x / R
    Result.y = Z1.y / R
    C_DivR = Result
End Function
Public Function C_RDiv(ByVal R As Double, ByRef Z2 As Complex) As Complex
    Dim Result As Complex
    Dim a As Double
    Dim C As Double
    Dim d As Double
    Dim e As Double
    Dim f As Double
    a = R
    C = Z2.x
    d = Z2.y
    If Abs(d) < Abs(C) Then
        e = d / C
        f = C + d * e
        Result.x = a / f
        Result.y = -(a * e / f)
    Else
        e = C / d
        f = d + C * e
        Result.x = a * e / f
        Result.y = -(a / f)
    End If
    C_RDiv = Result
End Function
Public Function C_Equal(ByRef Z1 As Complex, ByRef Z2 As Complex) As Boolean
    Dim Result As Boolean
    Result = Z1.x = Z2.x And Z1.y = Z2.y
    C_Equal = Result
End Function
Public Function C_NotEqual(ByRef Z1 As Complex, _
         ByRef Z2 As Complex) As Boolean
    Dim Result As Boolean
    Result = Z1.x <> Z2.x Or Z1.y <> Z2.y
    C_NotEqual = Result
End Function
Public Function C_EqualR(ByRef Z1 As Complex, ByVal R As Double) As Boolean
    Dim Result As Boolean
    Result = Z1.x = R And Z1.y = 0
    C_EqualR = Result
End Function
Public Function C_NotEqualR(ByRef Z1 As Complex, _
         ByVal R As Double) As Boolean
    Dim Result As Boolean
    Result = Z1.x <> R Or Z1.y <> 0
    C_NotEqualR = Result
End Function
Public Function SplitTrim(ByVal s As String, ByVal SEP As String) As String()
    Dim SPrev As String
    s = Trim(s)
    Do
        SPrev = s
        s = Replace(s, "  ", " ")
    Loop Until s = SPrev
    SplitTrim = Split(s, SEP)
End Function
Public Function OpenDataset(ByVal FileName As String, ByRef DS As ALGLIBDataset) As Boolean
    DS.NClasses = 0
    DS.NIn = 0
    DS.NOut = 0
    DS.TotalSize = 0
    DS.TrnSize = 0
    DS.TstSize = 0
    DS.ValSize = 0
    
    FileNumber = FreeFile()
    LinesRead = 0
    On Error GoTo HandleNoFile
    Open FileName For Input As FileNumber
    On Error GoTo HandleErrorWithinFile
    Do While Not EOF(FileNumber)
        Line Input #FileNumber, TextLine
        If (Left(TextLine, 2) <> "//") And (Trim(TextLine) <> "") Then
            If LinesRead = 0 Then
                '
                ' read header
                '
                HeadArr = SplitTrim(TextLine, "#")
                If UBound(HeadArr) <> 1 Then Error 1
                
                '
                ' rows information
                '
                RowsArr = SplitTrim(HeadArr(0), " ")
                If (UBound(RowsArr) < 0) Or (UBound(RowsArr) > 2) Then Error 1
                If UBound(RowsArr) = 0 Then
                    DS.TotalSize = val(RowsArr(0))
                    DS.TrnSize = DS.TotalSize
                End If
                If UBound(RowsArr) = 1 Then
                    DS.TrnSize = val(RowsArr(0))
                    DS.TstSize = val(RowsArr(1))
                    DS.TotalSize = DS.TrnSize + DS.TstSize
                End If
                If UBound(RowsArr) = 2 Then
                    DS.TrnSize = val(RowsArr(0))
                    DS.ValSize = val(RowsArr(1))
                    DS.TstSize = val(RowsArr(2))
                    DS.TotalSize = DS.TrnSize + DS.ValSize + DS.TstSize
                End If
                If DS.TotalSize <= 0 Or DS.TrnSize < 0 Or DS.ValSize < 0 Or DS.TstSize < 0 Then Error 1
                TrnFirst = 0
                TrnLast = TrnFirst + DS.TrnSize
                ValFirst = TrnLast
                ValLast = ValFirst + DS.ValSize
                TstFirst = ValLast
                TstLast = TstFirst + DS.TstSize
                
                '
                ' columns
                '
                ColsArr = SplitTrim(HeadArr(1), " ")
                If (UBound(ColsArr) <> 0) And (UBound(ColsArr) <> 3) Then Error 1
                If UBound(ColsArr) = 0 Then
                    DS.NIn = val(ColsArr(0))
                    If DS.NIn <= 0 Then Error 1
                End If
                If UBound(ColsArr) = 3 Then
                    If (LCase(ColsArr(0)) <> "reg") And (LCase(ColsArr(0)) <> "cls") Then Error 1
                    If ColsArr(2) <> "=>" Then Error 1
                    DS.NIn = val(ColsArr(1))
                    If DS.NIn < 1 Then Error 1
                    If LCase(ColsArr(0)) = "reg" Then
                        DS.NClasses = 0
                        DS.NOut = val(ColsArr(3))
                        If DS.NOut < 1 Then Error 1
                    Else
                        DS.NClasses = val(ColsArr(3))
                        DS.NOut = 1
                        If DS.NClasses < 2 Then Error 1
                    End If
                End If
                
                '
                ' initialize arrays
                '
                ReDim DS.AllDataset(0 To DS.TotalSize - 1, 0 To DS.NIn + DS.NOut - 1)
                If DS.TrnSize > 0 Then ReDim DS.Trn(0 To DS.TrnSize - 1, 0 To DS.NIn + DS.NOut - 1)
                If DS.ValSize > 0 Then ReDim DS.val(0 To DS.ValSize - 1, 0 To DS.NIn + DS.NOut - 1)
                If DS.TstSize > 0 Then ReDim DS.TST(0 To DS.TstSize - 1, 0 To DS.NIn + DS.NOut - 1)
            Else
                '
                ' read data
                '
                VarsArr = SplitTrim(TextLine, " ")
                If UBound(VarsArr) <> DS.NIn + DS.NOut - 1 Then Error 1
                TmpC = Round(VarsArr(DS.NIn + DS.NOut - 1))
                If (DS.NClasses > 0) And ((TmpC < 0) Or (TmpC >= DS.NClasses)) Then Error 1
                RowIndex = LinesRead - 1
                For i = 0 To DS.NIn + DS.NOut - 1 Step 1
                    DS.AllDataset(RowIndex, i) = VarsArr(i)
                    If RowIndex >= TrnFirst And RowIndex < TrnLast Then
                        DS.Trn(RowIndex - TrnFirst, i) = VarsArr(i)
                    End If
                    If RowIndex >= ValFirst And RowIndex < ValLast Then
                        DS.val(RowIndex - ValFirst, i) = VarsArr(i)
                    End If
                    If RowIndex >= TstFirst And RowIndex < TstLast Then
                        DS.TST(RowIndex - TstFirst, i) = VarsArr(i)
                    End If
                Next i
            End If
            LinesRead = LinesRead + 1
        End If
    Loop
    Close FileNumber
    OpenDataset = True
    Exit Function
HandleNoFile:
    OpenDataset = False
    Exit Function
HandleErrorWithinFile:
    Close FileNumber
    OpenDataset = False
    Exit Function
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2009, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This  function  generates  1-dimensional  general  interpolation task with
'moderate Lipshitz constant (close to 1.0)
'
'If N=1 then suborutine generates only one point at the middle of [A,B]
'
'  -- ALGLIB --
'     Copyright 02.12.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub TaskGenInt1D(ByVal a As Double, _
         ByVal B As Double, _
         ByVal N As Long, _
         ByRef x() As Double, _
         ByRef y() As Double)
    Dim i As Long
    Dim h As Double
    ReDim x(0 To N - 1)
    ReDim y(0 To N - 1)
    If N > 1# Then
        x(0#) = a
        y(0#) = 2# * Rnd() - 1#
        h = (B - a) / (N - 1#)
        For i = 1# To N - 1# Step 1
            If i <> N - 1# Then
                x(i) = a + (i + 0.2 * (2# * Rnd() - 1#)) * h
            Else
                x(i) = B
            End If
            y(i) = y(i - 1#) + (2# * Rnd() - 1#) * (x(i) - x(i - 1#))
        Next i
    Else
        x(0#) = 0.5 * (a + B)
        y(0#) = 2# * Rnd() - 1#
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function generates  1-dimensional equidistant interpolation task with
'moderate Lipshitz constant (close to 1.0)
'
'If N=1 then suborutine generates only one point at the middle of [A,B]
'
'  -- ALGLIB --
'     Copyright 02.12.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub TaskGenInt1DEquidist(ByVal a As Double, _
         ByVal B As Double, _
         ByVal N As Long, _
         ByRef x() As Double, _
         ByRef y() As Double)
    Dim i As Long
    Dim h As Double
    ReDim x(0 To N - 1)
    ReDim y(0 To N - 1)
    If N > 1# Then
        x(0#) = a
        y(0#) = 2# * Rnd() - 1#
        h = (B - a) / (N - 1#)
        For i = 1# To N - 1# Step 1
            x(i) = a + i * h
            y(i) = y(i - 1#) + (2# * Rnd() - 1#) * h
        Next i
    Else
        x(0#) = 0.5 * (a + B)
        y(0#) = 2# * Rnd() - 1#
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function generates  1-dimensional Chebyshev-1 interpolation task with
'moderate Lipshitz constant (close to 1.0)
'
'If N=1 then suborutine generates only one point at the middle of [A,B]
'
'  -- ALGLIB --
'     Copyright 02.12.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub TaskGenInt1DCheb1(ByVal a As Double, _
         ByVal B As Double, _
         ByVal N As Long, _
         ByRef x() As Double, _
         ByRef y() As Double)
    Dim i As Long
    ReDim x(0 To N - 1)
    ReDim y(0 To N - 1)
    If N > 1# Then
        For i = 0# To N - 1# Step 1
            x(i) = 0.5 * (B + a) + 0.5 * (B - a) * Cos(pi() * (2# * i + 1#) / (2# * N))
            If i = 0# Then
                y(i) = 2# * Rnd() - 1#
            Else
                y(i) = y(i - 1#) + (2# * Rnd() - 1#) * (x(i) - x(i - 1#))
            End If
        Next i
    Else
        x(0#) = 0.5 * (a + B)
        y(0#) = 2# * Rnd() - 1#
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function generates  1-dimensional Chebyshev-2 interpolation task with
'moderate Lipshitz constant (close to 1.0)
'
'If N=1 then suborutine generates only one point at the middle of [A,B]
'
'  -- ALGLIB --
'     Copyright 02.12.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub TaskGenInt1DCheb2(ByVal a As Double, _
         ByVal B As Double, _
         ByVal N As Long, _
         ByRef x() As Double, _
         ByRef y() As Double)
    Dim i As Long
    ReDim x(0 To N - 1)
    ReDim y(0 To N - 1)
    If N > 1# Then
        For i = 0# To N - 1# Step 1
            x(i) = 0.5 * (B + a) + 0.5 * (B - a) * Cos(pi() * i / (N - 1#))
            If i = 0# Then
                y(i) = 2# * Rnd() - 1#
            Else
                y(i) = y(i - 1#) + (2# * Rnd() - 1#) * (x(i) - x(i - 1#))
            End If
        Next i
    Else
        x(0#) = 0.5 * (a + B)
        y(0#) = 2# * Rnd() - 1#
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function checks that all values from X[] are distinct. It does more
'than just usual floating point comparison:
'* first, it calculates max(X) and min(X)
'* second, it maps X[] from [min,max] to [1,2]
'* only at this stage actual comparison is done
'
'The meaning of such check is to ensure that all values are "distinct enough"
'and will not cause interpolation subroutine to fail.
'
'NOTE:
'    X[] must be sorted by ascending (subroutine ASSERT's it)
'
'  -- ALGLIB --
'     Copyright 02.12.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function APSERVAreDistinct(ByRef x_() As Double, _
         ByVal N As Long) As Boolean
    Dim Result As Boolean
    Dim x() As Double
    Dim IsSorted As Boolean
    Dim a As Double
    Dim B As Double
    Dim i As Long
    x = x_
    If N = 1# Then
        '
        ' everything is alright, it is up to caller to decide whether it
        ' can interpolate something with just one point
        '
        Result = True
        APSERVAreDistinct = Result
        Exit Function
    End If
    a = x(0#)
    B = x(0#)
    For i = 1# To N - 1# Step 1
        a = MinReal(a, x(i))
        B = MaxReal(B, x(i))
    Next i
    For i = 0# To N - 1# Step 1
        x(i) = (x(i) - a) / (B - a) + 1#
    Next i
    For i = 1# To N - 1# Step 1
        If x(i) = x(i - 1#) Then
            Result = False
            APSERVAreDistinct = Result
            Exit Function
        End If
    Next i
    Result = True
    APSERVAreDistinct = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Safe sqrt(x^2+y^2)
'
'  -- ALGLIB --
'     Copyright by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function SafePythag2(ByVal x As Double, ByVal y As Double) As Double
    Dim Result As Double
    Dim w As Double
    Dim XABS As Double
    Dim YABS As Double
    Dim z As Double
    XABS = Abs(x)
    YABS = Abs(y)
    w = MaxReal(XABS, YABS)
    z = MinReal(XABS, YABS)
    If z = 0# Then
        Result = w
    Else
        Result = w * Sqr(1# + Square(z / w))
    End If
    SafePythag2 = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Safe sqrt(x^2+y^2)
'
'  -- ALGLIB --
'     Copyright by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function SafePythag3(ByVal x As Double, _
         ByVal y As Double, _
         ByVal z As Double) As Double
    Dim Result As Double
    Dim w As Double
    w = MaxReal(Abs(x), MaxReal(Abs(y), Abs(z)))
    If w = 0# Then
        Result = 0#
        SafePythag3 = Result
        Exit Function
    End If
    x = x / w
    y = y / w
    z = z / w
    Result = w * Sqr(Square(x) + Square(y) + Square(z))
    SafePythag3 = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function makes periodic mapping of X to [A,B].
'
'It accepts X, A, B (A>B). It returns T which lies in  [A,B] and integer K,
'such that X = T + K*(B-A).
'
'NOTES:
'* K is represented as real value, although actually it is integer
'* T is guaranteed to be in [A,B]
'* T replaces X
'
'  -- ALGLIB --
'     Copyright by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub APPeriodicMap(ByRef x As Double, _
         ByVal a As Double, _
         ByVal B As Double, _
         ByRef K As Double)
    K = Int((x - a) / (B - a))
    x = x - K * (B - a)
    Do While x < a
        x = x + (B - a)
        K = K - 1#
    Loop
    Do While x > B
        x = x - (B - a)
        K = K + 1#
    Loop
    x = MaxReal(x, a)
    x = MinReal(x, B)
End Sub
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'More precise dot-product. Absolute error of  subroutine  result  is  about
'1 ulp of max(MX,V), where:
'    MX = max( |a[i]*b[i]| )
'    V  = |(a,b)|
'
'INPUT PARAMETERS
'    A       -   array[0..N-1], vector 1
'    B       -   array[0..N-1], vector 2
'    N       -   vectors length, N<2^29.
'    Temp    -   array[0..N-1], pre-allocated temporary storage
'
'OUTPUT PARAMETERS
'    R       -   (A,B)
'    RErr    -   estimate of error. This estimate accounts for both  errors
'                during  calculation  of  (A,B)  and  errors  introduced by
'                rounding of A and B to fit in double (about 1 ulp).
'
'  -- ALGLIB --
'     Copyright 24.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub XDot(ByRef a() As Double, _
         ByRef B() As Double, _
         ByVal N As Long, _
         ByRef temp() As Double, _
         ByRef R As Double, _
         ByRef RErr As Double)
    Dim i As Long
    Dim MX As Double
    Dim V As Double
    '
    ' special cases:
    ' * N=0
    '
    If N = 0# Then
        R = 0#
        RErr = 0#
        Exit Sub
    End If
    MX = 0#
    For i = 0# To N - 1# Step 1
        V = a(i) * B(i)
        temp(i) = V
        MX = MaxReal(MX, Abs(V))
    Next i
    If MX = 0# Then
        R = 0#
        RErr = 0#
        Exit Sub
    End If
    Call XSum(temp, MX, N, R, RErr)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'More precise complex dot-product. Absolute error of  subroutine  result is
'about 1 ulp of max(MX,V), where:
'    MX = max( |a[i]*b[i]| )
'    V  = |(a,b)|
'
'INPUT PARAMETERS
'    A       -   array[0..N-1], vector 1
'    B       -   array[0..N-1], vector 2
'    N       -   vectors length, N<2^29.
'    Temp    -   array[0..2*N-1], pre-allocated temporary storage
'
'OUTPUT PARAMETERS
'    R       -   (A,B)
'    RErr    -   estimate of error. This estimate accounts for both  errors
'                during  calculation  of  (A,B)  and  errors  introduced by
'                rounding of A and B to fit in double (about 1 ulp).
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub XCDot(ByRef a() As Complex, _
         ByRef B() As Complex, _
         ByVal N As Long, _
         ByRef temp() As Double, _
         ByRef R As Complex, _
         ByRef RErr As Double)
    Dim i As Long
    Dim MX As Double
    Dim V As Double
    Dim RErrX As Double
    Dim RErrY As Double
    '
    ' special cases:
    ' * N=0
    '
    If N = 0# Then
        R = C_Complex(0#)
        RErr = 0#
        Exit Sub
    End If
    '
    ' calculate real part
    '
    MX = 0#
    For i = 0# To N - 1# Step 1
        V = a(i).x * B(i).x
        temp(2# * i + 0#) = V
        MX = MaxReal(MX, Abs(V))
        V = -(a(i).y * B(i).y)
        temp(2# * i + 1#) = V
        MX = MaxReal(MX, Abs(V))
    Next i
    If MX = 0# Then
        R.x = 0#
        RErrX = 0#
    Else
        Call XSum(temp, MX, 2# * N, R.x, RErrX)
    End If
    '
    ' calculate imaginary part
    '
    MX = 0#
    For i = 0# To N - 1# Step 1
        V = a(i).x * B(i).y
        temp(2# * i + 0#) = V
        MX = MaxReal(MX, Abs(V))
        V = a(i).y * B(i).x
        temp(2# * i + 1#) = V
        MX = MaxReal(MX, Abs(V))
    Next i
    If MX = 0# Then
        R.y = 0#
        RErrY = 0#
    Else
        Call XSum(temp, MX, 2# * N, R.y, RErrY)
    End If
    '
    ' total error
    '
    If RErrX = 0# And RErrY = 0# Then
        RErr = 0#
    Else
        RErr = MaxReal(RErrX, RErrY) * Sqr(1# + Square(MinReal(RErrX, RErrY) / MaxReal(RErrX, RErrY)))
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal subroutine for extra-precise calculation of SUM(w[i]).
'
'INPUT PARAMETERS:
'    W   -   array[0..N-1], values to be added
'            W is modified during calculations.
'    MX  -   max(W[i])
'    N   -   array size
'
'OUTPUT PARAMETERS:
'    R   -   SUM(w[i])
'    RErr-   error estimate for R
'
'  -- ALGLIB --
'     Copyright 24.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub XSum(ByRef w() As Double, _
         ByVal MX As Double, _
         ByVal N As Long, _
         ByRef R As Double, _
         ByRef RErr As Double)
    Dim i As Long
    Dim K As Long
    Dim KS As Long
    Dim V As Double
    Dim s As Double
    Dim LN2 As Double
    Dim Chunk As Double
    Dim InvChunk As Double
    Dim AllZeros As Boolean
    Dim i_ As Long
    '
    ' special cases:
    ' * N=0
    ' * N is too large to use integer arithmetics
    '
    If N = 0# Then
        R = 0#
        RErr = 0#
        Exit Sub
    End If
    If MX = 0# Then
        R = 0#
        RErr = 0#
        Exit Sub
    End If
    '
    ' Prepare
    '
    LN2 = Log(2#)
    RErr = MX * MachineEpsilon
    '
    ' 1. find S such that 0.5<=S*MX<1
    ' 2. multiply W by S, so task is normalized in some sense
    ' 3. S:=1/S so we can obtain original vector multiplying by S
    '
    K = Round(Log(MX) / LN2)
    s = XFastPow(2#, -K)
    Do While s * MX >= 1#
        s = 0.5 * s
    Loop
    Do While s * MX < 0.5
        s = 2# * s
    Loop
    For i_ = 0# To N - 1# Step 1
        w(i_) = s * w(i_)
    Next i_
    s = 1# / s
    '
    ' find Chunk=2^M such that N*Chunk<2^29
    '
    ' we have chosen upper limit (2^29) with enough space left
    ' to tolerate possible problems with rounding and N's close
    ' to the limit, so we don't want to be very strict here.
    '
    K = Fix(Log(536870912# / N) / LN2)
    Chunk = XFastPow(2#, K)
    If Chunk < 2# Then
        Chunk = 2#
    End If
    InvChunk = 1# / Chunk
    '
    ' calculate result
    '
    R = 0#
    For i_ = 0# To N - 1# Step 1
        w(i_) = Chunk * w(i_)
    Next i_
    Do While True
        s = s * InvChunk
        AllZeros = True
        KS = 0#
        For i = 0# To N - 1# Step 1
            V = w(i)
            K = Fix(V)
            If V <> K Then
                AllZeros = False
            End If
            w(i) = Chunk * (V - K)
            KS = KS + K
        Next i
        R = R + s * KS
        V = Abs(R)
        If AllZeros Or s * N + MX = MX Then
            Exit Do
        End If
    Loop
    '
    ' correct error
    '
    RErr = MaxReal(RErr, Abs(R) * MachineEpsilon)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Fast Pow
'
'  -- ALGLIB --
'     Copyright 24.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Function XFastPow(ByVal R As Double, ByVal N As Long) As Double
    Dim Result As Double
    If N > 0# Then
        If N Mod 2# = 0# Then
            Result = Square(XFastPow(R, N \ 2#))
        Else
            Result = R * XFastPow(R, N - 1#)
        End If
        XFastPow = Result
        Exit Function
    End If
    If N = 0# Then
        Result = 1#
    End If
    If N < 0# Then
        Result = XFastPow(1# / R, -N)
    End If
    XFastPow = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright 2008 by Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
Public Sub TagSort(ByRef a() As Double, _
         ByVal N As Long, _
         ByRef p1() As Long, _
         ByRef p2() As Long)
    Dim i As Long
    Dim PV() As Long
    Dim VP() As Long
    Dim LV As Long
    Dim LP As Long
    Dim RV As Long
    Dim RP As Long
    '
    ' Special cases
    '
    If N <= 0# Then
        Exit Sub
    End If
    If N = 1# Then
        ReDim p1(0# To 0#)
        ReDim p2(0# To 0#)
        p1(0#) = 0#
        p2(0#) = 0#
        Exit Sub
    End If
    '
    ' General case, N>1: prepare permutations table P1
    '
    ReDim p1(0# To N - 1#)
    For i = 0# To N - 1# Step 1
        p1(i) = i
    Next i
    '
    ' General case, N>1: sort, update P1
    '
    Call TagSortFastI(a, p1, N)
    '
    ' General case, N>1: fill permutations table P2
    '
    ' To fill P2 we maintain two arrays:
    ' * PV, Position(Value). PV[i] contains position of I-th key at the moment
    ' * VP, Value(Position). VP[i] contains key which has position I at the moment
    '
    ' At each step we making permutation of two items:
    '   Left, which is given by position/value pair LP/LV
    '   and Right, which is given by RP/RV
    ' and updating PV[] and VP[] correspondingly.
    '
    ReDim PV(0# To N - 1#)
    ReDim VP(0# To N - 1#)
    ReDim p2(0# To N - 1#)
    For i = 0# To N - 1# Step 1
        PV(i) = i
        VP(i) = i
    Next i
    For i = 0# To N - 1# Step 1
        '
        ' calculate LP, LV, RP, RV
        '
        LP = i
        LV = VP(LP)
        RV = p1(i)
        RP = PV(RV)
        '
        ' Fill P2
        '
        p2(i) = RP
        '
        ' update PV and VP
        '
        VP(LP) = RV
        VP(RP) = LV
        PV(LV) = RP
        PV(RV) = LP
    Next i
End Sub
Public Sub TagSortFastI(ByRef a() As Double, _
         ByRef B() As Long, _
         ByVal N As Long)
    Dim i As Long
    Dim K As Long
    Dim t As Long
    Dim tmp As Double
    Dim TmpI As Long
    '
    ' Special cases
    '
    If N <= 1# Then
        Exit Sub
    End If
    '
    ' General case, N>1: sort, update B
    '
    i = 2#
    Do
        t = i
        Do While t <> 1#
            K = t \ 2#
            If a(K - 1#) >= a(t - 1#) Then
                t = 1#
            Else
                tmp = a(K - 1#)
                a(K - 1#) = a(t - 1#)
                a(t - 1#) = tmp
                TmpI = B(K - 1#)
                B(K - 1#) = B(t - 1#)
                B(t - 1#) = TmpI
                t = K
            End If
        Loop
        i = i + 1#
    Loop Until Not i <= N
    i = N - 1#
    Do
        tmp = a(i)
        a(i) = a(0#)
        a(0#) = tmp
        TmpI = B(i)
        B(i) = B(0#)
        B(0#) = TmpI
        t = 1#
        Do While t <> 0#
            K = 2# * t
            If K > i Then
                t = 0#
            Else
                If K < i Then
                    If a(K) > a(K - 1#) Then
                        K = K + 1#
                    End If
                End If
                If a(t - 1#) >= a(K - 1#) Then
                    t = 0#
                Else
                    tmp = a(K - 1#)
                    a(K - 1#) = a(t - 1#)
                    a(t - 1#) = tmp
                    TmpI = B(K - 1#)
                    B(K - 1#) = B(t - 1#)
                    B(t - 1#) = TmpI
                    t = K
                End If
            End If
        Loop
        i = i - 1#
    Loop Until Not i >= 1#
End Sub
Public Sub TagSortFastR(ByRef a() As Double, _
         ByRef B() As Double, _
         ByVal N As Long)
    Dim i As Long
    Dim K As Long
    Dim t As Long
    Dim tmp As Double
    Dim TmpR As Double
    '
    ' Special cases
    '
    If N <= 1# Then
        Exit Sub
    End If
    '
    ' General case, N>1: sort, update B
    '
    i = 2#
    Do
        t = i
        Do While t <> 1#
            K = t \ 2#
            If a(K - 1#) >= a(t - 1#) Then
                t = 1#
            Else
                tmp = a(K - 1#)
                a(K - 1#) = a(t - 1#)
                a(t - 1#) = tmp
                TmpR = B(K - 1#)
                B(K - 1#) = B(t - 1#)
                B(t - 1#) = TmpR
                t = K
            End If
        Loop
        i = i + 1#
    Loop Until Not i <= N
    i = N - 1#
    Do
        tmp = a(i)
        a(i) = a(0#)
        a(0#) = tmp
        TmpR = B(i)
        B(i) = B(0#)
        B(0#) = TmpR
        t = 1#
        Do While t <> 0#
            K = 2# * t
            If K > i Then
                t = 0#
            Else
                If K < i Then
                    If a(K) > a(K - 1#) Then
                        K = K + 1#
                    End If
                End If
                If a(t - 1#) >= a(K - 1#) Then
                    t = 0#
                Else
                    tmp = a(K - 1#)
                    a(K - 1#) = a(t - 1#)
                    a(t - 1#) = tmp
                    TmpR = B(K - 1#)
                    B(K - 1#) = B(t - 1#)
                    B(t - 1#) = TmpR
                    t = K
                End If
            End If
        Loop
        i = i - 1#
    Loop Until Not i >= 1#
End Sub
Public Sub TagSortFast(ByRef a() As Double, ByVal N As Long)
    Dim i As Long
    Dim K As Long
    Dim t As Long
    Dim tmp As Double
    '
    ' Special cases
    '
    If N <= 1# Then
        Exit Sub
    End If
    '
    ' General case, N>1: sort, update B
    '
    i = 2#
    Do
        t = i
        Do While t <> 1#
            K = t \ 2#
            If a(K - 1#) >= a(t - 1#) Then
                t = 1#
            Else
                tmp = a(K - 1#)
                a(K - 1#) = a(t - 1#)
                a(t - 1#) = tmp
                t = K
            End If
        Loop
        i = i + 1#
    Loop Until Not i <= N
    i = N - 1#
    Do
        tmp = a(i)
        a(i) = a(0#)
        a(0#) = tmp
        t = 1#
        Do While t <> 0#
            K = 2# * t
            If K > i Then
                t = 0#
            Else
                If K < i Then
                    If a(K) > a(K - 1#) Then
                        K = K + 1#
                    End If
                End If
                If a(t - 1#) >= a(K - 1#) Then
                    t = 0#
                Else
                    tmp = a(K - 1#)
                    a(K - 1#) = a(t - 1#)
                    a(t - 1#) = tmp
                    t = K
                End If
            End If
        Loop
        i = i - 1#
    Loop Until Not i >= 1#
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Heap operations: adds element to the heap
'
'PARAMETERS:
'    A       -   heap itself, must be at least array[0..N]
'    B       -   array of integer tags, which are updated according to
'                permutations in the heap
'    N       -   size of the heap (without new element).
'                updated on output
'    VA      -   value of the element being added
'    VB      -   value of the tag
'
'  -- ALGLIB --
'     Copyright 28.02.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub TagHeapPushI(ByRef a() As Double, _
         ByRef B() As Long, _
         ByRef N As Long, _
         ByVal VA As Double, _
         ByVal VB As Long)
    Dim j As Long
    Dim K As Long
    Dim V As Double
    If N < 0# Then
        Exit Sub
    End If
    '
    ' N=0 is a special case
    '
    If N = 0# Then
        a(0#) = VA
        B(0#) = VB
        N = N + 1#
        Exit Sub
    End If
    '
    ' add current point to the heap
    ' (add to the bottom, then move up)
    '
    ' we don't write point to the heap
    ' until its final position is determined
    ' (it allow us to reduce number of array access operations)
    '
    j = N
    N = N + 1#
    Do While j > 0#
        K = (j - 1#) \ 2#
        V = a(K)
        If V < VA Then
            '
            ' swap with higher element
            '
            a(j) = V
            B(j) = B(K)
            j = K
        Else
            '
            ' element in its place. terminate.
            '
            Exit Do
        End If
    Loop
    a(j) = VA
    B(j) = VB
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Heap operations: replaces top element with new element
'(which is moved down)
'
'PARAMETERS:
'    A       -   heap itself, must be at least array[0..N-1]
'    B       -   array of integer tags, which are updated according to
'                permutations in the heap
'    N       -   size of the heap
'    VA      -   value of the element which replaces top element
'    VB      -   value of the tag
'
'  -- ALGLIB --
'     Copyright 28.02.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub TagHeapReplaceTopI(ByRef a() As Double, _
         ByRef B() As Long, _
         ByVal N As Long, _
         ByVal VA As Double, _
         ByVal VB As Long)
    Dim j As Long
    Dim K1 As Long
    Dim K2 As Long
    Dim V As Double
    Dim V1 As Double
    Dim V2 As Double
    If N < 1# Then
        Exit Sub
    End If
    '
    ' N=1 is a special case
    '
    If N = 1# Then
        a(0#) = VA
        B(0#) = VB
        Exit Sub
    End If
    '
    ' move down through heap:
    ' * J  -   current element
    ' * K1 -   first child (always exists)
    ' * K2 -   second child (may not exists)
    '
    ' we don't write point to the heap
    ' until its final position is determined
    ' (it allow us to reduce number of array access operations)
    '
    j = 0#
    K1 = 1#
    K2 = 2#
    Do While K1 < N
        If K2 >= N Then
            '
            ' only one child.
            '
            ' swap and terminate (because this child
            ' have no siblings due to heap structure)
            '
            V = a(K1)
            If V > VA Then
                a(j) = V
                B(j) = B(K1)
                j = K1
            End If
            Exit Do
        Else
            '
            ' two childs
            '
            V1 = a(K1)
            V2 = a(K2)
            If V1 > V2 Then
                If VA < V1 Then
                    a(j) = V1
                    B(j) = B(K1)
                    j = K1
                Else
                    Exit Do
                End If
            Else
                If VA < V2 Then
                    a(j) = V2
                    B(j) = B(K2)
                    j = K2
                Else
                    Exit Do
                End If
            End If
            K1 = 2# * j + 1#
            K2 = 2# * j + 2#
        End If
    Loop
    a(j) = VA
    B(j) = VB
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Heap operations: pops top element from the heap
'
'PARAMETERS:
'    A       -   heap itself, must be at least array[0..N-1]
'    B       -   array of integer tags, which are updated according to
'                permutations in the heap
'    N       -   size of the heap, N>=1
'
'On output top element is moved to A[N-1], B[N-1], heap is reordered, N is
'decreased by 1.
'
'  -- ALGLIB --
'     Copyright 28.02.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub TagHeapPopI(ByRef a() As Double, ByRef B() As Long, ByRef N As Long)
    Dim VA As Double
    Dim VB As Long
    If N < 1# Then
        Exit Sub
    End If
    '
    ' N=1 is a special case
    '
    If N = 1# Then
        N = 0#
        Exit Sub
    End If
    '
    ' swap top element and last element,
    ' then reorder heap
    '
    VA = a(N - 1#)
    VB = B(N - 1#)
    a(N - 1#) = a(0#)
    B(N - 1#) = B(0#)
    N = N - 1#
    Call TagHeapReplaceTopI(a, B, N, VA, VB)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2007, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Calculation of the distribution moments: mean, variance, slewness, kurtosis.
'
'Input parameters:
'    X       -   sample. Array with whose indexes range within [0..N-1]
'    N       -   sample size.
'
'Output parameters:
'    Mean    -   mean.
'    Variance-   variance.
'    Skewness-   skewness (if variance<>0; zero otherwise).
'    Kurtosis-   kurtosis (if variance<>0; zero otherwise).
'
'  -- ALGLIB --
'     Copyright 06.09.2006 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CalculateMoments(ByRef x() As Double, _
         ByVal N As Long, _
         ByRef Mean As Double, _
         ByRef Variance As Double, _
         ByRef Skewness As Double, _
         ByRef Kurtosis As Double)
    Dim i As Long
    Dim V As Double
    Dim V1 As Double
    Dim V2 As Double
    Dim StdDev As Double
    Mean = 0#
    Variance = 0#
    Skewness = 0#
    Kurtosis = 0#
    StdDev = 0#
    If N <= 0# Then
        Exit Sub
    End If
    '
    ' Mean
    '
    For i = 0# To N - 1# Step 1
        Mean = Mean + x(i)
    Next i
    Mean = Mean / N
    '
    ' Variance (using corrected two-pass algorithm)
    '
    If N <> 1# Then
        V1 = 0#
        For i = 0# To N - 1# Step 1
            V1 = V1 + Square(x(i) - Mean)
        Next i
        V2 = 0#
        For i = 0# To N - 1# Step 1
            V2 = V2 + (x(i) - Mean)
        Next i
        V2 = Square(V2) / N
        Variance = (V1 - V2) / (N - 1#)
        If Variance < 0# Then
            Variance = 0#
        End If
        StdDev = Sqr(Variance)
    End If
    '
    ' Skewness and kurtosis
    '
    If StdDev <> 0# Then
        For i = 0# To N - 1# Step 1
            V = (x(i) - Mean) / StdDev
            V2 = Square(V)
            Skewness = Skewness + V2 * V
            Kurtosis = Kurtosis + Square(V2)
        Next i
        Skewness = Skewness / N
        Kurtosis = Kurtosis / N - 3#
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'ADev
'
'Input parameters:
'    X   -   sample (array indexes: [0..N-1])
'    N   -   sample size
'
'Output parameters:
'    ADev-   ADev
'
'  -- ALGLIB --
'     Copyright 06.09.2006 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CalculateADev(ByRef x() As Double, _
         ByVal N As Long, _
         ByRef ADev As Double)
    Dim i As Long
    Dim Mean As Double
    Mean = 0#
    ADev = 0#
    If N <= 0# Then
        Exit Sub
    End If
    '
    ' Mean
    '
    For i = 0# To N - 1# Step 1
        Mean = Mean + x(i)
    Next i
    Mean = Mean / N
    '
    ' ADev
    '
    For i = 0# To N - 1# Step 1
        ADev = ADev + Abs(x(i) - Mean)
    Next i
    ADev = ADev / N
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Median calculation.
'
'Input parameters:
'    X   -   sample (array indexes: [0..N-1])
'    N   -   sample size
'
'Output parameters:
'    Median
'
'  -- ALGLIB --
'     Copyright 06.09.2006 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CalculateMedian(ByRef x_() As Double, _
         ByVal N As Long, _
         ByRef Median As Double)
    Dim x() As Double
    Dim i As Long
    Dim ir As Long
    Dim j As Long
    Dim L As Long
    Dim midp As Long
    Dim K As Long
    Dim a As Double
    Dim tval As Double
    x = x_
    '
    ' Some degenerate cases
    '
    Median = 0#
    If N <= 0# Then
        Exit Sub
    End If
    If N = 1# Then
        Median = x(0#)
        Exit Sub
    End If
    If N = 2# Then
        Median = 0.5 * (x(0#) + x(1#))
        Exit Sub
    End If
    '
    ' Common case, N>=3.
    ' Choose X[(N-1)/2]
    '
    L = 0#
    ir = N - 1#
    K = (N - 1#) \ 2#
    Do While True
        If ir <= L + 1# Then
            '
            ' 1 or 2 elements in partition
            '
            If ir = L + 1# And x(ir) < x(L) Then
                tval = x(L)
                x(L) = x(ir)
                x(ir) = tval
            End If
            Exit Do
        Else
            midp = (L + ir) \ 2#
            tval = x(midp)
            x(midp) = x(L + 1#)
            x(L + 1#) = tval
            If x(L) > x(ir) Then
                tval = x(L)
                x(L) = x(ir)
                x(ir) = tval
            End If
            If x(L + 1#) > x(ir) Then
                tval = x(L + 1#)
                x(L + 1#) = x(ir)
                x(ir) = tval
            End If
            If x(L) > x(L + 1#) Then
                tval = x(L)
                x(L) = x(L + 1#)
                x(L + 1#) = tval
            End If
            i = L + 1#
            j = ir
            a = x(L + 1#)
            Do While True
                Do
                    i = i + 1#
                Loop Until x(i) >= a
                Do
                    j = j - 1#
                Loop Until x(j) <= a
                If j < i Then
                    Exit Do
                End If
                tval = x(i)
                x(i) = x(j)
                x(j) = tval
            Loop
            x(L + 1#) = x(j)
            x(j) = a
            If j >= K Then
                ir = j - 1#
            End If
            If j <= K Then
                L = i
            End If
        End If
    Loop
    '
    ' If N is odd, return result
    '
    If N Mod 2# = 1# Then
        Median = x(K)
        Exit Sub
    End If
    a = x(N - 1#)
    For i = K + 1# To N - 1# Step 1
        If x(i) < a Then
            a = x(i)
        End If
    Next i
    Median = 0.5 * (x(K) + a)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Percentile calculation.
'
'Input parameters:
'    X   -   sample (array indexes: [0..N-1])
'    N   -   sample size, N>1
'    P   -   percentile (0<=P<=1)
'
'Output parameters:
'    V   -   percentile
'
'  -- ALGLIB --
'     Copyright 01.03.2008 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CalculatePercentile(ByRef x_() As Double, _
         ByVal N As Long, _
         ByVal p As Double, _
         ByRef V As Double)
    Dim x() As Double
    Dim I1 As Long
    Dim t As Double
    x = x_
    Call InternalStatHeapSort(x, N)
    If p = 0# Then
        V = x(0#)
        Exit Sub
    End If
    If p = 1# Then
        V = x(N - 1#)
        Exit Sub
    End If
    t = p * (N - 1#)
    I1 = Int(t)
    t = t - Int(t)
    V = x(I1) * (1# - t) + x(I1 + 1#) * t
End Sub
Private Sub InternalStatHeapSort(ByRef arr() As Double, ByVal N As Long)
    Dim i As Long
    Dim K As Long
    Dim t As Long
    Dim tmp As Double
    If N = 1# Then
        Exit Sub
    End If
    i = 2#
    Do
        t = i
        Do While t <> 1#
            K = t \ 2#
            If arr(K - 1#) >= arr(t - 1#) Then
                t = 1#
            Else
                tmp = arr(K - 1#)
                arr(K - 1#) = arr(t - 1#)
                arr(t - 1#) = tmp
                t = K
            End If
        Loop
        i = i + 1#
    Loop Until Not i <= N
    i = N - 1#
    Do
        tmp = arr(i)
        arr(i) = arr(0#)
        arr(0#) = tmp
        t = 1#
        Do While t <> 0#
            K = 2# * t
            If K > i Then
                t = 0#
            Else
                If K < i Then
                    If arr(K) > arr(K - 1#) Then
                        K = K + 1#
                    End If
                End If
                If arr(t - 1#) >= arr(K - 1#) Then
                    t = 0#
                Else
                    tmp = arr(K - 1#)
                    arr(K - 1#) = arr(t - 1#)
                    arr(t - 1#) = tmp
                    t = K
                End If
            End If
        Loop
        i = i - 1#
    Loop Until Not i >= 1#
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 1992-2007 The University of Tennessee.  All rights reserved.
'
'Contributors:
'    * Sergey Bochkanov (ALGLIB project). Translation from FORTRAN to
'      pseudocode.
'
'See subroutines comments for additional copyrights.
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Generation of an elementary reflection transformation
'
'The subroutine generates elementary reflection H of order N, so that, for
'a given X, the following equality holds true:
'
'    ( X(1) )   ( Beta )
'H * (  ..  ) = (  0   )
'    ( X(n) )   (  0   )
'
'where
'              ( V(1) )
'H = 1 - Tau * (  ..  ) * ( V(1), ..., V(n) )
'              ( V(n) )
'
'where the first component of vector V equals 1.
'
'Input parameters:
'    X   -   vector. Array whose index ranges within [1..N].
'    N   -   reflection order.
'
'Output parameters:
'    X   -   components from 2 to N are replaced with vector V.
'            The first component is replaced with parameter Beta.
'    Tau -   scalar value Tau. If X is a null vector, Tau equals 0,
'            otherwise 1 <= Tau <= 2.
'
'This subroutine is the modification of the DLARFG subroutines from
'the LAPACK library.
'
'MODIFICATIONS:
'    24.12.2005 sign(Alpha) was replaced with an analogous to the Fortran SIGN code.
'
'  -- LAPACK auxiliary routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     September 30, 1994
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub GenerateReflection(ByRef x() As Double, _
         ByVal N As Long, _
         ByRef Tau As Double)
    Dim j As Long
    Dim alpha As Double
    Dim XNorm As Double
    Dim V As Double
    Dim beta As Double
    Dim MX As Double
    Dim s As Double
    Dim i_ As Long
    If N <= 1# Then
        Tau = 0#
        Exit Sub
    End If
    
    '
    ' Scale if needed (to avoid overflow/underflow during intermediate
    ' calculations).
    '
    MX = 0#
    For j = 1# To N Step 1
        MX = MaxReal(Abs(x(j)), MX)
    Next j
    s = 1#
    If MX <> 0# Then
        If MX <= MinRealNumber / MachineEpsilon Then
            s = MinRealNumber / MachineEpsilon
            V = 1# / s
            For i_ = 1# To N Step 1
                x(i_) = V * x(i_)
            Next i_
            MX = MX * V
        Else
            If MX >= MaxRealNumber * MachineEpsilon Then
                s = MaxRealNumber * MachineEpsilon
                V = 1# / s
                For i_ = 1# To N Step 1
                    x(i_) = V * x(i_)
                Next i_
                MX = MX * V
            End If
        End If
    End If
    
    '
    ' XNORM = DNRM2( N-1, X, INCX )
    '
    alpha = x(1#)
    XNorm = 0#
    If MX <> 0# Then
        For j = 2# To N Step 1
            XNorm = XNorm + Square(x(j) / MX)
        Next j
        XNorm = Sqr(XNorm) * MX
    End If
    If XNorm = 0# Then
        
        '
        ' H  =  I
        '
        Tau = 0#
        x(1#) = x(1#) * s
        Exit Sub
    End If
    
    '
    ' general case
    '
    MX = MaxReal(Abs(alpha), Abs(XNorm))
    beta = -(MX * Sqr(Square(alpha / MX) + Square(XNorm / MX)))
    If alpha < 0# Then
        beta = -beta
    End If
    Tau = (beta - alpha) / beta
    V = 1# / (alpha - beta)
    For i_ = 2# To N Step 1
        x(i_) = V * x(i_)
    Next i_
    x(1#) = beta
    
    '
    ' Scale back outputs
    '
    x(1#) = x(1#) * s
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Application of an elementary reflection to a rectangular matrix of size MxN
'
'The algorithm pre-multiplies the matrix by an elementary reflection transformation
'which is given by column V and scalar Tau (see the description of the
'GenerateReflection procedure). Not the whole matrix but only a part of it
'is transformed (rows from M1 to M2, columns from N1 to N2). Only the elements
'of this submatrix are changed.
'
'Input parameters:
'    C       -   matrix to be transformed.
'    Tau     -   scalar defining the transformation.
'    V       -   column defining the transformation.
'                Array whose index ranges within [1..M2-M1+1].
'    M1, M2  -   range of rows to be transformed.
'    N1, N2  -   range of columns to be transformed.
'    WORK    -   working array whose indexes goes from N1 to N2.
'
'Output parameters:
'    C       -   the result of multiplying the input matrix C by the
'                transformation matrix which is given by Tau and V.
'                If N1>N2 or M1>M2, C is not modified.
'
'  -- LAPACK auxiliary routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     September 30, 1994
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub ApplyReflectionFromTheLeft(ByRef C() As Double, _
         ByVal Tau As Double, _
         ByRef V() As Double, _
         ByVal M1 As Long, _
         ByVal M2 As Long, _
         ByVal N1 As Long, _
         ByVal N2 As Long, _
         ByRef WORK() As Double)
    Dim t As Double
    Dim i As Long
    Dim VM As Long
    Dim i_ As Long
    If Tau = 0# Or N1 > N2 Or M1 > M2 Then
        Exit Sub
    End If
    
    '
    ' w := C' * v
    '
    VM = M2 - M1 + 1#
    For i = N1 To N2 Step 1
        WORK(i) = 0#
    Next i
    For i = M1 To M2 Step 1
        t = V(i + 1# - M1)
        For i_ = N1 To N2 Step 1
            WORK(i_) = WORK(i_) + t * C(i, i_)
        Next i_
    Next i
    
    '
    ' C := C - tau * v * w'
    '
    For i = M1 To M2 Step 1
        t = V(i - M1 + 1#) * Tau
        For i_ = N1 To N2 Step 1
            C(i, i_) = C(i, i_) - t * WORK(i_)
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Application of an elementary reflection to a rectangular matrix of size MxN
'
'The algorithm post-multiplies the matrix by an elementary reflection transformation
'which is given by column V and scalar Tau (see the description of the
'GenerateReflection procedure). Not the whole matrix but only a part of it
'is transformed (rows from M1 to M2, columns from N1 to N2). Only the
'elements of this submatrix are changed.
'
'Input parameters:
'    C       -   matrix to be transformed.
'    Tau     -   scalar defining the transformation.
'    V       -   column defining the transformation.
'                Array whose index ranges within [1..N2-N1+1].
'    M1, M2  -   range of rows to be transformed.
'    N1, N2  -   range of columns to be transformed.
'    WORK    -   working array whose indexes goes from M1 to M2.
'
'Output parameters:
'    C       -   the result of multiplying the input matrix C by the
'                transformation matrix which is given by Tau and V.
'                If N1>N2 or M1>M2, C is not modified.
'
'  -- LAPACK auxiliary routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     September 30, 1994
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub ApplyReflectionFromTheRight(ByRef C() As Double, _
         ByVal Tau As Double, _
         ByRef V() As Double, _
         ByVal M1 As Long, _
         ByVal M2 As Long, _
         ByVal N1 As Long, _
         ByVal N2 As Long, _
         ByRef WORK() As Double)
    Dim t As Double
    Dim i As Long
    Dim VM As Long
    Dim i_ As Long
    Dim i1_ As Long
    If Tau = 0# Or N1 > N2 Or M1 > M2 Then
        Exit Sub
    End If
    VM = N2 - N1 + 1#
    For i = M1 To M2 Step 1
        i1_ = (1#) - (N1)
        t = 0#
        For i_ = N1 To N2 Step 1
            t = t + C(i, i_) * V(i_ + i1_)
        Next i_
        t = t * Tau
        i1_ = (1#) - (N1)
        For i_ = N1 To N2 Step 1
            C(i, i_) = C(i, i_) - t * V(i_ + i1_)
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 1992-2007 The University of Tennessee.  All rights reserved.
'
'Contributors:
'    * Sergey Bochkanov (ALGLIB project). Translation from FORTRAN to
'      pseudocode.
'
'See subroutines comments for additional copyrights.
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Application of a sequence of  elementary rotations to a matrix
'
'The algorithm pre-multiplies the matrix by a sequence of rotation
'transformations which is given by arrays C and S. Depending on the value
'of the IsForward parameter either 1 and 2, 3 and 4 and so on (if IsForward=true)
'rows are rotated, or the rows N and N-1, N-2 and N-3 and so on, are rotated.
'
'Not the whole matrix but only a part of it is transformed (rows from M1 to
'M2, columns from N1 to N2). Only the elements of this submatrix are changed.
'
'Input parameters:
'    IsForward   -   the sequence of the rotation application.
'    M1,M2       -   the range of rows to be transformed.
'    N1, N2      -   the range of columns to be transformed.
'    C,S         -   transformation coefficients.
'                    Array whose index ranges within [1..M2-M1].
'    A           -   processed matrix.
'    WORK        -   working array whose index ranges within [N1..N2].
'
'Output parameters:
'    A           -   transformed matrix.
'
'Utility subroutine.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub ApplyRotationsFromTheLeft(ByVal IsForward As Boolean, _
         ByVal M1 As Long, _
         ByVal M2 As Long, _
         ByVal N1 As Long, _
         ByVal N2 As Long, _
         ByRef C() As Double, _
         ByRef s() As Double, _
         ByRef a() As Double, _
         ByRef WORK() As Double)
    Dim j As Long
    Dim JP1 As Long
    Dim CTEMP As Double
    Dim STEMP As Double
    Dim temp As Double
    Dim i_ As Long
    If M1 > M2 Or N1 > N2 Then
        Exit Sub
    End If
    
    '
    ' Form  P * A
    '
    If IsForward Then
        If N1 <> N2 Then
            
            '
            ' Common case: N1<>N2
            '
            For j = M1 To M2 - 1# Step 1
                CTEMP = C(j - M1 + 1#)
                STEMP = s(j - M1 + 1#)
                If CTEMP <> 1# Or STEMP <> 0# Then
                    JP1 = j + 1#
                    For i_ = N1 To N2 Step 1
                        WORK(i_) = CTEMP * a(JP1, i_)
                    Next i_
                    For i_ = N1 To N2 Step 1
                        WORK(i_) = WORK(i_) - STEMP * a(j, i_)
                    Next i_
                    For i_ = N1 To N2 Step 1
                        a(j, i_) = CTEMP * a(j, i_)
                    Next i_
                    For i_ = N1 To N2 Step 1
                        a(j, i_) = a(j, i_) + STEMP * a(JP1, i_)
                    Next i_
                    For i_ = N1 To N2 Step 1
                        a(JP1, i_) = WORK(i_)
                    Next i_
                End If
            Next j
        Else
            
            '
            ' Special case: N1=N2
            '
            For j = M1 To M2 - 1# Step 1
                CTEMP = C(j - M1 + 1#)
                STEMP = s(j - M1 + 1#)
                If CTEMP <> 1# Or STEMP <> 0# Then
                    temp = a(j + 1#, N1)
                    a(j + 1#, N1) = CTEMP * temp - STEMP * a(j, N1)
                    a(j, N1) = STEMP * temp + CTEMP * a(j, N1)
                End If
            Next j
        End If
    Else
        If N1 <> N2 Then
            
            '
            ' Common case: N1<>N2
            '
            For j = M2 - 1# To M1 Step -1
                CTEMP = C(j - M1 + 1#)
                STEMP = s(j - M1 + 1#)
                If CTEMP <> 1# Or STEMP <> 0# Then
                    JP1 = j + 1#
                    For i_ = N1 To N2 Step 1
                        WORK(i_) = CTEMP * a(JP1, i_)
                    Next i_
                    For i_ = N1 To N2 Step 1
                        WORK(i_) = WORK(i_) - STEMP * a(j, i_)
                    Next i_
                    For i_ = N1 To N2 Step 1
                        a(j, i_) = CTEMP * a(j, i_)
                    Next i_
                    For i_ = N1 To N2 Step 1
                        a(j, i_) = a(j, i_) + STEMP * a(JP1, i_)
                    Next i_
                    For i_ = N1 To N2 Step 1
                        a(JP1, i_) = WORK(i_)
                    Next i_
                End If
            Next j
        Else
            
            '
            ' Special case: N1=N2
            '
            For j = M2 - 1# To M1 Step -1
                CTEMP = C(j - M1 + 1#)
                STEMP = s(j - M1 + 1#)
                If CTEMP <> 1# Or STEMP <> 0# Then
                    temp = a(j + 1#, N1)
                    a(j + 1#, N1) = CTEMP * temp - STEMP * a(j, N1)
                    a(j, N1) = STEMP * temp + CTEMP * a(j, N1)
                End If
            Next j
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Application of a sequence of  elementary rotations to a matrix
'
'The algorithm post-multiplies the matrix by a sequence of rotation
'transformations which is given by arrays C and S. Depending on the value
'of the IsForward parameter either 1 and 2, 3 and 4 and so on (if IsForward=true)
'rows are rotated, or the rows N and N-1, N-2 and N-3 and so on are rotated.
'
'Not the whole matrix but only a part of it is transformed (rows from M1
'to M2, columns from N1 to N2). Only the elements of this submatrix are changed.
'
'Input parameters:
'    IsForward   -   the sequence of the rotation application.
'    M1,M2       -   the range of rows to be transformed.
'    N1, N2      -   the range of columns to be transformed.
'    C,S         -   transformation coefficients.
'                    Array whose index ranges within [1..N2-N1].
'    A           -   processed matrix.
'    WORK        -   working array whose index ranges within [M1..M2].
'
'Output parameters:
'    A           -   transformed matrix.
'
'Utility subroutine.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub ApplyRotationsFromTheRight(ByVal IsForward As Boolean, _
         ByVal M1 As Long, _
         ByVal M2 As Long, _
         ByVal N1 As Long, _
         ByVal N2 As Long, _
         ByRef C() As Double, _
         ByRef s() As Double, _
         ByRef a() As Double, _
         ByRef WORK() As Double)
    Dim j As Long
    Dim JP1 As Long
    Dim CTEMP As Double
    Dim STEMP As Double
    Dim temp As Double
    Dim i_ As Long
    
    '
    ' Form A * P'
    '
    If IsForward Then
        If M1 <> M2 Then
            
            '
            ' Common case: M1<>M2
            '
            For j = N1 To N2 - 1# Step 1
                CTEMP = C(j - N1 + 1#)
                STEMP = s(j - N1 + 1#)
                If CTEMP <> 1# Or STEMP <> 0# Then
                    JP1 = j + 1#
                    For i_ = M1 To M2 Step 1
                        WORK(i_) = CTEMP * a(i_, JP1)
                    Next i_
                    For i_ = M1 To M2 Step 1
                        WORK(i_) = WORK(i_) - STEMP * a(i_, j)
                    Next i_
                    For i_ = M1 To M2 Step 1
                        a(i_, j) = CTEMP * a(i_, j)
                    Next i_
                    For i_ = M1 To M2 Step 1
                        a(i_, j) = a(i_, j) + STEMP * a(i_, JP1)
                    Next i_
                    For i_ = M1 To M2 Step 1
                        a(i_, JP1) = WORK(i_)
                    Next i_
                End If
            Next j
        Else
            
            '
            ' Special case: M1=M2
            '
            For j = N1 To N2 - 1# Step 1
                CTEMP = C(j - N1 + 1#)
                STEMP = s(j - N1 + 1#)
                If CTEMP <> 1# Or STEMP <> 0# Then
                    temp = a(M1, j + 1#)
                    a(M1, j + 1#) = CTEMP * temp - STEMP * a(M1, j)
                    a(M1, j) = STEMP * temp + CTEMP * a(M1, j)
                End If
            Next j
        End If
    Else
        If M1 <> M2 Then
            
            '
            ' Common case: M1<>M2
            '
            For j = N2 - 1# To N1 Step -1
                CTEMP = C(j - N1 + 1#)
                STEMP = s(j - N1 + 1#)
                If CTEMP <> 1# Or STEMP <> 0# Then
                    JP1 = j + 1#
                    For i_ = M1 To M2 Step 1
                        WORK(i_) = CTEMP * a(i_, JP1)
                    Next i_
                    For i_ = M1 To M2 Step 1
                        WORK(i_) = WORK(i_) - STEMP * a(i_, j)
                    Next i_
                    For i_ = M1 To M2 Step 1
                        a(i_, j) = CTEMP * a(i_, j)
                    Next i_
                    For i_ = M1 To M2 Step 1
                        a(i_, j) = a(i_, j) + STEMP * a(i_, JP1)
                    Next i_
                    For i_ = M1 To M2 Step 1
                        a(i_, JP1) = WORK(i_)
                    Next i_
                End If
            Next j
        Else
            
            '
            ' Special case: M1=M2
            '
            For j = N2 - 1# To N1 Step -1
                CTEMP = C(j - N1 + 1#)
                STEMP = s(j - N1 + 1#)
                If CTEMP <> 1# Or STEMP <> 0# Then
                    temp = a(M1, j + 1#)
                    a(M1, j + 1#) = CTEMP * temp - STEMP * a(M1, j)
                    a(M1, j) = STEMP * temp + CTEMP * a(M1, j)
                End If
            Next j
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'The subroutine generates the elementary rotation, so that:
'
'[  CS  SN  ]  .  [ F ]  =  [ R ]
'[ -SN  CS  ]     [ G ]     [ 0 ]
'
'CS**2 + SN**2 = 1
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub GenerateRotation(ByVal f As Double, _
         ByVal g As Double, _
         ByRef cs As Double, _
         ByRef SN As Double, _
         ByRef R As Double)
    Dim F1 As Double
    Dim G1 As Double
    If g = 0# Then
        cs = 1#
        SN = 0#
        R = f
    Else
        If f = 0# Then
            cs = 0#
            SN = 1#
            R = g
        Else
            F1 = f
            G1 = g
            If Abs(F1) > Abs(G1) Then
                R = Abs(F1) * Sqr(1# + Square(G1 / F1))
            Else
                R = Abs(G1) * Sqr(1# + Square(F1 / G1))
            End If
            cs = F1 / R
            SN = G1 / R
            If Abs(f) > Abs(g) And cs < 0# Then
                cs = -cs
                SN = -SN
                R = -R
            End If
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 1992-2007 The University of Tennessee.  All rights reserved.
'
'Contributors:
'    * Sergey Bochkanov (ALGLIB project). Translation from FORTRAN to
'      pseudocode.
'
'See subroutines comments for additional copyrights.
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Generation of an elementary complex reflection transformation
'
'The subroutine generates elementary complex reflection H of  order  N,  so
'that, for a given X, the following equality holds true:
'
'     ( X(1) )   ( Beta )
'H' * (  ..  ) = (  0   ),   H'*H = I,   Beta is a real number
'     ( X(n) )   (  0   )
'
'where
'
'              ( V(1) )
'H = 1 - Tau * (  ..  ) * ( conj(V(1)), ..., conj(V(n)) )
'              ( V(n) )
'
'where the first component of vector V equals 1.
'
'Input parameters:
'    X   -   vector. Array with elements [1..N].
'    N   -   reflection order.
'
'Output parameters:
'    X   -   components from 2 to N are replaced by vector V.
'            The first component is replaced with parameter Beta.
'    Tau -   scalar value Tau.
'
'This subroutine is the modification of CLARFG subroutines  from the LAPACK
'library. It has similar functionality except for the fact that it  doesnt
'handle errors when intermediate results cause an overflow.
'
'  -- LAPACK auxiliary routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     September 30, 1994
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub ComplexGenerateReflection(ByRef x() As Complex, _
         ByVal N As Long, _
         ByRef Tau As Complex)
    Dim j As Long
    Dim alpha As Complex
    Dim ALPHI As Double
    Dim ALPHR As Double
    Dim beta As Double
    Dim XNorm As Double
    Dim MX As Double
    Dim t As Complex
    Dim s As Double
    Dim V As Complex
    Dim i_ As Long
    If N <= 0# Then
        Tau = C_Complex(0#)
        Exit Sub
    End If
    '
    ' Scale if needed (to avoid overflow/underflow during intermediate
    ' calculations).
    '
    MX = 0#
    For j = 1# To N Step 1
        MX = MaxReal(AbsComplex(x(j)), MX)
    Next j
    s = 1#
    If MX <> 0# Then
        If MX < 1# Then
            s = Sqr(MinRealNumber)
            V = C_Complex(1# / s)
            For i_ = 1# To N Step 1
                x(i_) = C_Mul(V, x(i_))
            Next i_
        Else
            s = Sqr(MaxRealNumber)
            V = C_Complex(1# / s)
            For i_ = 1# To N Step 1
                x(i_) = C_Mul(V, x(i_))
            Next i_
        End If
    End If
    '
    ' calculate
    '
    alpha = x(1#)
    MX = 0#
    For j = 2# To N Step 1
        MX = MaxReal(AbsComplex(x(j)), MX)
    Next j
    XNorm = 0#
    If MX <> 0# Then
        For j = 2# To N Step 1
            t = C_DivR(x(j), MX)
            XNorm = XNorm + C_Mul(t, Conj(t)).x
        Next j
        XNorm = Sqr(XNorm) * MX
    End If
    ALPHR = alpha.x
    ALPHI = alpha.y
    If XNorm = 0# And ALPHI = 0# Then
        Tau = C_Complex(0#)
        x(1#) = C_MulR(x(1#), s)
        Exit Sub
    End If
    MX = MaxReal(Abs(ALPHR), Abs(ALPHI))
    MX = MaxReal(MX, Abs(XNorm))
    beta = -(MX * Sqr(Square(ALPHR / MX) + Square(ALPHI / MX) + Square(XNorm / MX)))
    If ALPHR < 0# Then
        beta = -beta
    End If
    Tau.x = (beta - ALPHR) / beta
    Tau.y = -(ALPHI / beta)
    alpha = C_RDiv(1#, C_SubR(alpha, beta))
    If N > 1# Then
        For i_ = 2# To N Step 1
            x(i_) = C_Mul(alpha, x(i_))
        Next i_
    End If
    alpha = C_Complex(beta)
    x(1#) = alpha
    '
    ' Scale back
    '
    x(1#) = C_MulR(x(1#), s)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Application of an elementary reflection to a rectangular matrix of size MxN
'
'The  algorithm  pre-multiplies  the  matrix  by  an  elementary reflection
'transformation  which  is  given  by  column  V  and  scalar  Tau (see the
'description of the GenerateReflection). Not the whole matrix  but  only  a
'part of it is transformed (rows from M1 to M2, columns from N1 to N2). Only
'the elements of this submatrix are changed.
'
'Note: the matrix is multiplied by H, not by H'.   If  it  is  required  to
'multiply the matrix by H', it is necessary to pass Conj(Tau) instead of Tau.
'
'Input parameters:
'    C       -   matrix to be transformed.
'    Tau     -   scalar defining transformation.
'    V       -   column defining transformation.
'                Array whose index ranges within [1..M2-M1+1]
'    M1, M2  -   range of rows to be transformed.
'    N1, N2  -   range of columns to be transformed.
'    WORK    -   working array whose index goes from N1 to N2.
'
'Output parameters:
'    C       -   the result of multiplying the input matrix C by the
'                transformation matrix which is given by Tau and V.
'                If N1>N2 or M1>M2, C is not modified.
'
'  -- LAPACK auxiliary routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     September 30, 1994
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub ComplexApplyReflectionFromTheLeft(ByRef C() As Complex, _
         ByRef Tau_ As Complex, _
         ByRef V() As Complex, _
         ByVal M1 As Long, _
         ByVal M2 As Long, _
         ByVal N1 As Long, _
         ByVal N2 As Long, _
         ByRef WORK() As Complex)
    Dim Tau As Complex
    Dim t As Complex
    Dim i As Long
    Dim VM As Long
    Dim i_ As Long
    Tau = Tau_
    If C_EqualR(Tau, 0#) Or N1 > N2 Or M1 > M2 Then
        Exit Sub
    End If
    '
    ' w := C^T * conj(v)
    '
    VM = M2 - M1 + 1#
    For i = N1 To N2 Step 1
        WORK(i) = C_Complex(0#)
    Next i
    For i = M1 To M2 Step 1
        t = Conj(V(i + 1# - M1))
        For i_ = N1 To N2 Step 1
            WORK(i_) = C_Add(WORK(i_), C_Mul(t, C(i, i_)))
        Next i_
    Next i
    '
    ' C := C - tau * v * w^T
    '
    For i = M1 To M2 Step 1
        t = C_Mul(V(i - M1 + 1#), Tau)
        For i_ = N1 To N2 Step 1
            C(i, i_) = C_Sub(C(i, i_), C_Mul(t, WORK(i_)))
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Application of an elementary reflection to a rectangular matrix of size MxN
'
'The  algorithm  post-multiplies  the  matrix  by  an elementary reflection
'transformation  which  is  given  by  column  V  and  scalar  Tau (see the
'description  of  the  GenerateReflection). Not the whole matrix but only a
'part  of  it  is  transformed (rows from M1 to M2, columns from N1 to N2).
'Only the elements of this submatrix are changed.
'
'Input parameters:
'    C       -   matrix to be transformed.
'    Tau     -   scalar defining transformation.
'    V       -   column defining transformation.
'                Array whose index ranges within [1..N2-N1+1]
'    M1, M2  -   range of rows to be transformed.
'    N1, N2  -   range of columns to be transformed.
'    WORK    -   working array whose index goes from M1 to M2.
'
'Output parameters:
'    C       -   the result of multiplying the input matrix C by the
'                transformation matrix which is given by Tau and V.
'                If N1>N2 or M1>M2, C is not modified.
'
'  -- LAPACK auxiliary routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     September 30, 1994
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub ComplexApplyReflectionFromTheRight(ByRef C() As Complex, _
         ByRef Tau_ As Complex, _
         ByRef V() As Complex, _
         ByVal M1 As Long, _
         ByVal M2 As Long, _
         ByVal N1 As Long, _
         ByVal N2 As Long, _
         ByRef WORK() As Complex)
    Dim Tau As Complex
    Dim t As Complex
    Dim i As Long
    Dim VM As Long
    Dim i_ As Long
    Dim i1_ As Long
    Tau = Tau_
    If C_EqualR(Tau, 0#) Or N1 > N2 Or M1 > M2 Then
        Exit Sub
    End If
    '
    ' w := C * v
    '
    VM = N2 - N1 + 1#
    For i = M1 To M2 Step 1
        i1_ = (1#) - (N1)
        t = C_Complex(0#)
        For i_ = N1 To N2 Step 1
            t = C_Add(t, C_Mul(C(i, i_), V(i_ + i1_)))
        Next i_
        WORK(i) = t
    Next i
    '
    ' C := C - w * conj(v^T)
    '
    For i_ = 1# To VM Step 1
        V(i_) = Conj(V(i_))
    Next i_
    For i = M1 To M2 Step 1
        t = C_Mul(WORK(i), Tau)
        i1_ = (1#) - (N1)
        For i_ = N1 To N2 Step 1
            C(i, i_) = C_Sub(C(i, i_), C_Mul(t, V(i_ + i1_)))
        Next i_
    Next i
    For i_ = 1# To VM Step 1
        V(i_) = Conj(V(i_))
    Next i_
End Sub

