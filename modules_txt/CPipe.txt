'=======================================================================================
'Unifloc 7.50 year 2024                                  khabibullinra@gmail.com
'Petroleum engineering calculations modules (macroses)
'2000 - 2023
'
'=======================================================================================
' класс для расчета многофазного потока в трубе (вторая версия после рефакторинга Алма)
'
' История
' 2016.04    Реализован новый механизм расчета распределения давления в стволе с использованием модуля решения ОДУ
'            Упрощена структура хранения массивов
' 2017.01    Модернизация под 7 версию. Исправление ошибок и контроль температуры
' 2019.04    Рефакторинг в сторону упрощения
' 2019.10    Рефакторинг в сторону упрощения - продолжение
Option Explicit
Option Base 0
Public log_ As New CLogger                      ' create new log list for each object
Public fluid As CPVT                                   ' базовый флюид в трубе. Определяет свойства и расходы и фазовый состав
Private ambient_formation_ As New CAmbientFormation      ' порода за пределями скважины
Public curve As New CCurves                            ' все кривые планируется прятать тут
Public t_calc_C As Double                              ' начальная температура флюида для расчета с учетом эмисии тепла
Public p_result_atma As Double                         ' давление - результат расчета для отчета
Public t_result_C As Double                            ' температура - результат расчета для отчета
Public ZeroCoordMes_m As Double                        ' начальная координата трубы, измеренная, от которой будут отсчитываться координаты в выходных массивах
Public ZeroCoordVert_m As Double                       ' начальная координата трубы, вертикальная, от которой будут отсчитываться координаты в выходных массивах
Private param_ As PARAMCALC                               ' параметры расчета по трубе
' геометрия трубы заданная массивами
Private h_mes_insert_m_ As CInterpolation              ' измеренная глубина которую надо вставить в расчет трубы
                                                       ' чтобы отловить изменение градиента температуры, например при динамическом уровне
Private legth_total_m_ As Double                       ' общая длинна трубы
Private depth_vert_total_m_ As Double                  ' общая глубина трубы
' расчетные параметры по трубе  (используются для вывода после проведения расчета)
Private flow_params_out_() As PIPE_FLOW_PARAMS         ' расчетные параметры по трубе после расчета
' набор расчетных параметров по стволу скважины
' Private num_points_curve_ As Integer                    ' количество точек которые должны быть сохранены для распределения давления в трубе в итоговых кривых
Private step_hm_curve_ As Double                        ' шаг для формирования выходного массива по трубе. м
Private hm_curve_ As New CInterpolation                ' кривая для хранения набора точек, для которых должны строится все другие кривые
' поправочные коэффициенты для расчета распределения давления
Private calibr_grav_ As Double
Private calibr_fric_ As Double
Private znlf_ As Boolean
Public Sub add_log_msg(msg As String)
    Call log_.add_msg(msg)
End Sub
 
 
 
 ' конструктор класса
 ' вызывается при создании класса - гарантирует что все объекты будут созданы
Private Sub Class_Initialize()
   ZeroCoordMes_m = 0
   ZeroCoordVert_m = 0
   legth_total_m_ = 100
   ReDim flow_params_out_(0) As PIPE_FLOW_PARAMS
   curve("c_Roughness").isStepFunction = True ' шероховатость и диаметр трубы меняют ступенчато и не интерполируются
   curve("c_Diam").isStepFunction = True
   curve("c_fpat").isStepFunction = True
   
   Set fluid = New CPVT
   
   Call set_calc_flow_param(calc_along_coord:=True, _
                            flow_along_coord:=True, _
                            hcor:=Ansari, _
                            temp_method:=StartEndTemp, _
                            length_gas_m:=0)
                                     
   Set h_mes_insert_m_ = New CInterpolation
   Call h_mes_insert_m_.AddPoint(0, 0)
   Call h_mes_insert_m_.AddPoint(length_mes_m, 0)
   StepHmCurve = 1000    ' по умолчанию шаг 1000 м для сохранения кривых
   calibr_grav_ = 1
   calibr_fric_ = 1
   znlf_ = False
End Sub
Public Property Get param() As PARAMCALC
   param = param_
End Property
Public Property Let param(val As PARAMCALC)
    param_ = val
    If val.length_gas_m > 0 Then
        ' if correlation division point given - stable points in pipe have to be updated
        Call add_h_mes_save_m(val.length_gas_m)
        StepHmCurve = StepHmCurve
    End If
End Property
Public Property Get calibr_grav() As Double
   calibr_grav = calibr_grav_
End Property
Public Property Let calibr_grav(val As Double)
   If val >= 0 And val < 2 Then ' не стоит подстрочный коэффициент менять слишком сильно - если что тут можно поправить
       calibr_grav_ = val
   End If
End Property
Public Property Let calibr_fric(val As Double)
   If val >= 0 And val < 2 Then ' не стоит подстрочный коэффициент менять слишком сильно - если что тут можно поправить
       calibr_fric_ = val
   End If
End Property
Public Property Get calibr_fric() As Double
   calibr_fric = calibr_fric_
End Property
 
Public Property Get h_mes_save_m(ByVal i As Integer) As Double
  h_mes_save_m = h_mes_insert_m_.pointX(i)
End Property
Public Function add_h_mes_save_m(ByVal val As Double) As Boolean
    If val > ZeroCoordMes_m And val < (ZeroCoordMes_m + length_mes_m) Then
        Call h_mes_insert_m_.AddPoint(val, 0)   ' Запишем точку, которую надо сохранить
    End If
    StepHmCurve = StepHmCurve
End Function
Private Property Get StepHmCurve() As Double
   StepHmCurve = step_hm_curve_
End Property
Private Property Let StepHmCurve(val As Double)
   Dim i As Integer
   Dim Hm As Double
   Dim Hm_max As Double
   
   step_hm_curve_ = val
   ' установили шаг - сразу подготовим массив точек по давлению для которых должен быть проведен расчет
   hm_curve_.ClearPoints    ' очистили точки по давлению
   For i = 1 To h_mes_insert_m_.num_points    ' пустили цикл по количеству точек, которые должны быть обязательно
       Hm = h_mes_insert_m_.pointX(i)
       hm_curve_.AddPoint Hm, 0               ' добвляем точку в выходной массив. Важен только x, поэтому y задаем произвольно
                                              ' здесь же должны задаться первая и последняя точки
   Next i
   ' далее добавим все промежуточные точки с заданым шагом
   i = 0
   Hm = hm_curve_.pointX(1)   ' начинаем с первой точки
   Hm_max = hm_curve_.pointX(hm_curve_.num_points)
   Do
       Hm = Hm + StepHmCurve
       If Hm < Hm_max Then                     ' если новая точка попадает в диапазон, добавляем ее.
           hm_curve_.AddPoint Hm, 0             ' здесь предполагается, что координаты будут возрастать
       End If                                  ' если такая точка есть, то она просто перезапишется
   Loop While Hm < Hm_max
   ' здесь получили в кривой hm_curve_ все точки для которых надо искать параметры
End Property
' длина сегмента трубы
Public Property Get length_mes_m() As Double
    length_mes_m = legth_total_m_
End Property
Public Property Get depth_vert_m() As Double
    depth_vert_m = depth_vert_total_m_
End Property
Public Sub init_t_model(t_model As String)
    Call init_t_model_from_dict(ParseJson(t_model))
End Sub
Public Sub init_t_model_from_dict(t_model_dict As Dictionary)
    Dim t_calc_to_C As Double, t_calc_from_C As Double
    Dim dict As Dictionary
    Dim t_start_coord_C As Double
    Dim t_end_coord_C As Double
    
    Dim t_val As Dictionary
    Dim temperature_crv As New CInterpolation
    Dim amb As New CAmbientFormation
    Dim prm As PARAMCALC
    
    Set dict = t_model_dict
    
    Select Case dict(prm_t_model)
        Case StartEndTemp
            t_start_coord_C = dict(prm_t_start_C)
            t_end_coord_C = dict(prm_t_end_C)
            temperature_crv.AddPoint ZeroCoordMes_m, t_start_coord_C
            temperature_crv.AddPoint ZeroCoordMes_m + length_mes_m, t_end_coord_C
            temperature_crv.special = True
            
        Case GeoGradTemp, AmbientTemp, LengthTemp
            ' here we expetc t_val to be dictionary
            Set t_val = dict(const_name_t_list_C)
            Call temperature_crv.load_from_dictionary(t_val, const_name_hvert_m, const_name_t_C)
            
        
    End Select
    Set amb.amb_temp_curve = temperature_crv
    Set ambient_formation_ = amb
    
    prm = param
    prm.temp_method = dict(prm_t_model)
    param = prm
End Sub
Public Sub init_feed(ByVal json As String, _
             Optional ByVal q_liq_sm3day = -10000000000#, _
             Optional ByVal fw_perc = -1, _
             Optional ByVal rp_m3m3 = -1, _
             Optional ByVal q_gas_free_sm3day = -1, _
             Optional ByVal allow_zero_qliq As Boolean = True)
             
    Call fluid.init_feed(json, q_liq_sm3day, fw_perc, rp_m3m3, q_gas_free_sm3day, allow_zero_qliq)
    If fluid.q_liq_sm3day < 0 Then
        set_flow_along_coord (Not param.flow_along_coord)
        fluid.q_liq_sm3day = -fluid.q_liq_sm3day
    End If
    
    If znlf_ Then set_ZNLF
End Sub
Private Function t_amb_C(lmes_m As Double, _
                Optional vertical As Boolean = True) As Double
   ' возвращает температуру исходя из окружения скважины
   Dim Hv_m As Double
   If vertical Then
       Hv_m = h_vert_h_mes_m(lmes_m)              ' определяем вертикальную глубину для заданной измеренной глубины
   Else
       Hv_m = lmes_m
   End If
   t_amb_C = ambient_formation_.amb_temp_C(Hv_m)
End Function
Private Function t_init_C(lmes_m As Double) As Double
    Select Case param.temp_method
        Case StartEndTemp, LengthTemp
            t_init_C = t_amb_C(lmes_m, vertical:=False)  ' температуру берем извне
        Case GeoGradTemp, AmbientTemp
            t_init_C = t_amb_C(lmes_m, vertical:=True)
    End Select
End Function
 
Private Function dTdL_amb_Cm(lmes_m As Double, _
                    Optional vertical As Boolean = True) As Double
   ' возвращает градиент температуры исходя из окружения
   Dim theta_deg As Double
   Dim Hv_m As Double
   
   theta_deg = angle_hmes_deg(lmes_m)         ' определяем наклон на заданной глубине
   If vertical Then
       Hv_m = h_vert_h_mes_m(lmes_m)              ' определяем вертикальную глубину для заданной измеренной глубины
   Else
       Hv_m = lmes_m
   End If
   dTdL_amb_Cm = ambient_formation_.amb_temp_grad_Cm(Hv_m) * sind(theta_deg)
End Function
    
Public Function d_hmes_m(ByVal z As Double) As Double
' функция возвращает внутренний диаметр трубы по заданной абсолютной измеренной глубине (если труба проходит по этой глубине)
   d_hmes_m = curve("c_Diam").getPoint(z)
End Function
Public Function roughness_h_mes_m(ByVal z As Double) As Double
' возвращает шероховатость по измеренной глубине
   roughness_h_mes_m = curve("c_Roughness").getPoint(z)
End Function
Public Function angle_hmes_deg(ByVal z As Double) As Double
' возвращает угол по измеренной глубине
   angle_hmes_deg = curve("c_Theta").getPoint(z)
End Function
Public Function h_vert_h_mes_m(ByVal z As Double) As Double
' возвращает угол по измеренной глубине
   h_vert_h_mes_m = curve("c_Hvert").getPoint(z)
End Function
Public Function p_h_mes_atma(ByVal z As Double) As Double
' возвращает угол по измеренной глубине
   p_h_mes_atma = curve("c_P").getPoint(z)
End Function
Public Function t_h_mes_C(ByVal z As Double) As Double
' возвращает угол по измеренной глубине
   t_h_mes_C = curve("c_T").getPoint(z)
End Function
' инициализация трубы через данные по траектории скважины
Public Sub init_pipe_constr_by_trajectory( _
                            ByVal tr As CPipeTrajectory, _
                   Optional ByVal HmesStart_m As Variant, _
                   Optional ByVal HmesEnd_m As Variant, _
                   Optional tr_cas As CPipeTrajectory, _
                   Optional ByVal srv_points_step As Integer = 50)
                   
    Dim i As Integer
    Dim h As Double
    Dim p_pipe_segments_num As Integer
    
    If IsMissing(HmesStart_m) Then HmesStart_m = tr.h_mes_m(0)
    If IsMissing(HmesEnd_m) Then HmesEnd_m = tr.h_mes_m(tr.num_points - 1)
    
    If HmesStart_m < -10000000 Then HmesStart_m = tr.h_mes_m(0)
    If HmesEnd_m > 10000000 Then HmesEnd_m = tr.h_mes_m(tr.num_points - 1)
    
    If HmesEnd_m <= HmesStart_m Then
        HmesStart_m = tr.h_mes_m(0)
        HmesEnd_m = tr.h_mes_m(tr.num_points - 1)
    End If
    
    curve("c_Diam").isStepFunction = True
    curve("c_Theta").isStepFunction = True
    ZeroCoordMes_m = HmesStart_m
    ZeroCoordVert_m = tr.h_abs_hmes_m(HmesStart_m)
    p_pipe_segments_num = tr.num_points - 1
    ' по умолчанию используем все сегменты которые были заданы в траектории
    For i = 0 To p_pipe_segments_num + 2
         If i = 0 Then
            h = HmesStart_m
         ElseIf i = 1 Then
            h = HmesEnd_m
         Else
             h = tr.h_mes_m(i - 2)
         End If
         If h >= HmesStart_m And h <= HmesEnd_m Then
            ' теперь  заполним кривые соответствующие траектории скважины  - в первый раз пишем нулевую точку
            If IsMissing(tr_cas) Or tr_cas Is Nothing Then
                curve("c_Diam").AddPoint h, tr.diam_hmes_m(h)    ' НКТ
            Else
                curve("c_Diam").AddPoint h, tr_cas.diam_hmes_m(h) - tr.diam_hmes_m(h)   ' затруб
            End If
            curve("c_Roughness").AddPoint h, tr.roughness_m
            curve("c_Theta").AddPoint h, tr.ang_hmes_deg(h)
            curve("c_Hvert").AddPoint h, tr.h_abs_hmes_m(h)
         End If
    Next i
    curve("c_Diam").special = True
    curve("c_Roughness").special = True
    curve("c_Theta").special = True
    curve("c_Hvert").special = True
    
    legth_total_m_ = HmesEnd_m - HmesStart_m
    depth_vert_total_m_ = tr.h_abs_hmes_m(HmesEnd_m) - tr.h_abs_hmes_m(HmesStart_m)
    
    h_mes_insert_m_.ClearPoints
    h_mes_insert_m_.AddPoint ZeroCoordMes_m, 0
    h_mes_insert_m_.AddPoint ZeroCoordMes_m + legth_total_m_, 0
    With curve("c_Diam")
        If .num_points > 2 Then
            For i = 2 To .num_points
                If .PointY(i) <> .PointY(i - 1) Then
                   Call add_h_mes_save_m(.pointX(i))
                End If
            Next i
        End If
    End With
    Call add_h_mes_save_m(param_.length_gas_m)
    
    StepHmCurve = srv_points_step
End Sub
Public Function init_from_json(construction_json As String, _
                               t_model_json As String, _
        Optional ByVal h_start_m As Double = -10000000000#, _
        Optional ByVal h_end_m As Double = 10000000000#)
        
    Dim tr As New CPipeTrajectory
    
    Call tr.init_from_json(construction_json)
    Call init_pipe_constr_by_trajectory(tr, h_start_m, h_end_m)
    Call init_t_model(t_model_json)
End Function
Public Function init_from_dict(construction_dict As Dictionary, _
                               t_model_dict As Dictionary, _
        Optional ByVal h_start_m As Double = -10000000000#, _
        Optional ByVal h_end_m As Double = 10000000000#)
        
    Dim tr As New CPipeTrajectory
    
    Call tr.init_from_dict(construction_dict)
    Call init_pipe_constr_by_trajectory(tr, h_start_m, h_end_m)
    Call init_t_model_from_dict(t_model_dict)
End Function
Public Function calc_grad(l_m As Double, _
                         p_atma As Double, _
                         t_C As Double, _
                         Optional calc_dtdl As Boolean = True, _
                         Optional p_cas_atma As Double = 0.95) As PIPE_FLOW_PARAMS
' функция расчета градиента давления и температуры в скважине при заданных параметрах
' возвращает все параметры потока в заданной точке трубы при заданых термобарических условиях.
'
'
'
'  L_m      - измеренная глубина на которой ведется расчет, нужна для привязки по температуре
'  p_atma   - давление в заданной точке
'  T_C      - температура в заданной точке
'  calc_dtdl
'  p_cas_atma - затрубное давление для оптимизации расчета барботажа в затрубе
'Allocate variables used to output auxilary values
Dim dpdlg_out As Double
Dim dpdlf_out As Double
Dim dpdla_out As Double
Dim v_sl_out As Double
Dim v_sg_out As Double
Dim vl_msec As Double
Dim vg_msec As Double
Dim h_l_out As Double
Dim fpat_out
Dim d_m As Double   ' диаметр трубы по которой идет поток
Dim theta_deg As Double ' угол наклона трубы в расчете
Dim theta_sign As Integer
Dim rough_m As Double   ' шероховатость
Dim Hv_m As Double
Dim dp_dl As Double, dp_dl_arr
Dim dt_dl As Double
Dim V As Double, dvdL As Double
If param_.flow_along_coord Then
    theta_sign = -1
Else
    theta_sign = 1
End If
d_m = d_hmes_m(l_m)                ' определяем диаметр на указанной глубине
theta_deg = theta_sign * angle_hmes_deg(l_m)   ' определяем наклон на заданной глубине
rough_m = roughness_h_mes_m(l_m)       ' определяем шероховатость на заданной глубине
Hv_m = h_vert_h_mes_m(l_m)              ' определяем вертикальную глубину для заданной измеренной глубины
With fluid
  'проверим на корректность исходных данных
    If p_atma < const_minPpipe_atma Then
        dp_dl = 0
        GoTo endlab:
    End If
  
    Call .calc_PVT(p_atma, t_C)             ' найдем все PVT в заданных условиях
    If .q_mix_rc_m3day = 0 Then
        t_C = ambient_formation_.amb_temp_C(Hv_m)
    End If
    
    ReDim dp_dl_arr(7) As Double
    dp_dl_arr(0) = 0
    dp_dl_arr(1) = 0
    dp_dl_arr(2) = 0
    dp_dl_arr(3) = 0
    dp_dl_arr(4) = 0
    dp_dl_arr(5) = 0
    dp_dl_arr(6) = 0
    dp_dl_arr(7) = 101
    
    Dim corr As H_CORRELATION
    If ((l_m >= param_.start_length_gas_m) And (l_m < param_.start_length_gas_m + param_.length_gas_m)) Or fluid.gas_only Then
        corr = gas
    Else
        corr = param_.correlation
    End If
    
    
    Select Case corr
        Case BeggsBrill
            dp_dl_arr = unf_BegsBrillGradient(d_m, theta_deg, rough_m, .qliq_rc_m3day, .q_gas_rc_m3day, .mu_liq_cP, .mu_gas_cP, .sigma_liq_Nm, _
                                  .rho_liq_rc_kgm3, .rho_gas_rc_kgm3, 0, 1, calibr_grav, calibr_fric)
        Case Ansari
            If p_atma > p_cas_atma Then
                dp_dl_arr = unf_AnsariGradient(d_m, theta_deg, rough_m, .qliq_rc_m3day, .q_gas_rc_m3day, .mu_liq_cP, .mu_gas_cP, .sigma_liq_Nm, _
                                  .rho_liq_rc_kgm3, .rho_gas_rc_kgm3, p_atma, calibr_grav, calibr_fric)
            End If
        Case gas
            If p_atma > p_cas_atma Then
                dp_dl_arr = unf_GasGradient(d_m, theta_deg, rough_m, .q_gas_rc_m3day, .mu_gas_cP, _
                                           .rho_gas_rc_kgm3, p_atma)
                ' gas gradient do not use calibration coeficients
            End If
        Case Unified
            dp_dl_arr = unf_UnifiedTUFFPGradient(d_m, theta_deg, rough_m, .qliq_rc_m3day, .q_gas_rc_m3day, .mu_liq_cP, .mu_gas_cP, .sigma_liq_Nm, _
                                  .rho_liq_rc_kgm3, .rho_gas_rc_kgm3, p_atma, calibr_grav, calibr_fric)
        Case Gray
            dp_dl_arr = unf_GrayModifiedGradient(d_m, theta_deg, rough_m, .qliq_rc_m3day, .q_gas_rc_m3day, .mu_liq_cP, .mu_gas_cP, .sigma_liq_Nm, _
                                  .rho_liq_rc_kgm3, .rho_gas_rc_kgm3, 0, 1, , calibr_grav, calibr_fric)
        Case HagedornBrown
            dp_dl_arr = unf_HagedornandBrawnmodified(d_m, theta_deg, rough_m, .qliq_rc_m3day, .q_gas_rc_m3day, .mu_liq_cP, .mu_gas_cP, .sigma_liq_Nm, _
                                  .rho_liq_rc_kgm3, .rho_gas_rc_kgm3, p_atma, 0, 1, , calibr_grav, calibr_fric)
        Case SakharovMokhov
            dp_dl_arr = unf_Saharov_Mokhov_Gradient(d_m, theta_deg, rough_m, p_atma, .q_oil_sm3day, .q_wat_sm3day, .q_gas_sm3day, .bo_m3m3, _
                                      .bw_m3m3, .bg_m3m3, .rs_m3m3, .mu_oil_cP, .mu_wat_cP, .mu_gas_cP, .sigma_oil_gas_Nm, .sigma_wat_gas_Nm, .rho_oil_sckgm3, .rho_wat_sckgm3, .rho_gas_sckgm3, _
                                      , , , calibr_grav, calibr_fric)
    End Select
    
    dp_dl = theta_sign * dp_dl_arr(0)
    
    dpdlg_out = theta_sign * dp_dl_arr(1)
    dpdlf_out = theta_sign * dp_dl_arr(2)
    dpdla_out = theta_sign * dp_dl_arr(3)
    v_sl_out = dp_dl_arr(4)
    v_sg_out = dp_dl_arr(5)
    h_l_out = dp_dl_arr(6)
    fpat_out = dp_dl_arr(7)
    vl_msec = v_sl_out * const_Pi * d_m ^ 2 / 4 ' скорость жидкости реальная
    vg_msec = v_sg_out * const_Pi * d_m ^ 2 / 4 ' скорость жидкости реальная
    ' для оценки температуры оценим скорость потока и ускорение
    
    ' теперь зададим изменение температуры в потоке
    If calc_dtdl Then
        Select Case param.temp_method
              Case StartEndTemp, LengthTemp
                  dt_dl = dTdL_amb_Cm(Hv_m, vertical:=False)
              Case GeoGradTemp
                  dt_dl = dTdL_amb_Cm(Hv_m, vertical:=True)
              Case AmbientTemp
                  V = vg_msec    ' оценка сверху
                  dvdL = -V / p_atma * dp_dl
                  dt_dl = ambient_formation_.calc_dtdl_Cm(Hv_m, sind(theta_deg), t_C, .wm_kgsec, .cmix_JkgC, _
                                                          dp_dl, V, dvdL, .cJT_Katm, param_.flow_along_coord)
        End Select
    End If
    ' тут надо записать в результаты все расчетные параметры
    Dim res As PIPE_FLOW_PARAMS
 
 
         res.md_m = l_m                                 ' pipe measured depth (from start - top)
         res.vd_m = Hv_m                                ' pipe vertical depth from start - top
         res.diam_mm = d_m * 1000
         res.dpdl_a_atmm = dpdla_out                    ' acceleration gradient at measured depth
         res.dpdl_f_atmm = dpdlf_out                    ' friction gradient at measured depth
         res.dpdl_g_atmm = dpdlg_out                    ' gravity gradient at measured depth
         res.fpat = fpat_out                            ' flow pattern code
         res.gasfrac = fluid.gas_fraction_d()
         res.h_l_d = h_l_out                            ' liquid hold up
         res.Qg_m3day = fluid.q_gas_rc_m3day
         res.p_atma = p_atma                              '  pipe pressure at measured depth
         res.t_C = t_C                                  ' pipe temp at measured depth
         res.v_sl_msec = v_sl_out                       ' superficial liquid velosity
         res.v_sg_msec = v_sg_out                       ' superficial gas velosity
         res.thete_deg = theta_deg                      '
         res.roughness_m = rough_m                      '
         res.rs_m3m3 = fluid.rs_m3m3                    ' растворенный газ в нефти в потоке
         res.gasfrac = fluid.gas_fraction_d              ' расходное содержание газа в потоке
         res.mu_oil_cP = fluid.mu_oil_cP                      ' вязкость нефть в потоке
         res.mu_wat_cP = fluid.mu_wat_cP                      ' вязкость воды в потоке
         res.mu_gas_cP = fluid.mu_gas_cP                      ' вязкость газа в потоке
         res.mu_mix_cP = fluid.mu_mix_cP                  ' вязкость смеси в потоке
         res.Rhoo_kgm3 = fluid.rho_oil_rc_kgm3             ' плотность нефти
         res.Rhow_kgm3 = fluid.rho_wat_rc_kgm3           ' плотность воды
         res.rhol_kgm3 = fluid.rho_liq_rc_kgm3             ' плотность жидкости
         res.Rhog_kgm3 = fluid.rho_gas_rc_kgm3             ' плотность газа
         res.rhomix_kgm3 = fluid.rho_mix_rc_kgm3           ' плотность смеси в потоке
         res.q_oil_m3day = fluid.q_oil_rc_m3day                  ' расход нефти в рабочих условиях
         res.qw_m3day = fluid.q_wat_rc_m3day                  ' расход воды в рабочих условиях
         res.Qg_m3day = fluid.q_gas_rc_m3day            ' расход газа в рабочих условиях
         res.mo_kgsec = fluid.mo_kgsec                  ' массовый расход нефти в рабочих условиях
         res.mw_kgsec = fluid.mw_kgsec                  ' массовый расход воды в рабочих условиях
         res.mg_kgsec = fluid.mg_kgsec                  ' массовый расход газа в рабочих условиях
         res.vl_msec = vl_msec  ' скорость жидкости реальная
         res.vg_msec = vg_msec  ' скорость газа реальная
endlab:
 res.dp_dl = dp_dl
 res.dt_dl = dt_dl
 calc_grad = res
End With
End Function
Public Sub set_ZNLF()
        znlf_ = True
        param_.correlation = Ansari
        If param_.temp_method = 2 Then param_.temp_method = 1
        Set fluid = fluid.clone
        fluid.q_liq_sm3day = const_ZNLF_rate
        fluid.fw_fr = 0 ' только нефть при барботаже
End Sub
Public Function calc_dPipe(ByVal p_atma As Double, _
                  Optional ByVal t_C As Double, _
                  Optional ByVal saveCurve As CALC_RESULTS = noCurves) As PTtype
' здесь выбираем метод расчета
' если не надо рассчитывать эмисию тепла - то можно расчет делать только по давлению - это быстрее
' если температуру рассчитываем то решаем систему и по давлению и по температуре - медленнее
' если для расчета нужна стартовая температура флюида то берется из t_calc_C
    Dim PTres As PTtype
        
    If Not IsMissing(t_C) Then
        t_calc_C = t_C
    End If
    
    If length_mes_m = 0 Then
        PTres.p_atma = p_atma
        PTres.t_C = t_calc_C
    Else
        With param
            If .temp_method = AmbientTemp Then
                If .calc_along_coord = .flow_along_coord And fluid.q_liq_sm3day > 1 Then
                    ' расчет температуры с учетом эмисиии тепла в окружающее пространство возможен
                    ' только если расчет делается по направлению потока
                    PTres = calc_dPipe_2d(p_atma, t_calc_C, saveCurve)
                Else
                    log_.add_msg "CPipe.calc_dPipe warning: t_model = 2 can not be calculated .calc_along_coord <> .flow_along_coord"
                    PTres = calc_dPipe_1d(p_atma, saveCurve)
                End If
            Else
                PTres = calc_dPipe_1d(p_atma, saveCurve)
            End If
        End With
    End If
    p_result_atma = PTres.p_atma
    t_result_C = PTres.t_C
    calc_dPipe = PTres
End Function
Private Function calc_dPipe_2d(p_atma As Double, t_C As Double, Optional saveCurve As CALC_RESULTS = noCurves) As PTtype
' новая версия расчета перепада давления в трубе, сразу с учетом инклинометрии
' основан на применении ODEsolver
' PT   - термобарические условия в точке задания условия по давлению
' SaveCurve - флаг показывающий необходимость сохранения детальных результатов расчета
' t_other_C  - опциональное значение температуры на другом конце трубы, необходимо при линейном
'             распределении температуры
Dim y0(1) As Double   ' начальные значения для проведения расчета
Dim n, M As Long
Dim X() As Double, y() As Double     ' массив глубин для которых нужны значения
Dim eps As Double
Dim step As Double
Dim State As ODESolverState
Dim Rtn As Boolean
Dim i As Integer
Dim pfp As PIPE_FLOW_PARAMS
Dim Rep As ODESolverReport
Dim stPt As Boolean
Dim crv_hl As CInterpolation
Dim crv_fpat As CInterpolation
'ReDim Y0(1)
On Error GoTo err1:
    eps = const_pressure_tolerance '0.01
    step = 10
    
    Dim tstart As Single
    tstart = Timer
    
    log_.add_msg "calc_dPipe_2d start with pressure tolerance = " & CStr(eps) & " atm"
    log_.add_msg "{""multiphase_correlation"" :" & CStr(param.correlation) & ", ""t_model"" : " & CStr(param.temp_method) & _
                ", ""PVT_correlation"": " & CStr(fluid.PVT_correlation) & _
                ", ""calc_along_coord"": " & IIf(param.calc_along_coord, 1, 0) & ", ""flow_along_coord"": " & IIf(param.flow_along_coord, 1, 0) & "}"
  
    y0(0) = p_atma
    y0(1) = t_C
    n = 2                   ' размер системы  - две переменные - давление и температура
    M = hm_curve_.num_points ' количество точек для которых надо выдать ответ
    ' формируем массив глубин для расчета давления
    ' учитываем, что массив глубин зависит от направления в котором отсчитываем координаты
    ReDim X(M - 1)
    
    If param.calc_along_coord Then
        For i = 0 To M - 1
            X(i) = hm_curve_.pointX(i + 1)
        Next i
    Else
        For i = 0 To M - 1
            X(i) = hm_curve_.pointX(M - i)
        Next i
    End If
      ' проверка - если поток в скважине нулевой, тогда температура равна температуре окружающей среды
      ' без такой проверки расчет градиента температуры сходит с ума
    If fluid.q_liq_sm3day = 0 Then
        y0(1) = ambient_formation_.amb_temp_C(X(0))
    End If
        
 '   Y = solve_ode("calc_grad_2d", Y0, x, coeffA, Eps)
    
    Call ODESolverRKCK(y0(), n, X, M, eps, step, State)
    ' Loop through the AlgLib solver routine and the external ODE
    ' evaluation routine until the solver routine returns "False",
    ' which indicates that it has finished.
    ' The VBA function named in "FuncName" is called using
    ' the Application.Run method.
    Rtn = True
    i = 0
    
    If saveCurve > 0 Then
        Set crv_hl = New CInterpolation
        Set crv_fpat = New CInterpolation
    End If
    
    Do While Rtn = True And i < 10000
        Rtn = ODESolverIteration(State)
        pfp = calc_grad(State.X, State.y(0), State.y(1))    ' Application.Run(FuncName, State.X, State.Y, CoeffA)
        State.DY(0) = pfp.dp_dl
        State.DY(1) = pfp.dt_dl
        If saveCurve > 0 Then
            Call crv_hl.AddPoint(pfp.md_m, pfp.h_l_d)
            Call crv_fpat.AddPoint(pfp.md_m, pfp.fpat)
        End If
        i = i + 1
    Loop
     ' Extract the desired results from the State
     ' object using the appropriate AlgLib routine
    Call ODESolverResults(State, M, X, y, Rep)
    ' If necessary convert the AlgLib output array(s) to
    ' a form suitable for Excel.  In this case YA2 is
    ' a 2D base 0 array, which may be assigned to the
    ' function return value without further processing.
    ' Assign the output array to the function return value
    ' ODE = YA2
    
    ' подговим выходные результаты функции
    calc_dPipe_2d.p_atma = y(M - 1, 0)
    calc_dPipe_2d.t_C = y(M - 1, 1)
    
    log_.add_msg "calc_dPipe_2d calc done with " & CStr(i) & " iterations in " & CStr((Timer - tstart) * 1000) & " ms"
    
    If saveCurve > 0 Then
    ' сохраним результаты расчета для отображения на графиках
        curve("c_P").ClearPoints
        curve("c_T").ClearPoints
        curve("c_Tamb").ClearPoints
        For i = 0 To M - 1
            stPt = i = 0 Or i = M - 1
            curve("c_P").AddPoint X(i), y(i, 0), stPt
            curve("c_T").AddPoint X(i), y(i, 1), stPt
            If param.temp_method = AmbientTemp Then
                curve("c_Tamb").AddPoint X(i), ambient_formation_.amb_temp_C(curve("c_Hvert").getPoint(X(i))), stPt
            Else
                curve("c_Tamb").AddPoint X(i), y(i, 1), stPt
            End If
        Next i
        curve("c_P").special = True
        curve("c_T").special = True
        curve("c_Tamb").special = True
        Set curve("c_Hl") = crv_hl
        Set curve("c_fpat") = crv_fpat
        If saveCurve > 1 Then
            Call FillDetailedCurve
        End If
    End If
    Exit Function
err1:
    add_log_msg ("CPipe.calc_dPipe_2d: ошибка какая то")
    Err.Raise Err.Number, Err.source, Err.Description
End Function
Private Function calc_dPipe_1d(p_atma As Double, Optional saveCurve As CALC_RESULTS = noCurves) As PTtype
' новая версия расчета перепада давления в трубе, сразу с учетом инклинометрии
' основан на применении ODEsolver
' проверка работы одномерного решателя - ради скорости расчета
Dim y0(0) As Double   ' начальные значения для проведения расчета
Dim n As Long, M As Long
Dim X() As Double, y() As Double     ' массив глубин для которых нужны значения
Dim eps As Double
Dim step As Double
Dim State As ODESolverState
Dim Rtn As Boolean
Dim i As Integer
Dim pfp As PIPE_FLOW_PARAMS
Dim Rep As ODESolverReport
Dim stPt As Boolean
Dim crv_hl As CInterpolation
Dim crv_fpat As CInterpolation
On Error GoTo err1:
    eps = const_pressure_tolerance
    step = 10
    
    Dim tstart As Single
    tstart = Timer
    
    log_.add_msg "calc_dPipe_1d start with pressure tolerance = " & CStr(eps) & " atm"
    log_.add_msg "{""multiphase_correlation"" :" & CStr(param.correlation) & ", ""t_model"" : " & CStr(param.temp_method) & _
                ", ""PVT_correlation"": " & CStr(fluid.PVT_correlation) & _
                ", ""calc_along_coord"": " & IIf(param.calc_along_coord, 1, 0) & ", ""flow_along_coord"": " & IIf(param.flow_along_coord, 1, 0) & "}"
    
    y0(0) = p_atma
    
'    Y0(1) = PT.T_C
    n = 1                   ' размер системы  - одна переменные - давление и температура
    M = hm_curve_.num_points ' количество точек для которых надо выдать ответ
    ' формируем массив глубин для расчета давления
    ' учитываем, что массив глубин зависит от направления в котором отсчитываем координаты
    ReDim X(M - 1)
    If param.calc_along_coord Then
        For i = 0 To M - 1
            X(i) = hm_curve_.pointX(i + 1)
        Next i
    Else
        For i = 0 To M - 1
            X(i) = hm_curve_.pointX(M - i)
        Next i
    End If
      ' проверка - если поток в скважине нулевой, тогда температура равна температуре окружающей среды
      ' без такой проверки расчет градиента температуры сходит с ума
'    If fluid.q_liq_sm3day = 0 Then
'        Y0(1) = ambient_formation.amb_temp_C(X(0))
'    End If
    Call ODESolverRKCK(y0(), n, X, M, eps, step, State)
    ' Loop through the AlgLib solver routine and the external ODE
    ' evaluation routine until the solver routine returns "False",
    ' which indicates that it has finished.
    ' The VBA function named in "FuncName" is called using
    ' the Application.Run method.
    Rtn = True
    i = 0
    
    If saveCurve > 0 Then
        Set crv_hl = New CInterpolation
        Set crv_fpat = New CInterpolation
    End If
    
    Do While Rtn = True And i < 10000
        Rtn = ODESolverIteration(State)
        If State.y(0) < const_minPpipe_atma Then
        ' при расчете давления получили отрицательные значения
        ' может происходить про расчете в затрубе
        ' тогда имитируем правильное завершение работы цикла
            State.y(0) = 0
            'State.RepTerminationType = 2
            'Rtn = False
        End If
        pfp = calc_grad(State.X, State.y(0), t_init_C(State.X), calc_dtdl:=False)
        State.DY(0) = pfp.dp_dl
        If saveCurve > 0 Then
            Call crv_hl.AddPoint(pfp.md_m, pfp.h_l_d)
            Call crv_fpat.AddPoint(pfp.md_m, pfp.fpat)
        End If
        i = i + 1
    Loop
     ' Extract the desired results from the State
     ' object using the appropriate AlgLib routine
    Call ODESolverResults(State, M, X, y, Rep)
    ' If necessary convert the AlgLib output array(s) to
    ' a form suitable for Excel.  In this case YA2 is
    ' a 2D base 0 array, which may be assigned to the
    ' function return value without further processing.
    ' Assign the output array to the function return value
    ' ODE = YA2
   ' Debug.Print i    ' 133  iteration approximatly min
    ' подговим выходные результаты функции
    calc_dPipe_1d.p_atma = y(M - 1, 0)
    calc_dPipe_1d.t_C = t_init_C(X(M - 1))
    
    log_.add_msg "calc_dPipe_1d calc done with " & CStr(i) & " iterations in " & CStr((Timer - tstart) * 1000) & " ms"
    
    If saveCurve > 0 Then
    ' сохраним результаты расчета для отображения на графиках
        curve("c_P").ClearPoints
        curve("c_T").ClearPoints
        curve("c_Tamb").ClearPoints
        For i = 0 To M - 1
            If h_mes_insert_m_.TestPoint(X(i)) >= 0 Then
                stPt = True
            Else
                stPt = False
            End If
            curve("c_P").AddPoint X(i), y(i, 0), stPt
            curve("c_T").AddPoint X(i), t_init_C(X(i)), stPt
            curve("c_Tamb").AddPoint X(i), t_init_C(X(i)), stPt
        Next i
        curve("c_P").special = True
        curve("c_T").special = True
        curve("c_Tamb").special = True
        
        Set curve("c_Hl") = crv_hl
        Set curve("c_fpat") = crv_fpat
        
        If saveCurve > 1 Then
            Call FillDetailedCurve
        End If
    End If
    
    Exit Function
err1:
    Dim msg As String
    msg = "CPipe.calc_dPipe_1d: error -> " + sDELIM + Err.Description
    Err.Raise Err.Number, Err.source, msg
End Function
Private Sub FillDetailedCurve()
' функция расчета  детальных распределений параметров по длине трубы
    Dim i As Integer
    Dim M As Integer
    Dim FlowParams_out As PIPE_FLOW_PARAMS
    M = curve("c_P").num_points
    Call curve.ClearPoints_unprotected
    For i = 1 To M
        FlowParams_out = calc_grad(curve("c_P").pointX(i), _
                                   curve("c_P").PointY(i), _
                                   curve("c_T").PointY(i))
        With FlowParams_out
            curve("c_udl_m").AddPoint .md_m, .md_m - .vd_m
            curve("c_dpdl_g").AddPoint .md_m, .dpdl_g_atmm
            curve("c_dpdl_f").AddPoint .md_m, .dpdl_f_atmm
            curve("c_dpdl_a").AddPoint .md_m, .dpdl_a_atmm
            curve("c_vsl").AddPoint .md_m, .v_sl_msec
            curve("c_vsg").AddPoint .md_m, .v_sg_msec
'            curve("c_Hl").AddPoint .md_m, .h_l_d
'            curve("c_fpat").AddPoint .md_m, .fpat
            'curve("c_Theta").AddPoint .md_m, .thete_deg
            'curve("c_Roughness").AddPoint .md_m, .roughness_m
            curve("c_Rs").AddPoint .md_m, .rs_m3m3
            curve("c_gasfrac").AddPoint .md_m, .gasfrac
            curve("c_muo").AddPoint .md_m, .mu_oil_cP
            curve("c_muw").AddPoint .md_m, .mu_wat_cP
            curve("c_mug").AddPoint .md_m, .mu_gas_cP
            curve("c_mumix").AddPoint .md_m, .mu_mix_cP
            curve("c_rhoo").AddPoint .md_m, .Rhoo_kgm3
            curve("c_rhow").AddPoint .md_m, .Rhow_kgm3
            curve("c_rhol").AddPoint .md_m, .rhol_kgm3
            curve("c_rhog").AddPoint .md_m, .Rhog_kgm3
            curve("c_rhomix").AddPoint .md_m, .rhomix_kgm3
            curve("c_qo").AddPoint .md_m, .q_oil_m3day
            curve("c_qw").AddPoint .md_m, .qw_m3day
            curve("c_qg").AddPoint .md_m, .Qg_m3day
            curve("c_mo").AddPoint .md_m, .mo_kgsec
            curve("c_mw").AddPoint .md_m, .mw_kgsec
            curve("c_mg").AddPoint .md_m, .mg_kgsec
            curve("c_vl").AddPoint .md_m, .vl_msec
            curve("c_vg").AddPoint .md_m, .vg_msec
        End With
    Next i
End Sub
Public Property Get p_curve() As CInterpolation
    Set p_curve = curve("c_P")
End Property
Public Function get_result_dict(Optional ByVal num_points As Integer = 20, _
                                Optional ByVal show_array As Boolean = False, _
                                Optional ByVal show_log As Boolean = False)
' подготовка словаря для вывода в json
' num_points - количество точек в выходных массивах для вывода
    Dim resd As New Dictionary
    Dim M As Integer
    On Error Resume Next
    
            ' prepare dict for result output
        Dim crv_p As CInterpolation
        Dim crv_t As CInterpolation
        
        ' rearrange output curves one time here - will be used later
        Set crv_p = curve("c_P").ClonePointsToNum(num_points)
        Set crv_t = curve("c_T").ClonePointsToNum(num_points)
        M = crv_p.num_points
    
        resd.Add "p_result_atma", Round(p_result_atma, const_decimal_output)
        resd.Add "t_result_C", Round(t_result_C, const_decimal_output)
        resd.Add "p_1, atma", Round(crv_p.PointY(1), const_decimal_output)
        resd.Add "t_1, C", Round(crv_t.PointY(1), const_decimal_output)
        resd.Add "p_2, atma", Round(crv_p.PointY(M), const_decimal_output)
        resd.Add "t_2, C", Round(crv_t.PointY(M), const_decimal_output)
        resd.Add "calibr_grav", calibr_grav_
        resd.Add "calibr_fric", calibr_fric_
        resd.Add "q_gas_sm3day", Round(fluid.q_gas_sm3day, const_decimal_output)
        
        If show_array Then
            resd.Add "arr_hmes", crv_p.getJson(only_vector_num:=1)
            resd.Add "arr_p_atma", crv_p.getJson(only_vector_num:=2)
            resd.Add "arr_t_C", crv_t.getJson(only_vector_num:=2)
        End If
        If show_log Then
            resd.Add "log", log_.get_str_safe(show_log)
        End If
        Set get_result_dict = resd
End Function
Public Function get_result_dict_crv_main(Optional ByVal num_points As Integer = 20)
' подготовка массива для вывода Dictionary
' num_points - количество точек в выходных массивах для вывода
    Dim resd_crv1 As New Dictionary
    
    On Error Resume Next
    
            ' prepare dict for result output
        Dim crv_p As CInterpolation
        
        ' rearrange output curves one time here - will be used later
        Set crv_p = curve("c_P").ClonePointsToNum(num_points)
        
        resd_crv1.Add "crv_P", crv_p.ClonePointsToNum(num_points).getDict
        resd_crv1.Add "crv_Н", curve("c_Hvert").ClonePointsToNum(num_points).getDict
        resd_crv1.Add "c_T", curve("c_T").ClonePointsToNum(num_points).getDict
        resd_crv1.Add "c_Hl", curve("c_Hl").ClonePointsToNum(num_points).getDict
        resd_crv1.Add "c_fpat", curve("c_fpat").ClonePointsToNum(num_points).getDict
        resd_crv1.Add "c_Tamb", curve("c_Tamb").ClonePointsToNum(num_points).getDict
        resd_crv1.Add "c_Diam", curve("c_Diam").ClonePointsToNum(num_points).getDict
        Set get_result_dict_crv_main = resd_crv1
End Function
Public Function get_result_dict_crv_add(Optional ByVal num_points As Integer = 20)
' подготовка массива для вывода в Excel
' num_points - количество точек в выходных массивах для вывода
    Dim resd_crv2 As New Dictionary
    
    On Error Resume Next
        resd_crv2.Add "c_Roughness", curve("c_Roughness").getDict
        
        Set get_result_dict_crv_add = resd_crv2
End Function
Public Function get_result_array(Optional ByVal num_points As Integer = 20, _
                                 Optional show_log As Boolean = False)
' подготовка массива для вывода в Excel
' num_points - количество точек в выходных массивах для вывода
'
' базовый вывод, работает в любых версиях Excel - выводит только числа
    Dim arr()
    Dim M As Integer
    Dim offset As Integer
    Dim i As Integer
    Dim hh As Double
    
    offset = 2
On Error Resume Next
    Dim crv_p As CInterpolation
    Dim crv_t As CInterpolation
    
    ' rearrange output curves one time here - will be used later
    Set crv_p = curve("c_P").ClonePointsToNum(num_points)
    Set crv_t = curve("c_T").ClonePointsToNum(num_points)
    
    M = crv_p.num_points
    ReDim arr(M + offset, 7)
   
    arr(0, 0) = Round(p_result_atma, const_num_decimal_out)
    arr(0, 1) = Round(crv_p.PointY(1), const_num_decimal_out)
    arr(0, 2) = Round(crv_t.PointY(1), const_num_decimal_out)
    arr(0, 3) = Round(crv_p.PointY(M), const_num_decimal_out)
    arr(0, 4) = Round(crv_t.PointY(M), const_num_decimal_out)
    arr(0, 5) = Round(calibr_grav_, const_num_decimal_out)
    arr(0, 6) = Round(calibr_fric_, const_num_decimal_out)
    arr(0, 7) = log_.get_str_safe(show_log)
    
    arr(1, 0) = "p_result_atma"
    arr(1, 1) = "p_1, atma"
    arr(1, 2) = "t_1, C"
    arr(1, 3) = "p_2, atma"
    arr(1, 4) = "t_2, C"
    arr(1, 5) = "calibr_grav"
    arr(1, 6) = "calibr_fric"
    arr(1, 7) = "log"
    
    arr(offset, 0) = "h,m"
    arr(offset, 1) = "hvert,m"
    arr(offset, 2) = "p,atma"
    arr(offset, 3) = "t,C"
    arr(offset, 4) = "t_amb, C"
    arr(offset, 5) = "Hl, %"
    arr(offset, 6) = "fpat"
    arr(offset, 7) = "diam, mm"
    For i = 1 To M
        hh = crv_p.pointX(i)
        arr(offset + i, 0) = hh
        arr(offset + i, 1) = curve("c_Hvert").getPoint(hh)
        arr(offset + i, 2) = crv_p.PointY(i)
        arr(offset + i, 3) = crv_t.PointY(i)
        arr(offset + i, 4) = curve("c_Tamb").getPoint(hh)
        arr(offset + i, 5) = curve("c_Hl").getPoint(hh) * 100
        arr(offset + i, 6) = curve("c_fpat").getPoint(hh)
        arr(offset + i, 7) = curve("c_Diam").getPoint(hh) * 1000
    Next i
    get_result_array = arr
End Function
Public Property Get ambient_formation() As CAmbientFormation
    Set ambient_formation = ambient_formation_
End Property
Public Property Set ambient_formation(vNewValue As CAmbientFormation)
    Set ambient_formation_ = vNewValue
'    Call init_t_model(amb0:=ambient_formation_)
End Property
' flow parameter setting function in the pipe or well
Public Sub set_calc_flow_param( _
                Optional ByVal calc_along_coord As Boolean = False, _
                Optional ByVal flow_along_coord As Boolean = False, _
                Optional ByVal hcor As H_CORRELATION = Ansari, _
                Optional ByVal temp_method As TEMP_CALC_METHOD = StartEndTemp, _
                Optional ByVal length_gas_m As Double = 0, _
                Optional ByVal start_length_gas_m As Double = 0)
' calc_along_coord - calculation direction flag
' flow_along_coord - flow direction relative to coordinate
' hcor             - hydraulic correlation selector
' temp_method      - temperature method selector
' length_gas_m     - boundary of gas correlation application in flow
    Dim prm As PARAMCALC
    prm.calc_along_coord = calc_along_coord
    prm.flow_along_coord = flow_along_coord
    prm.correlation = hcor
    prm.temp_method = temp_method
    prm.length_gas_m = length_gas_m
    prm.start_length_gas_m = start_length_gas_m
    param = prm
End Sub
Public Sub set_flow_along_coord(ByVal flow_along_coord As Boolean)
' flow_along_coord - flow direction relative to coordinate
    param_.flow_along_coord = flow_along_coord
End Sub

