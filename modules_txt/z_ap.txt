Public Type Complex
    X As Double
    Y As Double
End Type
Public Type RCommState
    Stage As Long
    BA() As Boolean
    IA() As Long
    RA() As Double
    CA() As Complex
End Type
Public Type ALGLIBDataset
    NIn As Long
    NOut As Long
    NClasses As Long
    
    Trn() As Double
    TST() As Double
    val() As Double
    AllDataset() As Double
    
    TrnSize As Long
    TstSize As Long
    ValSize As Long
    TotalSize As Long
End Type
Public Const MachineEpsilon = 5E-16
Public Const MaxRealNumber = 1E+300
Public Const MinRealNumber = 1E-300
Private Const BigNumber As Double = 1E+70
Private Const SmallNumber As Double = 1E-70
Private Const PiNumber As Double = 3.14159265358979
Public Function FormatInteger(i As Long, w As Long) As String
    If w <= 1 Then
        FormatInteger = Format(i, "0")
    Else
        Tmp = Format(i, String(w - 1, "#") & "0")
        Do While Len(Tmp) < w
            Tmp = " " & Tmp
        Loop
        FormatInteger = Tmp
    End If
End Function
Public Function FormatFReal(R As Double, w As Long, p As Long) As String
    Tmp = Format(R, "0." & String(p, "0"))
    Do While Len(Tmp) < w
        Tmp = " " & Tmp
    Loop
    FormatFReal = Tmp
End Function
Public Function FormatEReal(R As Double, w As Long, p As Long) As String
    Tmp = Format(R, "0." & String(p, "0") & "E+0")
    Do While Len(Tmp) < w
        Tmp = " " & Tmp
    Loop
    FormatEReal = Tmp
End Function
Public Sub ConsoleOutputString(S As String)
End Sub
Public Function MaxReal(ByVal M1 As Double, ByVal M2 As Double) As Double
    If M1 > M2 Then
        MaxReal = M1
    Else
        MaxReal = M2
    End If
End Function
Public Function MinReal(ByVal M1 As Double, ByVal M2 As Double) As Double
    If M1 < M2 Then
        MinReal = M1
    Else
        MinReal = M2
    End If
End Function
Public Function MaxInt(ByVal M1 As Long, ByVal M2 As Long) As Long
    If M1 > M2 Then
        MaxInt = M1
    Else
        MaxInt = M2
    End If
End Function
Public Function MinInt(ByVal M1 As Long, ByVal M2 As Long) As Long
    If M1 < M2 Then
        MinInt = M1
    Else
        MinInt = M2
    End If
End Function
Public Function ArcSin(ByVal X As Double) As Double
    Dim T As Double
    T = Sqr(1 - X * X)
    If T < SmallNumber Then
        ArcSin = Atn(BigNumber * Sgn(X))
    Else
        ArcSin = Atn(X / T)
    End If
End Function
Public Function ArcCos(ByVal X As Double) As Double
    Dim T As Double
    T = Sqr(1 - X * X)
    If T < SmallNumber Then
        ArcCos = Atn(BigNumber * Sgn(-X)) + 2 * Atn(1)
    Else
        ArcCos = Atn(-X / T) + 2 * Atn(1)
    End If
End Function
Public Function SinH(ByVal X As Double) As Double
    SinH = (Exp(X) - Exp(-X)) / 2
End Function
Public Function CosH(ByVal X As Double) As Double
    CosH = (Exp(X) + Exp(-X)) / 2
End Function
Public Function TanH(ByVal X As Double) As Double
    Dim T As Double
    If X > 0 Then
        T = Exp(-X)
        T = T * T
        TanH = (1 - T) / (1 + T)
    Else
        T = Exp(X)
        T = T * T
        TanH = (T - 1) / (T + 1)
    End If
End Function
Public Function Pi() As Double
    'Pi = PiNumber
    Pi = ArcCos(-1)
End Function
Public Function Power(ByVal Base As Double, ByVal Exponent As Double) As Double
    Power = Base ^ Exponent
End Function
Public Function Square(ByVal X As Double) As Double
    Square = X * X
End Function
Public Function Log10(ByVal X As Double) As Double
    Log10 = log(X) / log(10)
End Function
Public Function Ceil(ByVal X As Double) As Double
    Ceil = -Int(-X)
End Function
Public Function RandomInteger(ByVal X As Long) As Long
    RandomInteger = Int(Rnd() * X)
End Function
Public Function Atn2(ByVal Y As Double, ByVal X As Double) As Double
    If SmallNumber * Abs(Y) < Abs(X) Then
        If X < 0 Then
            If Y = 0 Then
                Atn2 = Pi()
            Else
                Atn2 = Atn(Y / X) + Pi() * Sgn(Y)
            End If
        Else
            Atn2 = Atn(Y / X)
        End If
    Else
        Atn2 = Sgn(Y) * Pi() / 2
    End If
End Function
Public Function C_Complex(ByVal X As Double) As Complex
    Dim Result As Complex
    Result.X = X
    Result.Y = 0
    C_Complex = Result
End Function
Public Function AbsComplex(ByRef z As Complex) As Double
    Dim Result As Double
    Dim w As Double
    Dim XABS As Double
    Dim YABS As Double
    Dim V As Double
    XABS = Abs(z.X)
    YABS = Abs(z.Y)
    w = MaxReal(XABS, YABS)
    V = MinReal(XABS, YABS)
    If V = 0 Then
        Result = w
    Else
        Result = w * Sqr(1 + Square(V / w))
    End If
    AbsComplex = Result
End Function
Public Function C_Opposite(ByRef z As Complex) As Complex
    Dim Result As Complex
    Result.X = -z.X
    Result.Y = -z.Y
    C_Opposite = Result
End Function
Public Function Conj(ByRef z As Complex) As Complex
    Dim Result As Complex
    Result.X = z.X
    Result.Y = -z.Y
    Conj = Result
End Function
Public Function CSqr(ByRef z As Complex) As Complex
    Dim Result As Complex
    Result.X = Square(z.X) - Square(z.Y)
    Result.Y = 2 * z.X * z.Y
    CSqr = Result
End Function
Public Function C_Add(ByRef Z1 As Complex, ByRef Z2 As Complex) As Complex
    Dim Result As Complex
    Result.X = Z1.X + Z2.X
    Result.Y = Z1.Y + Z2.Y
    C_Add = Result
End Function
Public Function C_Mul(ByRef Z1 As Complex, ByRef Z2 As Complex) As Complex
    Dim Result As Complex
    Result.X = Z1.X * Z2.X - Z1.Y * Z2.Y
    Result.Y = Z1.X * Z2.Y + Z1.Y * Z2.X
    C_Mul = Result
End Function
Public Function C_AddR(ByRef Z1 As Complex, ByVal R As Double) As Complex
    Dim Result As Complex
    Result.X = Z1.X + R
    Result.Y = Z1.Y
    C_AddR = Result
End Function
Public Function C_MulR(ByRef Z1 As Complex, ByVal R As Double) As Complex
    Dim Result As Complex
    Result.X = Z1.X * R
    Result.Y = Z1.Y * R
    C_MulR = Result
End Function
Public Function C_Sub(ByRef Z1 As Complex, ByRef Z2 As Complex) As Complex
    Dim Result As Complex
    Result.X = Z1.X - Z2.X
    Result.Y = Z1.Y - Z2.Y
    C_Sub = Result
End Function
Public Function C_SubR(ByRef Z1 As Complex, ByVal R As Double) As Complex
    Dim Result As Complex
    Result.X = Z1.X - R
    Result.Y = Z1.Y
    C_SubR = Result
End Function
Public Function C_RSub(ByVal R As Double, ByRef Z1 As Complex) As Complex
    Dim Result As Complex
    Result.X = R - Z1.X
    Result.Y = -Z1.Y
    C_RSub = Result
End Function
Public Function C_Div(ByRef Z1 As Complex, ByRef Z2 As Complex) As Complex
    Dim Result As Complex
    Dim A As Double
    Dim B As Double
    Dim c As Double
    Dim d As Double
    Dim E As Double
    Dim F As Double
    A = Z1.X
    B = Z1.Y
    c = Z2.X
    d = Z2.Y
    If Abs(d) < Abs(c) Then
        E = d / c
        F = c + d * E
        Result.X = (A + B * E) / F
        Result.Y = (B - A * E) / F
    Else
        E = c / d
        F = d + c * E
        Result.X = (B + A * E) / F
        Result.Y = (-A + B * E) / F
    End If
    C_Div = Result
End Function
Public Function C_DivR(ByRef Z1 As Complex, ByVal R As Double) As Complex
    Dim Result As Complex
    Result.X = Z1.X / R
    Result.Y = Z1.Y / R
    C_DivR = Result
End Function
Public Function C_RDiv(ByVal R As Double, ByRef Z2 As Complex) As Complex
    Dim Result As Complex
    Dim A As Double
    Dim c As Double
    Dim d As Double
    Dim E As Double
    Dim F As Double
    A = R
    c = Z2.X
    d = Z2.Y
    If Abs(d) < Abs(c) Then
        E = d / c
        F = c + d * E
        Result.X = A / F
        Result.Y = -(A * E / F)
    Else
        E = c / d
        F = d + c * E
        Result.X = A * E / F
        Result.Y = -(A / F)
    End If
    C_RDiv = Result
End Function
Public Function C_Equal(ByRef Z1 As Complex, ByRef Z2 As Complex) As Boolean
    Dim Result As Boolean
    Result = Z1.X = Z2.X And Z1.Y = Z2.Y
    C_Equal = Result
End Function
Public Function C_NotEqual(ByRef Z1 As Complex, _
         ByRef Z2 As Complex) As Boolean
    Dim Result As Boolean
    Result = Z1.X <> Z2.X Or Z1.Y <> Z2.Y
    C_NotEqual = Result
End Function
Public Function C_EqualR(ByRef Z1 As Complex, ByVal R As Double) As Boolean
    Dim Result As Boolean
    Result = Z1.X = R And Z1.Y = 0
    C_EqualR = Result
End Function
Public Function C_NotEqualR(ByRef Z1 As Complex, _
         ByVal R As Double) As Boolean
    Dim Result As Boolean
    Result = Z1.X <> R Or Z1.Y <> 0
    C_NotEqualR = Result
End Function
Public Function SplitTrim(ByVal S As String, ByVal SEP As String) As String()
    Dim SPrev As String
    S = Trim(S)
    Do
        SPrev = S
        S = Replace(S, "  ", " ")
    Loop Until S = SPrev
    SplitTrim = Split(S, SEP)
End Function
Public Function OpenDataset(ByVal FileName As String, ByRef DS As ALGLIBDataset) As Boolean
    DS.NClasses = 0
    DS.NIn = 0
    DS.NOut = 0
    DS.TotalSize = 0
    DS.TrnSize = 0
    DS.TstSize = 0
    DS.ValSize = 0
    
    FileNumber = FreeFile()
    LinesRead = 0
    On Error GoTo HandleNoFile
    Open FileName For Input As FileNumber
    On Error GoTo HandleErrorWithinFile
    Do While Not EOF(FileNumber)
        Line Input #FileNumber, TextLine
        If (Left(TextLine, 2) <> "//") And (Trim(TextLine) <> "") Then
            If LinesRead = 0 Then
                '
                ' read header
                '
                HeadArr = SplitTrim(TextLine, "#")
                If UBound(HeadArr) <> 1 Then Error 1
                
                '
                ' rows information
                '
                RowsArr = SplitTrim(HeadArr(0), " ")
                If (UBound(RowsArr) < 0) Or (UBound(RowsArr) > 2) Then Error 1
                If UBound(RowsArr) = 0 Then
                    DS.TotalSize = val(RowsArr(0))
                    DS.TrnSize = DS.TotalSize
                End If
                If UBound(RowsArr) = 1 Then
                    DS.TrnSize = val(RowsArr(0))
                    DS.TstSize = val(RowsArr(1))
                    DS.TotalSize = DS.TrnSize + DS.TstSize
                End If
                If UBound(RowsArr) = 2 Then
                    DS.TrnSize = val(RowsArr(0))
                    DS.ValSize = val(RowsArr(1))
                    DS.TstSize = val(RowsArr(2))
                    DS.TotalSize = DS.TrnSize + DS.ValSize + DS.TstSize
                End If
                If DS.TotalSize <= 0 Or DS.TrnSize < 0 Or DS.ValSize < 0 Or DS.TstSize < 0 Then Error 1
                TrnFirst = 0
                TrnLast = TrnFirst + DS.TrnSize
                ValFirst = TrnLast
                ValLast = ValFirst + DS.ValSize
                TstFirst = ValLast
                TstLast = TstFirst + DS.TstSize
                
                '
                ' columns
                '
                ColsArr = SplitTrim(HeadArr(1), " ")
                If (UBound(ColsArr) <> 0) And (UBound(ColsArr) <> 3) Then Error 1
                If UBound(ColsArr) = 0 Then
                    DS.NIn = val(ColsArr(0))
                    If DS.NIn <= 0 Then Error 1
                End If
                If UBound(ColsArr) = 3 Then
                    If (LCase(ColsArr(0)) <> "reg") And (LCase(ColsArr(0)) <> "cls") Then Error 1
                    If ColsArr(2) <> "=>" Then Error 1
                    DS.NIn = val(ColsArr(1))
                    If DS.NIn < 1 Then Error 1
                    If LCase(ColsArr(0)) = "reg" Then
                        DS.NClasses = 0
                        DS.NOut = val(ColsArr(3))
                        If DS.NOut < 1 Then Error 1
                    Else
                        DS.NClasses = val(ColsArr(3))
                        DS.NOut = 1
                        If DS.NClasses < 2 Then Error 1
                    End If
                End If
                
                '
                ' initialize arrays
                '
                ReDim DS.AllDataset(0 To DS.TotalSize - 1, 0 To DS.NIn + DS.NOut - 1)
                If DS.TrnSize > 0 Then ReDim DS.Trn(0 To DS.TrnSize - 1, 0 To DS.NIn + DS.NOut - 1)
                If DS.ValSize > 0 Then ReDim DS.val(0 To DS.ValSize - 1, 0 To DS.NIn + DS.NOut - 1)
                If DS.TstSize > 0 Then ReDim DS.TST(0 To DS.TstSize - 1, 0 To DS.NIn + DS.NOut - 1)
            Else
                '
                ' read data
                '
                VarsArr = SplitTrim(TextLine, " ")
                If UBound(VarsArr) <> DS.NIn + DS.NOut - 1 Then Error 1
                TmpC = Round(VarsArr(DS.NIn + DS.NOut - 1))
                If (DS.NClasses > 0) And ((TmpC < 0) Or (TmpC >= DS.NClasses)) Then Error 1
                RowIndex = LinesRead - 1
                For i = 0 To DS.NIn + DS.NOut - 1 Step 1
                    DS.AllDataset(RowIndex, i) = VarsArr(i)
                    If RowIndex >= TrnFirst And RowIndex < TrnLast Then
                        DS.Trn(RowIndex - TrnFirst, i) = VarsArr(i)
                    End If
                    If RowIndex >= ValFirst And RowIndex < ValLast Then
                        DS.val(RowIndex - ValFirst, i) = VarsArr(i)
                    End If
                    If RowIndex >= TstFirst And RowIndex < TstLast Then
                        DS.TST(RowIndex - TstFirst, i) = VarsArr(i)
                    End If
                Next i
            End If
            LinesRead = LinesRead + 1
        End If
    Loop
    Close FileNumber
    OpenDataset = True
    Exit Function
HandleNoFile:
    OpenDataset = False
    Exit Function
HandleErrorWithinFile:
    Close FileNumber
    OpenDataset = False
    Exit Function
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2009, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This  function  generates  1-dimensional  general  interpolation task with
'moderate Lipshitz constant (close to 1.0)
'
'If N=1 then suborutine generates only one point at the middle of [A,B]
'
'  -- ALGLIB --
'     Copyright 02.12.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub TaskGenInt1D(ByVal A As Double, _
         ByVal B As Double, _
         ByVal N As Long, _
         ByRef X() As Double, _
         ByRef Y() As Double)
    Dim i As Long
    Dim H As Double
    ReDim X(0 To N - 1)
    ReDim Y(0 To N - 1)
    If N > 1# Then
        X(0#) = A
        Y(0#) = 2# * Rnd() - 1#
        H = (B - A) / (N - 1#)
        For i = 1# To N - 1# Step 1
            If i <> N - 1# Then
                X(i) = A + (i + 0.2 * (2# * Rnd() - 1#)) * H
            Else
                X(i) = B
            End If
            Y(i) = Y(i - 1#) + (2# * Rnd() - 1#) * (X(i) - X(i - 1#))
        Next i
    Else
        X(0#) = 0.5 * (A + B)
        Y(0#) = 2# * Rnd() - 1#
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function generates  1-dimensional equidistant interpolation task with
'moderate Lipshitz constant (close to 1.0)
'
'If N=1 then suborutine generates only one point at the middle of [A,B]
'
'  -- ALGLIB --
'     Copyright 02.12.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub TaskGenInt1DEquidist(ByVal A As Double, _
         ByVal B As Double, _
         ByVal N As Long, _
         ByRef X() As Double, _
         ByRef Y() As Double)
    Dim i As Long
    Dim H As Double
    ReDim X(0 To N - 1)
    ReDim Y(0 To N - 1)
    If N > 1# Then
        X(0#) = A
        Y(0#) = 2# * Rnd() - 1#
        H = (B - A) / (N - 1#)
        For i = 1# To N - 1# Step 1
            X(i) = A + i * H
            Y(i) = Y(i - 1#) + (2# * Rnd() - 1#) * H
        Next i
    Else
        X(0#) = 0.5 * (A + B)
        Y(0#) = 2# * Rnd() - 1#
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function generates  1-dimensional Chebyshev-1 interpolation task with
'moderate Lipshitz constant (close to 1.0)
'
'If N=1 then suborutine generates only one point at the middle of [A,B]
'
'  -- ALGLIB --
'     Copyright 02.12.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub TaskGenInt1DCheb1(ByVal A As Double, _
         ByVal B As Double, _
         ByVal N As Long, _
         ByRef X() As Double, _
         ByRef Y() As Double)
    Dim i As Long
    ReDim X(0 To N - 1)
    ReDim Y(0 To N - 1)
    If N > 1# Then
        For i = 0# To N - 1# Step 1
            X(i) = 0.5 * (B + A) + 0.5 * (B - A) * Cos(Pi() * (2# * i + 1#) / (2# * N))
            If i = 0# Then
                Y(i) = 2# * Rnd() - 1#
            Else
                Y(i) = Y(i - 1#) + (2# * Rnd() - 1#) * (X(i) - X(i - 1#))
            End If
        Next i
    Else
        X(0#) = 0.5 * (A + B)
        Y(0#) = 2# * Rnd() - 1#
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function generates  1-dimensional Chebyshev-2 interpolation task with
'moderate Lipshitz constant (close to 1.0)
'
'If N=1 then suborutine generates only one point at the middle of [A,B]
'
'  -- ALGLIB --
'     Copyright 02.12.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub TaskGenInt1DCheb2(ByVal A As Double, _
         ByVal B As Double, _
         ByVal N As Long, _
         ByRef X() As Double, _
         ByRef Y() As Double)
    Dim i As Long
    ReDim X(0 To N - 1)
    ReDim Y(0 To N - 1)
    If N > 1# Then
        For i = 0# To N - 1# Step 1
            X(i) = 0.5 * (B + A) + 0.5 * (B - A) * Cos(Pi() * i / (N - 1#))
            If i = 0# Then
                Y(i) = 2# * Rnd() - 1#
            Else
                Y(i) = Y(i - 1#) + (2# * Rnd() - 1#) * (X(i) - X(i - 1#))
            End If
        Next i
    Else
        X(0#) = 0.5 * (A + B)
        Y(0#) = 2# * Rnd() - 1#
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function checks that all values from X[] are distinct. It does more
'than just usual floating point comparison:
'* first, it calculates max(X) and min(X)
'* second, it maps X[] from [min,max] to [1,2]
'* only at this stage actual comparison is done
'
'The meaning of such check is to ensure that all values are "distinct enough"
'and will not cause interpolation subroutine to fail.
'
'NOTE:
'    X[] must be sorted by ascending (subroutine ASSERT's it)
'
'  -- ALGLIB --
'     Copyright 02.12.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function APSERVAreDistinct(ByRef X_() As Double, _
         ByVal N As Long) As Boolean
    Dim Result As Boolean
    Dim X() As Double
    Dim IsSorted As Boolean
    Dim A As Double
    Dim B As Double
    Dim i As Long
    X = X_
    If N = 1# Then
        '
        ' everything is alright, it is up to caller to decide whether it
        ' can interpolate something with just one point
        '
        Result = True
        APSERVAreDistinct = Result
        Exit Function
    End If
    A = X(0#)
    B = X(0#)
    For i = 1# To N - 1# Step 1
        A = MinReal(A, X(i))
        B = MaxReal(B, X(i))
    Next i
    For i = 0# To N - 1# Step 1
        X(i) = (X(i) - A) / (B - A) + 1#
    Next i
    For i = 1# To N - 1# Step 1
        If X(i) = X(i - 1#) Then
            Result = False
            APSERVAreDistinct = Result
            Exit Function
        End If
    Next i
    Result = True
    APSERVAreDistinct = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Safe sqrt(x^2+y^2)
'
'  -- ALGLIB --
'     Copyright by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function SafePythag2(ByVal X As Double, ByVal Y As Double) As Double
    Dim Result As Double
    Dim w As Double
    Dim XABS As Double
    Dim YABS As Double
    Dim z As Double
    XABS = Abs(X)
    YABS = Abs(Y)
    w = MaxReal(XABS, YABS)
    z = MinReal(XABS, YABS)
    If z = 0# Then
        Result = w
    Else
        Result = w * Sqr(1# + Square(z / w))
    End If
    SafePythag2 = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Safe sqrt(x^2+y^2)
'
'  -- ALGLIB --
'     Copyright by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function SafePythag3(ByVal X As Double, _
         ByVal Y As Double, _
         ByVal z As Double) As Double
    Dim Result As Double
    Dim w As Double
    w = MaxReal(Abs(X), MaxReal(Abs(Y), Abs(z)))
    If w = 0# Then
        Result = 0#
        SafePythag3 = Result
        Exit Function
    End If
    X = X / w
    Y = Y / w
    z = z / w
    Result = w * Sqr(Square(X) + Square(Y) + Square(z))
    SafePythag3 = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function makes periodic mapping of X to [A,B].
'
'It accepts X, A, B (A>B). It returns T which lies in  [A,B] and integer K,
'such that X = T + K*(B-A).
'
'NOTES:
'* K is represented as real value, although actually it is integer
'* T is guaranteed to be in [A,B]
'* T replaces X
'
'  -- ALGLIB --
'     Copyright by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub APPeriodicMap(ByRef X As Double, _
         ByVal A As Double, _
         ByVal B As Double, _
         ByRef K As Double)
    K = Int((X - A) / (B - A))
    X = X - K * (B - A)
    Do While X < A
        X = X + (B - A)
        K = K - 1#
    Loop
    Do While X > B
        X = X - (B - A)
        K = K + 1#
    Loop
    X = MaxReal(X, A)
    X = MinReal(X, B)
End Sub
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'More precise dot-product. Absolute error of  subroutine  result  is  about
'1 ulp of max(MX,V), where:
'    MX = max( |a[i]*b[i]| )
'    V  = |(a,b)|
'
'INPUT PARAMETERS
'    A       -   array[0..N-1], vector 1
'    B       -   array[0..N-1], vector 2
'    N       -   vectors length, N<2^29.
'    Temp    -   array[0..N-1], pre-allocated temporary storage
'
'OUTPUT PARAMETERS
'    R       -   (A,B)
'    RErr    -   estimate of error. This estimate accounts for both  errors
'                during  calculation  of  (A,B)  and  errors  introduced by
'                rounding of A and B to fit in double (about 1 ulp).
'
'  -- ALGLIB --
'     Copyright 24.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub XDot(ByRef A() As Double, _
         ByRef B() As Double, _
         ByVal N As Long, _
         ByRef temp() As Double, _
         ByRef R As Double, _
         ByRef RErr As Double)
    Dim i As Long
    Dim MX As Double
    Dim V As Double
    '
    ' special cases:
    ' * N=0
    '
    If N = 0# Then
        R = 0#
        RErr = 0#
        Exit Sub
    End If
    MX = 0#
    For i = 0# To N - 1# Step 1
        V = A(i) * B(i)
        temp(i) = V
        MX = MaxReal(MX, Abs(V))
    Next i
    If MX = 0# Then
        R = 0#
        RErr = 0#
        Exit Sub
    End If
    Call XSum(temp, MX, N, R, RErr)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'More precise complex dot-product. Absolute error of  subroutine  result is
'about 1 ulp of max(MX,V), where:
'    MX = max( |a[i]*b[i]| )
'    V  = |(a,b)|
'
'INPUT PARAMETERS
'    A       -   array[0..N-1], vector 1
'    B       -   array[0..N-1], vector 2
'    N       -   vectors length, N<2^29.
'    Temp    -   array[0..2*N-1], pre-allocated temporary storage
'
'OUTPUT PARAMETERS
'    R       -   (A,B)
'    RErr    -   estimate of error. This estimate accounts for both  errors
'                during  calculation  of  (A,B)  and  errors  introduced by
'                rounding of A and B to fit in double (about 1 ulp).
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub XCDot(ByRef A() As Complex, _
         ByRef B() As Complex, _
         ByVal N As Long, _
         ByRef temp() As Double, _
         ByRef R As Complex, _
         ByRef RErr As Double)
    Dim i As Long
    Dim MX As Double
    Dim V As Double
    Dim RErrX As Double
    Dim RErrY As Double
    '
    ' special cases:
    ' * N=0
    '
    If N = 0# Then
        R = C_Complex(0#)
        RErr = 0#
        Exit Sub
    End If
    '
    ' calculate real part
    '
    MX = 0#
    For i = 0# To N - 1# Step 1
        V = A(i).X * B(i).X
        temp(2# * i + 0#) = V
        MX = MaxReal(MX, Abs(V))
        V = -(A(i).Y * B(i).Y)
        temp(2# * i + 1#) = V
        MX = MaxReal(MX, Abs(V))
    Next i
    If MX = 0# Then
        R.X = 0#
        RErrX = 0#
    Else
        Call XSum(temp, MX, 2# * N, R.X, RErrX)
    End If
    '
    ' calculate imaginary part
    '
    MX = 0#
    For i = 0# To N - 1# Step 1
        V = A(i).X * B(i).Y
        temp(2# * i + 0#) = V
        MX = MaxReal(MX, Abs(V))
        V = A(i).Y * B(i).X
        temp(2# * i + 1#) = V
        MX = MaxReal(MX, Abs(V))
    Next i
    If MX = 0# Then
        R.Y = 0#
        RErrY = 0#
    Else
        Call XSum(temp, MX, 2# * N, R.Y, RErrY)
    End If
    '
    ' total error
    '
    If RErrX = 0# And RErrY = 0# Then
        RErr = 0#
    Else
        RErr = MaxReal(RErrX, RErrY) * Sqr(1# + Square(MinReal(RErrX, RErrY) / MaxReal(RErrX, RErrY)))
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal subroutine for extra-precise calculation of SUM(w[i]).
'
'INPUT PARAMETERS:
'    W   -   array[0..N-1], values to be added
'            W is modified during calculations.
'    MX  -   max(W[i])
'    N   -   array size
'
'OUTPUT PARAMETERS:
'    R   -   SUM(w[i])
'    RErr-   error estimate for R
'
'  -- ALGLIB --
'     Copyright 24.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub XSum(ByRef w() As Double, _
         ByVal MX As Double, _
         ByVal N As Long, _
         ByRef R As Double, _
         ByRef RErr As Double)
    Dim i As Long
    Dim K As Long
    Dim KS As Long
    Dim V As Double
    Dim S As Double
    Dim LN2 As Double
    Dim Chunk As Double
    Dim InvChunk As Double
    Dim AllZeros As Boolean
    Dim i_ As Long
    '
    ' special cases:
    ' * N=0
    ' * N is too large to use integer arithmetics
    '
    If N = 0# Then
        R = 0#
        RErr = 0#
        Exit Sub
    End If
    If MX = 0# Then
        R = 0#
        RErr = 0#
        Exit Sub
    End If
    '
    ' Prepare
    '
    LN2 = log(2#)
    RErr = MX * MachineEpsilon
    '
    ' 1. find S such that 0.5<=S*MX<1
    ' 2. multiply W by S, so task is normalized in some sense
    ' 3. S:=1/S so we can obtain original vector multiplying by S
    '
    K = Round(log(MX) / LN2)
    S = XFastPow(2#, -K)
    Do While S * MX >= 1#
        S = 0.5 * S
    Loop
    Do While S * MX < 0.5
        S = 2# * S
    Loop
    For i_ = 0# To N - 1# Step 1
        w(i_) = S * w(i_)
    Next i_
    S = 1# / S
    '
    ' find Chunk=2^M such that N*Chunk<2^29
    '
    ' we have chosen upper limit (2^29) with enough space left
    ' to tolerate possible problems with rounding and N's close
    ' to the limit, so we don't want to be very strict here.
    '
    K = Fix(log(536870912# / N) / LN2)
    Chunk = XFastPow(2#, K)
    If Chunk < 2# Then
        Chunk = 2#
    End If
    InvChunk = 1# / Chunk
    '
    ' calculate result
    '
    R = 0#
    For i_ = 0# To N - 1# Step 1
        w(i_) = Chunk * w(i_)
    Next i_
    Do While True
        S = S * InvChunk
        AllZeros = True
        KS = 0#
        For i = 0# To N - 1# Step 1
            V = w(i)
            K = Fix(V)
            If V <> K Then
                AllZeros = False
            End If
            w(i) = Chunk * (V - K)
            KS = KS + K
        Next i
        R = R + S * KS
        V = Abs(R)
        If AllZeros Or S * N + MX = MX Then
            Exit Do
        End If
    Loop
    '
    ' correct error
    '
    RErr = MaxReal(RErr, Abs(R) * MachineEpsilon)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Fast Pow
'
'  -- ALGLIB --
'     Copyright 24.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Function XFastPow(ByVal R As Double, ByVal N As Long) As Double
    Dim Result As Double
    If N > 0# Then
        If N Mod 2# = 0# Then
            Result = Square(XFastPow(R, N \ 2#))
        Else
            Result = R * XFastPow(R, N - 1#)
        End If
        XFastPow = Result
        Exit Function
    End If
    If N = 0# Then
        Result = 1#
    End If
    If N < 0# Then
        Result = XFastPow(1# / R, -N)
    End If
    XFastPow = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright 2008 by Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
Public Sub TagSort(ByRef A() As Double, _
         ByVal N As Long, _
         ByRef P1() As Long, _
         ByRef P2() As Long)
    Dim i As Long
    Dim PV() As Long
    Dim VP() As Long
    Dim LV As Long
    Dim LP As Long
    Dim RV As Long
    Dim RP As Long
    '
    ' Special cases
    '
    If N <= 0# Then
        Exit Sub
    End If
    If N = 1# Then
        ReDim P1(0# To 0#)
        ReDim P2(0# To 0#)
        P1(0#) = 0#
        P2(0#) = 0#
        Exit Sub
    End If
    '
    ' General case, N>1: prepare permutations table P1
    '
    ReDim P1(0# To N - 1#)
    For i = 0# To N - 1# Step 1
        P1(i) = i
    Next i
    '
    ' General case, N>1: sort, update P1
    '
    Call TagSortFastI(A, P1, N)
    '
    ' General case, N>1: fill permutations table P2
    '
    ' To fill P2 we maintain two arrays:
    ' * PV, Position(Value). PV[i] contains position of I-th key at the moment
    ' * VP, Value(Position). VP[i] contains key which has position I at the moment
    '
    ' At each step we making permutation of two items:
    '   Left, which is given by position/value pair LP/LV
    '   and Right, which is given by RP/RV
    ' and updating PV[] and VP[] correspondingly.
    '
    ReDim PV(0# To N - 1#)
    ReDim VP(0# To N - 1#)
    ReDim P2(0# To N - 1#)
    For i = 0# To N - 1# Step 1
        PV(i) = i
        VP(i) = i
    Next i
    For i = 0# To N - 1# Step 1
        '
        ' calculate LP, LV, RP, RV
        '
        LP = i
        LV = VP(LP)
        RV = P1(i)
        RP = PV(RV)
        '
        ' Fill P2
        '
        P2(i) = RP
        '
        ' update PV and VP
        '
        VP(LP) = RV
        VP(RP) = LV
        PV(LV) = RP
        PV(RV) = LP
    Next i
End Sub
Public Sub TagSortFastI(ByRef A() As Double, _
         ByRef B() As Long, _
         ByVal N As Long)
    Dim i As Long
    Dim K As Long
    Dim T As Long
    Dim Tmp As Double
    Dim TmpI As Long
    '
    ' Special cases
    '
    If N <= 1# Then
        Exit Sub
    End If
    '
    ' General case, N>1: sort, update B
    '
    i = 2#
    Do
        T = i
        Do While T <> 1#
            K = T \ 2#
            If A(K - 1#) >= A(T - 1#) Then
                T = 1#
            Else
                Tmp = A(K - 1#)
                A(K - 1#) = A(T - 1#)
                A(T - 1#) = Tmp
                TmpI = B(K - 1#)
                B(K - 1#) = B(T - 1#)
                B(T - 1#) = TmpI
                T = K
            End If
        Loop
        i = i + 1#
    Loop Until Not i <= N
    i = N - 1#
    Do
        Tmp = A(i)
        A(i) = A(0#)
        A(0#) = Tmp
        TmpI = B(i)
        B(i) = B(0#)
        B(0#) = TmpI
        T = 1#
        Do While T <> 0#
            K = 2# * T
            If K > i Then
                T = 0#
            Else
                If K < i Then
                    If A(K) > A(K - 1#) Then
                        K = K + 1#
                    End If
                End If
                If A(T - 1#) >= A(K - 1#) Then
                    T = 0#
                Else
                    Tmp = A(K - 1#)
                    A(K - 1#) = A(T - 1#)
                    A(T - 1#) = Tmp
                    TmpI = B(K - 1#)
                    B(K - 1#) = B(T - 1#)
                    B(T - 1#) = TmpI
                    T = K
                End If
            End If
        Loop
        i = i - 1#
    Loop Until Not i >= 1#
End Sub
Public Sub TagSortFastR(ByRef A() As Double, _
         ByRef B() As Double, _
         ByVal N As Long)
    Dim i As Long
    Dim K As Long
    Dim T As Long
    Dim Tmp As Double
    Dim TmpR As Double
    '
    ' Special cases
    '
    If N <= 1# Then
        Exit Sub
    End If
    '
    ' General case, N>1: sort, update B
    '
    i = 2#
    Do
        T = i
        Do While T <> 1#
            K = T \ 2#
            If A(K - 1#) >= A(T - 1#) Then
                T = 1#
            Else
                Tmp = A(K - 1#)
                A(K - 1#) = A(T - 1#)
                A(T - 1#) = Tmp
                TmpR = B(K - 1#)
                B(K - 1#) = B(T - 1#)
                B(T - 1#) = TmpR
                T = K
            End If
        Loop
        i = i + 1#
    Loop Until Not i <= N
    i = N - 1#
    Do
        Tmp = A(i)
        A(i) = A(0#)
        A(0#) = Tmp
        TmpR = B(i)
        B(i) = B(0#)
        B(0#) = TmpR
        T = 1#
        Do While T <> 0#
            K = 2# * T
            If K > i Then
                T = 0#
            Else
                If K < i Then
                    If A(K) > A(K - 1#) Then
                        K = K + 1#
                    End If
                End If
                If A(T - 1#) >= A(K - 1#) Then
                    T = 0#
                Else
                    Tmp = A(K - 1#)
                    A(K - 1#) = A(T - 1#)
                    A(T - 1#) = Tmp
                    TmpR = B(K - 1#)
                    B(K - 1#) = B(T - 1#)
                    B(T - 1#) = TmpR
                    T = K
                End If
            End If
        Loop
        i = i - 1#
    Loop Until Not i >= 1#
End Sub
Public Sub TagSortFast(ByRef A() As Double, ByVal N As Long)
    Dim i As Long
    Dim K As Long
    Dim T As Long
    Dim Tmp As Double
    '
    ' Special cases
    '
    If N <= 1# Then
        Exit Sub
    End If
    '
    ' General case, N>1: sort, update B
    '
    i = 2#
    Do
        T = i
        Do While T <> 1#
            K = T \ 2#
            If A(K - 1#) >= A(T - 1#) Then
                T = 1#
            Else
                Tmp = A(K - 1#)
                A(K - 1#) = A(T - 1#)
                A(T - 1#) = Tmp
                T = K
            End If
        Loop
        i = i + 1#
    Loop Until Not i <= N
    i = N - 1#
    Do
        Tmp = A(i)
        A(i) = A(0#)
        A(0#) = Tmp
        T = 1#
        Do While T <> 0#
            K = 2# * T
            If K > i Then
                T = 0#
            Else
                If K < i Then
                    If A(K) > A(K - 1#) Then
                        K = K + 1#
                    End If
                End If
                If A(T - 1#) >= A(K - 1#) Then
                    T = 0#
                Else
                    Tmp = A(K - 1#)
                    A(K - 1#) = A(T - 1#)
                    A(T - 1#) = Tmp
                    T = K
                End If
            End If
        Loop
        i = i - 1#
    Loop Until Not i >= 1#
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Heap operations: adds element to the heap
'
'PARAMETERS:
'    A       -   heap itself, must be at least array[0..N]
'    B       -   array of integer tags, which are updated according to
'                permutations in the heap
'    N       -   size of the heap (without new element).
'                updated on output
'    VA      -   value of the element being added
'    VB      -   value of the tag
'
'  -- ALGLIB --
'     Copyright 28.02.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub TagHeapPushI(ByRef A() As Double, _
         ByRef B() As Long, _
         ByRef N As Long, _
         ByVal VA As Double, _
         ByVal VB As Long)
    Dim j As Long
    Dim K As Long
    Dim V As Double
    If N < 0# Then
        Exit Sub
    End If
    '
    ' N=0 is a special case
    '
    If N = 0# Then
        A(0#) = VA
        B(0#) = VB
        N = N + 1#
        Exit Sub
    End If
    '
    ' add current point to the heap
    ' (add to the bottom, then move up)
    '
    ' we don't write point to the heap
    ' until its final position is determined
    ' (it allow us to reduce number of array access operations)
    '
    j = N
    N = N + 1#
    Do While j > 0#
        K = (j - 1#) \ 2#
        V = A(K)
        If V < VA Then
            '
            ' swap with higher element
            '
            A(j) = V
            B(j) = B(K)
            j = K
        Else
            '
            ' element in its place. terminate.
            '
            Exit Do
        End If
    Loop
    A(j) = VA
    B(j) = VB
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Heap operations: replaces top element with new element
'(which is moved down)
'
'PARAMETERS:
'    A       -   heap itself, must be at least array[0..N-1]
'    B       -   array of integer tags, which are updated according to
'                permutations in the heap
'    N       -   size of the heap
'    VA      -   value of the element which replaces top element
'    VB      -   value of the tag
'
'  -- ALGLIB --
'     Copyright 28.02.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub TagHeapReplaceTopI(ByRef A() As Double, _
         ByRef B() As Long, _
         ByVal N As Long, _
         ByVal VA As Double, _
         ByVal VB As Long)
    Dim j As Long
    Dim K1 As Long
    Dim K2 As Long
    Dim V As Double
    Dim V1 As Double
    Dim V2 As Double
    If N < 1# Then
        Exit Sub
    End If
    '
    ' N=1 is a special case
    '
    If N = 1# Then
        A(0#) = VA
        B(0#) = VB
        Exit Sub
    End If
    '
    ' move down through heap:
    ' * J  -   current element
    ' * K1 -   first child (always exists)
    ' * K2 -   second child (may not exists)
    '
    ' we don't write point to the heap
    ' until its final position is determined
    ' (it allow us to reduce number of array access operations)
    '
    j = 0#
    K1 = 1#
    K2 = 2#
    Do While K1 < N
        If K2 >= N Then
            '
            ' only one child.
            '
            ' swap and terminate (because this child
            ' have no siblings due to heap structure)
            '
            V = A(K1)
            If V > VA Then
                A(j) = V
                B(j) = B(K1)
                j = K1
            End If
            Exit Do
        Else
            '
            ' two childs
            '
            V1 = A(K1)
            V2 = A(K2)
            If V1 > V2 Then
                If VA < V1 Then
                    A(j) = V1
                    B(j) = B(K1)
                    j = K1
                Else
                    Exit Do
                End If
            Else
                If VA < V2 Then
                    A(j) = V2
                    B(j) = B(K2)
                    j = K2
                Else
                    Exit Do
                End If
            End If
            K1 = 2# * j + 1#
            K2 = 2# * j + 2#
        End If
    Loop
    A(j) = VA
    B(j) = VB
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Heap operations: pops top element from the heap
'
'PARAMETERS:
'    A       -   heap itself, must be at least array[0..N-1]
'    B       -   array of integer tags, which are updated according to
'                permutations in the heap
'    N       -   size of the heap, N>=1
'
'On output top element is moved to A[N-1], B[N-1], heap is reordered, N is
'decreased by 1.
'
'  -- ALGLIB --
'     Copyright 28.02.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub TagHeapPopI(ByRef A() As Double, ByRef B() As Long, ByRef N As Long)
    Dim VA As Double
    Dim VB As Long
    If N < 1# Then
        Exit Sub
    End If
    '
    ' N=1 is a special case
    '
    If N = 1# Then
        N = 0#
        Exit Sub
    End If
    '
    ' swap top element and last element,
    ' then reorder heap
    '
    VA = A(N - 1#)
    VB = B(N - 1#)
    A(N - 1#) = A(0#)
    B(N - 1#) = B(0#)
    N = N - 1#
    Call TagHeapReplaceTopI(A, B, N, VA, VB)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2007, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Calculation of the distribution moments: mean, variance, slewness, kurtosis.
'
'Input parameters:
'    X       -   sample. Array with whose indexes range within [0..N-1]
'    N       -   sample size.
'
'Output parameters:
'    Mean    -   mean.
'    Variance-   variance.
'    Skewness-   skewness (if variance<>0; zero otherwise).
'    Kurtosis-   kurtosis (if variance<>0; zero otherwise).
'
'  -- ALGLIB --
'     Copyright 06.09.2006 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CalculateMoments(ByRef X() As Double, _
         ByVal N As Long, _
         ByRef Mean As Double, _
         ByRef Variance As Double, _
         ByRef Skewness As Double, _
         ByRef Kurtosis As Double)
    Dim i As Long
    Dim V As Double
    Dim V1 As Double
    Dim V2 As Double
    Dim StdDev As Double
    Mean = 0#
    Variance = 0#
    Skewness = 0#
    Kurtosis = 0#
    StdDev = 0#
    If N <= 0# Then
        Exit Sub
    End If
    '
    ' Mean
    '
    For i = 0# To N - 1# Step 1
        Mean = Mean + X(i)
    Next i
    Mean = Mean / N
    '
    ' Variance (using corrected two-pass algorithm)
    '
    If N <> 1# Then
        V1 = 0#
        For i = 0# To N - 1# Step 1
            V1 = V1 + Square(X(i) - Mean)
        Next i
        V2 = 0#
        For i = 0# To N - 1# Step 1
            V2 = V2 + (X(i) - Mean)
        Next i
        V2 = Square(V2) / N
        Variance = (V1 - V2) / (N - 1#)
        If Variance < 0# Then
            Variance = 0#
        End If
        StdDev = Sqr(Variance)
    End If
    '
    ' Skewness and kurtosis
    '
    If StdDev <> 0# Then
        For i = 0# To N - 1# Step 1
            V = (X(i) - Mean) / StdDev
            V2 = Square(V)
            Skewness = Skewness + V2 * V
            Kurtosis = Kurtosis + Square(V2)
        Next i
        Skewness = Skewness / N
        Kurtosis = Kurtosis / N - 3#
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'ADev
'
'Input parameters:
'    X   -   sample (array indexes: [0..N-1])
'    N   -   sample size
'
'Output parameters:
'    ADev-   ADev
'
'  -- ALGLIB --
'     Copyright 06.09.2006 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CalculateADev(ByRef X() As Double, _
         ByVal N As Long, _
         ByRef ADev As Double)
    Dim i As Long
    Dim Mean As Double
    Mean = 0#
    ADev = 0#
    If N <= 0# Then
        Exit Sub
    End If
    '
    ' Mean
    '
    For i = 0# To N - 1# Step 1
        Mean = Mean + X(i)
    Next i
    Mean = Mean / N
    '
    ' ADev
    '
    For i = 0# To N - 1# Step 1
        ADev = ADev + Abs(X(i) - Mean)
    Next i
    ADev = ADev / N
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Median calculation.
'
'Input parameters:
'    X   -   sample (array indexes: [0..N-1])
'    N   -   sample size
'
'Output parameters:
'    Median
'
'  -- ALGLIB --
'     Copyright 06.09.2006 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CalculateMedian(ByRef X_() As Double, _
         ByVal N As Long, _
         ByRef Median As Double)
    Dim X() As Double
    Dim i As Long
    Dim ir As Long
    Dim j As Long
    Dim L As Long
    Dim midp As Long
    Dim K As Long
    Dim A As Double
    Dim tval As Double
    X = X_
    '
    ' Some degenerate cases
    '
    Median = 0#
    If N <= 0# Then
        Exit Sub
    End If
    If N = 1# Then
        Median = X(0#)
        Exit Sub
    End If
    If N = 2# Then
        Median = 0.5 * (X(0#) + X(1#))
        Exit Sub
    End If
    '
    ' Common case, N>=3.
    ' Choose X[(N-1)/2]
    '
    L = 0#
    ir = N - 1#
    K = (N - 1#) \ 2#
    Do While True
        If ir <= L + 1# Then
            '
            ' 1 or 2 elements in partition
            '
            If ir = L + 1# And X(ir) < X(L) Then
                tval = X(L)
                X(L) = X(ir)
                X(ir) = tval
            End If
            Exit Do
        Else
            midp = (L + ir) \ 2#
            tval = X(midp)
            X(midp) = X(L + 1#)
            X(L + 1#) = tval
            If X(L) > X(ir) Then
                tval = X(L)
                X(L) = X(ir)
                X(ir) = tval
            End If
            If X(L + 1#) > X(ir) Then
                tval = X(L + 1#)
                X(L + 1#) = X(ir)
                X(ir) = tval
            End If
            If X(L) > X(L + 1#) Then
                tval = X(L)
                X(L) = X(L + 1#)
                X(L + 1#) = tval
            End If
            i = L + 1#
            j = ir
            A = X(L + 1#)
            Do While True
                Do
                    i = i + 1#
                Loop Until X(i) >= A
                Do
                    j = j - 1#
                Loop Until X(j) <= A
                If j < i Then
                    Exit Do
                End If
                tval = X(i)
                X(i) = X(j)
                X(j) = tval
            Loop
            X(L + 1#) = X(j)
            X(j) = A
            If j >= K Then
                ir = j - 1#
            End If
            If j <= K Then
                L = i
            End If
        End If
    Loop
    '
    ' If N is odd, return result
    '
    If N Mod 2# = 1# Then
        Median = X(K)
        Exit Sub
    End If
    A = X(N - 1#)
    For i = K + 1# To N - 1# Step 1
        If X(i) < A Then
            A = X(i)
        End If
    Next i
    Median = 0.5 * (X(K) + A)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Percentile calculation.
'
'Input parameters:
'    X   -   sample (array indexes: [0..N-1])
'    N   -   sample size, N>1
'    P   -   percentile (0<=P<=1)
'
'Output parameters:
'    V   -   percentile
'
'  -- ALGLIB --
'     Copyright 01.03.2008 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CalculatePercentile(ByRef X_() As Double, _
         ByVal N As Long, _
         ByVal p As Double, _
         ByRef V As Double)
    Dim X() As Double
    Dim I1 As Long
    Dim T As Double
    X = X_
    Call InternalStatHeapSort(X, N)
    If p = 0# Then
        V = X(0#)
        Exit Sub
    End If
    If p = 1# Then
        V = X(N - 1#)
        Exit Sub
    End If
    T = p * (N - 1#)
    I1 = Int(T)
    T = T - Int(T)
    V = X(I1) * (1# - T) + X(I1 + 1#) * T
End Sub
Private Sub InternalStatHeapSort(ByRef arr() As Double, ByVal N As Long)
    Dim i As Long
    Dim K As Long
    Dim T As Long
    Dim Tmp As Double
    If N = 1# Then
        Exit Sub
    End If
    i = 2#
    Do
        T = i
        Do While T <> 1#
            K = T \ 2#
            If arr(K - 1#) >= arr(T - 1#) Then
                T = 1#
            Else
                Tmp = arr(K - 1#)
                arr(K - 1#) = arr(T - 1#)
                arr(T - 1#) = Tmp
                T = K
            End If
        Loop
        i = i + 1#
    Loop Until Not i <= N
    i = N - 1#
    Do
        Tmp = arr(i)
        arr(i) = arr(0#)
        arr(0#) = Tmp
        T = 1#
        Do While T <> 0#
            K = 2# * T
            If K > i Then
                T = 0#
            Else
                If K < i Then
                    If arr(K) > arr(K - 1#) Then
                        K = K + 1#
                    End If
                End If
                If arr(T - 1#) >= arr(K - 1#) Then
                    T = 0#
                Else
                    Tmp = arr(K - 1#)
                    arr(K - 1#) = arr(T - 1#)
                    arr(T - 1#) = Tmp
                    T = K
                End If
            End If
        Loop
        i = i - 1#
    Loop Until Not i >= 1#
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 1992-2007 The University of Tennessee.  All rights reserved.
'
'Contributors:
'    * Sergey Bochkanov (ALGLIB project). Translation from FORTRAN to
'      pseudocode.
'
'See subroutines comments for additional copyrights.
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Generation of an elementary reflection transformation
'
'The subroutine generates elementary reflection H of order N, so that, for
'a given X, the following equality holds true:
'
'    ( X(1) )   ( Beta )
'H * (  ..  ) = (  0   )
'    ( X(n) )   (  0   )
'
'where
'              ( V(1) )
'H = 1 - Tau * (  ..  ) * ( V(1), ..., V(n) )
'              ( V(n) )
'
'where the first component of vector V equals 1.
'
'Input parameters:
'    X   -   vector. Array whose index ranges within [1..N].
'    N   -   reflection order.
'
'Output parameters:
'    X   -   components from 2 to N are replaced with vector V.
'            The first component is replaced with parameter Beta.
'    Tau -   scalar value Tau. If X is a null vector, Tau equals 0,
'            otherwise 1 <= Tau <= 2.
'
'This subroutine is the modification of the DLARFG subroutines from
'the LAPACK library.
'
'MODIFICATIONS:
'    24.12.2005 sign(Alpha) was replaced with an analogous to the Fortran SIGN code.
'
'  -- LAPACK auxiliary routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     September 30, 1994
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub GenerateReflection(ByRef X() As Double, _
         ByVal N As Long, _
         ByRef Tau As Double)
    Dim j As Long
    Dim alpha As Double
    Dim XNorm As Double
    Dim V As Double
    Dim beta As Double
    Dim MX As Double
    Dim S As Double
    Dim i_ As Long
    If N <= 1# Then
        Tau = 0#
        Exit Sub
    End If
    
    '
    ' Scale if needed (to avoid overflow/underflow during intermediate
    ' calculations).
    '
    MX = 0#
    For j = 1# To N Step 1
        MX = MaxReal(Abs(X(j)), MX)
    Next j
    S = 1#
    If MX <> 0# Then
        If MX <= MinRealNumber / MachineEpsilon Then
            S = MinRealNumber / MachineEpsilon
            V = 1# / S
            For i_ = 1# To N Step 1
                X(i_) = V * X(i_)
            Next i_
            MX = MX * V
        Else
            If MX >= MaxRealNumber * MachineEpsilon Then
                S = MaxRealNumber * MachineEpsilon
                V = 1# / S
                For i_ = 1# To N Step 1
                    X(i_) = V * X(i_)
                Next i_
                MX = MX * V
            End If
        End If
    End If
    
    '
    ' XNORM = DNRM2( N-1, X, INCX )
    '
    alpha = X(1#)
    XNorm = 0#
    If MX <> 0# Then
        For j = 2# To N Step 1
            XNorm = XNorm + Square(X(j) / MX)
        Next j
        XNorm = Sqr(XNorm) * MX
    End If
    If XNorm = 0# Then
        
        '
        ' H  =  I
        '
        Tau = 0#
        X(1#) = X(1#) * S
        Exit Sub
    End If
    
    '
    ' general case
    '
    MX = MaxReal(Abs(alpha), Abs(XNorm))
    beta = -(MX * Sqr(Square(alpha / MX) + Square(XNorm / MX)))
    If alpha < 0# Then
        beta = -beta
    End If
    Tau = (beta - alpha) / beta
    V = 1# / (alpha - beta)
    For i_ = 2# To N Step 1
        X(i_) = V * X(i_)
    Next i_
    X(1#) = beta
    
    '
    ' Scale back outputs
    '
    X(1#) = X(1#) * S
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Application of an elementary reflection to a rectangular matrix of size MxN
'
'The algorithm pre-multiplies the matrix by an elementary reflection transformation
'which is given by column V and scalar Tau (see the description of the
'GenerateReflection procedure). Not the whole matrix but only a part of it
'is transformed (rows from M1 to M2, columns from N1 to N2). Only the elements
'of this submatrix are changed.
'
'Input parameters:
'    C       -   matrix to be transformed.
'    Tau     -   scalar defining the transformation.
'    V       -   column defining the transformation.
'                Array whose index ranges within [1..M2-M1+1].
'    M1, M2  -   range of rows to be transformed.
'    N1, N2  -   range of columns to be transformed.
'    WORK    -   working array whose indexes goes from N1 to N2.
'
'Output parameters:
'    C       -   the result of multiplying the input matrix C by the
'                transformation matrix which is given by Tau and V.
'                If N1>N2 or M1>M2, C is not modified.
'
'  -- LAPACK auxiliary routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     September 30, 1994
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub ApplyReflectionFromTheLeft(ByRef c() As Double, _
         ByVal Tau As Double, _
         ByRef V() As Double, _
         ByVal M1 As Long, _
         ByVal M2 As Long, _
         ByVal N1 As Long, _
         ByVal N2 As Long, _
         ByRef WORK() As Double)
    Dim T As Double
    Dim i As Long
    Dim VM As Long
    Dim i_ As Long
    If Tau = 0# Or N1 > N2 Or M1 > M2 Then
        Exit Sub
    End If
    
    '
    ' w := C' * v
    '
    VM = M2 - M1 + 1#
    For i = N1 To N2 Step 1
        WORK(i) = 0#
    Next i
    For i = M1 To M2 Step 1
        T = V(i + 1# - M1)
        For i_ = N1 To N2 Step 1
            WORK(i_) = WORK(i_) + T * c(i, i_)
        Next i_
    Next i
    
    '
    ' C := C - tau * v * w'
    '
    For i = M1 To M2 Step 1
        T = V(i - M1 + 1#) * Tau
        For i_ = N1 To N2 Step 1
            c(i, i_) = c(i, i_) - T * WORK(i_)
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Application of an elementary reflection to a rectangular matrix of size MxN
'
'The algorithm post-multiplies the matrix by an elementary reflection transformation
'which is given by column V and scalar Tau (see the description of the
'GenerateReflection procedure). Not the whole matrix but only a part of it
'is transformed (rows from M1 to M2, columns from N1 to N2). Only the
'elements of this submatrix are changed.
'
'Input parameters:
'    C       -   matrix to be transformed.
'    Tau     -   scalar defining the transformation.
'    V       -   column defining the transformation.
'                Array whose index ranges within [1..N2-N1+1].
'    M1, M2  -   range of rows to be transformed.
'    N1, N2  -   range of columns to be transformed.
'    WORK    -   working array whose indexes goes from M1 to M2.
'
'Output parameters:
'    C       -   the result of multiplying the input matrix C by the
'                transformation matrix which is given by Tau and V.
'                If N1>N2 or M1>M2, C is not modified.
'
'  -- LAPACK auxiliary routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     September 30, 1994
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub ApplyReflectionFromTheRight(ByRef c() As Double, _
         ByVal Tau As Double, _
         ByRef V() As Double, _
         ByVal M1 As Long, _
         ByVal M2 As Long, _
         ByVal N1 As Long, _
         ByVal N2 As Long, _
         ByRef WORK() As Double)
    Dim T As Double
    Dim i As Long
    Dim VM As Long
    Dim i_ As Long
    Dim i1_ As Long
    If Tau = 0# Or N1 > N2 Or M1 > M2 Then
        Exit Sub
    End If
    VM = N2 - N1 + 1#
    For i = M1 To M2 Step 1
        i1_ = (1#) - (N1)
        T = 0#
        For i_ = N1 To N2 Step 1
            T = T + c(i, i_) * V(i_ + i1_)
        Next i_
        T = T * Tau
        i1_ = (1#) - (N1)
        For i_ = N1 To N2 Step 1
            c(i, i_) = c(i, i_) - T * V(i_ + i1_)
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 1992-2007 The University of Tennessee.  All rights reserved.
'
'Contributors:
'    * Sergey Bochkanov (ALGLIB project). Translation from FORTRAN to
'      pseudocode.
'
'See subroutines comments for additional copyrights.
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Application of a sequence of  elementary rotations to a matrix
'
'The algorithm pre-multiplies the matrix by a sequence of rotation
'transformations which is given by arrays C and S. Depending on the value
'of the IsForward parameter either 1 and 2, 3 and 4 and so on (if IsForward=true)
'rows are rotated, or the rows N and N-1, N-2 and N-3 and so on, are rotated.
'
'Not the whole matrix but only a part of it is transformed (rows from M1 to
'M2, columns from N1 to N2). Only the elements of this submatrix are changed.
'
'Input parameters:
'    IsForward   -   the sequence of the rotation application.
'    M1,M2       -   the range of rows to be transformed.
'    N1, N2      -   the range of columns to be transformed.
'    C,S         -   transformation coefficients.
'                    Array whose index ranges within [1..M2-M1].
'    A           -   processed matrix.
'    WORK        -   working array whose index ranges within [N1..N2].
'
'Output parameters:
'    A           -   transformed matrix.
'
'Utility subroutine.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub ApplyRotationsFromTheLeft(ByVal IsForward As Boolean, _
         ByVal M1 As Long, _
         ByVal M2 As Long, _
         ByVal N1 As Long, _
         ByVal N2 As Long, _
         ByRef c() As Double, _
         ByRef S() As Double, _
         ByRef A() As Double, _
         ByRef WORK() As Double)
    Dim j As Long
    Dim JP1 As Long
    Dim CTEMP As Double
    Dim STEMP As Double
    Dim temp As Double
    Dim i_ As Long
    If M1 > M2 Or N1 > N2 Then
        Exit Sub
    End If
    
    '
    ' Form  P * A
    '
    If IsForward Then
        If N1 <> N2 Then
            
            '
            ' Common case: N1<>N2
            '
            For j = M1 To M2 - 1# Step 1
                CTEMP = c(j - M1 + 1#)
                STEMP = S(j - M1 + 1#)
                If CTEMP <> 1# Or STEMP <> 0# Then
                    JP1 = j + 1#
                    For i_ = N1 To N2 Step 1
                        WORK(i_) = CTEMP * A(JP1, i_)
                    Next i_
                    For i_ = N1 To N2 Step 1
                        WORK(i_) = WORK(i_) - STEMP * A(j, i_)
                    Next i_
                    For i_ = N1 To N2 Step 1
                        A(j, i_) = CTEMP * A(j, i_)
                    Next i_
                    For i_ = N1 To N2 Step 1
                        A(j, i_) = A(j, i_) + STEMP * A(JP1, i_)
                    Next i_
                    For i_ = N1 To N2 Step 1
                        A(JP1, i_) = WORK(i_)
                    Next i_
                End If
            Next j
        Else
            
            '
            ' Special case: N1=N2
            '
            For j = M1 To M2 - 1# Step 1
                CTEMP = c(j - M1 + 1#)
                STEMP = S(j - M1 + 1#)
                If CTEMP <> 1# Or STEMP <> 0# Then
                    temp = A(j + 1#, N1)
                    A(j + 1#, N1) = CTEMP * temp - STEMP * A(j, N1)
                    A(j, N1) = STEMP * temp + CTEMP * A(j, N1)
                End If
            Next j
        End If
    Else
        If N1 <> N2 Then
            
            '
            ' Common case: N1<>N2
            '
            For j = M2 - 1# To M1 Step -1
                CTEMP = c(j - M1 + 1#)
                STEMP = S(j - M1 + 1#)
                If CTEMP <> 1# Or STEMP <> 0# Then
                    JP1 = j + 1#
                    For i_ = N1 To N2 Step 1
                        WORK(i_) = CTEMP * A(JP1, i_)
                    Next i_
                    For i_ = N1 To N2 Step 1
                        WORK(i_) = WORK(i_) - STEMP * A(j, i_)
                    Next i_
                    For i_ = N1 To N2 Step 1
                        A(j, i_) = CTEMP * A(j, i_)
                    Next i_
                    For i_ = N1 To N2 Step 1
                        A(j, i_) = A(j, i_) + STEMP * A(JP1, i_)
                    Next i_
                    For i_ = N1 To N2 Step 1
                        A(JP1, i_) = WORK(i_)
                    Next i_
                End If
            Next j
        Else
            
            '
            ' Special case: N1=N2
            '
            For j = M2 - 1# To M1 Step -1
                CTEMP = c(j - M1 + 1#)
                STEMP = S(j - M1 + 1#)
                If CTEMP <> 1# Or STEMP <> 0# Then
                    temp = A(j + 1#, N1)
                    A(j + 1#, N1) = CTEMP * temp - STEMP * A(j, N1)
                    A(j, N1) = STEMP * temp + CTEMP * A(j, N1)
                End If
            Next j
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Application of a sequence of  elementary rotations to a matrix
'
'The algorithm post-multiplies the matrix by a sequence of rotation
'transformations which is given by arrays C and S. Depending on the value
'of the IsForward parameter either 1 and 2, 3 and 4 and so on (if IsForward=true)
'rows are rotated, or the rows N and N-1, N-2 and N-3 and so on are rotated.
'
'Not the whole matrix but only a part of it is transformed (rows from M1
'to M2, columns from N1 to N2). Only the elements of this submatrix are changed.
'
'Input parameters:
'    IsForward   -   the sequence of the rotation application.
'    M1,M2       -   the range of rows to be transformed.
'    N1, N2      -   the range of columns to be transformed.
'    C,S         -   transformation coefficients.
'                    Array whose index ranges within [1..N2-N1].
'    A           -   processed matrix.
'    WORK        -   working array whose index ranges within [M1..M2].
'
'Output parameters:
'    A           -   transformed matrix.
'
'Utility subroutine.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub ApplyRotationsFromTheRight(ByVal IsForward As Boolean, _
         ByVal M1 As Long, _
         ByVal M2 As Long, _
         ByVal N1 As Long, _
         ByVal N2 As Long, _
         ByRef c() As Double, _
         ByRef S() As Double, _
         ByRef A() As Double, _
         ByRef WORK() As Double)
    Dim j As Long
    Dim JP1 As Long
    Dim CTEMP As Double
    Dim STEMP As Double
    Dim temp As Double
    Dim i_ As Long
    
    '
    ' Form A * P'
    '
    If IsForward Then
        If M1 <> M2 Then
            
            '
            ' Common case: M1<>M2
            '
            For j = N1 To N2 - 1# Step 1
                CTEMP = c(j - N1 + 1#)
                STEMP = S(j - N1 + 1#)
                If CTEMP <> 1# Or STEMP <> 0# Then
                    JP1 = j + 1#
                    For i_ = M1 To M2 Step 1
                        WORK(i_) = CTEMP * A(i_, JP1)
                    Next i_
                    For i_ = M1 To M2 Step 1
                        WORK(i_) = WORK(i_) - STEMP * A(i_, j)
                    Next i_
                    For i_ = M1 To M2 Step 1
                        A(i_, j) = CTEMP * A(i_, j)
                    Next i_
                    For i_ = M1 To M2 Step 1
                        A(i_, j) = A(i_, j) + STEMP * A(i_, JP1)
                    Next i_
                    For i_ = M1 To M2 Step 1
                        A(i_, JP1) = WORK(i_)
                    Next i_
                End If
            Next j
        Else
            
            '
            ' Special case: M1=M2
            '
            For j = N1 To N2 - 1# Step 1
                CTEMP = c(j - N1 + 1#)
                STEMP = S(j - N1 + 1#)
                If CTEMP <> 1# Or STEMP <> 0# Then
                    temp = A(M1, j + 1#)
                    A(M1, j + 1#) = CTEMP * temp - STEMP * A(M1, j)
                    A(M1, j) = STEMP * temp + CTEMP * A(M1, j)
                End If
            Next j
        End If
    Else
        If M1 <> M2 Then
            
            '
            ' Common case: M1<>M2
            '
            For j = N2 - 1# To N1 Step -1
                CTEMP = c(j - N1 + 1#)
                STEMP = S(j - N1 + 1#)
                If CTEMP <> 1# Or STEMP <> 0# Then
                    JP1 = j + 1#
                    For i_ = M1 To M2 Step 1
                        WORK(i_) = CTEMP * A(i_, JP1)
                    Next i_
                    For i_ = M1 To M2 Step 1
                        WORK(i_) = WORK(i_) - STEMP * A(i_, j)
                    Next i_
                    For i_ = M1 To M2 Step 1
                        A(i_, j) = CTEMP * A(i_, j)
                    Next i_
                    For i_ = M1 To M2 Step 1
                        A(i_, j) = A(i_, j) + STEMP * A(i_, JP1)
                    Next i_
                    For i_ = M1 To M2 Step 1
                        A(i_, JP1) = WORK(i_)
                    Next i_
                End If
            Next j
        Else
            
            '
            ' Special case: M1=M2
            '
            For j = N2 - 1# To N1 Step -1
                CTEMP = c(j - N1 + 1#)
                STEMP = S(j - N1 + 1#)
                If CTEMP <> 1# Or STEMP <> 0# Then
                    temp = A(M1, j + 1#)
                    A(M1, j + 1#) = CTEMP * temp - STEMP * A(M1, j)
                    A(M1, j) = STEMP * temp + CTEMP * A(M1, j)
                End If
            Next j
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'The subroutine generates the elementary rotation, so that:
'
'[  CS  SN  ]  .  [ F ]  =  [ R ]
'[ -SN  CS  ]     [ G ]     [ 0 ]
'
'CS**2 + SN**2 = 1
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub GenerateRotation(ByVal F As Double, _
         ByVal G As Double, _
         ByRef CS As Double, _
         ByRef SN As Double, _
         ByRef R As Double)
    Dim F1 As Double
    Dim G1 As Double
    If G = 0# Then
        CS = 1#
        SN = 0#
        R = F
    Else
        If F = 0# Then
            CS = 0#
            SN = 1#
            R = G
        Else
            F1 = F
            G1 = G
            If Abs(F1) > Abs(G1) Then
                R = Abs(F1) * Sqr(1# + Square(G1 / F1))
            Else
                R = Abs(G1) * Sqr(1# + Square(F1 / G1))
            End If
            CS = F1 / R
            SN = G1 / R
            If Abs(F) > Abs(G) And CS < 0# Then
                CS = -CS
                SN = -SN
                R = -R
            End If
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 1992-2007 The University of Tennessee.  All rights reserved.
'
'Contributors:
'    * Sergey Bochkanov (ALGLIB project). Translation from FORTRAN to
'      pseudocode.
'
'See subroutines comments for additional copyrights.
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Generation of an elementary complex reflection transformation
'
'The subroutine generates elementary complex reflection H of  order  N,  so
'that, for a given X, the following equality holds true:
'
'     ( X(1) )   ( Beta )
'H' * (  ..  ) = (  0   ),   H'*H = I,   Beta is a real number
'     ( X(n) )   (  0   )
'
'where
'
'              ( V(1) )
'H = 1 - Tau * (  ..  ) * ( conj(V(1)), ..., conj(V(n)) )
'              ( V(n) )
'
'where the first component of vector V equals 1.
'
'Input parameters:
'    X   -   vector. Array with elements [1..N].
'    N   -   reflection order.
'
'Output parameters:
'    X   -   components from 2 to N are replaced by vector V.
'            The first component is replaced with parameter Beta.
'    Tau -   scalar value Tau.
'
'This subroutine is the modification of CLARFG subroutines  from the LAPACK
'library. It has similar functionality except for the fact that it  doesnt
'handle errors when intermediate results cause an overflow.
'
'  -- LAPACK auxiliary routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     September 30, 1994
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub ComplexGenerateReflection(ByRef X() As Complex, _
         ByVal N As Long, _
         ByRef Tau As Complex)
    Dim j As Long
    Dim alpha As Complex
    Dim ALPHI As Double
    Dim ALPHR As Double
    Dim beta As Double
    Dim XNorm As Double
    Dim MX As Double
    Dim T As Complex
    Dim S As Double
    Dim V As Complex
    Dim i_ As Long
    If N <= 0# Then
        Tau = C_Complex(0#)
        Exit Sub
    End If
    '
    ' Scale if needed (to avoid overflow/underflow during intermediate
    ' calculations).
    '
    MX = 0#
    For j = 1# To N Step 1
        MX = MaxReal(AbsComplex(X(j)), MX)
    Next j
    S = 1#
    If MX <> 0# Then
        If MX < 1# Then
            S = Sqr(MinRealNumber)
            V = C_Complex(1# / S)
            For i_ = 1# To N Step 1
                X(i_) = C_Mul(V, X(i_))
            Next i_
        Else
            S = Sqr(MaxRealNumber)
            V = C_Complex(1# / S)
            For i_ = 1# To N Step 1
                X(i_) = C_Mul(V, X(i_))
            Next i_
        End If
    End If
    '
    ' calculate
    '
    alpha = X(1#)
    MX = 0#
    For j = 2# To N Step 1
        MX = MaxReal(AbsComplex(X(j)), MX)
    Next j
    XNorm = 0#
    If MX <> 0# Then
        For j = 2# To N Step 1
            T = C_DivR(X(j), MX)
            XNorm = XNorm + C_Mul(T, Conj(T)).X
        Next j
        XNorm = Sqr(XNorm) * MX
    End If
    ALPHR = alpha.X
    ALPHI = alpha.Y
    If XNorm = 0# And ALPHI = 0# Then
        Tau = C_Complex(0#)
        X(1#) = C_MulR(X(1#), S)
        Exit Sub
    End If
    MX = MaxReal(Abs(ALPHR), Abs(ALPHI))
    MX = MaxReal(MX, Abs(XNorm))
    beta = -(MX * Sqr(Square(ALPHR / MX) + Square(ALPHI / MX) + Square(XNorm / MX)))
    If ALPHR < 0# Then
        beta = -beta
    End If
    Tau.X = (beta - ALPHR) / beta
    Tau.Y = -(ALPHI / beta)
    alpha = C_RDiv(1#, C_SubR(alpha, beta))
    If N > 1# Then
        For i_ = 2# To N Step 1
            X(i_) = C_Mul(alpha, X(i_))
        Next i_
    End If
    alpha = C_Complex(beta)
    X(1#) = alpha
    '
    ' Scale back
    '
    X(1#) = C_MulR(X(1#), S)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Application of an elementary reflection to a rectangular matrix of size MxN
'
'The  algorithm  pre-multiplies  the  matrix  by  an  elementary reflection
'transformation  which  is  given  by  column  V  and  scalar  Tau (see the
'description of the GenerateReflection). Not the whole matrix  but  only  a
'part of it is transformed (rows from M1 to M2, columns from N1 to N2). Only
'the elements of this submatrix are changed.
'
'Note: the matrix is multiplied by H, not by H'.   If  it  is  required  to
'multiply the matrix by H', it is necessary to pass Conj(Tau) instead of Tau.
'
'Input parameters:
'    C       -   matrix to be transformed.
'    Tau     -   scalar defining transformation.
'    V       -   column defining transformation.
'                Array whose index ranges within [1..M2-M1+1]
'    M1, M2  -   range of rows to be transformed.
'    N1, N2  -   range of columns to be transformed.
'    WORK    -   working array whose index goes from N1 to N2.
'
'Output parameters:
'    C       -   the result of multiplying the input matrix C by the
'                transformation matrix which is given by Tau and V.
'                If N1>N2 or M1>M2, C is not modified.
'
'  -- LAPACK auxiliary routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     September 30, 1994
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub ComplexApplyReflectionFromTheLeft(ByRef c() As Complex, _
         ByRef Tau_ As Complex, _
         ByRef V() As Complex, _
         ByVal M1 As Long, _
         ByVal M2 As Long, _
         ByVal N1 As Long, _
         ByVal N2 As Long, _
         ByRef WORK() As Complex)
    Dim Tau As Complex
    Dim T As Complex
    Dim i As Long
    Dim VM As Long
    Dim i_ As Long
    Tau = Tau_
    If C_EqualR(Tau, 0#) Or N1 > N2 Or M1 > M2 Then
        Exit Sub
    End If
    '
    ' w := C^T * conj(v)
    '
    VM = M2 - M1 + 1#
    For i = N1 To N2 Step 1
        WORK(i) = C_Complex(0#)
    Next i
    For i = M1 To M2 Step 1
        T = Conj(V(i + 1# - M1))
        For i_ = N1 To N2 Step 1
            WORK(i_) = C_Add(WORK(i_), C_Mul(T, c(i, i_)))
        Next i_
    Next i
    '
    ' C := C - tau * v * w^T
    '
    For i = M1 To M2 Step 1
        T = C_Mul(V(i - M1 + 1#), Tau)
        For i_ = N1 To N2 Step 1
            c(i, i_) = C_Sub(c(i, i_), C_Mul(T, WORK(i_)))
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Application of an elementary reflection to a rectangular matrix of size MxN
'
'The  algorithm  post-multiplies  the  matrix  by  an elementary reflection
'transformation  which  is  given  by  column  V  and  scalar  Tau (see the
'description  of  the  GenerateReflection). Not the whole matrix but only a
'part  of  it  is  transformed (rows from M1 to M2, columns from N1 to N2).
'Only the elements of this submatrix are changed.
'
'Input parameters:
'    C       -   matrix to be transformed.
'    Tau     -   scalar defining transformation.
'    V       -   column defining transformation.
'                Array whose index ranges within [1..N2-N1+1]
'    M1, M2  -   range of rows to be transformed.
'    N1, N2  -   range of columns to be transformed.
'    WORK    -   working array whose index goes from M1 to M2.
'
'Output parameters:
'    C       -   the result of multiplying the input matrix C by the
'                transformation matrix which is given by Tau and V.
'                If N1>N2 or M1>M2, C is not modified.
'
'  -- LAPACK auxiliary routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     September 30, 1994
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub ComplexApplyReflectionFromTheRight(ByRef c() As Complex, _
         ByRef Tau_ As Complex, _
         ByRef V() As Complex, _
         ByVal M1 As Long, _
         ByVal M2 As Long, _
         ByVal N1 As Long, _
         ByVal N2 As Long, _
         ByRef WORK() As Complex)
    Dim Tau As Complex
    Dim T As Complex
    Dim i As Long
    Dim VM As Long
    Dim i_ As Long
    Dim i1_ As Long
    Tau = Tau_
    If C_EqualR(Tau, 0#) Or N1 > N2 Or M1 > M2 Then
        Exit Sub
    End If
    '
    ' w := C * v
    '
    VM = N2 - N1 + 1#
    For i = M1 To M2 Step 1
        i1_ = (1#) - (N1)
        T = C_Complex(0#)
        For i_ = N1 To N2 Step 1
            T = C_Add(T, C_Mul(c(i, i_), V(i_ + i1_)))
        Next i_
        WORK(i) = T
    Next i
    '
    ' C := C - w * conj(v^T)
    '
    For i_ = 1# To VM Step 1
        V(i_) = Conj(V(i_))
    Next i_
    For i = M1 To M2 Step 1
        T = C_Mul(WORK(i), Tau)
        i1_ = (1#) - (N1)
        For i_ = N1 To N2 Step 1
            c(i, i_) = C_Sub(c(i, i_), C_Mul(T, V(i_ + i1_)))
        Next i_
    Next i
    For i_ = 1# To VM Step 1
        V(i_) = Conj(V(i_))
    Next i_
End Sub

