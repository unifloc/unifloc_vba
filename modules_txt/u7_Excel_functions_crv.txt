'=======================================================================================
'Unifloc 7.38 aspo                               khabibullinra@gmail.com
'Petroleum engineering calculations modules (macroses)
'2000 - 2022
'
'=======================================================================================
' функции для работы с кривыми из интерфейса Excel
Option Explicit
Option Base 1
'description_to_manual      - для автогенерации
' функция поиска значения функции по заданным табличным данным (интерполяция)
Public Function crv_interpolation(x_points, y_points, x_val, _
                        Optional ByVal type_interpolation As Integer = 0)
' x_points  - таблица аргументов функции (или json строка - вектор)
' y_points  - таблица значений функции (или json строка - вектор)
'             количество агрументов и значений должно совпадать.
'             для табличной функции одному аргументу соответствует
'             строго одно значение функции (последнее)
' x_val     - аргумент для которого надо найти значение
'             одно значение в ячейке или диапазон значений
'             для диапазона аргументов будет найден диапазон значений
'             диапазоны могут быть заданы как в строках,
'             так и в столбцах
' type_interpolation - тип интерполяции
'             0 - линейная интерполяция
'             1 - кубическая интерполяция
'             2 - интерполяция Акима (выбросы)
'                 https://en.wikipedia.org/wiki/Akima_spline
'             3 - кубический сплайн Катмулла Рома
'                 https://en.wikipedia.org/wiki/Cubic_Hermite_spline
' результат
'             значение функции для заданного x_val
'description_end
    Dim x_arr(), y_arr(), x_val_arr(), y_out()
    Dim y_val_temp
    Dim i As Integer
    Dim crv As New CInterpolation
    Dim interp_type As String
On Error GoTo err1:
    ' прочитаем все исходные вектора с листа и подготовим выходной массив
    Call read_xy_vectors(x_points, y_points, x_val, x_arr, y_arr, x_val_arr, y_out)
    ' формируем объект функции для работы с ним
    For i = 1 To UBound(x_arr)
        crv.AddPoint x_arr(i), y_arr(i)
    Next i
    ' готовим интерполяцию
    Select Case type_interpolation
        Case 0
            interp_type = "Linear"
        Case 1
            interp_type = "Cubic"
        Case 2
            interp_type = "Akima"
        Case 3
            interp_type = "CatmullRom"
    End Select
    crv.init_interpolation interp_type
    ' интерполируем требуемые данные и готовим для вывода массива значений
    For i = LBound(x_val_arr) To UBound(x_val_arr)
        y_val_temp = crv.get_interpolation_point(x_val_arr(i))
        If UBound(y_out, 1) > 1 Then
            y_out(i, LBound(y_out)) = y_val_temp
        Else
            y_out(LBound(y_out), i) = y_val_temp
        End If
    Next i
    crv_interpolation = y_out
    Exit Function
err1:
    crv_interpolation = "Error:crv_interpolation:" & Err.Description
End Function
'description_to_manual      - для автогенерации
' функция поиска значения функции по двумерным табличным данным (интерполяция 2D)
Function crv_interpolation_2D(XA As Variant, _
                              YA As Variant, _
                              fa As Variant, _
                     Optional XYIA As Variant, _
                     Optional out As Long = 1, _
                     Optional ByVal type_interpolation As Integer = 0) As Variant
' XA    - x значения исходных данных (строка значений или массив)
' YA    - y значения исходных данных (столбец значений или массив)
' FA    - табличные значения интерполируемой функции,
'         двумерная таблица или массив
' XYIA  - таблица значений для которой надо найти результат
'         два столбца значений (x,y) или массив с двумя колонками
'         если не заданы возвращаются кубические коэффициента
'         для каждого сегмента
' out   - для интерполяции кубическими сплайнами
'           out = 0 возвращаются только значения
'           out = 1 возвращаются значения и производные
' type_interpolation - тип интерполяции
'                    0 - линейная интерполяция
'                    1 - кубическая интерполяция
' результат
'             значение функции для заданного XYIA
'description_end
On Error GoTo err1:
    Select Case type_interpolation
        Case 0
            crv_interpolation_2D = crv_lin_spline_2D(XA, YA, fa, XYIA)
        Case 1
            crv_interpolation_2D = crv_cubic_spline_2D(XA, YA, fa, XYIA, out)
    End Select
    Exit Function
err1:
    crv_interpolation_2D = "Error:crv_interpolation_2D:" & Err.Description
End Function
'description_to_manual      - для автогенерации
' функция решения уравнения в табличном виде f(x) = y_val
' ищется значение аргумента соответствующее заданному значению
' используется линейная интерполяция
' возможно несколько решений
Public Function crv_solve(x_points, y_points, ByVal y_val As Double)
' x_points  - таблица аргументов функции
' y_points  - таблица значений функции
'             количество агрументов и значений функции должно совпадать
'             для табличной функции одному аргументу соответствует
'             строго одно значение функции (последнее)
' y_val     - значение функции для которого надо ищутся аргументы
'             строго одно вещественное число (ссылка на ячейку)
' результат
'             массив значений аргументов - решений уравнения
'description_end
    Dim x_arr(), y_arr(), y_val_arr(), x_out()
    Dim n_y_val As Integer
    Dim i As Integer
    Dim crv As New CInterpolation
On Error GoTo err1:
    ' прочитаем все исходные вектора с листа и подготовим выходной массив
    Call read_xy_vectors(x_points, y_points, 0, x_arr, y_arr, y_val_arr, x_out)
    ' формируем объект функции для работы с ним
    For i = 1 To UBound(x_arr)
        crv.AddPoint x_arr(i), y_arr(i)
    Next i
    ' только для первого элемента ищем
    n_y_val = crv.FindSolutions(y_val)
    ReDim x_out(1 To n_y_val)
    For i = 1 To n_y_val
        x_out(i) = crv.SolutionPointX(i)
    Next i
    crv_solve = x_out
    Exit Function
err1:
    crv_solve = "Error:crv_solve:" & Err.Description
End Function
'description_to_manual      - для автогенерации
'Поиск пересечений для кривых заданных таблицами.
'Используется линейная интерполяция.
'Возможно несколько решений.
Public Function crv_intersection(x1_points, y1_points, _
                                 x2_points, y2_points)
' x1_points  - таблица аргументов функции 1
' y1_points  - таблица значений функции 1
'             количество агрументов и значений функции должно совпадать
'             для табличной функции одному аргументу соответствует
'             строго одно значение функции (последнее)
' x2_points  - таблица аргументов функции 2
' y2_points  - таблица значений функции 2
'             количество агрументов и значений функции должно совпадать
'             для табличной функции одному аргументу соответствует
'             строго одно значение функции (последнее)
' результат
'             массив значений аргументов пересечений двух функций
'description_end
    Dim x1_arr(), y1_arr(), y_val_arr(), x_out()
    Dim x2_arr(), y2_arr()
    Dim n_y_val As Integer
    Dim i As Integer
    Dim crv1 As New CInterpolation
    Dim crv2 As New CInterpolation
    Dim crv As CInterpolation
    Dim count_vert As Integer
    Dim eps As Double
    Dim new_x1_arr As Double
On Error GoTo err1:
    count_vert = 0
    eps = 0.001
    ' прочитаем все исходные вектора с листа и подготовим выходной массив
    Call read_xy_vectors(x1_points, y1_points, 0, x1_arr, y1_arr, y_val_arr, x_out)
    ' формируем объект функции для работы с ним
    For i = 1 To UBound(x1_arr)
        new_x1_arr = x1_arr(i)
        If i > 1 Then
            If Abs(x1_arr(i) - x1_arr(i - 1)) < eps Then
                count_vert = count_vert + 1
                new_x1_arr = x1_arr(i - 1) + eps * count_vert
            End If
        End If
        crv1.AddPoint new_x1_arr, y1_arr(i)
    Next i
    ' прочитаем все исходные вектора с листа и подготовим выходной массив
    Call read_xy_vectors(x2_points, y2_points, 0, x2_arr, y2_arr, y_val_arr, x_out)
    ' формируем объект функции для работы с ним
    For i = 1 To UBound(x2_arr)
        crv2.AddPoint x2_arr(i), y2_arr(i)
    Next i
    crv_intersection = intersection(crv1, crv2)
    Exit Function
err1:
    crv_intersection = "Error:crv_intersection:" & Err.Description
End Function
Public Function intersection(ByVal crv1 As CInterpolation, ByVal crv2 As CInterpolation)
    Dim crv As CInterpolation
    Dim n_y_val As Integer
    Dim x_out() As Double
    Dim i As Integer
    
    Set crv = crv1.SubtractCurve(crv2)
    n_y_val = crv.FindSolutions(0)
    ReDim x_out(1 To n_y_val)
    For i = 1 To n_y_val
        x_out(i) = crv.SolutionPointX(i)
    Next i
    intersection = x_out
End Function
'description_to_manual      - для автогенерации
'Поиск пересечений для кривых заданных таблицами.
'Используется линейная интерполяция.
'Возможно несколько решений.
Public Function crv_fit_spline_1D(XA As Variant, _
                            YA As Variant, _
                            M As Long, _
                   Optional XIA As Variant, _
                   Optional WA As Variant, _
                   Optional XCA As Variant, _
                   Optional YCA As Variant, _
                   Optional DCA As Variant, _
                   Optional hermite As Boolean = False)
' XA    - x значения исходных данных (строка значений или массив)
' YA    - y значения исходных данных (столбец значений или массив)
' М     - количество точек для сплайна интерполяции
'         должно быть четное для hermite = True
' XIA   - таблица выходных значений
'         столбц значений (x) или массив в возрастающем порядке
'  если не заданы возвращаются кубические коэффициента для сегментов
' WA    - веса исходных данных
' XCA   - х значения матрицы ограничений (столбец или массив)
' YCA   - величина ограничения для заданного значения
'         (столбец или массив)
' DCA   - тип ограничения. 0 - значение, 1 - наклон.
'         (столбец или массив).
'         если хоть одно из ограничений не задано - они не учитываются
' результат
'          значение функции для заданного XIA
'description_end
On Error GoTo err1:
    If Not hermite Then
        If IsMissing(XCA) Or IsMissing(YCA) Or IsMissing(DCA) Or IsMissing(WA) Then
            crv_fit_spline_1D = CSplineFit1DA(XA, YA, M, XIA)
        Else
            crv_fit_spline_1D = CSplineFitCW1DA(XA, YA, WA, M, XIA, XCA, YCA, DCA)
        End If
    Else
        crv_fit_spline_1D = HSplineFit1DA(XA, YA, M, XIA)
    End If
Exit Function
err1:
    crv_fit_spline_1D = "Error:crv_fit_spline_1D:" & Err.Description
End Function
'description_to_manual      - для автогенерации
'Аппроксимация данных линейной функцией.
'Решается задача min|XM-Y| ищется вектор M
Public Function crv_fit_linear(YA, _
                           XA, _
                   Optional out As Long, _
                   Optional weight, _
                   Optional cnstraints)
' YA    - Y вектор исходных данных [0..N-1] (столбец или массив)
' XA    - x матрица исходных данных [0..N-1, 0..D-1]
'        (таблица или массив)
' out   - тип вывода,
'      out=0 (по умолчанию) коэффициенты аппроксимации [0..D-1],
'      out=1 код ошибки подбора аппроксимации
'      out=2 отчет по подбору аппроксимации,
'          AvgError, AvgRelError, MaxError, RMSError, TaskRCond.
' weight - вектор весов [0..N-1] для каждого параметра
' cnstraints - матрица ограничений С [0..K-1, 0..D] такая что
'               C[I,0]*M[0] + ... + C[I,D-1]*C[D-1] = CMatrix[I,D]
' результат
'          вектор M минимизирующий min|XM-Y|
'description_end
On Error GoTo err1:
    If IsMissing(weight) Or IsMissing(cnstraints) Then
        crv_fit_linear = AL_Linest(YA, XA, out)
    Else
        crv_fit_linear = AL_LinestCW(YA, XA, out, weight, cnstraints)
    End If
Exit Function
err1:
    crv_fit_linear = "Error:crv_fit_linear:" & Err.Description
End Function
'description_to_manual      - для автогенерации
'Аппроксимация данных полиномом функцией.
'Решается задача min|XM-Y| ищется вектор M
Public Function crv_fit_poly(YA As Variant, _
                           XA As Variant, _
                           M As Long, _
                   Optional out As Long, _
                   Optional XIA As Variant, _
                   Optional weight, _
                   Optional cnstraints)
' YA    - Y вектор исходных данных [0..N-1] (столбец или массив)
' XA    - Х вектор исходных данных [0..N-1] (таблица или массив)
' M     - степень полинома для аппроксимации
' out   - тип вывода, out=0 (по умолчанию) значения полинома для XIA,
'      out=1 код ошибки аппроксимации
'      out=2 отчет по подбору аппроксимации,
'            AvgError, AvgRelError, MaxError, RMSError, TaskRCond.
' XIA   - Х вектор значений для расчета аппроксимации [0..D-1]
' weight   - вектор весов [0..N-1] для каждого параметра
' cnstraints - матрица ограничений С[0..K-1,0..2].
'       С[i,0] - значение x где задано ограничение
'       С[i,1] - велична ограничения,
'       С[i,2] - тип ограничения (0 -значение,1 -производная)
' результат
'          вектор YIA значений полинома для XIA
'description_end
On Error GoTo err1:
    If IsMissing(weight) And IsMissing(cnstraints) Then
        crv_fit_poly = AL_FitPoly(YA, XA, M, out, XIA)
    Else
        crv_fit_poly = AL_FitPolyCW(YA, XA, M, out, XIA, weight, cnstraints)
    End If
Exit Function
err1:
    crv_fit_poly = "Error:crv_fit_poly:" & Err.Description
End Function
' рабочая функция для чтения данных кривых из range
Private Sub read_xy_vectors(x_points, y_points, x_val, _
                                ByRef x_arr(), _
                                ByRef y_arr(), _
                                ByRef x_val_arr(), _
                                ByRef y_val_arr())
On Error GoTo err1:
    Call convert_to_array(x_points, x_arr)
    Call convert_to_array(y_points, y_arr)
    Call convert_to_array(x_val, x_val_arr)
    ReDim y_val_arr(1 To UBound(x_val_arr), 1)
    Exit Sub
err1:
    ' унифицированная реакция на ошибочный ввод ключевых параметров класса
Dim msg As String
Dim fname As String
    fname = "read_xy_vectors"
    msg = fname & ": " & msg
    add_log_msg msg
    Err.Raise kreadRangeError, fname, msg
End Sub
'description_to_manual      - для автогенерации
' интерполяция функции заданной параметрически
' параметр номер значения
Public Function crv_parametric_interpolation(x_points, y_points, x_val, _
                        Optional ByVal type_interpolation As Integer = 0, _
                        Optional param_points = -1)
' x_points  - таблица аргументов функции
' y_points  - таблица значений функции
'             количество агрументов и значений функции должно совпадать
'             для табличной функции одному аргументу соответствует
'             строго одно значение функции (последнее)
' x_val     - аргумент для которого надо найти значение
'             одно значение в ячейке или диапазон значений
'             для диапазона аргументов будет найден диапазон значений
'             диапазоны могут быть заданы как в строках,
'             так и в столбцах
' type_interpolation - тип интерполяции
'             0 - линейная интерполяция
'             1 - кубическая интерполяция
'             2 - интерполяция Акима (выбросы)
'                 https://en.wikipedia.org/wiki/Akima_spline
'             3 - кубический сплайн Катмулла Рома
'                 https://en.wikipedia.org/wiki/Cubic_Hermite_spline
' результат
'             значение функции для заданного x_val
'description_end
    Dim x_arr(), y_arr(), x_val_arr(), y_val_arr()
    Dim x_val_temp
    Dim y_val_temp
    Dim i As Integer
    Dim crv_x As New CInterpolation
    Dim crv_y As New CInterpolation
    Dim interp_type As String
    
On Error GoTo err1:
        
    ' прочитаем все исходные вектора с листа и подготовим выходной массив
    Call read_xy_vectors(x_points, y_points, x_val, x_arr, y_arr, x_val_arr, y_val_arr)
    ' формируем объекты двух кривых для параметрического задания функции
    For i = 1 To UBound(x_arr)
        crv_x.AddPoint i, x_arr(i) ', y_arr(i)
        crv_y.AddPoint i, y_arr(i)
    Next i
    
    ' готовим интерполяцию
    Select Case type_interpolation
        Case 0
            interp_type = "Linear"
        Case 1
            interp_type = "Cubic"
        Case 2
            interp_type = "Akima"
        Case 3
            interp_type = "CatmullRom"
    End Select
           
    crv_x.init_interpolation interp_type
    crv_y.init_interpolation interp_type
    
    ' интерполируем требуемые данные и готовим для вывода массива значений
    For i = LBound(x_val_arr) To UBound(x_val_arr)
        x_val_temp = crv_x.get_interpolation_point(x_val_arr(i))
        y_val_temp = crv_y.get_interpolation_point(x_val_arr(i))
        If UBound(y_val_arr, 1) > 1 Then
            y_val_arr(i, LBound(y_val_arr)) = y_val_temp
        Else
            y_val_arr(LBound(y_val_arr), i) = y_val_temp
        End If
    Next i
    crv_parametric_interpolation = y_val_arr
    Exit Function
err1:
    crv_parametric_interpolation = "Error:crv_interpolation:" & Err.Description
End Function
' =========================================================================================
' далее функции с использованием alglib на основе наработок с сайта https://newtonexcelbach.com/
' =========================================================================================
Private Function crv_lin_spline_2D(XA As Variant, _
                           YA As Variant, _
                           fa As Variant, _
                  Optional XYIA As Variant) As Variant
                  
    Dim LinResA() As Double, NumXcols As Long, NumYRows As Long, NumXYIrows As Long, i As Long, j As Long
    Dim XAD() As Double, YAD() As Double, FAD() As Double, Rtn As Variant, Tbl() As Double, NumCells As Long
    Dim C1 As Spline2DInterpolant
    If IsMissing(XYIA) = True Then
        Rtn = Get2DSplineData(XA, YA, fa, XAD, YAD, FAD, NumXcols, NumYRows)
    Else
        Rtn = Get2DSplineData(XA, YA, fa, XAD, YAD, FAD, NumXcols, NumYRows, XYIA, NumXYIrows)
    End If
    If Rtn <> 0 Then
        crv_lin_spline_2D = Rtn
        Exit Function
    End If
    Spline2DBuildBilinear XAD, YAD, FAD, NumYRows, NumXcols, C1
    If IsMissing(XYIA) = True Then
        NumCells = (NumXcols - 1) * (NumYRows - 1)
        ReDim LinResA(1 To NumCells, 1 To 8)
        Spline2DUnpack C1, NumYRows, NumXcols, Tbl
        For i = 1 To NumCells
            For j = 1 To 6
                LinResA(i, j) = Tbl(i - 1, j - 1)
            Next j
            For j = 7 To 8
                LinResA(i, j) = Tbl(i - 1, j + 1)
            Next j
        Next i
    Else
        ReDim LinResA(1 To NumXYIrows, 1 To 1)
        For i = 1 To NumXYIrows
            LinResA(i, 1) = Spline2DCalc(C1, XYIA(i, 1), XYIA(i, 2))
        Next i
    End If
    crv_lin_spline_2D = LinResA
End Function
Private Function crv_cubic_spline_2D(XA As Variant, _
                             YA As Variant, _
                             fa As Variant, _
                    Optional XYIA As Variant, _
                    Optional out As Long = 1) As Variant
                    
' Out index: 1 = Y values, 2 = Y values and derivatives
    Dim CubResA() As Double, NumXcols As Long, NumYRows As Long, NumXYIrows As Long, i As Long, j As Long
    Dim XAD() As Double, YAD() As Double, FAD() As Double, Rtn As Variant, Tbl() As Double, NumCells As Long
    Dim C1 As Spline2DInterpolant, f As Double, FX As Double, FY As Double, FXY As Double
    If IsMissing(XYIA) = True Then
        Rtn = Get2DSplineData(XA, YA, fa, XAD, YAD, FAD, NumXcols, NumYRows)
    Else
        Rtn = Get2DSplineData(XA, YA, fa, XAD, YAD, FAD, NumXcols, NumYRows, XYIA, NumXYIrows)
    End If
    If Rtn <> 0 Then
        crv_cubic_spline_2D = Rtn
        Exit Function
    End If
    Spline2DBuildBicubic XAD, YAD, FAD, NumYRows, NumXcols, C1
    If IsMissing(XYIA) = True Then
        NumCells = (NumXcols - 1) * (NumYRows - 1)
        ReDim CubResA(1 To NumCells, 1 To 20)
        Spline2DUnpack C1, NumXcols, NumYRows, Tbl
        For i = 1 To NumCells
            For j = 1 To 20
                CubResA(i, j) = Tbl(i - 1, j - 1)
            Next j
        Next i
    Else
        If out = 1 Then
            ReDim CubResA(1 To NumXYIrows, 1 To 1)
            For i = 1 To NumXYIrows
                CubResA(i, 1) = Spline2DCalc(C1, XYIA(i, 1), XYIA(i, 2))
            Next i
        Else
            ReDim CubResA(1 To NumXYIrows, 1 To 4)
            For i = 1 To NumXYIrows
                Call Spline2DDiff(C1, XYIA(i, 1), XYIA(i, 2), f, FX, FY, FXY)
                CubResA(i, 1) = f
                CubResA(i, 2) = FX
                CubResA(i, 3) = FY
                CubResA(i, 4) = FXY
            Next i
        End If
    End If
    crv_cubic_spline_2D = CubResA
End Function
Private Function Get2DSplineData(XA As Variant, YA As Variant, fa As Variant, XAD() As Double, YAD() As Double, FAD() As Double, _
                         NumXcols As Long, NumYRows As Long, Optional XYIA As Variant, Optional NumXYIrows As Long) As Variant
    Dim NumFRows As Long, NumFCols As Long, i As Long, j As Long
    If TypeName(XA) = "Range" Then XA = XA.Value2
    If TypeName(YA) = "Range" Then YA = YA.Value2
    If TypeName(fa) = "Range" Then fa = fa.Value2
    If IsMissing(XYIA) = False Then
        If TypeName(XYIA) = "Range" Then XYIA = XYIA.Value2
        NumXYIrows = UBound(XYIA)
    End If
    NumXcols = UBound(XA, 2)
    NumYRows = UBound(YA)
    NumFRows = UBound(fa)
    NumFCols = UBound(fa, 2)
    If NumXcols <> NumFCols Or NumYRows <> NumFRows Then
        Get2DSplineData = ("There must be one function value for each X,Y value")
        Exit Function
    End If
    ReDim XAD(0 To NumXcols - 1)
    ReDim YAD(0 To NumYRows - 1)
    ReDim FAD(0 To NumYRows - 1, 0 To NumXcols - 1)
    For i = 1 To NumXcols
        XAD(i - 1) = XA(1, i)
    Next i
    For i = 1 To NumYRows
        YAD(i - 1) = YA(i, 1)
    Next i
    For i = 1 To NumYRows
        For j = 1 To NumXcols
            FAD(i - 1, j - 1) = fa(i, j)
        Next j
    Next i
End Function
' ======================================
'
'
' ======================================

