''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2009-2010, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Data types
Public Type MatInvReport
    R1 As Double
    RInf As Double
End Type
'Data types
Public Type DenseSolverReport
    R1 As Double
    RInf As Double
End Type
Public Type DenseSolverLSReport
    R2 As Double
    CX() As Double
    N As Long
    K As Long
End Type
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Splits matrix length in two parts, left part should match ABLAS block size
'
'INPUT PARAMETERS
'    A   -   real matrix, is passed to ensure that we didn't split
'            complex matrix using real splitting subroutine.
'            matrix itself is not changed.
'    N   -   length, N>0
'
'OUTPUT PARAMETERS
'    N1  -   length
'    N2  -   length
'
'N1+N2=N, N1>=N2, N2 may be zero
'
'  -- ALGLIB routine --
'     15.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub ABLASSplitLength(ByRef A() As Double, _
         ByVal N As Long, _
         ByRef N1 As Long, _
         ByRef N2 As Long)
    If N > ABLASBlockSize(A) Then
        Call ABLASInternalSplitLength(N, ABLASBlockSize(A), N1, N2)
    Else
        Call ABLASInternalSplitLength(N, ABLASMicroBlockSize(), N1, N2)
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Complex ABLASSplitLength
'
'  -- ALGLIB routine --
'     15.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub ABLASComplexSplitLength(ByRef A() As Complex, _
         ByVal N As Long, _
         ByRef N1 As Long, _
         ByRef N2 As Long)
    If N > ABLASComplexBlockSize(A) Then
        Call ABLASInternalSplitLength(N, ABLASComplexBlockSize(A), N1, N2)
    Else
        Call ABLASInternalSplitLength(N, ABLASMicroBlockSize(), N1, N2)
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Returns block size - subdivision size where  cache-oblivious  soubroutines
'switch to the optimized kernel.
'
'INPUT PARAMETERS
'    A   -   real matrix, is passed to ensure that we didn't split
'            complex matrix using real splitting subroutine.
'            matrix itself is not changed.
'
'  -- ALGLIB routine --
'     15.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function ABLASBlockSize(ByRef A() As Double) As Long
    Dim Result As Long
    Result = 32#
    ABLASBlockSize = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Block size for complex subroutines.
'
'  -- ALGLIB routine --
'     15.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function ABLASComplexBlockSize(ByRef A() As Complex) As Long
    Dim Result As Long
    Result = 24#
    ABLASComplexBlockSize = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Microblock size
'
'  -- ALGLIB routine --
'     15.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function ABLASMicroBlockSize() As Long
    Dim Result As Long
    Result = 8#
    ABLASMicroBlockSize = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Cache-oblivous complex "copy-and-transpose"
'
'Input parameters:
'    M   -   number of rows
'    N   -   number of columns
'    A   -   source matrix, MxN submatrix is copied and transposed
'    IA  -   submatrix offset (row index)
'    JA  -   submatrix offset (column index)
'    A   -   destination matrix
'    IB  -   submatrix offset (row index)
'    JB  -   submatrix offset (column index)
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixTranspose(ByVal M As Long, _
         ByVal N As Long, _
         ByRef A() As Complex, _
         ByVal IA As Long, _
         ByVal JA As Long, _
         ByRef B() As Complex, _
         ByVal IB As Long, _
         ByVal JB As Long)
    Dim i As Long
    Dim S1 As Long
    Dim S2 As Long
    Dim i_ As Long
    Dim i1_ As Long
    If M <= 2# * ABLASComplexBlockSize(A) And N <= 2# * ABLASComplexBlockSize(A) Then
        
        '
        ' base case
        '
        For i = 0# To M - 1# Step 1
            i1_ = (JA) - (IB)
            For i_ = IB To IB + N - 1# Step 1
                B(i_, JB + i) = A(IA + i, i_ + i1_)
            Next i_
        Next i
    Else
        
        '
        ' Cache-oblivious recursion
        '
        If M > N Then
            Call ABLASComplexSplitLength(A, M, S1, S2)
            Call CMatrixTranspose(S1, N, A, IA, JA, B, IB, JB)
            Call CMatrixTranspose(S2, N, A, IA + S1, JA, B, IB, JB + S1)
        Else
            Call ABLASComplexSplitLength(A, N, S1, S2)
            Call CMatrixTranspose(M, S1, A, IA, JA, B, IB, JB)
            Call CMatrixTranspose(M, S2, A, IA, JA + S1, B, IB + S1, JB)
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Cache-oblivous real "copy-and-transpose"
'
'Input parameters:
'    M   -   number of rows
'    N   -   number of columns
'    A   -   source matrix, MxN submatrix is copied and transposed
'    IA  -   submatrix offset (row index)
'    JA  -   submatrix offset (column index)
'    A   -   destination matrix
'    IB  -   submatrix offset (row index)
'    JB  -   submatrix offset (column index)
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixTranspose(ByVal M As Long, _
         ByVal N As Long, _
         ByRef A() As Double, _
         ByVal IA As Long, _
         ByVal JA As Long, _
         ByRef B() As Double, _
         ByVal IB As Long, _
         ByVal JB As Long)
    Dim i As Long
    Dim S1 As Long
    Dim S2 As Long
    Dim i_ As Long
    Dim i1_ As Long
    If M <= 2# * ABLASBlockSize(A) And N <= 2# * ABLASBlockSize(A) Then
        
        '
        ' base case
        '
        For i = 0# To M - 1# Step 1
            i1_ = (JA) - (IB)
            For i_ = IB To IB + N - 1# Step 1
                B(i_, JB + i) = A(IA + i, i_ + i1_)
            Next i_
        Next i
    Else
        
        '
        ' Cache-oblivious recursion
        '
        If M > N Then
            Call ABLASSplitLength(A, M, S1, S2)
            Call RMatrixTranspose(S1, N, A, IA, JA, B, IB, JB)
            Call RMatrixTranspose(S2, N, A, IA + S1, JA, B, IB, JB + S1)
        Else
            Call ABLASSplitLength(A, N, S1, S2)
            Call RMatrixTranspose(M, S1, A, IA, JA, B, IB, JB)
            Call RMatrixTranspose(M, S2, A, IA, JA + S1, B, IB + S1, JB)
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copy
'
'Input parameters:
'    M   -   number of rows
'    N   -   number of columns
'    A   -   source matrix, MxN submatrix is copied and transposed
'    IA  -   submatrix offset (row index)
'    JA  -   submatrix offset (column index)
'    B   -   destination matrix
'    IB  -   submatrix offset (row index)
'    JB  -   submatrix offset (column index)
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixCopy(ByVal M As Long, _
         ByVal N As Long, _
         ByRef A() As Complex, _
         ByVal IA As Long, _
         ByVal JA As Long, _
         ByRef B() As Complex, _
         ByVal IB As Long, _
         ByVal JB As Long)
    Dim i As Long
    Dim i_ As Long
    Dim i1_ As Long
    For i = 0# To M - 1# Step 1
        i1_ = (JA) - (JB)
        For i_ = JB To JB + N - 1# Step 1
            B(IB + i, i_) = A(IA + i, i_ + i1_)
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copy
'
'Input parameters:
'    M   -   number of rows
'    N   -   number of columns
'    A   -   source matrix, MxN submatrix is copied and transposed
'    IA  -   submatrix offset (row index)
'    JA  -   submatrix offset (column index)
'    B   -   destination matrix
'    IB  -   submatrix offset (row index)
'    JB  -   submatrix offset (column index)
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixCopy(ByVal M As Long, _
         ByVal N As Long, _
         ByRef A() As Double, _
         ByVal IA As Long, _
         ByVal JA As Long, _
         ByRef B() As Double, _
         ByVal IB As Long, _
         ByVal JB As Long)
    Dim i As Long
    Dim i_ As Long
    Dim i1_ As Long
    For i = 0# To M - 1# Step 1
        i1_ = (JA) - (JB)
        For i_ = JB To JB + N - 1# Step 1
            B(IB + i, i_) = A(IA + i, i_ + i1_)
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Rank-1 correction: A := A + u*v'
'
'INPUT PARAMETERS:
'    M   -   number of rows
'    N   -   number of columns
'    A   -   target matrix, MxN submatrix is updated
'    IA  -   submatrix offset (row index)
'    JA  -   submatrix offset (column index)
'    U   -   vector #1
'    IU  -   subvector offset
'    V   -   vector #2
'    IV  -   subvector offset
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixRank1(ByVal M As Long, _
         ByVal N As Long, _
         ByRef A() As Complex, _
         ByVal IA As Long, _
         ByVal JA As Long, _
         ByRef U() As Complex, _
         ByVal IU As Long, _
         ByRef V() As Complex, _
         ByVal IV As Long)
    Dim i As Long
    Dim S As Complex
    Dim i_ As Long
    Dim i1_ As Long
    If M = 0# Or N = 0# Then
        Exit Sub
    End If
    If CMatrixRank1F(M, N, A, IA, JA, U, IU, V, IV) Then
        Exit Sub
    End If
    For i = 0# To M - 1# Step 1
        S = U(IU + i)
        i1_ = (IV) - (JA)
        For i_ = JA To JA + N - 1# Step 1
            A(IA + i, i_) = C_Add(A(IA + i, i_), C_Mul(S, V(i_ + i1_)))
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Rank-1 correction: A := A + u*v'
'
'INPUT PARAMETERS:
'    M   -   number of rows
'    N   -   number of columns
'    A   -   target matrix, MxN submatrix is updated
'    IA  -   submatrix offset (row index)
'    JA  -   submatrix offset (column index)
'    U   -   vector #1
'    IU  -   subvector offset
'    V   -   vector #2
'    IV  -   subvector offset
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixRank1(ByVal M As Long, _
         ByVal N As Long, _
         ByRef A() As Double, _
         ByVal IA As Long, _
         ByVal JA As Long, _
         ByRef U() As Double, _
         ByVal IU As Long, _
         ByRef V() As Double, _
         ByVal IV As Long)
    Dim i As Long
    Dim S As Double
    Dim i_ As Long
    Dim i1_ As Long
    If M = 0# Or N = 0# Then
        Exit Sub
    End If
    If RMatrixRank1F(M, N, A, IA, JA, U, IU, V, IV) Then
        Exit Sub
    End If
    For i = 0# To M - 1# Step 1
        S = U(IU + i)
        i1_ = (IV) - (JA)
        For i_ = JA To JA + N - 1# Step 1
            A(IA + i, i_) = A(IA + i, i_) + S * V(i_ + i1_)
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Matrix-vector product: y := op(A)*x
'
'INPUT PARAMETERS:
'    M   -   number of rows of op(A)
'            M>=0
'    N   -   number of columns of op(A)
'            N>=0
'    A   -   target matrix
'    IA  -   submatrix offset (row index)
'    JA  -   submatrix offset (column index)
'    OpA -   operation type:
'            * OpA=0     =>  op(A) = A
'            * OpA=1     =>  op(A) = A^T
'            * OpA=2     =>  op(A) = A^H
'    X   -   input vector
'    IX  -   subvector offset
'    IY  -   subvector offset
'
'OUTPUT PARAMETERS:
'    Y   -   vector which stores result
'
'if M=0, then subroutine does nothing.
'if N=0, Y is filled by zeros.
'
'
'  -- ALGLIB routine --
'
'     28.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixMV(ByVal M As Long, _
         ByVal N As Long, _
         ByRef A() As Complex, _
         ByVal IA As Long, _
         ByVal JA As Long, _
         ByVal OpA As Long, _
         ByRef X() As Complex, _
         ByVal IX As Long, _
         ByRef y() As Complex, _
         ByVal IY As Long)
    Dim i As Long
    Dim V As Complex
    Dim i_ As Long
    Dim i1_ As Long
    If M = 0# Then
        Exit Sub
    End If
    If N = 0# Then
        For i = 0# To M - 1# Step 1
            y(IY + i) = C_Complex(0#)
        Next i
        Exit Sub
    End If
    If CMatrixMVF(M, N, A, IA, JA, OpA, X, IX, y, IY) Then
        Exit Sub
    End If
    If OpA = 0# Then
        
        '
        ' y = A*x
        '
        For i = 0# To M - 1# Step 1
            i1_ = (IX) - (JA)
            V = C_Complex(0#)
            For i_ = JA To JA + N - 1# Step 1
                V = C_Add(V, C_Mul(A(IA + i, i_), X(i_ + i1_)))
            Next i_
            y(IY + i) = V
        Next i
        Exit Sub
    End If
    If OpA = 1# Then
        
        '
        ' y = A^T*x
        '
        For i = 0# To M - 1# Step 1
            y(IY + i) = C_Complex(0#)
        Next i
        For i = 0# To N - 1# Step 1
            V = X(IX + i)
            i1_ = (JA) - (IY)
            For i_ = IY To IY + M - 1# Step 1
                y(i_) = C_Add(y(i_), C_Mul(V, A(IA + i, i_ + i1_)))
            Next i_
        Next i
        Exit Sub
    End If
    If OpA = 2# Then
        
        '
        ' y = A^H*x
        '
        For i = 0# To M - 1# Step 1
            y(IY + i) = C_Complex(0#)
        Next i
        For i = 0# To N - 1# Step 1
            V = X(IX + i)
            i1_ = (JA) - (IY)
            For i_ = IY To IY + M - 1# Step 1
                y(i_) = C_Add(y(i_), C_Mul(V, Conj(A(IA + i, i_ + i1_))))
            Next i_
        Next i
        Exit Sub
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Matrix-vector product: y := op(A)*x
'
'INPUT PARAMETERS:
'    M   -   number of rows of op(A)
'    N   -   number of columns of op(A)
'    A   -   target matrix
'    IA  -   submatrix offset (row index)
'    JA  -   submatrix offset (column index)
'    OpA -   operation type:
'            * OpA=0     =>  op(A) = A
'            * OpA=1     =>  op(A) = A^T
'    X   -   input vector
'    IX  -   subvector offset
'    IY  -   subvector offset
'
'OUTPUT PARAMETERS:
'    Y   -   vector which stores result
'
'if M=0, then subroutine does nothing.
'if N=0, Y is filled by zeros.
'
'
'  -- ALGLIB routine --
'
'     28.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixMV(ByVal M As Long, _
         ByVal N As Long, _
         ByRef A() As Double, _
         ByVal IA As Long, _
         ByVal JA As Long, _
         ByVal OpA As Long, _
         ByRef X() As Double, _
         ByVal IX As Long, _
         ByRef y() As Double, _
         ByVal IY As Long)
    Dim i As Long
    Dim V As Double
    Dim i_ As Long
    Dim i1_ As Long
    If M = 0# Then
        Exit Sub
    End If
    If N = 0# Then
        For i = 0# To M - 1# Step 1
            y(IY + i) = 0#
        Next i
        Exit Sub
    End If
    If RMatrixMVF(M, N, A, IA, JA, OpA, X, IX, y, IY) Then
        Exit Sub
    End If
    If OpA = 0# Then
        
        '
        ' y = A*x
        '
        For i = 0# To M - 1# Step 1
            i1_ = (IX) - (JA)
            V = 0#
            For i_ = JA To JA + N - 1# Step 1
                V = V + A(IA + i, i_) * X(i_ + i1_)
            Next i_
            y(IY + i) = V
        Next i
        Exit Sub
    End If
    If OpA = 1# Then
        
        '
        ' y = A^T*x
        '
        For i = 0# To M - 1# Step 1
            y(IY + i) = 0#
        Next i
        For i = 0# To N - 1# Step 1
            V = X(IX + i)
            i1_ = (JA) - (IY)
            For i_ = IY To IY + M - 1# Step 1
                y(i_) = y(i_) + V * A(IA + i, i_ + i1_)
            Next i_
        Next i
        Exit Sub
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This subroutine calculates X*op(A^-1) where:
'* X is MxN general matrix
'* A is NxN upper/lower triangular/unitriangular matrix
'* "op" may be identity transformation, transposition, conjugate transposition
'
'Multiplication result replaces X.
'Cache-oblivious algorithm is used.
'
'INPUT PARAMETERS
'    N   -   matrix size, N>=0
'    M   -   matrix size, N>=0
'    A       -   matrix, actial matrix is stored in A[I1:I1+N-1,J1:J1+N-1]
'    I1      -   submatrix offset
'    J1      -   submatrix offset
'    IsUpper -   whether matrix is upper triangular
'    IsUnit  -   whether matrix is unitriangular
'    OpType  -   transformation type:
'                * 0 - no transformation
'                * 1 - transposition
'                * 2 - conjugate transposition
'    C   -   matrix, actial matrix is stored in C[I2:I2+M-1,J2:J2+N-1]
'    I2  -   submatrix offset
'    J2  -   submatrix offset
'
'  -- ALGLIB routine --
'     15.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixRightTRSM(ByVal M As Long, _
         ByVal N As Long, _
         ByRef A() As Complex, _
         ByVal I1 As Long, _
         ByVal J1 As Long, _
         ByVal IsUpper As Boolean, _
         ByVal Isunit As Boolean, _
         ByVal OpType As Long, _
         ByRef X() As Complex, _
         ByVal I2 As Long, _
         ByVal J2 As Long)
    Dim S1 As Long
    Dim S2 As Long
    Dim BS As Long
    BS = ABLASComplexBlockSize(A)
    If M <= BS And N <= BS Then
        Call CMatrixRightTRSM2(M, N, A, I1, J1, IsUpper, Isunit, OpType, X, I2, J2)
        Exit Sub
    End If
    If M >= N Then
        
        '
        ' Split X: X*A = (X1 X2)^T*A
        '
        Call ABLASComplexSplitLength(A, M, S1, S2)
        Call CMatrixRightTRSM(S1, N, A, I1, J1, IsUpper, Isunit, OpType, X, I2, J2)
        Call CMatrixRightTRSM(S2, N, A, I1, J1, IsUpper, Isunit, OpType, X, I2 + S1, J2)
    Else
        
        '
        ' Split A:
        '               (A1  A12)
        ' X*op(A) = X*op(       )
        '               (     A2)
        '
        ' Different variants depending on
        ' IsUpper/OpType combinations
        '
        Call ABLASComplexSplitLength(A, N, S1, S2)
        If IsUpper And OpType = 0# Then
            
            '
            '                  (A1  A12)-1
            ' X*A^-1 = (X1 X2)*(       )
            '                  (     A2)
            '
            Call CMatrixRightTRSM(M, S1, A, I1, J1, IsUpper, Isunit, OpType, X, I2, J2)
            Call CMatrixGEMM(M, S2, S1, C_Complex(-1#), X, I2, J2, 0#, A, I1, J1 + S1, 0#, C_Complex(1#), X, I2, J2 + S1)
            Call CMatrixRightTRSM(M, S2, A, I1 + S1, J1 + S1, IsUpper, Isunit, OpType, X, I2, J2 + S1)
            Exit Sub
        End If
        If IsUpper And OpType <> 0# Then
            
            '
            '                  (A1'     )-1
            ' X*A^-1 = (X1 X2)*(        )
            '                  (A12' A2')
            '
            Call CMatrixRightTRSM(M, S2, A, I1 + S1, J1 + S1, IsUpper, Isunit, OpType, X, I2, J2 + S1)
            Call CMatrixGEMM(M, S1, S2, C_Complex(-1#), X, I2, J2 + S1, 0#, A, I1, J1 + S1, OpType, C_Complex(1#), X, I2, J2)
            Call CMatrixRightTRSM(M, S1, A, I1, J1, IsUpper, Isunit, OpType, X, I2, J2)
            Exit Sub
        End If
        If Not IsUpper And OpType = 0# Then
            
            '
            '                  (A1     )-1
            ' X*A^-1 = (X1 X2)*(       )
            '                  (A21  A2)
            '
            Call CMatrixRightTRSM(M, S2, A, I1 + S1, J1 + S1, IsUpper, Isunit, OpType, X, I2, J2 + S1)
            Call CMatrixGEMM(M, S1, S2, C_Complex(-1#), X, I2, J2 + S1, 0#, A, I1 + S1, J1, 0#, C_Complex(1#), X, I2, J2)
            Call CMatrixRightTRSM(M, S1, A, I1, J1, IsUpper, Isunit, OpType, X, I2, J2)
            Exit Sub
        End If
        If Not IsUpper And OpType <> 0# Then
            
            '
            '                  (A1' A21')-1
            ' X*A^-1 = (X1 X2)*(        )
            '                  (     A2')
            '
            Call CMatrixRightTRSM(M, S1, A, I1, J1, IsUpper, Isunit, OpType, X, I2, J2)
            Call CMatrixGEMM(M, S2, S1, C_Complex(-1#), X, I2, J2, 0#, A, I1 + S1, J1, OpType, C_Complex(1#), X, I2, J2 + S1)
            Call CMatrixRightTRSM(M, S2, A, I1 + S1, J1 + S1, IsUpper, Isunit, OpType, X, I2, J2 + S1)
            Exit Sub
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This subroutine calculates op(A^-1)*X where:
'* X is MxN general matrix
'* A is MxM upper/lower triangular/unitriangular matrix
'* "op" may be identity transformation, transposition, conjugate transposition
'
'Multiplication result replaces X.
'Cache-oblivious algorithm is used.
'
'INPUT PARAMETERS
'    N   -   matrix size, N>=0
'    M   -   matrix size, N>=0
'    A       -   matrix, actial matrix is stored in A[I1:I1+M-1,J1:J1+M-1]
'    I1      -   submatrix offset
'    J1      -   submatrix offset
'    IsUpper -   whether matrix is upper triangular
'    IsUnit  -   whether matrix is unitriangular
'    OpType  -   transformation type:
'                * 0 - no transformation
'                * 1 - transposition
'                * 2 - conjugate transposition
'    C   -   matrix, actial matrix is stored in C[I2:I2+M-1,J2:J2+N-1]
'    I2  -   submatrix offset
'    J2  -   submatrix offset
'
'  -- ALGLIB routine --
'     15.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixLeftTRSM(ByVal M As Long, _
         ByVal N As Long, _
         ByRef A() As Complex, _
         ByVal I1 As Long, _
         ByVal J1 As Long, _
         ByVal IsUpper As Boolean, _
         ByVal Isunit As Boolean, _
         ByVal OpType As Long, _
         ByRef X() As Complex, _
         ByVal I2 As Long, _
         ByVal J2 As Long)
    Dim S1 As Long
    Dim S2 As Long
    Dim BS As Long
    BS = ABLASComplexBlockSize(A)
    If M <= BS And N <= BS Then
        Call CMatrixLeftTRSM2(M, N, A, I1, J1, IsUpper, Isunit, OpType, X, I2, J2)
        Exit Sub
    End If
    If N >= M Then
        
        '
        ' Split X: op(A)^-1*X = op(A)^-1*(X1 X2)
        '
        Call ABLASComplexSplitLength(X, N, S1, S2)
        Call CMatrixLeftTRSM(M, S1, A, I1, J1, IsUpper, Isunit, OpType, X, I2, J2)
        Call CMatrixLeftTRSM(M, S2, A, I1, J1, IsUpper, Isunit, OpType, X, I2, J2 + S1)
    Else
        
        '
        ' Split A
        '
        Call ABLASComplexSplitLength(A, M, S1, S2)
        If IsUpper And OpType = 0# Then
            
            '
            '           (A1  A12)-1  ( X1 )
            ' A^-1*X* = (       )   *(    )
            '           (     A2)    ( X2 )
            '
            Call CMatrixLeftTRSM(S2, N, A, I1 + S1, J1 + S1, IsUpper, Isunit, OpType, X, I2 + S1, J2)
            Call CMatrixGEMM(S1, N, S2, C_Complex(-1#), A, I1, J1 + S1, 0#, X, I2 + S1, J2, 0#, C_Complex(1#), X, I2, J2)
            Call CMatrixLeftTRSM(S1, N, A, I1, J1, IsUpper, Isunit, OpType, X, I2, J2)
            Exit Sub
        End If
        If IsUpper And OpType <> 0# Then
            
            '
            '          (A1'     )-1 ( X1 )
            ' A^-1*X = (        )  *(    )
            '          (A12' A2')   ( X2 )
            '
            Call CMatrixLeftTRSM(S1, N, A, I1, J1, IsUpper, Isunit, OpType, X, I2, J2)
            Call CMatrixGEMM(S2, N, S1, C_Complex(-1#), A, I1, J1 + S1, OpType, X, I2, J2, 0#, C_Complex(1#), X, I2 + S1, J2)
            Call CMatrixLeftTRSM(S2, N, A, I1 + S1, J1 + S1, IsUpper, Isunit, OpType, X, I2 + S1, J2)
            Exit Sub
        End If
        If Not IsUpper And OpType = 0# Then
            
            '
            '          (A1     )-1 ( X1 )
            ' A^-1*X = (       )  *(    )
            '          (A21  A2)   ( X2 )
            '
            Call CMatrixLeftTRSM(S1, N, A, I1, J1, IsUpper, Isunit, OpType, X, I2, J2)
            Call CMatrixGEMM(S2, N, S1, C_Complex(-1#), A, I1 + S1, J1, 0#, X, I2, J2, 0#, C_Complex(1#), X, I2 + S1, J2)
            Call CMatrixLeftTRSM(S2, N, A, I1 + S1, J1 + S1, IsUpper, Isunit, OpType, X, I2 + S1, J2)
            Exit Sub
        End If
        If Not IsUpper And OpType <> 0# Then
            
            '
            '          (A1' A21')-1 ( X1 )
            ' A^-1*X = (        )  *(    )
            '          (     A2')   ( X2 )
            '
            Call CMatrixLeftTRSM(S2, N, A, I1 + S1, J1 + S1, IsUpper, Isunit, OpType, X, I2 + S1, J2)
            Call CMatrixGEMM(S1, N, S2, C_Complex(-1#), A, I1 + S1, J1, OpType, X, I2 + S1, J2, 0#, C_Complex(1#), X, I2, J2)
            Call CMatrixLeftTRSM(S1, N, A, I1, J1, IsUpper, Isunit, OpType, X, I2, J2)
            Exit Sub
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Same as CMatrixRightTRSM, but for real matrices
'
'OpType may be only 0 or 1.
'
'  -- ALGLIB routine --
'     15.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixRightTRSM(ByVal M As Long, _
         ByVal N As Long, _
         ByRef A() As Double, _
         ByVal I1 As Long, _
         ByVal J1 As Long, _
         ByVal IsUpper As Boolean, _
         ByVal Isunit As Boolean, _
         ByVal OpType As Long, _
         ByRef X() As Double, _
         ByVal I2 As Long, _
         ByVal J2 As Long)
    Dim S1 As Long
    Dim S2 As Long
    Dim BS As Long
    BS = ABLASBlockSize(A)
    If M <= BS And N <= BS Then
        Call RMatrixRightTRSM2(M, N, A, I1, J1, IsUpper, Isunit, OpType, X, I2, J2)
        Exit Sub
    End If
    If M >= N Then
        
        '
        ' Split X: X*A = (X1 X2)^T*A
        '
        Call ABLASSplitLength(A, M, S1, S2)
        Call RMatrixRightTRSM(S1, N, A, I1, J1, IsUpper, Isunit, OpType, X, I2, J2)
        Call RMatrixRightTRSM(S2, N, A, I1, J1, IsUpper, Isunit, OpType, X, I2 + S1, J2)
    Else
        
        '
        ' Split A:
        '               (A1  A12)
        ' X*op(A) = X*op(       )
        '               (     A2)
        '
        ' Different variants depending on
        ' IsUpper/OpType combinations
        '
        Call ABLASSplitLength(A, N, S1, S2)
        If IsUpper And OpType = 0# Then
            
            '
            '                  (A1  A12)-1
            ' X*A^-1 = (X1 X2)*(       )
            '                  (     A2)
            '
            Call RMatrixRightTRSM(M, S1, A, I1, J1, IsUpper, Isunit, OpType, X, I2, J2)
            Call RMatrixGEMM(M, S2, S1, -1#, X, I2, J2, 0#, A, I1, J1 + S1, 0#, 1#, X, I2, J2 + S1)
            Call RMatrixRightTRSM(M, S2, A, I1 + S1, J1 + S1, IsUpper, Isunit, OpType, X, I2, J2 + S1)
            Exit Sub
        End If
        If IsUpper And OpType <> 0# Then
            
            '
            '                  (A1'     )-1
            ' X*A^-1 = (X1 X2)*(        )
            '                  (A12' A2')
            '
            Call RMatrixRightTRSM(M, S2, A, I1 + S1, J1 + S1, IsUpper, Isunit, OpType, X, I2, J2 + S1)
            Call RMatrixGEMM(M, S1, S2, -1#, X, I2, J2 + S1, 0#, A, I1, J1 + S1, OpType, 1#, X, I2, J2)
            Call RMatrixRightTRSM(M, S1, A, I1, J1, IsUpper, Isunit, OpType, X, I2, J2)
            Exit Sub
        End If
        If Not IsUpper And OpType = 0# Then
            
            '
            '                  (A1     )-1
            ' X*A^-1 = (X1 X2)*(       )
            '                  (A21  A2)
            '
            Call RMatrixRightTRSM(M, S2, A, I1 + S1, J1 + S1, IsUpper, Isunit, OpType, X, I2, J2 + S1)
            Call RMatrixGEMM(M, S1, S2, -1#, X, I2, J2 + S1, 0#, A, I1 + S1, J1, 0#, 1#, X, I2, J2)
            Call RMatrixRightTRSM(M, S1, A, I1, J1, IsUpper, Isunit, OpType, X, I2, J2)
            Exit Sub
        End If
        If Not IsUpper And OpType <> 0# Then
            
            '
            '                  (A1' A21')-1
            ' X*A^-1 = (X1 X2)*(        )
            '                  (     A2')
            '
            Call RMatrixRightTRSM(M, S1, A, I1, J1, IsUpper, Isunit, OpType, X, I2, J2)
            Call RMatrixGEMM(M, S2, S1, -1#, X, I2, J2, 0#, A, I1 + S1, J1, OpType, 1#, X, I2, J2 + S1)
            Call RMatrixRightTRSM(M, S2, A, I1 + S1, J1 + S1, IsUpper, Isunit, OpType, X, I2, J2 + S1)
            Exit Sub
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Same as CMatrixLeftTRSM, but for real matrices
'
'OpType may be only 0 or 1.
'
'  -- ALGLIB routine --
'     15.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixLeftTRSM(ByVal M As Long, _
         ByVal N As Long, _
         ByRef A() As Double, _
         ByVal I1 As Long, _
         ByVal J1 As Long, _
         ByVal IsUpper As Boolean, _
         ByVal Isunit As Boolean, _
         ByVal OpType As Long, _
         ByRef X() As Double, _
         ByVal I2 As Long, _
         ByVal J2 As Long)
    Dim S1 As Long
    Dim S2 As Long
    Dim BS As Long
    BS = ABLASBlockSize(A)
    If M <= BS And N <= BS Then
        Call RMatrixLeftTRSM2(M, N, A, I1, J1, IsUpper, Isunit, OpType, X, I2, J2)
        Exit Sub
    End If
    If N >= M Then
        
        '
        ' Split X: op(A)^-1*X = op(A)^-1*(X1 X2)
        '
        Call ABLASSplitLength(X, N, S1, S2)
        Call RMatrixLeftTRSM(M, S1, A, I1, J1, IsUpper, Isunit, OpType, X, I2, J2)
        Call RMatrixLeftTRSM(M, S2, A, I1, J1, IsUpper, Isunit, OpType, X, I2, J2 + S1)
    Else
        
        '
        ' Split A
        '
        Call ABLASSplitLength(A, M, S1, S2)
        If IsUpper And OpType = 0# Then
            
            '
            '           (A1  A12)-1  ( X1 )
            ' A^-1*X* = (       )   *(    )
            '           (     A2)    ( X2 )
            '
            Call RMatrixLeftTRSM(S2, N, A, I1 + S1, J1 + S1, IsUpper, Isunit, OpType, X, I2 + S1, J2)
            Call RMatrixGEMM(S1, N, S2, -1#, A, I1, J1 + S1, 0#, X, I2 + S1, J2, 0#, 1#, X, I2, J2)
            Call RMatrixLeftTRSM(S1, N, A, I1, J1, IsUpper, Isunit, OpType, X, I2, J2)
            Exit Sub
        End If
        If IsUpper And OpType <> 0# Then
            
            '
            '          (A1'     )-1 ( X1 )
            ' A^-1*X = (        )  *(    )
            '          (A12' A2')   ( X2 )
            '
            Call RMatrixLeftTRSM(S1, N, A, I1, J1, IsUpper, Isunit, OpType, X, I2, J2)
            Call RMatrixGEMM(S2, N, S1, -1#, A, I1, J1 + S1, OpType, X, I2, J2, 0#, 1#, X, I2 + S1, J2)
            Call RMatrixLeftTRSM(S2, N, A, I1 + S1, J1 + S1, IsUpper, Isunit, OpType, X, I2 + S1, J2)
            Exit Sub
        End If
        If Not IsUpper And OpType = 0# Then
            
            '
            '          (A1     )-1 ( X1 )
            ' A^-1*X = (       )  *(    )
            '          (A21  A2)   ( X2 )
            '
            Call RMatrixLeftTRSM(S1, N, A, I1, J1, IsUpper, Isunit, OpType, X, I2, J2)
            Call RMatrixGEMM(S2, N, S1, -1#, A, I1 + S1, J1, 0#, X, I2, J2, 0#, 1#, X, I2 + S1, J2)
            Call RMatrixLeftTRSM(S2, N, A, I1 + S1, J1 + S1, IsUpper, Isunit, OpType, X, I2 + S1, J2)
            Exit Sub
        End If
        If Not IsUpper And OpType <> 0# Then
            
            '
            '          (A1' A21')-1 ( X1 )
            ' A^-1*X = (        )  *(    )
            '          (     A2')   ( X2 )
            '
            Call RMatrixLeftTRSM(S2, N, A, I1 + S1, J1 + S1, IsUpper, Isunit, OpType, X, I2 + S1, J2)
            Call RMatrixGEMM(S1, N, S2, -1#, A, I1 + S1, J1, OpType, X, I2 + S1, J2, 0#, 1#, X, I2, J2)
            Call RMatrixLeftTRSM(S1, N, A, I1, J1, IsUpper, Isunit, OpType, X, I2, J2)
            Exit Sub
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This subroutine calculates  C=alpha*A*A^H+beta*C  or  C=alpha*A^H*A+beta*C
'where:
'* C is NxN Hermitian matrix given by its upper/lower triangle
'* A is NxK matrix when A*A^H is calculated, KxN matrix otherwise
'
'Additional info:
'* cache-oblivious algorithm is used.
'* multiplication result replaces C. If Beta=0, C elements are not used in
'  calculations (not multiplied by zero - just not referenced)
'* if Alpha=0, A is not used (not multiplied by zero - just not referenced)
'* if both Beta and Alpha are zero, C is filled by zeros.
'
'INPUT PARAMETERS
'    N       -   matrix size, N>=0
'    K       -   matrix size, K>=0
'    Alpha   -   coefficient
'    A       -   matrix
'    IA      -   submatrix offset
'    JA      -   submatrix offset
'    OpTypeA -   multiplication type:
'                * 0 - A*A^H is calculated
'                * 2 - A^H*A is calculated
'    Beta    -   coefficient
'    C       -   matrix
'    IC      -   submatrix offset
'    JC      -   submatrix offset
'    IsUpper -   whether C is upper triangular or lower triangular
'
'  -- ALGLIB routine --
'     16.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixSYRK(ByVal N As Long, _
         ByVal K As Long, _
         ByVal Alpha As Double, _
         ByRef A() As Complex, _
         ByVal IA As Long, _
         ByVal JA As Long, _
         ByVal OpTypeA As Long, _
         ByVal Beta As Double, _
         ByRef C() As Complex, _
         ByVal IC As Long, _
         ByVal JC As Long, _
         ByVal IsUpper As Boolean)
    Dim S1 As Long
    Dim S2 As Long
    Dim BS As Long
    BS = ABLASComplexBlockSize(A)
    If N <= BS And K <= BS Then
        Call CMatrixSYRK2(N, K, Alpha, A, IA, JA, OpTypeA, Beta, C, IC, JC, IsUpper)
        Exit Sub
    End If
    If K >= N Then
        
        '
        ' Split K
        '
        Call ABLASComplexSplitLength(A, K, S1, S2)
        If OpTypeA = 0# Then
            Call CMatrixSYRK(N, S1, Alpha, A, IA, JA, OpTypeA, Beta, C, IC, JC, IsUpper)
            Call CMatrixSYRK(N, S2, Alpha, A, IA, JA + S1, OpTypeA, 1#, C, IC, JC, IsUpper)
        Else
            Call CMatrixSYRK(N, S1, Alpha, A, IA, JA, OpTypeA, Beta, C, IC, JC, IsUpper)
            Call CMatrixSYRK(N, S2, Alpha, A, IA + S1, JA, OpTypeA, 1#, C, IC, JC, IsUpper)
        End If
    Else
        
        '
        ' Split N
        '
        Call ABLASComplexSplitLength(A, N, S1, S2)
        If OpTypeA = 0# And IsUpper Then
            Call CMatrixSYRK(S1, K, Alpha, A, IA, JA, OpTypeA, Beta, C, IC, JC, IsUpper)
            Call CMatrixGEMM(S1, S2, K, C_Complex(Alpha), A, IA, JA, 0#, A, IA + S1, JA, 2#, C_Complex(Beta), C, IC, JC + S1)
            Call CMatrixSYRK(S2, K, Alpha, A, IA + S1, JA, OpTypeA, Beta, C, IC + S1, JC + S1, IsUpper)
            Exit Sub
        End If
        If OpTypeA = 0# And Not IsUpper Then
            Call CMatrixSYRK(S1, K, Alpha, A, IA, JA, OpTypeA, Beta, C, IC, JC, IsUpper)
            Call CMatrixGEMM(S2, S1, K, C_Complex(Alpha), A, IA + S1, JA, 0#, A, IA, JA, 2#, C_Complex(Beta), C, IC + S1, JC)
            Call CMatrixSYRK(S2, K, Alpha, A, IA + S1, JA, OpTypeA, Beta, C, IC + S1, JC + S1, IsUpper)
            Exit Sub
        End If
        If OpTypeA <> 0# And IsUpper Then
            Call CMatrixSYRK(S1, K, Alpha, A, IA, JA, OpTypeA, Beta, C, IC, JC, IsUpper)
            Call CMatrixGEMM(S1, S2, K, C_Complex(Alpha), A, IA, JA, 2#, A, IA, JA + S1, 0#, C_Complex(Beta), C, IC, JC + S1)
            Call CMatrixSYRK(S2, K, Alpha, A, IA, JA + S1, OpTypeA, Beta, C, IC + S1, JC + S1, IsUpper)
            Exit Sub
        End If
        If OpTypeA <> 0# And Not IsUpper Then
            Call CMatrixSYRK(S1, K, Alpha, A, IA, JA, OpTypeA, Beta, C, IC, JC, IsUpper)
            Call CMatrixGEMM(S2, S1, K, C_Complex(Alpha), A, IA, JA + S1, 2#, A, IA, JA, 0#, C_Complex(Beta), C, IC + S1, JC)
            Call CMatrixSYRK(S2, K, Alpha, A, IA, JA + S1, OpTypeA, Beta, C, IC + S1, JC + S1, IsUpper)
            Exit Sub
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Same as CMatrixSYRK, but for real matrices
'
'OpType may be only 0 or 1.
'
'  -- ALGLIB routine --
'     16.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixSYRK(ByVal N As Long, _
         ByVal K As Long, _
         ByVal Alpha As Double, _
         ByRef A() As Double, _
         ByVal IA As Long, _
         ByVal JA As Long, _
         ByVal OpTypeA As Long, _
         ByVal Beta As Double, _
         ByRef C() As Double, _
         ByVal IC As Long, _
         ByVal JC As Long, _
         ByVal IsUpper As Boolean)
    Dim S1 As Long
    Dim S2 As Long
    Dim BS As Long
    BS = ABLASBlockSize(A)
    If N <= BS And K <= BS Then
        Call RMatrixSYRK2(N, K, Alpha, A, IA, JA, OpTypeA, Beta, C, IC, JC, IsUpper)
        Exit Sub
    End If
    If K >= N Then
        
        '
        ' Split K
        '
        Call ABLASSplitLength(A, K, S1, S2)
        If OpTypeA = 0# Then
            Call RMatrixSYRK(N, S1, Alpha, A, IA, JA, OpTypeA, Beta, C, IC, JC, IsUpper)
            Call RMatrixSYRK(N, S2, Alpha, A, IA, JA + S1, OpTypeA, 1#, C, IC, JC, IsUpper)
        Else
            Call RMatrixSYRK(N, S1, Alpha, A, IA, JA, OpTypeA, Beta, C, IC, JC, IsUpper)
            Call RMatrixSYRK(N, S2, Alpha, A, IA + S1, JA, OpTypeA, 1#, C, IC, JC, IsUpper)
        End If
    Else
        
        '
        ' Split N
        '
        Call ABLASSplitLength(A, N, S1, S2)
        If OpTypeA = 0# And IsUpper Then
            Call RMatrixSYRK(S1, K, Alpha, A, IA, JA, OpTypeA, Beta, C, IC, JC, IsUpper)
            Call RMatrixGEMM(S1, S2, K, Alpha, A, IA, JA, 0#, A, IA + S1, JA, 1#, Beta, C, IC, JC + S1)
            Call RMatrixSYRK(S2, K, Alpha, A, IA + S1, JA, OpTypeA, Beta, C, IC + S1, JC + S1, IsUpper)
            Exit Sub
        End If
        If OpTypeA = 0# And Not IsUpper Then
            Call RMatrixSYRK(S1, K, Alpha, A, IA, JA, OpTypeA, Beta, C, IC, JC, IsUpper)
            Call RMatrixGEMM(S2, S1, K, Alpha, A, IA + S1, JA, 0#, A, IA, JA, 1#, Beta, C, IC + S1, JC)
            Call RMatrixSYRK(S2, K, Alpha, A, IA + S1, JA, OpTypeA, Beta, C, IC + S1, JC + S1, IsUpper)
            Exit Sub
        End If
        If OpTypeA <> 0# And IsUpper Then
            Call RMatrixSYRK(S1, K, Alpha, A, IA, JA, OpTypeA, Beta, C, IC, JC, IsUpper)
            Call RMatrixGEMM(S1, S2, K, Alpha, A, IA, JA, 1#, A, IA, JA + S1, 0#, Beta, C, IC, JC + S1)
            Call RMatrixSYRK(S2, K, Alpha, A, IA, JA + S1, OpTypeA, Beta, C, IC + S1, JC + S1, IsUpper)
            Exit Sub
        End If
        If OpTypeA <> 0# And Not IsUpper Then
            Call RMatrixSYRK(S1, K, Alpha, A, IA, JA, OpTypeA, Beta, C, IC, JC, IsUpper)
            Call RMatrixGEMM(S2, S1, K, Alpha, A, IA, JA + S1, 1#, A, IA, JA, 0#, Beta, C, IC + S1, JC)
            Call RMatrixSYRK(S2, K, Alpha, A, IA, JA + S1, OpTypeA, Beta, C, IC + S1, JC + S1, IsUpper)
            Exit Sub
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This subroutine calculates C = alpha*op1(A)*op2(B) +beta*C where:
'* C is MxN general matrix
'* op1(A) is MxK matrix
'* op2(B) is KxN matrix
'* "op" may be identity transformation, transposition, conjugate transposition
'
'Additional info:
'* cache-oblivious algorithm is used.
'* multiplication result replaces C. If Beta=0, C elements are not used in
'  calculations (not multiplied by zero - just not referenced)
'* if Alpha=0, A is not used (not multiplied by zero - just not referenced)
'* if both Beta and Alpha are zero, C is filled by zeros.
'
'INPUT PARAMETERS
'    N       -   matrix size, N>0
'    M       -   matrix size, N>0
'    K       -   matrix size, K>0
'    Alpha   -   coefficient
'    A       -   matrix
'    IA      -   submatrix offset
'    JA      -   submatrix offset
'    OpTypeA -   transformation type:
'                * 0 - no transformation
'                * 1 - transposition
'                * 2 - conjugate transposition
'    B       -   matrix
'    IB      -   submatrix offset
'    JB      -   submatrix offset
'    OpTypeB -   transformation type:
'                * 0 - no transformation
'                * 1 - transposition
'                * 2 - conjugate transposition
'    Beta    -   coefficient
'    C       -   matrix
'    IC      -   submatrix offset
'    JC      -   submatrix offset
'
'  -- ALGLIB routine --
'     16.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixGEMM(ByVal M As Long, _
         ByVal N As Long, _
         ByVal K As Long, _
         ByRef Alpha_ As Complex, _
         ByRef A() As Complex, _
         ByVal IA As Long, _
         ByVal JA As Long, _
         ByVal OpTypeA As Long, _
         ByRef B() As Complex, _
         ByVal IB As Long, _
         ByVal JB As Long, _
         ByVal OpTypeB As Long, _
         ByRef Beta_ As Complex, _
         ByRef C() As Complex, _
         ByVal IC As Long, _
         ByVal JC As Long)
    Dim Alpha As Complex
    Dim Beta As Complex
    Dim S1 As Long
    Dim S2 As Long
    Dim BS As Long
    Alpha = Alpha_
    Beta = Beta_
    BS = ABLASComplexBlockSize(A)
    If M <= BS And N <= BS And K <= BS Then
        Call CMatrixGEMMK(M, N, K, Alpha, A, IA, JA, OpTypeA, B, IB, JB, OpTypeB, Beta, C, IC, JC)
        Exit Sub
    End If
    If M >= N And M >= K Then
        
        '
        ' A*B = (A1 A2)^T*B
        '
        Call ABLASComplexSplitLength(A, M, S1, S2)
        Call CMatrixGEMM(S1, N, K, Alpha, A, IA, JA, OpTypeA, B, IB, JB, OpTypeB, Beta, C, IC, JC)
        If OpTypeA = 0# Then
            Call CMatrixGEMM(S2, N, K, Alpha, A, IA + S1, JA, OpTypeA, B, IB, JB, OpTypeB, Beta, C, IC + S1, JC)
        Else
            Call CMatrixGEMM(S2, N, K, Alpha, A, IA, JA + S1, OpTypeA, B, IB, JB, OpTypeB, Beta, C, IC + S1, JC)
        End If
        Exit Sub
    End If
    If N >= M And N >= K Then
        
        '
        ' A*B = A*(B1 B2)
        '
        Call ABLASComplexSplitLength(A, N, S1, S2)
        If OpTypeB = 0# Then
            Call CMatrixGEMM(M, S1, K, Alpha, A, IA, JA, OpTypeA, B, IB, JB, OpTypeB, Beta, C, IC, JC)
            Call CMatrixGEMM(M, S2, K, Alpha, A, IA, JA, OpTypeA, B, IB, JB + S1, OpTypeB, Beta, C, IC, JC + S1)
        Else
            Call CMatrixGEMM(M, S1, K, Alpha, A, IA, JA, OpTypeA, B, IB, JB, OpTypeB, Beta, C, IC, JC)
            Call CMatrixGEMM(M, S2, K, Alpha, A, IA, JA, OpTypeA, B, IB + S1, JB, OpTypeB, Beta, C, IC, JC + S1)
        End If
        Exit Sub
    End If
    If K >= M And K >= N Then
        
        '
        ' A*B = (A1 A2)*(B1 B2)^T
        '
        Call ABLASComplexSplitLength(A, K, S1, S2)
        If OpTypeA = 0# And OpTypeB = 0# Then
            Call CMatrixGEMM(M, N, S1, Alpha, A, IA, JA, OpTypeA, B, IB, JB, OpTypeB, Beta, C, IC, JC)
            Call CMatrixGEMM(M, N, S2, Alpha, A, IA, JA + S1, OpTypeA, B, IB + S1, JB, OpTypeB, C_Complex(1#), C, IC, JC)
        End If
        If OpTypeA = 0# And OpTypeB <> 0# Then
            Call CMatrixGEMM(M, N, S1, Alpha, A, IA, JA, OpTypeA, B, IB, JB, OpTypeB, Beta, C, IC, JC)
            Call CMatrixGEMM(M, N, S2, Alpha, A, IA, JA + S1, OpTypeA, B, IB, JB + S1, OpTypeB, C_Complex(1#), C, IC, JC)
        End If
        If OpTypeA <> 0# And OpTypeB = 0# Then
            Call CMatrixGEMM(M, N, S1, Alpha, A, IA, JA, OpTypeA, B, IB, JB, OpTypeB, Beta, C, IC, JC)
            Call CMatrixGEMM(M, N, S2, Alpha, A, IA + S1, JA, OpTypeA, B, IB + S1, JB, OpTypeB, C_Complex(1#), C, IC, JC)
        End If
        If OpTypeA <> 0# And OpTypeB <> 0# Then
            Call CMatrixGEMM(M, N, S1, Alpha, A, IA, JA, OpTypeA, B, IB, JB, OpTypeB, Beta, C, IC, JC)
            Call CMatrixGEMM(M, N, S2, Alpha, A, IA + S1, JA, OpTypeA, B, IB, JB + S1, OpTypeB, C_Complex(1#), C, IC, JC)
        End If
        Exit Sub
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Same as CMatrixGEMM, but for real numbers.
'OpType may be only 0 or 1.
'
'  -- ALGLIB routine --
'     16.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixGEMM(ByVal M As Long, _
         ByVal N As Long, _
         ByVal K As Long, _
         ByVal Alpha As Double, _
         ByRef A() As Double, _
         ByVal IA As Long, _
         ByVal JA As Long, _
         ByVal OpTypeA As Long, _
         ByRef B() As Double, _
         ByVal IB As Long, _
         ByVal JB As Long, _
         ByVal OpTypeB As Long, _
         ByVal Beta As Double, _
         ByRef C() As Double, _
         ByVal IC As Long, _
         ByVal JC As Long)
    Dim S1 As Long
    Dim S2 As Long
    Dim BS As Long
    BS = ABLASBlockSize(A)
    If M <= BS And N <= BS And K <= BS Then
        Call RMatrixGEMMK(M, N, K, Alpha, A, IA, JA, OpTypeA, B, IB, JB, OpTypeB, Beta, C, IC, JC)
        Exit Sub
    End If
    If M >= N And M >= K Then
        
        '
        ' A*B = (A1 A2)^T*B
        '
        Call ABLASSplitLength(A, M, S1, S2)
        If OpTypeA = 0# Then
            Call RMatrixGEMM(S1, N, K, Alpha, A, IA, JA, OpTypeA, B, IB, JB, OpTypeB, Beta, C, IC, JC)
            Call RMatrixGEMM(S2, N, K, Alpha, A, IA + S1, JA, OpTypeA, B, IB, JB, OpTypeB, Beta, C, IC + S1, JC)
        Else
            Call RMatrixGEMM(S1, N, K, Alpha, A, IA, JA, OpTypeA, B, IB, JB, OpTypeB, Beta, C, IC, JC)
            Call RMatrixGEMM(S2, N, K, Alpha, A, IA, JA + S1, OpTypeA, B, IB, JB, OpTypeB, Beta, C, IC + S1, JC)
        End If
        Exit Sub
    End If
    If N >= M And N >= K Then
        
        '
        ' A*B = A*(B1 B2)
        '
        Call ABLASSplitLength(A, N, S1, S2)
        If OpTypeB = 0# Then
            Call RMatrixGEMM(M, S1, K, Alpha, A, IA, JA, OpTypeA, B, IB, JB, OpTypeB, Beta, C, IC, JC)
            Call RMatrixGEMM(M, S2, K, Alpha, A, IA, JA, OpTypeA, B, IB, JB + S1, OpTypeB, Beta, C, IC, JC + S1)
        Else
            Call RMatrixGEMM(M, S1, K, Alpha, A, IA, JA, OpTypeA, B, IB, JB, OpTypeB, Beta, C, IC, JC)
            Call RMatrixGEMM(M, S2, K, Alpha, A, IA, JA, OpTypeA, B, IB + S1, JB, OpTypeB, Beta, C, IC, JC + S1)
        End If
        Exit Sub
    End If
    If K >= M And K >= N Then
        
        '
        ' A*B = (A1 A2)*(B1 B2)^T
        '
        Call ABLASSplitLength(A, K, S1, S2)
        If OpTypeA = 0# And OpTypeB = 0# Then
            Call RMatrixGEMM(M, N, S1, Alpha, A, IA, JA, OpTypeA, B, IB, JB, OpTypeB, Beta, C, IC, JC)
            Call RMatrixGEMM(M, N, S2, Alpha, A, IA, JA + S1, OpTypeA, B, IB + S1, JB, OpTypeB, 1#, C, IC, JC)
        End If
        If OpTypeA = 0# And OpTypeB <> 0# Then
            Call RMatrixGEMM(M, N, S1, Alpha, A, IA, JA, OpTypeA, B, IB, JB, OpTypeB, Beta, C, IC, JC)
            Call RMatrixGEMM(M, N, S2, Alpha, A, IA, JA + S1, OpTypeA, B, IB, JB + S1, OpTypeB, 1#, C, IC, JC)
        End If
        If OpTypeA <> 0# And OpTypeB = 0# Then
            Call RMatrixGEMM(M, N, S1, Alpha, A, IA, JA, OpTypeA, B, IB, JB, OpTypeB, Beta, C, IC, JC)
            Call RMatrixGEMM(M, N, S2, Alpha, A, IA + S1, JA, OpTypeA, B, IB + S1, JB, OpTypeB, 1#, C, IC, JC)
        End If
        If OpTypeA <> 0# And OpTypeB <> 0# Then
            Call RMatrixGEMM(M, N, S1, Alpha, A, IA, JA, OpTypeA, B, IB, JB, OpTypeB, Beta, C, IC, JC)
            Call RMatrixGEMM(M, N, S2, Alpha, A, IA + S1, JA, OpTypeA, B, IB, JB + S1, OpTypeB, 1#, C, IC, JC)
        End If
        Exit Sub
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Complex ABLASSplitLength
'
'  -- ALGLIB routine --
'     15.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub ABLASInternalSplitLength(ByVal N As Long, _
         ByVal NB As Long, _
         ByRef N1 As Long, _
         ByRef N2 As Long)
    Dim R As Long
    If N <= NB Then
        
        '
        ' Block size, no further splitting
        '
        N1 = N
        N2 = 0#
    Else
        
        '
        ' Greater than block size
        '
        If N Mod NB <> 0# Then
            
            '
            ' Split remainder
            '
            N2 = N Mod NB
            N1 = N - N2
        Else
            
            '
            ' Split on block boundaries
            '
            N2 = N \ 2#
            N1 = N - N2
            If N1 Mod NB = 0# Then
                Exit Sub
            End If
            R = NB - N1 Mod NB
            N1 = N1 + R
            N2 = N2 - R
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Level 2 variant of CMatrixRightTRSM
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub CMatrixRightTRSM2(ByVal M As Long, _
         ByVal N As Long, _
         ByRef A() As Complex, _
         ByVal I1 As Long, _
         ByVal J1 As Long, _
         ByVal IsUpper As Boolean, _
         ByVal Isunit As Boolean, _
         ByVal OpType As Long, _
         ByRef X() As Complex, _
         ByVal I2 As Long, _
         ByVal J2 As Long)
    Dim i As Long
    Dim j As Long
    Dim VC As Complex
    Dim VD As Complex
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' Special case
    '
    If N * M = 0# Then
        Exit Sub
    End If
    
    '
    ' Try to call fast TRSM
    '
    If CMatrixRightTRSMF(M, N, A, I1, J1, IsUpper, Isunit, OpType, X, I2, J2) Then
        Exit Sub
    End If
    
    '
    ' General case
    '
    If IsUpper Then
        
        '
        ' Upper triangular matrix
        '
        If OpType = 0# Then
            
            '
            ' X*A^(-1)
            '
            For i = 0# To M - 1# Step 1
                For j = 0# To N - 1# Step 1
                    If Isunit Then
                        VD = C_Complex(1#)
                    Else
                        VD = A(I1 + j, J1 + j)
                    End If
                    X(I2 + i, J2 + j) = C_Div(X(I2 + i, J2 + j), VD)
                    If j < N - 1# Then
                        VC = X(I2 + i, J2 + j)
                        i1_ = (J1 + j + 1#) - (J2 + j + 1#)
                        For i_ = J2 + j + 1# To J2 + N - 1# Step 1
                            X(I2 + i, i_) = C_Sub(X(I2 + i, i_), C_Mul(VC, A(I1 + j, i_ + i1_)))
                        Next i_
                    End If
                Next j
            Next i
            Exit Sub
        End If
        If OpType = 1# Then
            
            '
            ' X*A^(-T)
            '
            For i = 0# To M - 1# Step 1
                For j = N - 1# To 0# Step -1
                    VC = C_Complex(0#)
                    VD = C_Complex(1#)
                    If j < N - 1# Then
                        i1_ = (J1 + j + 1#) - (J2 + j + 1#)
                        VC = C_Complex(0#)
                        For i_ = J2 + j + 1# To J2 + N - 1# Step 1
                            VC = C_Add(VC, C_Mul(X(I2 + i, i_), A(I1 + j, i_ + i1_)))
                        Next i_
                    End If
                    If Not Isunit Then
                        VD = A(I1 + j, J1 + j)
                    End If
                    X(I2 + i, J2 + j) = C_Div(C_Sub(X(I2 + i, J2 + j), VC), VD)
                Next j
            Next i
            Exit Sub
        End If
        If OpType = 2# Then
            
            '
            ' X*A^(-H)
            '
            For i = 0# To M - 1# Step 1
                For j = N - 1# To 0# Step -1
                    VC = C_Complex(0#)
                    VD = C_Complex(1#)
                    If j < N - 1# Then
                        i1_ = (J1 + j + 1#) - (J2 + j + 1#)
                        VC = C_Complex(0#)
                        For i_ = J2 + j + 1# To J2 + N - 1# Step 1
                            VC = C_Add(VC, C_Mul(X(I2 + i, i_), Conj(A(I1 + j, i_ + i1_))))
                        Next i_
                    End If
                    If Not Isunit Then
                        VD = Conj(A(I1 + j, J1 + j))
                    End If
                    X(I2 + i, J2 + j) = C_Div(C_Sub(X(I2 + i, J2 + j), VC), VD)
                Next j
            Next i
            Exit Sub
        End If
    Else
        
        '
        ' Lower triangular matrix
        '
        If OpType = 0# Then
            
            '
            ' X*A^(-1)
            '
            For i = 0# To M - 1# Step 1
                For j = N - 1# To 0# Step -1
                    If Isunit Then
                        VD = C_Complex(1#)
                    Else
                        VD = A(I1 + j, J1 + j)
                    End If
                    X(I2 + i, J2 + j) = C_Div(X(I2 + i, J2 + j), VD)
                    If j > 0# Then
                        VC = X(I2 + i, J2 + j)
                        i1_ = (J1) - (J2)
                        For i_ = J2 To J2 + j - 1# Step 1
                            X(I2 + i, i_) = C_Sub(X(I2 + i, i_), C_Mul(VC, A(I1 + j, i_ + i1_)))
                        Next i_
                    End If
                Next j
            Next i
            Exit Sub
        End If
        If OpType = 1# Then
            
            '
            ' X*A^(-T)
            '
            For i = 0# To M - 1# Step 1
                For j = 0# To N - 1# Step 1
                    VC = C_Complex(0#)
                    VD = C_Complex(1#)
                    If j > 0# Then
                        i1_ = (J1) - (J2)
                        VC = C_Complex(0#)
                        For i_ = J2 To J2 + j - 1# Step 1
                            VC = C_Add(VC, C_Mul(X(I2 + i, i_), A(I1 + j, i_ + i1_)))
                        Next i_
                    End If
                    If Not Isunit Then
                        VD = A(I1 + j, J1 + j)
                    End If
                    X(I2 + i, J2 + j) = C_Div(C_Sub(X(I2 + i, J2 + j), VC), VD)
                Next j
            Next i
            Exit Sub
        End If
        If OpType = 2# Then
            
            '
            ' X*A^(-H)
            '
            For i = 0# To M - 1# Step 1
                For j = 0# To N - 1# Step 1
                    VC = C_Complex(0#)
                    VD = C_Complex(1#)
                    If j > 0# Then
                        i1_ = (J1) - (J2)
                        VC = C_Complex(0#)
                        For i_ = J2 To J2 + j - 1# Step 1
                            VC = C_Add(VC, C_Mul(X(I2 + i, i_), Conj(A(I1 + j, i_ + i1_))))
                        Next i_
                    End If
                    If Not Isunit Then
                        VD = Conj(A(I1 + j, J1 + j))
                    End If
                    X(I2 + i, J2 + j) = C_Div(C_Sub(X(I2 + i, J2 + j), VC), VD)
                Next j
            Next i
            Exit Sub
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Level-2 subroutine
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub CMatrixLeftTRSM2(ByVal M As Long, _
         ByVal N As Long, _
         ByRef A() As Complex, _
         ByVal I1 As Long, _
         ByVal J1 As Long, _
         ByVal IsUpper As Boolean, _
         ByVal Isunit As Boolean, _
         ByVal OpType As Long, _
         ByRef X() As Complex, _
         ByVal I2 As Long, _
         ByVal J2 As Long)
    Dim i As Long
    Dim j As Long
    Dim VC As Complex
    Dim VD As Complex
    Dim i_ As Long
    
    '
    ' Special case
    '
    If N * M = 0# Then
        Exit Sub
    End If
    
    '
    ' Try to call fast TRSM
    '
    If CMatrixLeftTRSMF(M, N, A, I1, J1, IsUpper, Isunit, OpType, X, I2, J2) Then
        Exit Sub
    End If
    
    '
    ' General case
    '
    If IsUpper Then
        
        '
        ' Upper triangular matrix
        '
        If OpType = 0# Then
            
            '
            ' A^(-1)*X
            '
            For i = M - 1# To 0# Step -1
                For j = i + 1# To M - 1# Step 1
                    VC = A(I1 + i, J1 + j)
                    For i_ = J2 To J2 + N - 1# Step 1
                        X(I2 + i, i_) = C_Sub(X(I2 + i, i_), C_Mul(VC, X(I2 + j, i_)))
                    Next i_
                Next j
                If Not Isunit Then
                    VD = C_RDiv(1#, A(I1 + i, J1 + i))
                    For i_ = J2 To J2 + N - 1# Step 1
                        X(I2 + i, i_) = C_Mul(VD, X(I2 + i, i_))
                    Next i_
                End If
            Next i
            Exit Sub
        End If
        If OpType = 1# Then
            
            '
            ' A^(-T)*X
            '
            For i = 0# To M - 1# Step 1
                If Isunit Then
                    VD = C_Complex(1#)
                Else
                    VD = C_RDiv(1#, A(I1 + i, J1 + i))
                End If
                For i_ = J2 To J2 + N - 1# Step 1
                    X(I2 + i, i_) = C_Mul(VD, X(I2 + i, i_))
                Next i_
                For j = i + 1# To M - 1# Step 1
                    VC = A(I1 + i, J1 + j)
                    For i_ = J2 To J2 + N - 1# Step 1
                        X(I2 + j, i_) = C_Sub(X(I2 + j, i_), C_Mul(VC, X(I2 + i, i_)))
                    Next i_
                Next j
            Next i
            Exit Sub
        End If
        If OpType = 2# Then
            
            '
            ' A^(-H)*X
            '
            For i = 0# To M - 1# Step 1
                If Isunit Then
                    VD = C_Complex(1#)
                Else
                    VD = C_RDiv(1#, Conj(A(I1 + i, J1 + i)))
                End If
                For i_ = J2 To J2 + N - 1# Step 1
                    X(I2 + i, i_) = C_Mul(VD, X(I2 + i, i_))
                Next i_
                For j = i + 1# To M - 1# Step 1
                    VC = Conj(A(I1 + i, J1 + j))
                    For i_ = J2 To J2 + N - 1# Step 1
                        X(I2 + j, i_) = C_Sub(X(I2 + j, i_), C_Mul(VC, X(I2 + i, i_)))
                    Next i_
                Next j
            Next i
            Exit Sub
        End If
    Else
        
        '
        ' Lower triangular matrix
        '
        If OpType = 0# Then
            
            '
            ' A^(-1)*X
            '
            For i = 0# To M - 1# Step 1
                For j = 0# To i - 1# Step 1
                    VC = A(I1 + i, J1 + j)
                    For i_ = J2 To J2 + N - 1# Step 1
                        X(I2 + i, i_) = C_Sub(X(I2 + i, i_), C_Mul(VC, X(I2 + j, i_)))
                    Next i_
                Next j
                If Isunit Then
                    VD = C_Complex(1#)
                Else
                    VD = C_RDiv(1#, A(I1 + j, J1 + j))
                End If
                For i_ = J2 To J2 + N - 1# Step 1
                    X(I2 + i, i_) = C_Mul(VD, X(I2 + i, i_))
                Next i_
            Next i
            Exit Sub
        End If
        If OpType = 1# Then
            
            '
            ' A^(-T)*X
            '
            For i = M - 1# To 0# Step -1
                If Isunit Then
                    VD = C_Complex(1#)
                Else
                    VD = C_RDiv(1#, A(I1 + i, J1 + i))
                End If
                For i_ = J2 To J2 + N - 1# Step 1
                    X(I2 + i, i_) = C_Mul(VD, X(I2 + i, i_))
                Next i_
                For j = i - 1# To 0# Step -1
                    VC = A(I1 + i, J1 + j)
                    For i_ = J2 To J2 + N - 1# Step 1
                        X(I2 + j, i_) = C_Sub(X(I2 + j, i_), C_Mul(VC, X(I2 + i, i_)))
                    Next i_
                Next j
            Next i
            Exit Sub
        End If
        If OpType = 2# Then
            
            '
            ' A^(-H)*X
            '
            For i = M - 1# To 0# Step -1
                If Isunit Then
                    VD = C_Complex(1#)
                Else
                    VD = C_RDiv(1#, Conj(A(I1 + i, J1 + i)))
                End If
                For i_ = J2 To J2 + N - 1# Step 1
                    X(I2 + i, i_) = C_Mul(VD, X(I2 + i, i_))
                Next i_
                For j = i - 1# To 0# Step -1
                    VC = Conj(A(I1 + i, J1 + j))
                    For i_ = J2 To J2 + N - 1# Step 1
                        X(I2 + j, i_) = C_Sub(X(I2 + j, i_), C_Mul(VC, X(I2 + i, i_)))
                    Next i_
                Next j
            Next i
            Exit Sub
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Level 2 subroutine
'
'  -- ALGLIB routine --
'     15.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub RMatrixRightTRSM2(ByVal M As Long, _
         ByVal N As Long, _
         ByRef A() As Double, _
         ByVal I1 As Long, _
         ByVal J1 As Long, _
         ByVal IsUpper As Boolean, _
         ByVal Isunit As Boolean, _
         ByVal OpType As Long, _
         ByRef X() As Double, _
         ByVal I2 As Long, _
         ByVal J2 As Long)
    Dim i As Long
    Dim j As Long
    Dim VR As Double
    Dim VD As Double
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' Special case
    '
    If N * M = 0# Then
        Exit Sub
    End If
    
    '
    ' Try to use "fast" code
    '
    If RMatrixRightTRSMF(M, N, A, I1, J1, IsUpper, Isunit, OpType, X, I2, J2) Then
        Exit Sub
    End If
    
    '
    ' General case
    '
    If IsUpper Then
        
        '
        ' Upper triangular matrix
        '
        If OpType = 0# Then
            
            '
            ' X*A^(-1)
            '
            For i = 0# To M - 1# Step 1
                For j = 0# To N - 1# Step 1
                    If Isunit Then
                        VD = 1#
                    Else
                        VD = A(I1 + j, J1 + j)
                    End If
                    X(I2 + i, J2 + j) = X(I2 + i, J2 + j) / VD
                    If j < N - 1# Then
                        VR = X(I2 + i, J2 + j)
                        i1_ = (J1 + j + 1#) - (J2 + j + 1#)
                        For i_ = J2 + j + 1# To J2 + N - 1# Step 1
                            X(I2 + i, i_) = X(I2 + i, i_) - VR * A(I1 + j, i_ + i1_)
                        Next i_
                    End If
                Next j
            Next i
            Exit Sub
        End If
        If OpType = 1# Then
            
            '
            ' X*A^(-T)
            '
            For i = 0# To M - 1# Step 1
                For j = N - 1# To 0# Step -1
                    VR = 0#
                    VD = 1#
                    If j < N - 1# Then
                        i1_ = (J1 + j + 1#) - (J2 + j + 1#)
                        VR = 0#
                        For i_ = J2 + j + 1# To J2 + N - 1# Step 1
                            VR = VR + X(I2 + i, i_) * A(I1 + j, i_ + i1_)
                        Next i_
                    End If
                    If Not Isunit Then
                        VD = A(I1 + j, J1 + j)
                    End If
                    X(I2 + i, J2 + j) = (X(I2 + i, J2 + j) - VR) / VD
                Next j
            Next i
            Exit Sub
        End If
    Else
        
        '
        ' Lower triangular matrix
        '
        If OpType = 0# Then
            
            '
            ' X*A^(-1)
            '
            For i = 0# To M - 1# Step 1
                For j = N - 1# To 0# Step -1
                    If Isunit Then
                        VD = 1#
                    Else
                        VD = A(I1 + j, J1 + j)
                    End If
                    X(I2 + i, J2 + j) = X(I2 + i, J2 + j) / VD
                    If j > 0# Then
                        VR = X(I2 + i, J2 + j)
                        i1_ = (J1) - (J2)
                        For i_ = J2 To J2 + j - 1# Step 1
                            X(I2 + i, i_) = X(I2 + i, i_) - VR * A(I1 + j, i_ + i1_)
                        Next i_
                    End If
                Next j
            Next i
            Exit Sub
        End If
        If OpType = 1# Then
            
            '
            ' X*A^(-T)
            '
            For i = 0# To M - 1# Step 1
                For j = 0# To N - 1# Step 1
                    VR = 0#
                    VD = 1#
                    If j > 0# Then
                        i1_ = (J1) - (J2)
                        VR = 0#
                        For i_ = J2 To J2 + j - 1# Step 1
                            VR = VR + X(I2 + i, i_) * A(I1 + j, i_ + i1_)
                        Next i_
                    End If
                    If Not Isunit Then
                        VD = A(I1 + j, J1 + j)
                    End If
                    X(I2 + i, J2 + j) = (X(I2 + i, J2 + j) - VR) / VD
                Next j
            Next i
            Exit Sub
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Level 2 subroutine
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub RMatrixLeftTRSM2(ByVal M As Long, _
         ByVal N As Long, _
         ByRef A() As Double, _
         ByVal I1 As Long, _
         ByVal J1 As Long, _
         ByVal IsUpper As Boolean, _
         ByVal Isunit As Boolean, _
         ByVal OpType As Long, _
         ByRef X() As Double, _
         ByVal I2 As Long, _
         ByVal J2 As Long)
    Dim i As Long
    Dim j As Long
    Dim VR As Double
    Dim VD As Double
    Dim i_ As Long
    
    '
    ' Special case
    '
    If N * M = 0# Then
        Exit Sub
    End If
    
    '
    ' Try fast code
    '
    If RMatrixLeftTRSMF(M, N, A, I1, J1, IsUpper, Isunit, OpType, X, I2, J2) Then
        Exit Sub
    End If
    
    '
    ' General case
    '
    If IsUpper Then
        
        '
        ' Upper triangular matrix
        '
        If OpType = 0# Then
            
            '
            ' A^(-1)*X
            '
            For i = M - 1# To 0# Step -1
                For j = i + 1# To M - 1# Step 1
                    VR = A(I1 + i, J1 + j)
                    For i_ = J2 To J2 + N - 1# Step 1
                        X(I2 + i, i_) = X(I2 + i, i_) - VR * X(I2 + j, i_)
                    Next i_
                Next j
                If Not Isunit Then
                    VD = 1# / A(I1 + i, J1 + i)
                    For i_ = J2 To J2 + N - 1# Step 1
                        X(I2 + i, i_) = VD * X(I2 + i, i_)
                    Next i_
                End If
            Next i
            Exit Sub
        End If
        If OpType = 1# Then
            
            '
            ' A^(-T)*X
            '
            For i = 0# To M - 1# Step 1
                If Isunit Then
                    VD = 1#
                Else
                    VD = 1# / A(I1 + i, J1 + i)
                End If
                For i_ = J2 To J2 + N - 1# Step 1
                    X(I2 + i, i_) = VD * X(I2 + i, i_)
                Next i_
                For j = i + 1# To M - 1# Step 1
                    VR = A(I1 + i, J1 + j)
                    For i_ = J2 To J2 + N - 1# Step 1
                        X(I2 + j, i_) = X(I2 + j, i_) - VR * X(I2 + i, i_)
                    Next i_
                Next j
            Next i
            Exit Sub
        End If
    Else
        
        '
        ' Lower triangular matrix
        '
        If OpType = 0# Then
            
            '
            ' A^(-1)*X
            '
            For i = 0# To M - 1# Step 1
                For j = 0# To i - 1# Step 1
                    VR = A(I1 + i, J1 + j)
                    For i_ = J2 To J2 + N - 1# Step 1
                        X(I2 + i, i_) = X(I2 + i, i_) - VR * X(I2 + j, i_)
                    Next i_
                Next j
                If Isunit Then
                    VD = 1#
                Else
                    VD = 1# / A(I1 + j, J1 + j)
                End If
                For i_ = J2 To J2 + N - 1# Step 1
                    X(I2 + i, i_) = VD * X(I2 + i, i_)
                Next i_
            Next i
            Exit Sub
        End If
        If OpType = 1# Then
            
            '
            ' A^(-T)*X
            '
            For i = M - 1# To 0# Step -1
                If Isunit Then
                    VD = 1#
                Else
                    VD = 1# / A(I1 + i, J1 + i)
                End If
                For i_ = J2 To J2 + N - 1# Step 1
                    X(I2 + i, i_) = VD * X(I2 + i, i_)
                Next i_
                For j = i - 1# To 0# Step -1
                    VR = A(I1 + i, J1 + j)
                    For i_ = J2 To J2 + N - 1# Step 1
                        X(I2 + j, i_) = X(I2 + j, i_) - VR * X(I2 + i, i_)
                    Next i_
                Next j
            Next i
            Exit Sub
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Level 2 subroutine
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub CMatrixSYRK2(ByVal N As Long, _
         ByVal K As Long, _
         ByVal Alpha As Double, _
         ByRef A() As Complex, _
         ByVal IA As Long, _
         ByVal JA As Long, _
         ByVal OpTypeA As Long, _
         ByVal Beta As Double, _
         ByRef C() As Complex, _
         ByVal IC As Long, _
         ByVal JC As Long, _
         ByVal IsUpper As Boolean)
    Dim i As Long
    Dim j As Long
    Dim J1 As Long
    Dim J2 As Long
    Dim V As Complex
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' Fast exit (nothing to be done)
    '
    If (Alpha = 0# Or K = 0#) And Beta = 1# Then
        Exit Sub
    End If
    
    '
    ' Try to call fast SYRK
    '
    If CMatrixSYRKF(N, K, Alpha, A, IA, JA, OpTypeA, Beta, C, IC, JC, IsUpper) Then
        Exit Sub
    End If
    
    '
    ' SYRK
    '
    If OpTypeA = 0# Then
        
        '
        ' C=alpha*A*A^H+beta*C
        '
        For i = 0# To N - 1# Step 1
            If IsUpper Then
                J1 = i
                J2 = N - 1#
            Else
                J1 = 0#
                J2 = i
            End If
            For j = J1 To J2 Step 1
                If Alpha <> 0# And K > 0# Then
                    V = C_Complex(0#)
                    For i_ = JA To JA + K - 1# Step 1
                        V = C_Add(V, C_Mul(A(IA + i, i_), Conj(A(IA + j, i_))))
                    Next i_
                Else
                    V = C_Complex(0#)
                End If
                If Beta = 0# Then
                    C(IC + i, JC + j) = C_MulR(V, Alpha)
                Else
                    C(IC + i, JC + j) = C_Add(C_MulR(C(IC + i, JC + j), Beta), C_MulR(V, Alpha))
                End If
            Next j
        Next i
        Exit Sub
    Else
        
        '
        ' C=alpha*A^H*A+beta*C
        '
        For i = 0# To N - 1# Step 1
            If IsUpper Then
                J1 = i
                J2 = N - 1#
            Else
                J1 = 0#
                J2 = i
            End If
            If Beta = 0# Then
                For j = J1 To J2 Step 1
                    C(IC + i, JC + j) = C_Complex(0#)
                Next j
            Else
                For i_ = JC + J1 To JC + J2 Step 1
                    C(IC + i, i_) = C_MulR(C(IC + i, i_), Beta)
                Next i_
            End If
        Next i
        For i = 0# To K - 1# Step 1
            For j = 0# To N - 1# Step 1
                If IsUpper Then
                    J1 = j
                    J2 = N - 1#
                Else
                    J1 = 0#
                    J2 = j
                End If
                V = C_MulR(Conj(A(IA + i, JA + j)), Alpha)
                i1_ = (JA + J1) - (JC + J1)
                For i_ = JC + J1 To JC + J2 Step 1
                    C(IC + j, i_) = C_Add(C(IC + j, i_), C_Mul(V, A(IA + i, i_ + i1_)))
                Next i_
            Next j
        Next i
        Exit Sub
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Level 2 subrotuine
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub RMatrixSYRK2(ByVal N As Long, _
         ByVal K As Long, _
         ByVal Alpha As Double, _
         ByRef A() As Double, _
         ByVal IA As Long, _
         ByVal JA As Long, _
         ByVal OpTypeA As Long, _
         ByVal Beta As Double, _
         ByRef C() As Double, _
         ByVal IC As Long, _
         ByVal JC As Long, _
         ByVal IsUpper As Boolean)
    Dim i As Long
    Dim j As Long
    Dim J1 As Long
    Dim J2 As Long
    Dim V As Double
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' Fast exit (nothing to be done)
    '
    If (Alpha = 0# Or K = 0#) And Beta = 1# Then
        Exit Sub
    End If
    
    '
    ' Try to call fast SYRK
    '
    If RMatrixSYRKF(N, K, Alpha, A, IA, JA, OpTypeA, Beta, C, IC, JC, IsUpper) Then
        Exit Sub
    End If
    
    '
    ' SYRK
    '
    If OpTypeA = 0# Then
        
        '
        ' C=alpha*A*A^H+beta*C
        '
        For i = 0# To N - 1# Step 1
            If IsUpper Then
                J1 = i
                J2 = N - 1#
            Else
                J1 = 0#
                J2 = i
            End If
            For j = J1 To J2 Step 1
                If Alpha <> 0# And K > 0# Then
                    V = 0#
                    For i_ = JA To JA + K - 1# Step 1
                        V = V + A(IA + i, i_) * A(IA + j, i_)
                    Next i_
                Else
                    V = 0#
                End If
                If Beta = 0# Then
                    C(IC + i, JC + j) = Alpha * V
                Else
                    C(IC + i, JC + j) = Beta * C(IC + i, JC + j) + Alpha * V
                End If
            Next j
        Next i
        Exit Sub
    Else
        
        '
        ' C=alpha*A^H*A+beta*C
        '
        For i = 0# To N - 1# Step 1
            If IsUpper Then
                J1 = i
                J2 = N - 1#
            Else
                J1 = 0#
                J2 = i
            End If
            If Beta = 0# Then
                For j = J1 To J2 Step 1
                    C(IC + i, JC + j) = 0#
                Next j
            Else
                For i_ = JC + J1 To JC + J2 Step 1
                    C(IC + i, i_) = Beta * C(IC + i, i_)
                Next i_
            End If
        Next i
        For i = 0# To K - 1# Step 1
            For j = 0# To N - 1# Step 1
                If IsUpper Then
                    J1 = j
                    J2 = N - 1#
                Else
                    J1 = 0#
                    J2 = j
                End If
                V = Alpha * A(IA + i, JA + j)
                i1_ = (JA + J1) - (JC + J1)
                For i_ = JC + J1 To JC + J2 Step 1
                    C(IC + j, i_) = C(IC + j, i_) + V * A(IA + i, i_ + i1_)
                Next i_
            Next j
        Next i
        Exit Sub
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'GEMM kernel
'
'  -- ALGLIB routine --
'     16.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub CMatrixGEMMK(ByVal M As Long, _
         ByVal N As Long, _
         ByVal K As Long, _
         ByRef Alpha_ As Complex, _
         ByRef A() As Complex, _
         ByVal IA As Long, _
         ByVal JA As Long, _
         ByVal OpTypeA As Long, _
         ByRef B() As Complex, _
         ByVal IB As Long, _
         ByVal JB As Long, _
         ByVal OpTypeB As Long, _
         ByRef Beta_ As Complex, _
         ByRef C() As Complex, _
         ByVal IC As Long, _
         ByVal JC As Long)
    Dim Alpha As Complex
    Dim Beta As Complex
    Dim i As Long
    Dim j As Long
    Dim V As Complex
    Dim i_ As Long
    Dim i1_ As Long
    Alpha = Alpha_
    Beta = Beta_
    
    '
    ' Special case
    '
    If M * N = 0# Then
        Exit Sub
    End If
    
    '
    ' Try optimized code
    '
    If CMatrixGEMMF(M, N, K, Alpha, A, IA, JA, OpTypeA, B, IB, JB, OpTypeB, Beta, C, IC, JC) Then
        Exit Sub
    End If
    
    '
    ' Another special case
    '
    If K = 0# Then
        If C_NotEqualR(Beta, 0#) Then
            For i = 0# To M - 1# Step 1
                For j = 0# To N - 1# Step 1
                    C(IC + i, JC + j) = C_Mul(Beta, C(IC + i, JC + j))
                Next j
            Next i
        Else
            For i = 0# To M - 1# Step 1
                For j = 0# To N - 1# Step 1
                    C(IC + i, JC + j) = C_Complex(0#)
                Next j
            Next i
        End If
        Exit Sub
    End If
    
    '
    ' General case
    '
    If OpTypeA = 0# And OpTypeB <> 0# Then
        
        '
        ' A*B'
        '
        For i = 0# To M - 1# Step 1
            For j = 0# To N - 1# Step 1
                If K = 0# Or C_EqualR(Alpha, 0#) Then
                    V = C_Complex(0#)
                Else
                    If OpTypeB = 1# Then
                        i1_ = (JB) - (JA)
                        V = C_Complex(0#)
                        For i_ = JA To JA + K - 1# Step 1
                            V = C_Add(V, C_Mul(A(IA + i, i_), B(IB + j, i_ + i1_)))
                        Next i_
                    Else
                        i1_ = (JB) - (JA)
                        V = C_Complex(0#)
                        For i_ = JA To JA + K - 1# Step 1
                            V = C_Add(V, C_Mul(A(IA + i, i_), Conj(B(IB + j, i_ + i1_))))
                        Next i_
                    End If
                End If
                If C_EqualR(Beta, 0#) Then
                    C(IC + i, JC + j) = C_Mul(Alpha, V)
                Else
                    C(IC + i, JC + j) = C_Add(C_Mul(Beta, C(IC + i, JC + j)), C_Mul(Alpha, V))
                End If
            Next j
        Next i
        Exit Sub
    End If
    If OpTypeA = 0# And OpTypeB = 0# Then
        
        '
        ' A*B
        '
        For i = 0# To M - 1# Step 1
            If C_NotEqualR(Beta, 0#) Then
                For i_ = JC To JC + N - 1# Step 1
                    C(IC + i, i_) = C_Mul(Beta, C(IC + i, i_))
                Next i_
            Else
                For j = 0# To N - 1# Step 1
                    C(IC + i, JC + j) = C_Complex(0#)
                Next j
            End If
            If C_NotEqualR(Alpha, 0#) Then
                For j = 0# To K - 1# Step 1
                    V = C_Mul(Alpha, A(IA + i, JA + j))
                    i1_ = (JB) - (JC)
                    For i_ = JC To JC + N - 1# Step 1
                        C(IC + i, i_) = C_Add(C(IC + i, i_), C_Mul(V, B(IB + j, i_ + i1_)))
                    Next i_
                Next j
            End If
        Next i
        Exit Sub
    End If
    If OpTypeA <> 0# And OpTypeB <> 0# Then
        
        '
        ' A'*B'
        '
        For i = 0# To M - 1# Step 1
            For j = 0# To N - 1# Step 1
                If C_EqualR(Alpha, 0#) Then
                    V = C_Complex(0#)
                Else
                    If OpTypeA = 1# Then
                        If OpTypeB = 1# Then
                            i1_ = (JB) - (IA)
                            V = C_Complex(0#)
                            For i_ = IA To IA + K - 1# Step 1
                                V = C_Add(V, C_Mul(A(i_, JA + i), B(IB + j, i_ + i1_)))
                            Next i_
                        Else
                            i1_ = (JB) - (IA)
                            V = C_Complex(0#)
                            For i_ = IA To IA + K - 1# Step 1
                                V = C_Add(V, C_Mul(A(i_, JA + i), Conj(B(IB + j, i_ + i1_))))
                            Next i_
                        End If
                    Else
                        If OpTypeB = 1# Then
                            i1_ = (JB) - (IA)
                            V = C_Complex(0#)
                            For i_ = IA To IA + K - 1# Step 1
                                V = C_Add(V, C_Mul(Conj(A(i_, JA + i)), B(IB + j, i_ + i1_)))
                            Next i_
                        Else
                            i1_ = (JB) - (IA)
                            V = C_Complex(0#)
                            For i_ = IA To IA + K - 1# Step 1
                                V = C_Add(V, C_Mul(Conj(A(i_, JA + i)), Conj(B(IB + j, i_ + i1_))))
                            Next i_
                        End If
                    End If
                End If
                If C_EqualR(Beta, 0#) Then
                    C(IC + i, JC + j) = C_Mul(Alpha, V)
                Else
                    C(IC + i, JC + j) = C_Add(C_Mul(Beta, C(IC + i, JC + j)), C_Mul(Alpha, V))
                End If
            Next j
        Next i
        Exit Sub
    End If
    If OpTypeA <> 0# And OpTypeB = 0# Then
        
        '
        ' A'*B
        '
        If C_EqualR(Beta, 0#) Then
            For i = 0# To M - 1# Step 1
                For j = 0# To N - 1# Step 1
                    C(IC + i, JC + j) = C_Complex(0#)
                Next j
            Next i
        Else
            For i = 0# To M - 1# Step 1
                For i_ = JC To JC + N - 1# Step 1
                    C(IC + i, i_) = C_Mul(Beta, C(IC + i, i_))
                Next i_
            Next i
        End If
        If C_NotEqualR(Alpha, 0#) Then
            For j = 0# To K - 1# Step 1
                For i = 0# To M - 1# Step 1
                    If OpTypeA = 1# Then
                        V = C_Mul(Alpha, A(IA + j, JA + i))
                    Else
                        V = C_Mul(Alpha, Conj(A(IA + j, JA + i)))
                    End If
                    i1_ = (JB) - (JC)
                    For i_ = JC To JC + N - 1# Step 1
                        C(IC + i, i_) = C_Add(C(IC + i, i_), C_Mul(V, B(IB + j, i_ + i1_)))
                    Next i_
                Next i
            Next j
        End If
        Exit Sub
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'GEMM kernel
'
'  -- ALGLIB routine --
'     16.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub RMatrixGEMMK(ByVal M As Long, _
         ByVal N As Long, _
         ByVal K As Long, _
         ByVal Alpha As Double, _
         ByRef A() As Double, _
         ByVal IA As Long, _
         ByVal JA As Long, _
         ByVal OpTypeA As Long, _
         ByRef B() As Double, _
         ByVal IB As Long, _
         ByVal JB As Long, _
         ByVal OpTypeB As Long, _
         ByVal Beta As Double, _
         ByRef C() As Double, _
         ByVal IC As Long, _
         ByVal JC As Long)
    Dim i As Long
    Dim j As Long
    Dim V As Double
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' if matrix size is zero
    '
    If M * N = 0# Then
        Exit Sub
    End If
    
    '
    ' Try optimized code
    '
    If RMatrixGEMMF(M, N, K, Alpha, A, IA, JA, OpTypeA, B, IB, JB, OpTypeB, Beta, C, IC, JC) Then
        Exit Sub
    End If
    
    '
    ' if K=0, then C=Beta*C
    '
    If K = 0# Then
        If Beta <> 1# Then
            If Beta <> 0# Then
                For i = 0# To M - 1# Step 1
                    For j = 0# To N - 1# Step 1
                        C(IC + i, JC + j) = Beta * C(IC + i, JC + j)
                    Next j
                Next i
            Else
                For i = 0# To M - 1# Step 1
                    For j = 0# To N - 1# Step 1
                        C(IC + i, JC + j) = 0#
                    Next j
                Next i
            End If
        End If
        Exit Sub
    End If
    
    '
    ' General case
    '
    If OpTypeA = 0# And OpTypeB <> 0# Then
        
        '
        ' A*B'
        '
        For i = 0# To M - 1# Step 1
            For j = 0# To N - 1# Step 1
                If K = 0# Or Alpha = 0# Then
                    V = 0#
                Else
                    i1_ = (JB) - (JA)
                    V = 0#
                    For i_ = JA To JA + K - 1# Step 1
                        V = V + A(IA + i, i_) * B(IB + j, i_ + i1_)
                    Next i_
                End If
                If Beta = 0# Then
                    C(IC + i, JC + j) = Alpha * V
                Else
                    C(IC + i, JC + j) = Beta * C(IC + i, JC + j) + Alpha * V
                End If
            Next j
        Next i
        Exit Sub
    End If
    If OpTypeA = 0# And OpTypeB = 0# Then
        
        '
        ' A*B
        '
        For i = 0# To M - 1# Step 1
            If Beta <> 0# Then
                For i_ = JC To JC + N - 1# Step 1
                    C(IC + i, i_) = Beta * C(IC + i, i_)
                Next i_
            Else
                For j = 0# To N - 1# Step 1
                    C(IC + i, JC + j) = 0#
                Next j
            End If
            If Alpha <> 0# Then
                For j = 0# To K - 1# Step 1
                    V = Alpha * A(IA + i, JA + j)
                    i1_ = (JB) - (JC)
                    For i_ = JC To JC + N - 1# Step 1
                        C(IC + i, i_) = C(IC + i, i_) + V * B(IB + j, i_ + i1_)
                    Next i_
                Next j
            End If
        Next i
        Exit Sub
    End If
    If OpTypeA <> 0# And OpTypeB <> 0# Then
        
        '
        ' A'*B'
        '
        For i = 0# To M - 1# Step 1
            For j = 0# To N - 1# Step 1
                If Alpha = 0# Then
                    V = 0#
                Else
                    i1_ = (JB) - (IA)
                    V = 0#
                    For i_ = IA To IA + K - 1# Step 1
                        V = V + A(i_, JA + i) * B(IB + j, i_ + i1_)
                    Next i_
                End If
                If Beta = 0# Then
                    C(IC + i, JC + j) = Alpha * V
                Else
                    C(IC + i, JC + j) = Beta * C(IC + i, JC + j) + Alpha * V
                End If
            Next j
        Next i
        Exit Sub
    End If
    If OpTypeA <> 0# And OpTypeB = 0# Then
        
        '
        ' A'*B
        '
        If Beta = 0# Then
            For i = 0# To M - 1# Step 1
                For j = 0# To N - 1# Step 1
                    C(IC + i, JC + j) = 0#
                Next j
            Next i
        Else
            For i = 0# To M - 1# Step 1
                For i_ = JC To JC + N - 1# Step 1
                    C(IC + i, i_) = Beta * C(IC + i, i_)
                Next i_
            Next i
        End If
        If Alpha <> 0# Then
            For j = 0# To K - 1# Step 1
                For i = 0# To M - 1# Step 1
                    V = Alpha * A(IA + j, JA + i)
                    i1_ = (JB) - (JC)
                    For i_ = JC To JC + N - 1# Step 1
                        C(IC + i, i_) = C(IC + i, i_) + V * B(IB + j, i_ + i1_)
                    Next i_
                Next i
            Next j
        End If
        Exit Sub
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2009, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Fast kernel
'
'  -- ALGLIB routine --
'     19.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function CMatrixRank1F(ByVal M As Long, _
         ByVal N As Long, _
         ByRef A() As Complex, _
         ByVal IA As Long, _
         ByVal JA As Long, _
         ByRef U() As Complex, _
         ByVal IU As Long, _
         ByRef V() As Complex, _
         ByVal IV As Long) As Boolean
    Dim Result As Boolean
    Result = False
    CMatrixRank1F = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Fast kernel
'
'  -- ALGLIB routine --
'     19.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function RMatrixRank1F(ByVal M As Long, _
         ByVal N As Long, _
         ByRef A() As Double, _
         ByVal IA As Long, _
         ByVal JA As Long, _
         ByRef U() As Double, _
         ByVal IU As Long, _
         ByRef V() As Double, _
         ByVal IV As Long) As Boolean
    Dim Result As Boolean
    Result = False
    RMatrixRank1F = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Fast kernel
'
'  -- ALGLIB routine --
'     19.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function CMatrixMVF(ByVal M As Long, _
         ByVal N As Long, _
         ByRef A() As Complex, _
         ByVal IA As Long, _
         ByVal JA As Long, _
         ByVal OpA As Long, _
         ByRef X() As Complex, _
         ByVal IX As Long, _
         ByRef y() As Complex, _
         ByVal IY As Long) As Boolean
    Dim Result As Boolean
    Result = False
    CMatrixMVF = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Fast kernel
'
'  -- ALGLIB routine --
'     19.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function RMatrixMVF(ByVal M As Long, _
         ByVal N As Long, _
         ByRef A() As Double, _
         ByVal IA As Long, _
         ByVal JA As Long, _
         ByVal OpA As Long, _
         ByRef X() As Double, _
         ByVal IX As Long, _
         ByRef y() As Double, _
         ByVal IY As Long) As Boolean
    Dim Result As Boolean
    Result = False
    RMatrixMVF = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Fast kernel
'
'  -- ALGLIB routine --
'     19.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function CMatrixRightTRSMF(ByVal M As Long, _
         ByVal N As Long, _
         ByRef A() As Complex, _
         ByVal I1 As Long, _
         ByVal J1 As Long, _
         ByVal IsUpper As Boolean, _
         ByVal Isunit As Boolean, _
         ByVal OpType As Long, _
         ByRef X() As Complex, _
         ByVal I2 As Long, _
         ByVal J2 As Long) As Boolean
    Dim Result As Boolean
    Result = False
    CMatrixRightTRSMF = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Fast kernel
'
'  -- ALGLIB routine --
'     19.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function CMatrixLeftTRSMF(ByVal M As Long, _
         ByVal N As Long, _
         ByRef A() As Complex, _
         ByVal I1 As Long, _
         ByVal J1 As Long, _
         ByVal IsUpper As Boolean, _
         ByVal Isunit As Boolean, _
         ByVal OpType As Long, _
         ByRef X() As Complex, _
         ByVal I2 As Long, _
         ByVal J2 As Long) As Boolean
    Dim Result As Boolean
    Result = False
    CMatrixLeftTRSMF = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Fast kernel
'
'  -- ALGLIB routine --
'     19.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function RMatrixRightTRSMF(ByVal M As Long, _
         ByVal N As Long, _
         ByRef A() As Double, _
         ByVal I1 As Long, _
         ByVal J1 As Long, _
         ByVal IsUpper As Boolean, _
         ByVal Isunit As Boolean, _
         ByVal OpType As Long, _
         ByRef X() As Double, _
         ByVal I2 As Long, _
         ByVal J2 As Long) As Boolean
    Dim Result As Boolean
    Result = False
    RMatrixRightTRSMF = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Fast kernel
'
'  -- ALGLIB routine --
'     19.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function RMatrixLeftTRSMF(ByVal M As Long, _
         ByVal N As Long, _
         ByRef A() As Double, _
         ByVal I1 As Long, _
         ByVal J1 As Long, _
         ByVal IsUpper As Boolean, _
         ByVal Isunit As Boolean, _
         ByVal OpType As Long, _
         ByRef X() As Double, _
         ByVal I2 As Long, _
         ByVal J2 As Long) As Boolean
    Dim Result As Boolean
    Result = False
    RMatrixLeftTRSMF = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Fast kernel
'
'  -- ALGLIB routine --
'     19.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function CMatrixSYRKF(ByVal N As Long, _
         ByVal K As Long, _
         ByVal Alpha As Double, _
         ByRef A() As Complex, _
         ByVal IA As Long, _
         ByVal JA As Long, _
         ByVal OpTypeA As Long, _
         ByVal Beta As Double, _
         ByRef C() As Complex, _
         ByVal IC As Long, _
         ByVal JC As Long, _
         ByVal IsUpper As Boolean) As Boolean
    Dim Result As Boolean
    Result = False
    CMatrixSYRKF = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Fast kernel
'
'  -- ALGLIB routine --
'     19.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function RMatrixSYRKF(ByVal N As Long, _
         ByVal K As Long, _
         ByVal Alpha As Double, _
         ByRef A() As Double, _
         ByVal IA As Long, _
         ByVal JA As Long, _
         ByVal OpTypeA As Long, _
         ByVal Beta As Double, _
         ByRef C() As Double, _
         ByVal IC As Long, _
         ByVal JC As Long, _
         ByVal IsUpper As Boolean) As Boolean
    Dim Result As Boolean
    Result = False
    RMatrixSYRKF = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Fast kernel
'
'  -- ALGLIB routine --
'     19.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function RMatrixGEMMF(ByVal M As Long, _
         ByVal N As Long, _
         ByVal K As Long, _
         ByVal Alpha As Double, _
         ByRef A() As Double, _
         ByVal IA As Long, _
         ByVal JA As Long, _
         ByVal OpTypeA As Long, _
         ByRef B() As Double, _
         ByVal IB As Long, _
         ByVal JB As Long, _
         ByVal OpTypeB As Long, _
         ByVal Beta As Double, _
         ByRef C() As Double, _
         ByVal IC As Long, _
         ByVal JC As Long) As Boolean
    Dim Result As Boolean
    Result = False
    RMatrixGEMMF = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Fast kernel
'
'  -- ALGLIB routine --
'     19.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function CMatrixGEMMF(ByVal M As Long, _
         ByVal N As Long, _
         ByVal K As Long, _
         ByRef Alpha_ As Complex, _
         ByRef A() As Complex, _
         ByVal IA As Long, _
         ByVal JA As Long, _
         ByVal OpTypeA As Long, _
         ByRef B() As Complex, _
         ByVal IB As Long, _
         ByVal JB As Long, _
         ByVal OpTypeB As Long, _
         ByRef Beta_ As Complex, _
         ByRef C() As Complex, _
         ByVal IC As Long, _
         ByVal JC As Long) As Boolean
    Dim Result As Boolean
    Dim Alpha As Complex
    Dim Beta As Complex
    Alpha = Alpha_
    Beta = Beta_
    Result = False
    CMatrixGEMMF = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 1992-2007 The University of Tennessee.  All rights reserved.
'
'Contributors:
'    * Sergey Bochkanov (ALGLIB project). Translation from FORTRAN to
'      pseudocode.
'
'See subroutines comments for additional copyrights.
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Singular value decomposition of a bidiagonal matrix (extended algorithm)
'
'The algorithm performs the singular value decomposition  of  a  bidiagonal
'matrix B (upper or lower) representing it as B = Q*S*P^T, where Q and  P -
'orthogonal matrices, S - diagonal matrix with non-negative elements on the
'main diagonal, in descending order.
'
'The  algorithm  finds  singular  values.  In  addition,  the algorithm can
'calculate  matrices  Q  and P (more precisely, not the matrices, but their
'product  with  given  matrices U and VT - U*Q and (P^T)*VT)).  Of  course,
'matrices U and VT can be of any type, including identity. Furthermore, the
'algorithm can calculate Q'*C (this product is calculated more  effectively
'than U*Q,  because  this calculation operates with rows instead  of matrix
'columns).
'
'The feature of the algorithm is its ability to find  all  singular  values
'including those which are arbitrarily close to 0  with  relative  accuracy
'close to  machine precision. If the parameter IsFractionalAccuracyRequired
'is set to True, all singular values will have high relative accuracy close
'to machine precision. If the parameter is set to False, only  the  biggest
'singular value will have relative accuracy  close  to  machine  precision.
'The absolute error of other singular values is equal to the absolute error
'of the biggest singular value.
'
'Input parameters:
'    D       -   main diagonal of matrix B.
'                Array whose index ranges within [0..N-1].
'    E       -   superdiagonal (or subdiagonal) of matrix B.
'                Array whose index ranges within [0..N-2].
'    N       -   size of matrix B.
'    IsUpper -   True, if the matrix is upper bidiagonal.
'    IsFractionalAccuracyRequired -
'                accuracy to search singular values with.
'    U       -   matrix to be multiplied by Q.
'                Array whose indexes range within [0..NRU-1, 0..N-1].
'                The matrix can be bigger, in that case only the  submatrix
'                [0..NRU-1, 0..N-1] will be multiplied by Q.
'    NRU     -   number of rows in matrix U.
'    C       -   matrix to be multiplied by Q'.
'                Array whose indexes range within [0..N-1, 0..NCC-1].
'                The matrix can be bigger, in that case only the  submatrix
'                [0..N-1, 0..NCC-1] will be multiplied by Q'.
'    NCC     -   number of columns in matrix C.
'    VT      -   matrix to be multiplied by P^T.
'                Array whose indexes range within [0..N-1, 0..NCVT-1].
'                The matrix can be bigger, in that case only the  submatrix
'                [0..N-1, 0..NCVT-1] will be multiplied by P^T.
'    NCVT    -   number of columns in matrix VT.
'
'Output parameters:
'    D       -   singular values of matrix B in descending order.
'    U       -   if NRU>0, contains matrix U*Q.
'    VT      -   if NCVT>0, contains matrix (P^T)*VT.
'    C       -   if NCC>0, contains matrix Q'*C.
'
'Result:
'    True, if the algorithm has converged.
'    False, if the algorithm hasn't converged (rare case).
'
'Additional information:
'    The type of convergence is controlled by the internal  parameter  TOL.
'    If the parameter is greater than 0, the singular values will have
'    relative accuracy TOL. If TOL<0, the singular values will have
'    absolute accuracy ABS(TOL)*norm(B).
'    By default, |TOL| falls within the range of 10*Epsilon and 100*Epsilon,
'    where Epsilon is the machine precision. It is not  recommended  to  use
'    TOL less than 10*Epsilon since this will  considerably  slow  down  the
'    algorithm and may not lead to error decreasing.
'History:
'    * 31 March, 2007.
'        changed MAXITR from 6 to 12.
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     October 31, 1999.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function RMatrixBDSVD(ByRef D() As Double, _
         ByRef E_() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByVal IsFractionalAccuracyRequired As Boolean, _
         ByRef U() As Double, _
         ByVal NRU As Long, _
         ByRef C() As Double, _
         ByVal NCC As Long, _
         ByRef VT() As Double, _
         ByVal NCVT As Long) As Boolean
    Dim Result As Boolean
    Dim E() As Double
    Dim D1() As Double
    Dim E1() As Double
    Dim i_ As Long
    Dim i1_ As Long
    E = E_
    ReDim D1(1# To N)
    i1_ = (0#) - (1#)
    For i_ = 1# To N Step 1
        D1(i_) = D(i_ + i1_)
    Next i_
    If N > 1# Then
        ReDim E1(1# To N - 1#)
        i1_ = (0#) - (1#)
        For i_ = 1# To N - 1# Step 1
            E1(i_) = E(i_ + i1_)
        Next i_
    End If
    Result = BidiagonalSVDDecompositionInternal(D1, E1, N, IsUpper, IsFractionalAccuracyRequired, U, 0#, NRU, C, 0#, NCC, VT, 0#, NCVT)
    i1_ = (1#) - (0#)
    For i_ = 0# To N - 1# Step 1
        D(i_) = D1(i_ + i1_)
    Next i_
    RMatrixBDSVD = Result
End Function
Public Function BidiagonalSVDDecomposition(ByRef D() As Double, _
         ByRef E_() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByVal IsFractionalAccuracyRequired As Boolean, _
         ByRef U() As Double, _
         ByVal NRU As Long, _
         ByRef C() As Double, _
         ByVal NCC As Long, _
         ByRef VT() As Double, _
         ByVal NCVT As Long) As Boolean
    Dim Result As Boolean
    Dim E() As Double
    E = E_
    Result = BidiagonalSVDDecompositionInternal(D, E, N, IsUpper, IsFractionalAccuracyRequired, U, 1#, NRU, C, 1#, NCC, VT, 1#, NCVT)
    BidiagonalSVDDecomposition = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal working subroutine for bidiagonal decomposition
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Function BidiagonalSVDDecompositionInternal(ByRef D() As Double, _
         ByRef E_() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByVal IsFractionalAccuracyRequired As Boolean, _
         ByRef U() As Double, _
         ByVal UStart As Long, _
         ByVal NRU As Long, _
         ByRef C() As Double, _
         ByVal CStart As Long, _
         ByVal NCC As Long, _
         ByRef VT() As Double, _
         ByVal VStart As Long, _
         ByVal NCVT As Long) As Boolean
    Dim Result As Boolean
    Dim E() As Double
    Dim i As Long
    Dim IDIR As Long
    Dim ISUB As Long
    Dim ITER As Long
    Dim j As Long
    Dim LL As Long
    Dim LLL As Long
    Dim M As Long
    Dim MAXIT As Long
    Dim OLDLL As Long
    Dim OLDM As Long
    Dim ABSE As Double
    Dim ABSS As Double
    Dim COSL As Double
    Dim COSR As Double
    Dim CS As Double
    Dim Eps As Double
    Dim F As Double
    Dim G As Double
    Dim H As Double
    Dim Mu As Double
    Dim OLDCS As Double
    Dim OLDSN As Double
    Dim R As Double
    Dim Shift As Double
    Dim SIGMN As Double
    Dim SIGMX As Double
    Dim SINL As Double
    Dim SINR As Double
    Dim SLL As Double
    Dim SMAX As Double
    Dim SMIN As Double
    Dim SMINL As Double
    Dim SMINLO As Double
    Dim SMINOA As Double
    Dim SN As Double
    Dim thresh As Double
    Dim TOL As Double
    Dim TOLMUL As Double
    Dim UNFL As Double
    Dim WORK0() As Double
    Dim WORK1() As Double
    Dim WORK2() As Double
    Dim WORK3() As Double
    Dim MAXITR As Long
    Dim MatrixSplitFlag As Boolean
    Dim IterFlag As Boolean
    Dim UTemp() As Double
    Dim VTTemp() As Double
    Dim CTEMP() As Double
    Dim ETemp() As Double
    Dim RightSide As Boolean
    Dim FwdDir As Boolean
    Dim Tmp As Double
    Dim MM1 As Long
    Dim MM0 As Long
    Dim BChangeDir As Boolean
    Dim UEnd As Long
    Dim CEnd As Long
    Dim VEnd As Long
    Dim i_ As Long
    E = E_
    Result = True
    If N = 0# Then
        BidiagonalSVDDecompositionInternal = Result
        Exit Function
    End If
    If N = 1# Then
        If D(1#) < 0# Then
            D(1#) = -D(1#)
            If NCVT > 0# Then
                For i_ = VStart To VStart + NCVT - 1# Step 1
                    VT(VStart, i_) = -1 * VT(VStart, i_)
                Next i_
            End If
        End If
        BidiagonalSVDDecompositionInternal = Result
        Exit Function
    End If
    
    '
    ' init
    '
    ReDim WORK0(1# To N - 1#)
    ReDim WORK1(1# To N - 1#)
    ReDim WORK2(1# To N - 1#)
    ReDim WORK3(1# To N - 1#)
    UEnd = UStart + MaxInt(NRU - 1#, 0#)
    VEnd = VStart + MaxInt(NCVT - 1#, 0#)
    CEnd = CStart + MaxInt(NCC - 1#, 0#)
    ReDim UTemp(UStart To UEnd)
    ReDim VTTemp(VStart To VEnd)
    ReDim CTEMP(CStart To CEnd)
    MAXITR = 12#
    RightSide = True
    FwdDir = True
    
    '
    ' resize E from N-1 to N
    '
    ReDim ETemp(1# To N)
    For i = 1# To N - 1# Step 1
        ETemp(i) = E(i)
    Next i
    ReDim E(1# To N)
    For i = 1# To N - 1# Step 1
        E(i) = ETemp(i)
    Next i
    E(N) = 0#
    IDIR = 0#
    
    '
    ' Get machine constants
    '
    Eps = MachineEpsilon
    UNFL = MinRealNumber
    
    '
    ' If matrix lower bidiagonal, rotate to be upper bidiagonal
    ' by applying Givens rotations on the left
    '
    If Not IsUpper Then
        For i = 1# To N - 1# Step 1
            Call GenerateRotation(D(i), E(i), CS, SN, R)
            D(i) = R
            E(i) = SN * D(i + 1#)
            D(i + 1#) = CS * D(i + 1#)
            WORK0(i) = CS
            WORK1(i) = SN
        Next i
        
        '
        ' Update singular vectors if desired
        '
        If NRU > 0# Then
            Call ApplyRotationsFromTheRight(FwdDir, UStart, UEnd, 1# + UStart - 1#, N + UStart - 1#, WORK0, WORK1, U, UTemp)
        End If
        If NCC > 0# Then
            Call ApplyRotationsFromTheLeft(FwdDir, 1# + CStart - 1#, N + CStart - 1#, CStart, CEnd, WORK0, WORK1, C, CTEMP)
        End If
    End If
    
    '
    ' Compute singular values to relative accuracy TOL
    ' (By setting TOL to be negative, algorithm will compute
    ' singular values to absolute accuracy ABS(TOL)*norm(input matrix))
    '
    TOLMUL = MaxReal(10#, MinReal(100#, Power(Eps, -0.125)))
    TOL = TOLMUL * Eps
    If Not IsFractionalAccuracyRequired Then
        TOL = -TOL
    End If
    
    '
    ' Compute approximate maximum, minimum singular values
    '
    SMAX = 0#
    For i = 1# To N Step 1
        SMAX = MaxReal(SMAX, Abs(D(i)))
    Next i
    For i = 1# To N - 1# Step 1
        SMAX = MaxReal(SMAX, Abs(E(i)))
    Next i
    SMINL = 0#
    If TOL >= 0# Then
        
        '
        ' Relative accuracy desired
        '
        SMINOA = Abs(D(1#))
        If SMINOA <> 0# Then
            Mu = SMINOA
            For i = 2# To N Step 1
                Mu = Abs(D(i)) * (Mu / (Mu + Abs(E(i - 1#))))
                SMINOA = MinReal(SMINOA, Mu)
                If SMINOA = 0# Then
                    Exit For
                End If
            Next i
        End If
        SMINOA = SMINOA / Sqr(N)
        thresh = MaxReal(TOL * SMINOA, MAXITR * N * N * UNFL)
    Else
        
        '
        ' Absolute accuracy desired
        '
        thresh = MaxReal(Abs(TOL) * SMAX, MAXITR * N * N * UNFL)
    End If
    
    '
    ' Prepare for main iteration loop for the singular values
    ' (MAXIT is the maximum number of passes through the inner
    ' loop permitted before nonconvergence signalled.)
    '
    MAXIT = MAXITR * N * N
    ITER = 0#
    OLDLL = -1#
    OLDM = -1#
    
    '
    ' M points to last element of unconverged part of matrix
    '
    M = N
    
    '
    ' Begin main iteration loop
    '
    Do While True
        
        '
        ' Check for convergence or exceeding iteration count
        '
        If M <= 1# Then
            Exit Do
        End If
        If ITER > MAXIT Then
            Result = False
            BidiagonalSVDDecompositionInternal = Result
            Exit Function
        End If
        
        '
        ' Find diagonal block of matrix to work on
        '
        If TOL < 0# And Abs(D(M)) <= thresh Then
            D(M) = 0#
        End If
        SMAX = Abs(D(M))
        SMIN = SMAX
        MatrixSplitFlag = False
        For LLL = 1# To M - 1# Step 1
            LL = M - LLL
            ABSS = Abs(D(LL))
            ABSE = Abs(E(LL))
            If TOL < 0# And ABSS <= thresh Then
                D(LL) = 0#
            End If
            If ABSE <= thresh Then
                MatrixSplitFlag = True
                Exit For
            End If
            SMIN = MinReal(SMIN, ABSS)
            SMAX = MaxReal(SMAX, MaxReal(ABSS, ABSE))
        Next LLL
        If Not MatrixSplitFlag Then
            LL = 0#
        Else
            
            '
            ' Matrix splits since E(LL) = 0
            '
            E(LL) = 0#
            If LL = M - 1# Then
                
                '
                ' Convergence of bottom singular value, return to top of loop
                '
                M = M - 1#
                GoTo Cont_7
            End If
        End If
        LL = LL + 1#
        
        '
        ' E(LL) through E(M-1) are nonzero, E(LL-1) is zero
        '
        If LL = M - 1# Then
            
            '
            ' 2 by 2 block, handle separately
            '
            Call SvdV2X2(D(M - 1#), E(M - 1#), D(M), SIGMN, SIGMX, SINR, COSR, SINL, COSL)
            D(M - 1#) = SIGMX
            E(M - 1#) = 0#
            D(M) = SIGMN
            
            '
            ' Compute singular vectors, if desired
            '
            If NCVT > 0# Then
                MM0 = M + (VStart - 1#)
                MM1 = M - 1# + (VStart - 1#)
                For i_ = VStart To VEnd Step 1
                    VTTemp(i_) = COSR * VT(MM1, i_)
                Next i_
                For i_ = VStart To VEnd Step 1
                    VTTemp(i_) = VTTemp(i_) + SINR * VT(MM0, i_)
                Next i_
                For i_ = VStart To VEnd Step 1
                    VT(MM0, i_) = COSR * VT(MM0, i_)
                Next i_
                For i_ = VStart To VEnd Step 1
                    VT(MM0, i_) = VT(MM0, i_) - SINR * VT(MM1, i_)
                Next i_
                For i_ = VStart To VEnd Step 1
                    VT(MM1, i_) = VTTemp(i_)
                Next i_
            End If
            If NRU > 0# Then
                MM0 = M + UStart - 1#
                MM1 = M - 1# + UStart - 1#
                For i_ = UStart To UEnd Step 1
                    UTemp(i_) = COSL * U(i_, MM1)
                Next i_
                For i_ = UStart To UEnd Step 1
                    UTemp(i_) = UTemp(i_) + SINL * U(i_, MM0)
                Next i_
                For i_ = UStart To UEnd Step 1
                    U(i_, MM0) = COSL * U(i_, MM0)
                Next i_
                For i_ = UStart To UEnd Step 1
                    U(i_, MM0) = U(i_, MM0) - SINL * U(i_, MM1)
                Next i_
                For i_ = UStart To UEnd Step 1
                    U(i_, MM1) = UTemp(i_)
                Next i_
            End If
            If NCC > 0# Then
                MM0 = M + CStart - 1#
                MM1 = M - 1# + CStart - 1#
                For i_ = CStart To CEnd Step 1
                    CTEMP(i_) = COSL * C(MM1, i_)
                Next i_
                For i_ = CStart To CEnd Step 1
                    CTEMP(i_) = CTEMP(i_) + SINL * C(MM0, i_)
                Next i_
                For i_ = CStart To CEnd Step 1
                    C(MM0, i_) = COSL * C(MM0, i_)
                Next i_
                For i_ = CStart To CEnd Step 1
                    C(MM0, i_) = C(MM0, i_) - SINL * C(MM1, i_)
                Next i_
                For i_ = CStart To CEnd Step 1
                    C(MM1, i_) = CTEMP(i_)
                Next i_
            End If
            M = M - 2#
            GoTo Cont_7
        End If
        
        '
        ' If working on new submatrix, choose shift direction
        ' (from larger end diagonal element towards smaller)
        '
        ' Previously was
        '     "if (LL>OLDM) or (M<OLDLL) then"
        ' fixed thanks to Michael Rolle < m@rolle.name >
        ' Very strange that LAPACK still contains it.
        '
        BChangeDir = False
        If IDIR = 1# And Abs(D(LL)) < 0.001 * Abs(D(M)) Then
            BChangeDir = True
        End If
        If IDIR = 2# And Abs(D(M)) < 0.001 * Abs(D(LL)) Then
            BChangeDir = True
        End If
        If LL <> OLDLL Or M <> OLDM Or BChangeDir Then
            If Abs(D(LL)) >= Abs(D(M)) Then
                
                '
                ' Chase bulge from top (big end) to bottom (small end)
                '
                IDIR = 1#
            Else
                
                '
                ' Chase bulge from bottom (big end) to top (small end)
                '
                IDIR = 2#
            End If
        End If
        
        '
        ' Apply convergence tests
        '
        If IDIR = 1# Then
            
            '
            ' Run convergence test in forward direction
            ' First apply standard test to bottom of matrix
            '
            If Abs(E(M - 1#)) <= Abs(TOL) * Abs(D(M)) Or TOL < 0# And Abs(E(M - 1#)) <= thresh Then
                E(M - 1#) = 0#
                GoTo Cont_7
            End If
            If TOL >= 0# Then
                
                '
                ' If relative accuracy desired,
                ' apply convergence criterion forward
                '
                Mu = Abs(D(LL))
                SMINL = Mu
                IterFlag = False
                For LLL = LL To M - 1# Step 1
                    If Abs(E(LLL)) <= TOL * Mu Then
                        E(LLL) = 0#
                        IterFlag = True
                        Exit For
                    End If
                    SMINLO = SMINL
                    Mu = Abs(D(LLL + 1#)) * (Mu / (Mu + Abs(E(LLL))))
                    SMINL = MinReal(SMINL, Mu)
                Next LLL
                If IterFlag Then
                    GoTo Cont_7
                End If
            End If
        Else
            
            '
            ' Run convergence test in backward direction
            ' First apply standard test to top of matrix
            '
            If Abs(E(LL)) <= Abs(TOL) * Abs(D(LL)) Or TOL < 0# And Abs(E(LL)) <= thresh Then
                E(LL) = 0#
                GoTo Cont_7
            End If
            If TOL >= 0# Then
                
                '
                ' If relative accuracy desired,
                ' apply convergence criterion backward
                '
                Mu = Abs(D(M))
                SMINL = Mu
                IterFlag = False
                For LLL = M - 1# To LL Step -1
                    If Abs(E(LLL)) <= TOL * Mu Then
                        E(LLL) = 0#
                        IterFlag = True
                        Exit For
                    End If
                    SMINLO = SMINL
                    Mu = Abs(D(LLL)) * (Mu / (Mu + Abs(E(LLL))))
                    SMINL = MinReal(SMINL, Mu)
                Next LLL
                If IterFlag Then
                    GoTo Cont_7
                End If
            End If
        End If
        OLDLL = LL
        OLDM = M
        
        '
        ' Compute shift.  First, test if shifting would ruin relative
        ' accuracy, and if so set the shift to zero.
        '
        If TOL >= 0# And N * TOL * (SMINL / SMAX) <= MaxReal(Eps, 0.01 * TOL) Then
            
            '
            ' Use a zero shift to avoid loss of relative accuracy
            '
            Shift = 0#
        Else
            
            '
            ' Compute the shift from 2-by-2 block at end of matrix
            '
            If IDIR = 1# Then
                SLL = Abs(D(LL))
                Call Svd2X2(D(M - 1#), E(M - 1#), D(M), Shift, R)
            Else
                SLL = Abs(D(M))
                Call Svd2X2(D(LL), E(LL), D(LL + 1#), Shift, R)
            End If
            
            '
            ' Test if shift negligible, and if so set to zero
            '
            If SLL > 0# Then
                If Square(Shift / SLL) < Eps Then
                    Shift = 0#
                End If
            End If
        End If
        
        '
        ' Increment iteration count
        '
        ITER = ITER + M - LL
        
        '
        ' If SHIFT = 0, do simplified QR iteration
        '
        If Shift = 0# Then
            If IDIR = 1# Then
                
                '
                ' Chase bulge from top to bottom
                ' Save cosines and sines for later singular vector updates
                '
                CS = 1#
                OLDCS = 1#
                For i = LL To M - 1# Step 1
                    Call GenerateRotation(D(i) * CS, E(i), CS, SN, R)
                    If i > LL Then
                        E(i - 1#) = OLDSN * R
                    End If
                    Call GenerateRotation(OLDCS * R, D(i + 1#) * SN, OLDCS, OLDSN, Tmp)
                    D(i) = Tmp
                    WORK0(i - LL + 1#) = CS
                    WORK1(i - LL + 1#) = SN
                    WORK2(i - LL + 1#) = OLDCS
                    WORK3(i - LL + 1#) = OLDSN
                Next i
                H = D(M) * CS
                D(M) = H * OLDCS
                E(M - 1#) = H * OLDSN
                
                '
                ' Update singular vectors
                '
                If NCVT > 0# Then
                    Call ApplyRotationsFromTheLeft(FwdDir, LL + VStart - 1#, M + VStart - 1#, VStart, VEnd, WORK0, WORK1, VT, VTTemp)
                End If
                If NRU > 0# Then
                    Call ApplyRotationsFromTheRight(FwdDir, UStart, UEnd, LL + UStart - 1#, M + UStart - 1#, WORK2, WORK3, U, UTemp)
                End If
                If NCC > 0# Then
                    Call ApplyRotationsFromTheLeft(FwdDir, LL + CStart - 1#, M + CStart - 1#, CStart, CEnd, WORK2, WORK3, C, CTEMP)
                End If
                
                '
                ' Test convergence
                '
                If Abs(E(M - 1#)) <= thresh Then
                    E(M - 1#) = 0#
                End If
            Else
                
                '
                ' Chase bulge from bottom to top
                ' Save cosines and sines for later singular vector updates
                '
                CS = 1#
                OLDCS = 1#
                For i = M To LL + 1# Step -1
                    Call GenerateRotation(D(i) * CS, E(i - 1#), CS, SN, R)
                    If i < M Then
                        E(i) = OLDSN * R
                    End If
                    Call GenerateRotation(OLDCS * R, D(i - 1#) * SN, OLDCS, OLDSN, Tmp)
                    D(i) = Tmp
                    WORK0(i - LL) = CS
                    WORK1(i - LL) = -SN
                    WORK2(i - LL) = OLDCS
                    WORK3(i - LL) = -OLDSN
                Next i
                H = D(LL) * CS
                D(LL) = H * OLDCS
                E(LL) = H * OLDSN
                
                '
                ' Update singular vectors
                '
                If NCVT > 0# Then
                    Call ApplyRotationsFromTheLeft(Not FwdDir, LL + VStart - 1#, M + VStart - 1#, VStart, VEnd, WORK2, WORK3, VT, VTTemp)
                End If
                If NRU > 0# Then
                    Call ApplyRotationsFromTheRight(Not FwdDir, UStart, UEnd, LL + UStart - 1#, M + UStart - 1#, WORK0, WORK1, U, UTemp)
                End If
                If NCC > 0# Then
                    Call ApplyRotationsFromTheLeft(Not FwdDir, LL + CStart - 1#, M + CStart - 1#, CStart, CEnd, WORK0, WORK1, C, CTEMP)
                End If
                
                '
                ' Test convergence
                '
                If Abs(E(LL)) <= thresh Then
                    E(LL) = 0#
                End If
            End If
        Else
            
            '
            ' Use nonzero shift
            '
            If IDIR = 1# Then
                
                '
                ' Chase bulge from top to bottom
                ' Save cosines and sines for later singular vector updates
                '
                F = (Abs(D(LL)) - Shift) * (ExtSignBDSQR(1#, D(LL)) + Shift / D(LL))
                G = E(LL)
                For i = LL To M - 1# Step 1
                    Call GenerateRotation(F, G, COSR, SINR, R)
                    If i > LL Then
                        E(i - 1#) = R
                    End If
                    F = COSR * D(i) + SINR * E(i)
                    E(i) = COSR * E(i) - SINR * D(i)
                    G = SINR * D(i + 1#)
                    D(i + 1#) = COSR * D(i + 1#)
                    Call GenerateRotation(F, G, COSL, SINL, R)
                    D(i) = R
                    F = COSL * E(i) + SINL * D(i + 1#)
                    D(i + 1#) = COSL * D(i + 1#) - SINL * E(i)
                    If i < M - 1# Then
                        G = SINL * E(i + 1#)
                        E(i + 1#) = COSL * E(i + 1#)
                    End If
                    WORK0(i - LL + 1#) = COSR
                    WORK1(i - LL + 1#) = SINR
                    WORK2(i - LL + 1#) = COSL
                    WORK3(i - LL + 1#) = SINL
                Next i
                E(M - 1#) = F
                
                '
                ' Update singular vectors
                '
                If NCVT > 0# Then
                    Call ApplyRotationsFromTheLeft(FwdDir, LL + VStart - 1#, M + VStart - 1#, VStart, VEnd, WORK0, WORK1, VT, VTTemp)
                End If
                If NRU > 0# Then
                    Call ApplyRotationsFromTheRight(FwdDir, UStart, UEnd, LL + UStart - 1#, M + UStart - 1#, WORK2, WORK3, U, UTemp)
                End If
                If NCC > 0# Then
                    Call ApplyRotationsFromTheLeft(FwdDir, LL + CStart - 1#, M + CStart - 1#, CStart, CEnd, WORK2, WORK3, C, CTEMP)
                End If
                
                '
                ' Test convergence
                '
                If Abs(E(M - 1#)) <= thresh Then
                    E(M - 1#) = 0#
                End If
            Else
                
                '
                ' Chase bulge from bottom to top
                ' Save cosines and sines for later singular vector updates
                '
                F = (Abs(D(M)) - Shift) * (ExtSignBDSQR(1#, D(M)) + Shift / D(M))
                G = E(M - 1#)
                For i = M To LL + 1# Step -1
                    Call GenerateRotation(F, G, COSR, SINR, R)
                    If i < M Then
                        E(i) = R
                    End If
                    F = COSR * D(i) + SINR * E(i - 1#)
                    E(i - 1#) = COSR * E(i - 1#) - SINR * D(i)
                    G = SINR * D(i - 1#)
                    D(i - 1#) = COSR * D(i - 1#)
                    Call GenerateRotation(F, G, COSL, SINL, R)
                    D(i) = R
                    F = COSL * E(i - 1#) + SINL * D(i - 1#)
                    D(i - 1#) = COSL * D(i - 1#) - SINL * E(i - 1#)
                    If i > LL + 1# Then
                        G = SINL * E(i - 2#)
                        E(i - 2#) = COSL * E(i - 2#)
                    End If
                    WORK0(i - LL) = COSR
                    WORK1(i - LL) = -SINR
                    WORK2(i - LL) = COSL
                    WORK3(i - LL) = -SINL
                Next i
                E(LL) = F
                
                '
                ' Test convergence
                '
                If Abs(E(LL)) <= thresh Then
                    E(LL) = 0#
                End If
                
                '
                ' Update singular vectors if desired
                '
                If NCVT > 0# Then
                    Call ApplyRotationsFromTheLeft(Not FwdDir, LL + VStart - 1#, M + VStart - 1#, VStart, VEnd, WORK2, WORK3, VT, VTTemp)
                End If
                If NRU > 0# Then
                    Call ApplyRotationsFromTheRight(Not FwdDir, UStart, UEnd, LL + UStart - 1#, M + UStart - 1#, WORK0, WORK1, U, UTemp)
                End If
                If NCC > 0# Then
                    Call ApplyRotationsFromTheLeft(Not FwdDir, LL + CStart - 1#, M + CStart - 1#, CStart, CEnd, WORK0, WORK1, C, CTEMP)
                End If
            End If
        End If
        
        '
        ' QR iteration finished, go back and check convergence
        '
        GoTo Cont_7
Cont_7:
    Loop
    
    '
    ' All singular values converged, so make them positive
    '
    For i = 1# To N Step 1
        If D(i) < 0# Then
            D(i) = -D(i)
            
            '
            ' Change sign of singular vectors, if desired
            '
            If NCVT > 0# Then
                For i_ = VStart To VEnd Step 1
                    VT(i + VStart - 1#, i_) = -1 * VT(i + VStart - 1#, i_)
                Next i_
            End If
        End If
    Next i
    
    '
    ' Sort the singular values into decreasing order (insertion sort on
    ' singular values, but only one transposition per singular vector)
    '
    For i = 1# To N - 1# Step 1
        
        '
        ' Scan for smallest D(I)
        '
        ISUB = 1#
        SMIN = D(1#)
        For j = 2# To N + 1# - i Step 1
            If D(j) <= SMIN Then
                ISUB = j
                SMIN = D(j)
            End If
        Next j
        If ISUB <> N + 1# - i Then
            
            '
            ' Swap singular values and vectors
            '
            D(ISUB) = D(N + 1# - i)
            D(N + 1# - i) = SMIN
            If NCVT > 0# Then
                j = N + 1# - i
                For i_ = VStart To VEnd Step 1
                    VTTemp(i_) = VT(ISUB + VStart - 1#, i_)
                Next i_
                For i_ = VStart To VEnd Step 1
                    VT(ISUB + VStart - 1#, i_) = VT(j + VStart - 1#, i_)
                Next i_
                For i_ = VStart To VEnd Step 1
                    VT(j + VStart - 1#, i_) = VTTemp(i_)
                Next i_
            End If
            If NRU > 0# Then
                j = N + 1# - i
                For i_ = UStart To UEnd Step 1
                    UTemp(i_) = U(i_, ISUB + UStart - 1#)
                Next i_
                For i_ = UStart To UEnd Step 1
                    U(i_, ISUB + UStart - 1#) = U(i_, j + UStart - 1#)
                Next i_
                For i_ = UStart To UEnd Step 1
                    U(i_, j + UStart - 1#) = UTemp(i_)
                Next i_
            End If
            If NCC > 0# Then
                j = N + 1# - i
                For i_ = CStart To CEnd Step 1
                    CTEMP(i_) = C(ISUB + CStart - 1#, i_)
                Next i_
                For i_ = CStart To CEnd Step 1
                    C(ISUB + CStart - 1#, i_) = C(j + CStart - 1#, i_)
                Next i_
                For i_ = CStart To CEnd Step 1
                    C(j + CStart - 1#, i_) = CTEMP(i_)
                Next i_
            End If
        End If
    Next i
    BidiagonalSVDDecompositionInternal = Result
End Function
Private Function ExtSignBDSQR(ByVal A As Double, ByVal B As Double) As Double
    Dim Result As Double
    If B >= 0# Then
        Result = Abs(A)
    Else
        Result = -Abs(A)
    End If
    ExtSignBDSQR = Result
End Function
Private Sub Svd2X2(ByVal F As Double, _
         ByVal G As Double, _
         ByVal H As Double, _
         ByRef SSMIN As Double, _
         ByRef SSMAX As Double)
    Dim AAS As Double
    Dim AT As Double
    Dim AU As Double
    Dim C As Double
    Dim FA As Double
    Dim FHMN As Double
    Dim FHMX As Double
    Dim GA As Double
    Dim HA As Double
    FA = Abs(F)
    GA = Abs(G)
    HA = Abs(H)
    FHMN = MinReal(FA, HA)
    FHMX = MaxReal(FA, HA)
    If FHMN = 0# Then
        SSMIN = 0#
        If FHMX = 0# Then
            SSMAX = GA
        Else
            SSMAX = MaxReal(FHMX, GA) * Sqr(1# + Square(MinReal(FHMX, GA) / MaxReal(FHMX, GA)))
        End If
    Else
        If GA < FHMX Then
            AAS = 1# + FHMN / FHMX
            AT = (FHMX - FHMN) / FHMX
            AU = Square(GA / FHMX)
            C = 2# / (Sqr(AAS * AAS + AU) + Sqr(AT * AT + AU))
            SSMIN = FHMN * C
            SSMAX = FHMX / C
        Else
            AU = FHMX / GA
            If AU = 0# Then
                
                '
                ' Avoid possible harmful underflow if exponent range
                ' asymmetric (true SSMIN may not underflow even if
                ' AU underflows)
                '
                SSMIN = FHMN * FHMX / GA
                SSMAX = GA
            Else
                AAS = 1# + FHMN / FHMX
                AT = (FHMX - FHMN) / FHMX
                C = 1# / (Sqr(1# + Square(AAS * AU)) + Sqr(1# + Square(AT * AU)))
                SSMIN = FHMN * C * AU
                SSMIN = SSMIN + SSMIN
                SSMAX = GA / (C + C)
            End If
        End If
    End If
End Sub
Private Sub SvdV2X2(ByVal F As Double, _
         ByVal G As Double, _
         ByVal H As Double, _
         ByRef SSMIN As Double, _
         ByRef SSMAX As Double, _
         ByRef SNR As Double, _
         ByRef CSR As Double, _
         ByRef SNL As Double, _
         ByRef CSL As Double)
    Dim GASMAL As Boolean
    Dim SWP As Boolean
    Dim PMAX As Long
    Dim A As Double
    Dim CLT As Double
    Dim CRT As Double
    Dim D As Double
    Dim FA As Double
    Dim FT As Double
    Dim GA As Double
    Dim GT As Double
    Dim HA As Double
    Dim HT As Double
    Dim L As Double
    Dim M As Double
    Dim MM As Double
    Dim R As Double
    Dim S As Double
    Dim SLT As Double
    Dim SRT As Double
    Dim T As Double
    Dim temp As Double
    Dim TSIGN As Double
    Dim TT As Double
    Dim V As Double
    FT = F
    FA = Abs(FT)
    HT = H
    HA = Abs(H)
    
    '
    ' PMAX points to the maximum absolute element of matrix
    '  PMAX = 1 if F largest in absolute values
    '  PMAX = 2 if G largest in absolute values
    '  PMAX = 3 if H largest in absolute values
    '
    PMAX = 1#
    SWP = HA > FA
    If SWP Then
        
        '
        ' Now FA .ge. HA
        '
        PMAX = 3#
        temp = FT
        FT = HT
        HT = temp
        temp = FA
        FA = HA
        HA = temp
    End If
    GT = G
    GA = Abs(GT)
    If GA = 0# Then
        
        '
        ' Diagonal matrix
        '
        SSMIN = HA
        SSMAX = FA
        CLT = 1#
        CRT = 1#
        SLT = 0#
        SRT = 0#
    Else
        GASMAL = True
        If GA > FA Then
            PMAX = 2#
            If FA / GA < MachineEpsilon Then
                
                '
                ' Case of very large GA
                '
                GASMAL = False
                SSMAX = GA
                If HA > 1# Then
                    V = GA / HA
                    SSMIN = FA / V
                Else
                    V = FA / GA
                    SSMIN = V * HA
                End If
                CLT = 1#
                SLT = HT / GT
                SRT = 1#
                CRT = FT / GT
            End If
        End If
        If GASMAL Then
            
            '
            ' Normal case
            '
            D = FA - HA
            If D = FA Then
                L = 1#
            Else
                L = D / FA
            End If
            M = GT / FT
            T = 2# - L
            MM = M * M
            TT = T * T
            S = Sqr(TT + MM)
            If L = 0# Then
                R = Abs(M)
            Else
                R = Sqr(L * L + MM)
            End If
            A = 0.5 * (S + R)
            SSMIN = HA / A
            SSMAX = FA * A
            If MM = 0# Then
                
                '
                ' Note that M is very tiny
                '
                If L = 0# Then
                    T = ExtSignBDSQR(2#, FT) * ExtSignBDSQR(1#, GT)
                Else
                    T = GT / ExtSignBDSQR(D, FT) + M / T
                End If
            Else
                T = (M / (S + T) + M / (R + L)) * (1# + A)
            End If
            L = Sqr(T * T + 4#)
            CRT = 2# / L
            SRT = T / L
            CLT = (CRT + SRT * M) / A
            V = HT / FT
            SLT = V * SRT / A
        End If
    End If
    If SWP Then
        CSL = SRT
        SNL = CRT
        CSR = SLT
        SNR = CLT
    Else
        CSL = CLT
        SNL = SLT
        CSR = CRT
        SNR = SRT
    End If
    
    '
    ' Correct signs of SSMAX and SSMIN
    '
    If PMAX = 1# Then
        TSIGN = ExtSignBDSQR(1#, CSR) * ExtSignBDSQR(1#, CSL) * ExtSignBDSQR(1#, F)
    End If
    If PMAX = 2# Then
        TSIGN = ExtSignBDSQR(1#, SNR) * ExtSignBDSQR(1#, CSL) * ExtSignBDSQR(1#, G)
    End If
    If PMAX = 3# Then
        TSIGN = ExtSignBDSQR(1#, SNR) * ExtSignBDSQR(1#, SNL) * ExtSignBDSQR(1#, H)
    End If
    SSMAX = ExtSignBDSQR(SSMAX, TSIGN)
    SSMIN = ExtSignBDSQR(SSMIN, TSIGN * ExtSignBDSQR(1#, F) * ExtSignBDSQR(1#, H))
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2005-2007, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
Public Function VectorNorm2(ByRef X() As Double, _
         ByVal I1 As Long, _
         ByVal I2 As Long) As Double
    Dim Result As Double
    Dim N As Long
    Dim IX As Long
    Dim ABSXI As Double
    Dim SCL As Double
    Dim SSQ As Double
    N = I2 - I1 + 1#
    If N < 1# Then
        Result = 0#
        VectorNorm2 = Result
        Exit Function
    End If
    If N = 1# Then
        Result = Abs(X(I1))
        VectorNorm2 = Result
        Exit Function
    End If
    SCL = 0#
    SSQ = 1#
    For IX = I1 To I2 Step 1
        If X(IX) <> 0# Then
            ABSXI = Abs(X(IX))
            If SCL < ABSXI Then
                SSQ = 1# + SSQ * Square(SCL / ABSXI)
                SCL = ABSXI
            Else
                SSQ = SSQ + Square(ABSXI / SCL)
            End If
        End If
    Next IX
    Result = SCL * Sqr(SSQ)
    VectorNorm2 = Result
End Function
Public Function VectorIdxAbsMax(ByRef X() As Double, _
         ByVal I1 As Long, _
         ByVal I2 As Long) As Long
    Dim Result As Long
    Dim i As Long
    Dim A As Double
    Result = I1
    A = Abs(X(Result))
    For i = I1 + 1# To I2 Step 1
        If Abs(X(i)) > Abs(X(Result)) Then
            Result = i
        End If
    Next i
    VectorIdxAbsMax = Result
End Function
Public Function ColumnIdxAbsMax(ByRef X() As Double, _
         ByVal I1 As Long, _
         ByVal I2 As Long, _
         ByVal j As Long) As Long
    Dim Result As Long
    Dim i As Long
    Dim A As Double
    Result = I1
    A = Abs(X(Result, j))
    For i = I1 + 1# To I2 Step 1
        If Abs(X(i, j)) > Abs(X(Result, j)) Then
            Result = i
        End If
    Next i
    ColumnIdxAbsMax = Result
End Function
Public Function RowIdxAbsMax(ByRef X() As Double, _
         ByVal J1 As Long, _
         ByVal J2 As Long, _
         ByVal i As Long) As Long
    Dim Result As Long
    Dim j As Long
    Dim A As Double
    Result = J1
    A = Abs(X(i, Result))
    For j = J1 + 1# To J2 Step 1
        If Abs(X(i, j)) > Abs(X(i, Result)) Then
            Result = j
        End If
    Next j
    RowIdxAbsMax = Result
End Function
Public Function UpperHessenberg1Norm(ByRef A() As Double, _
         ByVal I1 As Long, _
         ByVal I2 As Long, _
         ByVal J1 As Long, _
         ByVal J2 As Long, _
         ByRef WORK() As Double) As Double
    Dim Result As Double
    Dim i As Long
    Dim j As Long
    For j = J1 To J2 Step 1
        WORK(j) = 0#
    Next j
    For i = I1 To I2 Step 1
        For j = MaxInt(J1, J1 + i - I1 - 1#) To J2 Step 1
            WORK(j) = WORK(j) + Abs(A(i, j))
        Next j
    Next i
    Result = 0#
    For j = J1 To J2 Step 1
        Result = MaxReal(Result, WORK(j))
    Next j
    UpperHessenberg1Norm = Result
End Function
Public Sub CopyMatrix(ByRef A() As Double, _
         ByVal IS1 As Long, _
         ByVal IS2 As Long, _
         ByVal JS1 As Long, _
         ByVal JS2 As Long, _
         ByRef B() As Double, _
         ByVal ID1 As Long, _
         ByVal ID2 As Long, _
         ByVal JD1 As Long, _
         ByVal JD2 As Long)
    Dim ISRC As Long
    Dim IDST As Long
    Dim i_ As Long
    Dim i1_ As Long
    If IS1 > IS2 Or JS1 > JS2 Then
        Exit Sub
    End If
    For ISRC = IS1 To IS2 Step 1
        IDST = ISRC - IS1 + ID1
        i1_ = (JS1) - (JD1)
        For i_ = JD1 To JD2 Step 1
            B(IDST, i_) = A(ISRC, i_ + i1_)
        Next i_
    Next ISRC
End Sub
Public Sub InplaceTranspose(ByRef A() As Double, _
         ByVal I1 As Long, _
         ByVal I2 As Long, _
         ByVal J1 As Long, _
         ByVal J2 As Long, _
         ByRef WORK() As Double)
    Dim i As Long
    Dim j As Long
    Dim IPS As Long
    Dim JPS As Long
    Dim L As Long
    Dim i_ As Long
    Dim i1_ As Long
    If I1 > I2 Or J1 > J2 Then
        Exit Sub
    End If
    For i = I1 To I2 - 1# Step 1
        j = J1 + i - I1
        IPS = i + 1#
        JPS = J1 + IPS - I1
        L = I2 - i
        i1_ = (IPS) - (1#)
        For i_ = 1# To L Step 1
            WORK(i_) = A(i_ + i1_, j)
        Next i_
        i1_ = (JPS) - (IPS)
        For i_ = IPS To I2 Step 1
            A(i_, j) = A(i, i_ + i1_)
        Next i_
        i1_ = (1#) - (JPS)
        For i_ = JPS To J2 Step 1
            A(i, i_) = WORK(i_ + i1_)
        Next i_
    Next i
End Sub
Public Sub CopyAndTranspose(ByRef A() As Double, _
         ByVal IS1 As Long, _
         ByVal IS2 As Long, _
         ByVal JS1 As Long, _
         ByVal JS2 As Long, _
         ByRef B() As Double, _
         ByVal ID1 As Long, _
         ByVal ID2 As Long, _
         ByVal JD1 As Long, _
         ByVal JD2 As Long)
    Dim ISRC As Long
    Dim JDST As Long
    Dim i_ As Long
    Dim i1_ As Long
    If IS1 > IS2 Or JS1 > JS2 Then
        Exit Sub
    End If
    For ISRC = IS1 To IS2 Step 1
        JDST = ISRC - IS1 + JD1
        i1_ = (JS1) - (ID1)
        For i_ = ID1 To ID2 Step 1
            B(i_, JDST) = A(ISRC, i_ + i1_)
        Next i_
    Next ISRC
End Sub
Public Sub MatrixVectorMultiply(ByRef A() As Double, _
         ByVal I1 As Long, _
         ByVal I2 As Long, _
         ByVal J1 As Long, _
         ByVal J2 As Long, _
         ByVal Trans As Boolean, _
         ByRef X() As Double, _
         ByVal IX1 As Long, _
         ByVal IX2 As Long, _
         ByVal Alpha As Double, _
         ByRef y() As Double, _
         ByVal IY1 As Long, _
         ByVal IY2 As Long, _
         ByVal Beta As Double)
    Dim i As Long
    Dim V As Double
    Dim i_ As Long
    Dim i1_ As Long
    If Not Trans Then
        
        '
        ' y := alpha*A*x + beta*y;
        '
        If I1 > I2 Or J1 > J2 Then
            Exit Sub
        End If
        
        '
        ' beta*y
        '
        If Beta = 0# Then
            For i = IY1 To IY2 Step 1
                y(i) = 0#
            Next i
        Else
            For i_ = IY1 To IY2 Step 1
                y(i_) = Beta * y(i_)
            Next i_
        End If
        
        '
        ' alpha*A*x
        '
        For i = I1 To I2 Step 1
            i1_ = (IX1) - (J1)
            V = 0#
            For i_ = J1 To J2 Step 1
                V = V + A(i, i_) * X(i_ + i1_)
            Next i_
            y(IY1 + i - I1) = y(IY1 + i - I1) + Alpha * V
        Next i
    Else
        
        '
        ' y := alpha*A'*x + beta*y;
        '
        If I1 > I2 Or J1 > J2 Then
            Exit Sub
        End If
        
        '
        ' beta*y
        '
        If Beta = 0# Then
            For i = IY1 To IY2 Step 1
                y(i) = 0#
            Next i
        Else
            For i_ = IY1 To IY2 Step 1
                y(i_) = Beta * y(i_)
            Next i_
        End If
        
        '
        ' alpha*A'*x
        '
        For i = I1 To I2 Step 1
            V = Alpha * X(IX1 + i - I1)
            i1_ = (J1) - (IY1)
            For i_ = IY1 To IY2 Step 1
                y(i_) = y(i_) + V * A(i, i_ + i1_)
            Next i_
        Next i
    End If
End Sub
Public Function Pythag2(ByVal X As Double, ByVal y As Double) As Double
    Dim Result As Double
    Dim w As Double
    Dim XABS As Double
    Dim YABS As Double
    Dim z As Double
    XABS = Abs(X)
    YABS = Abs(y)
    w = MaxReal(XABS, YABS)
    z = MinReal(XABS, YABS)
    If z = 0# Then
        Result = w
    Else
        Result = w * Sqr(1# + Square(z / w))
    End If
    Pythag2 = Result
End Function
Public Sub MatrixMatrixMultiply(ByRef A() As Double, _
         ByVal AI1 As Long, _
         ByVal AI2 As Long, _
         ByVal AJ1 As Long, _
         ByVal AJ2 As Long, _
         ByVal TransA As Boolean, _
         ByRef B() As Double, _
         ByVal BI1 As Long, _
         ByVal BI2 As Long, _
         ByVal BJ1 As Long, _
         ByVal BJ2 As Long, _
         ByVal TransB As Boolean, _
         ByVal Alpha As Double, _
         ByRef C() As Double, _
         ByVal CI1 As Long, _
         ByVal CI2 As Long, _
         ByVal CJ1 As Long, _
         ByVal CJ2 As Long, _
         ByVal Beta As Double, _
         ByRef WORK() As Double)
    Dim ARows As Long
    Dim ACols As Long
    Dim BRows As Long
    Dim BCols As Long
    Dim CRows As Long
    Dim CCols As Long
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim L As Long
    Dim R As Long
    Dim V As Double
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' Setup
    '
    If Not TransA Then
        ARows = AI2 - AI1 + 1#
        ACols = AJ2 - AJ1 + 1#
    Else
        ARows = AJ2 - AJ1 + 1#
        ACols = AI2 - AI1 + 1#
    End If
    If Not TransB Then
        BRows = BI2 - BI1 + 1#
        BCols = BJ2 - BJ1 + 1#
    Else
        BRows = BJ2 - BJ1 + 1#
        BCols = BI2 - BI1 + 1#
    End If
    If ARows <= 0# Or ACols <= 0# Or BRows <= 0# Or BCols <= 0# Then
        Exit Sub
    End If
    CRows = ARows
    CCols = BCols
    
    '
    ' Test WORK
    '
    i = MaxInt(ARows, ACols)
    i = MaxInt(BRows, i)
    i = MaxInt(i, BCols)
    WORK(1#) = 0#
    WORK(i) = 0#
    
    '
    ' Prepare C
    '
    If Beta = 0# Then
        For i = CI1 To CI2 Step 1
            For j = CJ1 To CJ2 Step 1
                C(i, j) = 0#
            Next j
        Next i
    Else
        For i = CI1 To CI2 Step 1
            For i_ = CJ1 To CJ2 Step 1
                C(i, i_) = Beta * C(i, i_)
            Next i_
        Next i
    End If
    
    '
    ' A*B
    '
    If Not TransA And Not TransB Then
        For L = AI1 To AI2 Step 1
            For R = BI1 To BI2 Step 1
                V = Alpha * A(L, AJ1 + R - BI1)
                K = CI1 + L - AI1
                i1_ = (BJ1) - (CJ1)
                For i_ = CJ1 To CJ2 Step 1
                    C(K, i_) = C(K, i_) + V * B(R, i_ + i1_)
                Next i_
            Next R
        Next L
        Exit Sub
    End If
    
    '
    ' A*B'
    '
    If Not TransA And TransB Then
        If ARows * ACols < BRows * BCols Then
            For R = BI1 To BI2 Step 1
                For L = AI1 To AI2 Step 1
                    i1_ = (BJ1) - (AJ1)
                    V = 0#
                    For i_ = AJ1 To AJ2 Step 1
                        V = V + A(L, i_) * B(R, i_ + i1_)
                    Next i_
                    C(CI1 + L - AI1, CJ1 + R - BI1) = C(CI1 + L - AI1, CJ1 + R - BI1) + Alpha * V
                Next L
            Next R
            Exit Sub
        Else
            For L = AI1 To AI2 Step 1
                For R = BI1 To BI2 Step 1
                    i1_ = (BJ1) - (AJ1)
                    V = 0#
                    For i_ = AJ1 To AJ2 Step 1
                        V = V + A(L, i_) * B(R, i_ + i1_)
                    Next i_
                    C(CI1 + L - AI1, CJ1 + R - BI1) = C(CI1 + L - AI1, CJ1 + R - BI1) + Alpha * V
                Next R
            Next L
            Exit Sub
        End If
    End If
    
    '
    ' A'*B
    '
    If TransA And Not TransB Then
        For L = AJ1 To AJ2 Step 1
            For R = BI1 To BI2 Step 1
                V = Alpha * A(AI1 + R - BI1, L)
                K = CI1 + L - AJ1
                i1_ = (BJ1) - (CJ1)
                For i_ = CJ1 To CJ2 Step 1
                    C(K, i_) = C(K, i_) + V * B(R, i_ + i1_)
                Next i_
            Next R
        Next L
        Exit Sub
    End If
    
    '
    ' A'*B'
    '
    If TransA And TransB Then
        If ARows * ACols < BRows * BCols Then
            For R = BI1 To BI2 Step 1
                For i = 1# To CRows Step 1
                    WORK(i) = 0#
                Next i
                For L = AI1 To AI2 Step 1
                    V = Alpha * B(R, BJ1 + L - AI1)
                    K = CJ1 + R - BI1
                    i1_ = (AJ1) - (1#)
                    For i_ = 1# To CRows Step 1
                        WORK(i_) = WORK(i_) + V * A(L, i_ + i1_)
                    Next i_
                Next L
                i1_ = (1#) - (CI1)
                For i_ = CI1 To CI2 Step 1
                    C(i_, K) = C(i_, K) + WORK(i_ + i1_)
                Next i_
            Next R
            Exit Sub
        Else
            For L = AJ1 To AJ2 Step 1
                K = AI2 - AI1 + 1#
                i1_ = (AI1) - (1#)
                For i_ = 1# To K Step 1
                    WORK(i_) = A(i_ + i1_, L)
                Next i_
                For R = BI1 To BI2 Step 1
                    i1_ = (BJ1) - (1#)
                    V = 0#
                    For i_ = 1# To K Step 1
                        V = V + WORK(i_) * B(R, i_ + i1_)
                    Next i_
                    C(CI1 + L - AJ1, CJ1 + R - BI1) = C(CI1 + L - AJ1, CJ1 + R - BI1) + Alpha * V
                Next R
            Next L
            Exit Sub
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This file is a part of ALGLIB project.
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Utility subroutine performing the "safe" solution of system of linear
'equations with triangular coefficient matrices.
'
'The subroutine uses scaling and solves the scaled system A*x=s*b (where  s
'is  a  scalar  value)  instead  of  A*x=b,  choosing  s  so  that x can be
'represented by a floating-point number. The closer the system  gets  to  a
'singular, the less s is. If the system is singular, s=0 and x contains the
'non-trivial solution of equation A*x=0.
'
'The feature of an algorithm is that it could not cause an  overflow  or  a
'division by zero regardless of the matrix used as the input.
'
'The algorithm can solve systems of equations with  upper/lower  triangular
'matrices,  with/without unit diagonal, and systems of type A*x=b or A'*x=b
'(where A' is a transposed matrix A).
'
'Input parameters:
'    A       -   system matrix. Array whose indexes range within [0..N-1, 0..N-1].
'    N       -   size of matrix A.
'    X       -   right-hand member of a system.
'                Array whose index ranges within [0..N-1].
'    IsUpper -   matrix type. If it is True, the system matrix is the upper
'                triangular and is located in  the  corresponding  part  of
'                matrix A.
'    Trans   -   problem type. If it is True, the problem to be  solved  is
'                A'*x=b, otherwise it is A*x=b.
'    Isunit  -   matrix type. If it is True, the system matrix has  a  unit
'                diagonal (the elements on the main diagonal are  not  used
'                in the calculation process), otherwise the matrix is considered
'                to be a general triangular matrix.
'
'Output parameters:
'    X       -   solution. Array whose index ranges within [0..N-1].
'    S       -   scaling factor.
'
'  -- LAPACK auxiliary routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     June 30, 1992
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixTRSafeSolve(ByRef A() As Double, _
         ByVal N As Long, _
         ByRef X() As Double, _
         ByRef S As Double, _
         ByVal IsUpper As Boolean, _
         ByVal IsTrans As Boolean, _
         ByVal Isunit As Boolean)
    Dim NORMIN As Boolean
    Dim CNORM() As Double
    Dim A1() As Double
    Dim X1() As Double
    Dim i As Long
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' From 0-based to 1-based
    '
    NORMIN = False
    ReDim A1(1# To N, 1# To N)
    ReDim X1(1# To N)
    For i = 1# To N Step 1
        i1_ = (0#) - (1#)
        For i_ = 1# To N Step 1
            A1(i, i_) = A(i - 1#, i_ + i1_)
        Next i_
    Next i
    i1_ = (0#) - (1#)
    For i_ = 1# To N Step 1
        X1(i_) = X(i_ + i1_)
    Next i_
    
    '
    ' Solve 1-based
    '
    Call SafeSolveTriangular(A1, N, X1, S, IsUpper, IsTrans, Isunit, NORMIN, CNORM)
    
    '
    ' From 1-based to 0-based
    '
    i1_ = (1#) - (0#)
    For i_ = 0# To N - 1# Step 1
        X(i_) = X1(i_ + i1_)
    Next i_
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Obsolete 1-based subroutine.
'See RMatrixTRSafeSolve for 0-based replacement.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub SafeSolveTriangular(ByRef A() As Double, _
         ByVal N As Long, _
         ByRef X() As Double, _
         ByRef S As Double, _
         ByVal IsUpper As Boolean, _
         ByVal IsTrans As Boolean, _
         ByVal Isunit As Boolean, _
         ByVal NORMIN As Boolean, _
         ByRef CNORM() As Double)
    Dim i As Long
    Dim IMAX As Long
    Dim j As Long
    Dim JFIRST As Long
    Dim JINC As Long
    Dim JLAST As Long
    Dim JM1 As Long
    Dim JP1 As Long
    Dim IP1 As Long
    Dim IM1 As Long
    Dim K As Long
    Dim Flg As Long
    Dim V As Double
    Dim VD As Double
    Dim BIGNUM As Double
    Dim GROW As Double
    Dim REC As Double
    Dim SMLNUM As Double
    Dim SUMJ As Double
    Dim TJJ As Double
    Dim TJJS As Double
    Dim TMAX As Double
    Dim TSCAL As Double
    Dim USCAL As Double
    Dim XBND As Double
    Dim XJ As Double
    Dim XMAX As Double
    Dim NOTRAN As Boolean
    Dim UPPER As Boolean
    Dim NOunit As Boolean
    Dim i_ As Long
    UPPER = IsUpper
    NOTRAN = Not IsTrans
    NOunit = Not Isunit
    
    '
    ' Quick return if possible
    '
    If N = 0# Then
        Exit Sub
    End If
    
    '
    ' Determine machine dependent parameters to control overflow.
    '
    SMLNUM = MinRealNumber / (MachineEpsilon * 2#)
    BIGNUM = 1# / SMLNUM
    S = 1#
    If Not NORMIN Then
        ReDim CNORM(1# To N)
        
        '
        ' Compute the 1-norm of each column, not including the diagonal.
        '
        If UPPER Then
            
            '
            ' A is upper triangular.
            '
            For j = 1# To N Step 1
                V = 0#
                For K = 1# To j - 1# Step 1
                    V = V + Abs(A(K, j))
                Next K
                CNORM(j) = V
            Next j
        Else
            
            '
            ' A is lower triangular.
            '
            For j = 1# To N - 1# Step 1
                V = 0#
                For K = j + 1# To N Step 1
                    V = V + Abs(A(K, j))
                Next K
                CNORM(j) = V
            Next j
            CNORM(N) = 0#
        End If
    End If
    
    '
    ' Scale the column norms by TSCAL if the maximum element in CNORM is
    ' greater than BIGNUM.
    '
    IMAX = 1#
    For K = 2# To N Step 1
        If CNORM(K) > CNORM(IMAX) Then
            IMAX = K
        End If
    Next K
    TMAX = CNORM(IMAX)
    If TMAX <= BIGNUM Then
        TSCAL = 1#
    Else
        TSCAL = 1# / (SMLNUM * TMAX)
        For i_ = 1# To N Step 1
            CNORM(i_) = TSCAL * CNORM(i_)
        Next i_
    End If
    
    '
    ' Compute a bound on the computed solution vector to see if the
    ' Level 2 BLAS routine DTRSV can be used.
    '
    j = 1#
    For K = 2# To N Step 1
        If Abs(X(K)) > Abs(X(j)) Then
            j = K
        End If
    Next K
    XMAX = Abs(X(j))
    XBND = XMAX
    If NOTRAN Then
        
        '
        ' Compute the growth in A * x = b.
        '
        If UPPER Then
            JFIRST = N
            JLAST = 1#
            JINC = -1#
        Else
            JFIRST = 1#
            JLAST = N
            JINC = 1#
        End If
        If TSCAL <> 1# Then
            GROW = 0#
        Else
            If NOunit Then
                
                '
                ' A is non-unit triangular.
                '
                ' Compute GROW = 1/G(j) and XBND = 1/M(j).
                ' Initially, G(0) = max{x(i), i=1,...,n}.
                '
                GROW = 1# / MaxReal(XBND, SMLNUM)
                XBND = GROW
                j = JFIRST
                Do While JINC > 0# And j <= JLAST Or JINC < 0# And j >= JLAST
                    
                    '
                    ' Exit the loop if the growth factor is too small.
                    '
                    If GROW <= SMLNUM Then
                        Exit Do
                    End If
                    
                    '
                    ' M(j) = G(j-1) / abs(A(j,j))
                    '
                    TJJ = Abs(A(j, j))
                    XBND = MinReal(XBND, MinReal(1#, TJJ) * GROW)
                    If TJJ + CNORM(j) >= SMLNUM Then
                        
                        '
                        ' G(j) = G(j-1)*( 1 + CNORM(j) / abs(A(j,j)) )
                        '
                        GROW = GROW * (TJJ / (TJJ + CNORM(j)))
                    Else
                        
                        '
                        ' G(j) could overflow, set GROW to 0.
                        '
                        GROW = 0#
                    End If
                    If j = JLAST Then
                        GROW = XBND
                    End If
                    j = j + JINC
                Loop
            Else
                
                '
                ' A is unit triangular.
                '
                ' Compute GROW = 1/G(j), where G(0) = max{x(i), i=1,...,n}.
                '
                GROW = MinReal(1#, 1# / MaxReal(XBND, SMLNUM))
                j = JFIRST
                Do While JINC > 0# And j <= JLAST Or JINC < 0# And j >= JLAST
                    
                    '
                    ' Exit the loop if the growth factor is too small.
                    '
                    If GROW <= SMLNUM Then
                        Exit Do
                    End If
                    
                    '
                    ' G(j) = G(j-1)*( 1 + CNORM(j) )
                    '
                    GROW = GROW * (1# / (1# + CNORM(j)))
                    j = j + JINC
                Loop
            End If
        End If
    Else
        
        '
        ' Compute the growth in A' * x = b.
        '
        If UPPER Then
            JFIRST = 1#
            JLAST = N
            JINC = 1#
        Else
            JFIRST = N
            JLAST = 1#
            JINC = -1#
        End If
        If TSCAL <> 1# Then
            GROW = 0#
        Else
            If NOunit Then
                
                '
                ' A is non-unit triangular.
                '
                ' Compute GROW = 1/G(j) and XBND = 1/M(j).
                ' Initially, M(0) = max{x(i), i=1,...,n}.
                '
                GROW = 1# / MaxReal(XBND, SMLNUM)
                XBND = GROW
                j = JFIRST
                Do While JINC > 0# And j <= JLAST Or JINC < 0# And j >= JLAST
                    
                    '
                    ' Exit the loop if the growth factor is too small.
                    '
                    If GROW <= SMLNUM Then
                        Exit Do
                    End If
                    
                    '
                    ' G(j) = max( G(j-1), M(j-1)*( 1 + CNORM(j) ) )
                    '
                    XJ = 1# + CNORM(j)
                    GROW = MinReal(GROW, XBND / XJ)
                    
                    '
                    ' M(j) = M(j-1)*( 1 + CNORM(j) ) / abs(A(j,j))
                    '
                    TJJ = Abs(A(j, j))
                    If XJ > TJJ Then
                        XBND = XBND * (TJJ / XJ)
                    End If
                    If j = JLAST Then
                        GROW = MinReal(GROW, XBND)
                    End If
                    j = j + JINC
                Loop
            Else
                
                '
                ' A is unit triangular.
                '
                ' Compute GROW = 1/G(j), where G(0) = max{x(i), i=1,...,n}.
                '
                GROW = MinReal(1#, 1# / MaxReal(XBND, SMLNUM))
                j = JFIRST
                Do While JINC > 0# And j <= JLAST Or JINC < 0# And j >= JLAST
                    
                    '
                    ' Exit the loop if the growth factor is too small.
                    '
                    If GROW <= SMLNUM Then
                        Exit Do
                    End If
                    
                    '
                    ' G(j) = ( 1 + CNORM(j) )*G(j-1)
                    '
                    XJ = 1# + CNORM(j)
                    GROW = GROW / XJ
                    j = j + JINC
                Loop
            End If
        End If
    End If
    If GROW * TSCAL > SMLNUM Then
        
        '
        ' Use the Level 2 BLAS solve if the reciprocal of the bound on
        ' elements of X is not too small.
        '
        If UPPER And NOTRAN Or Not UPPER And Not NOTRAN Then
            If NOunit Then
                VD = A(N, N)
            Else
                VD = 1#
            End If
            X(N) = X(N) / VD
            For i = N - 1# To 1# Step -1
                IP1 = i + 1#
                If UPPER Then
                    V = 0#
                    For i_ = IP1 To N Step 1
                        V = V + A(i, i_) * X(i_)
                    Next i_
                Else
                    V = 0#
                    For i_ = IP1 To N Step 1
                        V = V + A(i_, i) * X(i_)
                    Next i_
                End If
                If NOunit Then
                    VD = A(i, i)
                Else
                    VD = 1#
                End If
                X(i) = (X(i) - V) / VD
            Next i
        Else
            If NOunit Then
                VD = A(1#, 1#)
            Else
                VD = 1#
            End If
            X(1#) = X(1#) / VD
            For i = 2# To N Step 1
                IM1 = i - 1#
                If UPPER Then
                    V = 0#
                    For i_ = 1# To IM1 Step 1
                        V = V + A(i_, i) * X(i_)
                    Next i_
                Else
                    V = 0#
                    For i_ = 1# To IM1 Step 1
                        V = V + A(i, i_) * X(i_)
                    Next i_
                End If
                If NOunit Then
                    VD = A(i, i)
                Else
                    VD = 1#
                End If
                X(i) = (X(i) - V) / VD
            Next i
        End If
    Else
        
        '
        ' Use a Level 1 BLAS solve, scaling intermediate results.
        '
        If XMAX > BIGNUM Then
            
            '
            ' Scale X so that its components are less than or equal to
            ' BIGNUM in absolute value.
            '
            S = BIGNUM / XMAX
            For i_ = 1# To N Step 1
                X(i_) = S * X(i_)
            Next i_
            XMAX = BIGNUM
        End If
        If NOTRAN Then
            
            '
            ' Solve A * x = b
            '
            j = JFIRST
            Do While JINC > 0# And j <= JLAST Or JINC < 0# And j >= JLAST
                
                '
                ' Compute x(j) = b(j) / A(j,j), scaling x if necessary.
                '
                XJ = Abs(X(j))
                Flg = 0#
                If NOunit Then
                    TJJS = A(j, j) * TSCAL
                Else
                    TJJS = TSCAL
                    If TSCAL = 1# Then
                        Flg = 100#
                    End If
                End If
                If Flg <> 100# Then
                    TJJ = Abs(TJJS)
                    If TJJ > SMLNUM Then
                        
                        '
                        ' abs(A(j,j)) > SMLNUM:
                        '
                        If TJJ < 1# Then
                            If XJ > TJJ * BIGNUM Then
                                
                                '
                                ' Scale x by 1/b(j).
                                '
                                REC = 1# / XJ
                                For i_ = 1# To N Step 1
                                    X(i_) = REC * X(i_)
                                Next i_
                                S = S * REC
                                XMAX = XMAX * REC
                            End If
                        End If
                        X(j) = X(j) / TJJS
                        XJ = Abs(X(j))
                    Else
                        If TJJ > 0# Then
                            
                            '
                            ' 0 < abs(A(j,j)) <= SMLNUM:
                            '
                            If XJ > TJJ * BIGNUM Then
                                
                                '
                                ' Scale x by (1/abs(x(j)))*abs(A(j,j))*BIGNUM
                                ' to avoid overflow when dividing by A(j,j).
                                '
                                REC = TJJ * BIGNUM / XJ
                                If CNORM(j) > 1# Then
                                    
                                    '
                                    ' Scale by 1/CNORM(j) to avoid overflow when
                                    ' multiplying x(j) times column j.
                                    '
                                    REC = REC / CNORM(j)
                                End If
                                For i_ = 1# To N Step 1
                                    X(i_) = REC * X(i_)
                                Next i_
                                S = S * REC
                                XMAX = XMAX * REC
                            End If
                            X(j) = X(j) / TJJS
                            XJ = Abs(X(j))
                        Else
                            
                            '
                            ' A(j,j) = 0:  Set x(1:n) = 0, x(j) = 1, and
                            ' scale = 0, and compute a solution to A*x = 0.
                            '
                            For i = 1# To N Step 1
                                X(i) = 0#
                            Next i
                            X(j) = 1#
                            XJ = 1#
                            S = 0#
                            XMAX = 0#
                        End If
                    End If
                End If
                
                '
                ' Scale x if necessary to avoid overflow when adding a
                ' multiple of column j of A.
                '
                If XJ > 1# Then
                    REC = 1# / XJ
                    If CNORM(j) > (BIGNUM - XMAX) * REC Then
                        
                        '
                        ' Scale x by 1/(2*abs(x(j))).
                        '
                        REC = REC * 0.5
                        For i_ = 1# To N Step 1
                            X(i_) = REC * X(i_)
                        Next i_
                        S = S * REC
                    End If
                Else
                    If XJ * CNORM(j) > BIGNUM - XMAX Then
                        
                        '
                        ' Scale x by 1/2.
                        '
                        For i_ = 1# To N Step 1
                            X(i_) = 0.5 * X(i_)
                        Next i_
                        S = S * 0.5
                    End If
                End If
                If UPPER Then
                    If j > 1# Then
                        
                        '
                        ' Compute the update
                        ' x(1:j-1) := x(1:j-1) - x(j) * A(1:j-1,j)
                        '
                        V = X(j) * TSCAL
                        JM1 = j - 1#
                        For i_ = 1# To JM1 Step 1
                            X(i_) = X(i_) - V * A(i_, j)
                        Next i_
                        i = 1#
                        For K = 2# To j - 1# Step 1
                            If Abs(X(K)) > Abs(X(i)) Then
                                i = K
                            End If
                        Next K
                        XMAX = Abs(X(i))
                    End If
                Else
                    If j < N Then
                        
                        '
                        ' Compute the update
                        ' x(j+1:n) := x(j+1:n) - x(j) * A(j+1:n,j)
                        '
                        JP1 = j + 1#
                        V = X(j) * TSCAL
                        For i_ = JP1 To N Step 1
                            X(i_) = X(i_) - V * A(i_, j)
                        Next i_
                        i = j + 1#
                        For K = j + 2# To N Step 1
                            If Abs(X(K)) > Abs(X(i)) Then
                                i = K
                            End If
                        Next K
                        XMAX = Abs(X(i))
                    End If
                End If
                j = j + JINC
            Loop
        Else
            
            '
            ' Solve A' * x = b
            '
            j = JFIRST
            Do While JINC > 0# And j <= JLAST Or JINC < 0# And j >= JLAST
                
                '
                ' Compute x(j) = b(j) - sum A(k,j)*x(k).
                '   k<>j
                '
                XJ = Abs(X(j))
                USCAL = TSCAL
                REC = 1# / MaxReal(XMAX, 1#)
                If CNORM(j) > (BIGNUM - XJ) * REC Then
                    
                    '
                    ' If x(j) could overflow, scale x by 1/(2*XMAX).
                    '
                    REC = REC * 0.5
                    If NOunit Then
                        TJJS = A(j, j) * TSCAL
                    Else
                        TJJS = TSCAL
                    End If
                    TJJ = Abs(TJJS)
                    If TJJ > 1# Then
                        
                        '
                        ' Divide by A(j,j) when scaling x if A(j,j) > 1.
                        '
                        REC = MinReal(1#, REC * TJJ)
                        USCAL = USCAL / TJJS
                    End If
                    If REC < 1# Then
                        For i_ = 1# To N Step 1
                            X(i_) = REC * X(i_)
                        Next i_
                        S = S * REC
                        XMAX = XMAX * REC
                    End If
                End If
                SUMJ = 0#
                If USCAL = 1# Then
                    
                    '
                    ' If the scaling needed for A in the dot product is 1,
                    ' call DDOT to perform the dot product.
                    '
                    If UPPER Then
                        If j > 1# Then
                            JM1 = j - 1#
                            SUMJ = 0#
                            For i_ = 1# To JM1 Step 1
                                SUMJ = SUMJ + A(i_, j) * X(i_)
                            Next i_
                        Else
                            SUMJ = 0#
                        End If
                    Else
                        If j < N Then
                            JP1 = j + 1#
                            SUMJ = 0#
                            For i_ = JP1 To N Step 1
                                SUMJ = SUMJ + A(i_, j) * X(i_)
                            Next i_
                        End If
                    End If
                Else
                    
                    '
                    ' Otherwise, use in-line code for the dot product.
                    '
                    If UPPER Then
                        For i = 1# To j - 1# Step 1
                            V = A(i, j) * USCAL
                            SUMJ = SUMJ + V * X(i)
                        Next i
                    Else
                        If j < N Then
                            For i = j + 1# To N Step 1
                                V = A(i, j) * USCAL
                                SUMJ = SUMJ + V * X(i)
                            Next i
                        End If
                    End If
                End If
                If USCAL = TSCAL Then
                    
                    '
                    ' Compute x(j) := ( x(j) - sumj ) / A(j,j) if 1/A(j,j)
                    ' was not used to scale the dotproduct.
                    '
                    X(j) = X(j) - SUMJ
                    XJ = Abs(X(j))
                    Flg = 0#
                    If NOunit Then
                        TJJS = A(j, j) * TSCAL
                    Else
                        TJJS = TSCAL
                        If TSCAL = 1# Then
                            Flg = 150#
                        End If
                    End If
                    
                    '
                    ' Compute x(j) = x(j) / A(j,j), scaling if necessary.
                    '
                    If Flg <> 150# Then
                        TJJ = Abs(TJJS)
                        If TJJ > SMLNUM Then
                            
                            '
                            ' abs(A(j,j)) > SMLNUM:
                            '
                            If TJJ < 1# Then
                                If XJ > TJJ * BIGNUM Then
                                    
                                    '
                                    ' Scale X by 1/abs(x(j)).
                                    '
                                    REC = 1# / XJ
                                    For i_ = 1# To N Step 1
                                        X(i_) = REC * X(i_)
                                    Next i_
                                    S = S * REC
                                    XMAX = XMAX * REC
                                End If
                            End If
                            X(j) = X(j) / TJJS
                        Else
                            If TJJ > 0# Then
                                
                                '
                                ' 0 < abs(A(j,j)) <= SMLNUM:
                                '
                                If XJ > TJJ * BIGNUM Then
                                    
                                    '
                                    ' Scale x by (1/abs(x(j)))*abs(A(j,j))*BIGNUM.
                                    '
                                    REC = TJJ * BIGNUM / XJ
                                    For i_ = 1# To N Step 1
                                        X(i_) = REC * X(i_)
                                    Next i_
                                    S = S * REC
                                    XMAX = XMAX * REC
                                End If
                                X(j) = X(j) / TJJS
                            Else
                                
                                '
                                ' A(j,j) = 0:  Set x(1:n) = 0, x(j) = 1, and
                                ' scale = 0, and compute a solution to A'*x = 0.
                                '
                                For i = 1# To N Step 1
                                    X(i) = 0#
                                Next i
                                X(j) = 1#
                                S = 0#
                                XMAX = 0#
                            End If
                        End If
                    End If
                Else
                    
                    '
                    ' Compute x(j) := x(j) / A(j,j)  - sumj if the dot
                    ' product has already been divided by 1/A(j,j).
                    '
                    X(j) = X(j) / TJJS - SUMJ
                End If
                XMAX = MaxReal(XMAX, Abs(X(j)))
                j = j + JINC
            Loop
        End If
        S = S / TSCAL
    End If
    
    '
    ' Scale the column norms by 1/TSCAL for return.
    '
    If TSCAL <> 1# Then
        V = 1# / TSCAL
        For i_ = 1# To N Step 1
            CNORM(i_) = V * CNORM(i_)
        Next i_
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 1992-2007 The University of Tennessee. All rights reserved.
'
'Contributors:
'    * Sergey Bochkanov (ALGLIB project). Translation from FORTRAN to
'      pseudocode.
'
'See subroutines comments for additional copyrights.
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'LU decomposition of a general real matrix with row pivoting
'
'A is represented as A = P*L*U, where:
'* L is lower unitriangular matrix
'* U is upper triangular matrix
'* P = P0*P1*...*PK, K=min(M,N)-1,
'  Pi - permutation matrix for I and Pivots[I]
'
'This is cache-oblivous implementation of LU decomposition.
'It is optimized for square matrices. As for rectangular matrices:
'* best case - M>>N
'* worst case - N>>M, small M, large N, matrix does not fit in CPU cache
'
'INPUT PARAMETERS:
'    A       -   array[0..M-1, 0..N-1].
'    M       -   number of rows in matrix A.
'    N       -   number of columns in matrix A.
'
'
'OUTPUT PARAMETERS:
'    A       -   matrices L and U in compact form:
'                * L is stored under main diagonal
'                * U is stored on and above main diagonal
'    Pivots  -   permutation matrix in compact form.
'                array[0..Min(M-1,N-1)].
'
'  -- ALGLIB routine --
'     10.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixLU(ByRef A() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Pivots() As Long)
    Call RMatrixPLU(A, M, N, Pivots)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'LU decomposition of a general complex matrix with row pivoting
'
'A is represented as A = P*L*U, where:
'* L is lower unitriangular matrix
'* U is upper triangular matrix
'* P = P0*P1*...*PK, K=min(M,N)-1,
'  Pi - permutation matrix for I and Pivots[I]
'
'This is cache-oblivous implementation of LU decomposition. It is optimized
'for square matrices. As for rectangular matrices:
'* best case - M>>N
'* worst case - N>>M, small M, large N, matrix does not fit in CPU cache
'
'INPUT PARAMETERS:
'    A       -   array[0..M-1, 0..N-1].
'    M       -   number of rows in matrix A.
'    N       -   number of columns in matrix A.
'
'
'OUTPUT PARAMETERS:
'    A       -   matrices L and U in compact form:
'                * L is stored under main diagonal
'                * U is stored on and above main diagonal
'    Pivots  -   permutation matrix in compact form.
'                array[0..Min(M-1,N-1)].
'
'  -- ALGLIB routine --
'     10.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixLU(ByRef A() As Complex, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Pivots() As Long)
    Call CMatrixPLU(A, M, N, Pivots)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Cache-oblivious Cholesky decomposition
'
'The algorithm computes Cholesky decomposition  of  a  Hermitian  positive-
'definite matrix. The result of an algorithm is a representation  of  A  as
'A=U'*U  or A=L*L' (here X' detones conj(X^T)).
'
'INPUT PARAMETERS:
'    A       -   upper or lower triangle of a factorized matrix.
'                array with elements [0..N-1, 0..N-1].
'    N       -   size of matrix A.
'    IsUpper -   if IsUpper=True, then A contains an upper triangle of
'                a symmetric matrix, otherwise A contains a lower one.
'
'OUTPUT PARAMETERS:
'    A       -   the result of factorization. If IsUpper=True, then
'                the upper triangle contains matrix U, so that A = U'*U,
'                and the elements below the main diagonal are not modified.
'                Similarly, if IsUpper = False.
'
'RESULT:
'    If  the  matrix  is  positive-definite,  the  function  returns  True.
'    Otherwise, the function returns False. Contents of A is not determined
'    in such case.
'
'  -- ALGLIB routine --
'     15.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function HPDMatrixCholesky(ByRef A() As Complex, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean) As Boolean
    Dim Result As Boolean
    Dim Tmp() As Complex
    If N < 1# Then
        Result = False
        HPDMatrixCholesky = Result
        Exit Function
    End If
    ReDim Tmp(0 To 2# * N - 1)
    Result = HPDMatrixCholeskyRec(A, 0#, N, IsUpper, Tmp)
    HPDMatrixCholesky = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Cache-oblivious Cholesky decomposition
'
'The algorithm computes Cholesky decomposition  of  a  symmetric  positive-
'definite matrix. The result of an algorithm is a representation  of  A  as
'A=U^T*U  or A=L*L^T
'
'INPUT PARAMETERS:
'    A       -   upper or lower triangle of a factorized matrix.
'                array with elements [0..N-1, 0..N-1].
'    N       -   size of matrix A.
'    IsUpper -   if IsUpper=True, then A contains an upper triangle of
'                a symmetric matrix, otherwise A contains a lower one.
'
'OUTPUT PARAMETERS:
'    A       -   the result of factorization. If IsUpper=True, then
'                the upper triangle contains matrix U, so that A = U^T*U,
'                and the elements below the main diagonal are not modified.
'                Similarly, if IsUpper = False.
'
'RESULT:
'    If  the  matrix  is  positive-definite,  the  function  returns  True.
'    Otherwise, the function returns False. Contents of A is not determined
'    in such case.
'
'  -- ALGLIB routine --
'     15.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function SPDMatrixCholesky(ByRef A() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean) As Boolean
    Dim Result As Boolean
    Dim Tmp() As Double
    If N < 1# Then
        Result = False
        SPDMatrixCholesky = Result
        Exit Function
    End If
    ReDim Tmp(0 To 2# * N - 1)
    Result = SPDMatrixCholeskyRec(A, 0#, N, IsUpper, Tmp)
    SPDMatrixCholesky = Result
End Function
Public Sub RMatrixLUP(ByRef A() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Pivots() As Long)
    Dim Tmp() As Double
    Dim i As Long
    Dim j As Long
    Dim MX As Double
    Dim V As Double
    Dim i_ As Long
    
    '
    ' Internal LU decomposition subroutine.
    ' Never call it directly.
    '
    
    '
    ' Scale matrix to avoid overflows,
    ' decompose it, then scale back.
    '
    MX = 0#
    For i = 0# To M - 1# Step 1
        For j = 0# To N - 1# Step 1
            MX = MaxReal(MX, Abs(A(i, j)))
        Next j
    Next i
    If MX <> 0# Then
        V = 1# / MX
        For i = 0# To M - 1# Step 1
            For i_ = 0# To N - 1# Step 1
                A(i, i_) = V * A(i, i_)
            Next i_
        Next i
    End If
    ReDim Pivots(0 To MinInt(M, N) - 1)
    ReDim Tmp(0 To 2# * MaxInt(M, N) - 1)
    Call RMatrixLUPRec(A, 0#, M, N, Pivots, Tmp)
    If MX <> 0# Then
        V = MX
        For i = 0# To M - 1# Step 1
            For i_ = 0# To MinInt(i, N - 1#) Step 1
                A(i, i_) = V * A(i, i_)
            Next i_
        Next i
    End If
End Sub
Public Sub CMatrixLUP(ByRef A() As Complex, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Pivots() As Long)
    Dim Tmp() As Complex
    Dim i As Long
    Dim j As Long
    Dim MX As Double
    Dim V As Double
    Dim i_ As Long
    
    '
    ' Internal LU decomposition subroutine.
    ' Never call it directly.
    '
    
    '
    ' Scale matrix to avoid overflows,
    ' decompose it, then scale back.
    '
    MX = 0#
    For i = 0# To M - 1# Step 1
        For j = 0# To N - 1# Step 1
            MX = MaxReal(MX, AbsComplex(A(i, j)))
        Next j
    Next i
    If MX <> 0# Then
        V = 1# / MX
        For i = 0# To M - 1# Step 1
            For i_ = 0# To N - 1# Step 1
                A(i, i_) = C_MulR(A(i, i_), V)
            Next i_
        Next i
    End If
    ReDim Pivots(0 To MinInt(M, N) - 1)
    ReDim Tmp(0 To 2# * MaxInt(M, N) - 1)
    Call CMatrixLUPRec(A, 0#, M, N, Pivots, Tmp)
    If MX <> 0# Then
        V = MX
        For i = 0# To M - 1# Step 1
            For i_ = 0# To MinInt(i, N - 1#) Step 1
                A(i, i_) = C_MulR(A(i, i_), V)
            Next i_
        Next i
    End If
End Sub
Public Sub RMatrixPLU(ByRef A() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Pivots() As Long)
    Dim Tmp() As Double
    Dim i As Long
    Dim j As Long
    Dim MX As Double
    Dim V As Double
    Dim i_ As Long
    
    '
    ' Internal LU decomposition subroutine.
    ' Never call it directly.
    '
    ReDim Tmp(0 To 2# * MaxInt(M, N) - 1)
    ReDim Pivots(0 To MinInt(M, N) - 1)
    
    '
    ' Scale matrix to avoid overflows,
    ' decompose it, then scale back.
    '
    MX = 0#
    For i = 0# To M - 1# Step 1
        For j = 0# To N - 1# Step 1
            MX = MaxReal(MX, Abs(A(i, j)))
        Next j
    Next i
    If MX <> 0# Then
        V = 1# / MX
        For i = 0# To M - 1# Step 1
            For i_ = 0# To N - 1# Step 1
                A(i, i_) = V * A(i, i_)
            Next i_
        Next i
    End If
    Call RMatrixPLURec(A, 0#, M, N, Pivots, Tmp)
    If MX <> 0# Then
        V = MX
        For i = 0# To MinInt(M, N) - 1# Step 1
            For i_ = i To N - 1# Step 1
                A(i, i_) = V * A(i, i_)
            Next i_
        Next i
    End If
End Sub
Public Sub CMatrixPLU(ByRef A() As Complex, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Pivots() As Long)
    Dim Tmp() As Complex
    Dim i As Long
    Dim j As Long
    Dim MX As Double
    Dim V As Complex
    Dim i_ As Long
    
    '
    ' Internal LU decomposition subroutine.
    ' Never call it directly.
    '
    ReDim Tmp(0 To 2# * MaxInt(M, N) - 1)
    ReDim Pivots(0 To MinInt(M, N) - 1)
    
    '
    ' Scale matrix to avoid overflows,
    ' decompose it, then scale back.
    '
    MX = 0#
    For i = 0# To M - 1# Step 1
        For j = 0# To N - 1# Step 1
            MX = MaxReal(MX, AbsComplex(A(i, j)))
        Next j
    Next i
    If MX <> 0# Then
        V = C_Complex(1# / MX)
        For i = 0# To M - 1# Step 1
            For i_ = 0# To N - 1# Step 1
                A(i, i_) = C_Mul(V, A(i, i_))
            Next i_
        Next i
    End If
    Call CMatrixPLURec(A, 0#, M, N, Pivots, Tmp)
    If MX <> 0# Then
        V = C_Complex(MX)
        For i = 0# To MinInt(M, N) - 1# Step 1
            For i_ = i To N - 1# Step 1
                A(i, i_) = C_Mul(V, A(i, i_))
            Next i_
        Next i
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Recurrent complex LU subroutine.
'Never call it directly.
'
'  -- ALGLIB routine --
'     04.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub CMatrixLUPRec(ByRef A() As Complex, _
         ByVal Offs As Long, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Pivots() As Long, _
         ByRef Tmp() As Complex)
    Dim i As Long
    Dim M1 As Long
    Dim M2 As Long
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' Kernel case
    '
    If MinInt(M, N) <= ABLASComplexBlockSize(A) Then
        Call CMatrixLUP2(A, Offs, M, N, Pivots, Tmp)
        Exit Sub
    End If
    
    '
    ' Preliminary step, make N>=M
    '
    '     ( A1 )
    ' A = (    ), where A1 is square
    '     ( A2 )
    '
    ' Factorize A1, update A2
    '
    If M > N Then
        Call CMatrixLUPRec(A, Offs, N, N, Pivots, Tmp)
        For i = 0# To N - 1# Step 1
            i1_ = (Offs + N) - (0#)
            For i_ = 0# To M - N - 1# Step 1
                Tmp(i_) = A(i_ + i1_, Offs + i)
            Next i_
            For i_ = Offs + N To Offs + M - 1# Step 1
                A(i_, Offs + i) = A(i_, Pivots(Offs + i))
            Next i_
            i1_ = (0#) - (Offs + N)
            For i_ = Offs + N To Offs + M - 1# Step 1
                A(i_, Pivots(Offs + i)) = Tmp(i_ + i1_)
            Next i_
        Next i
        Call CMatrixRightTRSM(M - N, N, A, Offs, Offs, True, True, 0#, A, Offs + N, Offs)
        Exit Sub
    End If
    
    '
    ' Non-kernel case
    '
    Call ABLASComplexSplitLength(A, M, M1, M2)
    Call CMatrixLUPRec(A, Offs, M1, N, Pivots, Tmp)
    If M2 > 0# Then
        For i = 0# To M1 - 1# Step 1
            If Offs + i <> Pivots(Offs + i) Then
                i1_ = (Offs + M1) - (0#)
                For i_ = 0# To M2 - 1# Step 1
                    Tmp(i_) = A(i_ + i1_, Offs + i)
                Next i_
                For i_ = Offs + M1 To Offs + M - 1# Step 1
                    A(i_, Offs + i) = A(i_, Pivots(Offs + i))
                Next i_
                i1_ = (0#) - (Offs + M1)
                For i_ = Offs + M1 To Offs + M - 1# Step 1
                    A(i_, Pivots(Offs + i)) = Tmp(i_ + i1_)
                Next i_
            End If
        Next i
        Call CMatrixRightTRSM(M2, M1, A, Offs, Offs, True, True, 0#, A, Offs + M1, Offs)
        Call CMatrixGEMM(M - M1, N - M1, M1, C_Complex(-1#), A, Offs + M1, Offs, 0#, A, Offs, Offs + M1, 0#, C_Complex(1#), A, Offs + M1, Offs + M1)
        Call CMatrixLUPRec(A, Offs + M1, M - M1, N - M1, Pivots, Tmp)
        For i = 0# To M2 - 1# Step 1
            If Offs + M1 + i <> Pivots(Offs + M1 + i) Then
                i1_ = (Offs) - (0#)
                For i_ = 0# To M1 - 1# Step 1
                    Tmp(i_) = A(i_ + i1_, Offs + M1 + i)
                Next i_
                For i_ = Offs To Offs + M1 - 1# Step 1
                    A(i_, Offs + M1 + i) = A(i_, Pivots(Offs + M1 + i))
                Next i_
                i1_ = (0#) - (Offs)
                For i_ = Offs To Offs + M1 - 1# Step 1
                    A(i_, Pivots(Offs + M1 + i)) = Tmp(i_ + i1_)
                Next i_
            End If
        Next i
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Recurrent real LU subroutine.
'Never call it directly.
'
'  -- ALGLIB routine --
'     04.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub RMatrixLUPRec(ByRef A() As Double, _
         ByVal Offs As Long, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Pivots() As Long, _
         ByRef Tmp() As Double)
    Dim i As Long
    Dim M1 As Long
    Dim M2 As Long
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' Kernel case
    '
    If MinInt(M, N) <= ABLASBlockSize(A) Then
        Call RMatrixLUP2(A, Offs, M, N, Pivots, Tmp)
        Exit Sub
    End If
    
    '
    ' Preliminary step, make N>=M
    '
    '     ( A1 )
    ' A = (    ), where A1 is square
    '     ( A2 )
    '
    ' Factorize A1, update A2
    '
    If M > N Then
        Call RMatrixLUPRec(A, Offs, N, N, Pivots, Tmp)
        For i = 0# To N - 1# Step 1
            If Offs + i <> Pivots(Offs + i) Then
                i1_ = (Offs + N) - (0#)
                For i_ = 0# To M - N - 1# Step 1
                    Tmp(i_) = A(i_ + i1_, Offs + i)
                Next i_
                For i_ = Offs + N To Offs + M - 1# Step 1
                    A(i_, Offs + i) = A(i_, Pivots(Offs + i))
                Next i_
                i1_ = (0#) - (Offs + N)
                For i_ = Offs + N To Offs + M - 1# Step 1
                    A(i_, Pivots(Offs + i)) = Tmp(i_ + i1_)
                Next i_
            End If
        Next i
        Call RMatrixRightTRSM(M - N, N, A, Offs, Offs, True, True, 0#, A, Offs + N, Offs)
        Exit Sub
    End If
    
    '
    ' Non-kernel case
    '
    Call ABLASSplitLength(A, M, M1, M2)
    Call RMatrixLUPRec(A, Offs, M1, N, Pivots, Tmp)
    If M2 > 0# Then
        For i = 0# To M1 - 1# Step 1
            If Offs + i <> Pivots(Offs + i) Then
                i1_ = (Offs + M1) - (0#)
                For i_ = 0# To M2 - 1# Step 1
                    Tmp(i_) = A(i_ + i1_, Offs + i)
                Next i_
                For i_ = Offs + M1 To Offs + M - 1# Step 1
                    A(i_, Offs + i) = A(i_, Pivots(Offs + i))
                Next i_
                i1_ = (0#) - (Offs + M1)
                For i_ = Offs + M1 To Offs + M - 1# Step 1
                    A(i_, Pivots(Offs + i)) = Tmp(i_ + i1_)
                Next i_
            End If
        Next i
        Call RMatrixRightTRSM(M2, M1, A, Offs, Offs, True, True, 0#, A, Offs + M1, Offs)
        Call RMatrixGEMM(M - M1, N - M1, M1, -1#, A, Offs + M1, Offs, 0#, A, Offs, Offs + M1, 0#, 1#, A, Offs + M1, Offs + M1)
        Call RMatrixLUPRec(A, Offs + M1, M - M1, N - M1, Pivots, Tmp)
        For i = 0# To M2 - 1# Step 1
            If Offs + M1 + i <> Pivots(Offs + M1 + i) Then
                i1_ = (Offs) - (0#)
                For i_ = 0# To M1 - 1# Step 1
                    Tmp(i_) = A(i_ + i1_, Offs + M1 + i)
                Next i_
                For i_ = Offs To Offs + M1 - 1# Step 1
                    A(i_, Offs + M1 + i) = A(i_, Pivots(Offs + M1 + i))
                Next i_
                i1_ = (0#) - (Offs)
                For i_ = Offs To Offs + M1 - 1# Step 1
                    A(i_, Pivots(Offs + M1 + i)) = Tmp(i_ + i1_)
                Next i_
            End If
        Next i
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Recurrent complex LU subroutine.
'Never call it directly.
'
'  -- ALGLIB routine --
'     04.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub CMatrixPLURec(ByRef A() As Complex, _
         ByVal Offs As Long, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Pivots() As Long, _
         ByRef Tmp() As Complex)
    Dim i As Long
    Dim N1 As Long
    Dim N2 As Long
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' Kernel case
    '
    If MinInt(M, N) <= ABLASComplexBlockSize(A) Then
        Call CMatrixPLU2(A, Offs, M, N, Pivots, Tmp)
        Exit Sub
    End If
    
    '
    ' Preliminary step, make M>=N.
    '
    ' A = (A1 A2), where A1 is square
    ' Factorize A1, update A2
    '
    If N > M Then
        Call CMatrixPLURec(A, Offs, M, M, Pivots, Tmp)
        For i = 0# To M - 1# Step 1
            i1_ = (Offs + M) - (0#)
            For i_ = 0# To N - M - 1# Step 1
                Tmp(i_) = A(Offs + i, i_ + i1_)
            Next i_
            For i_ = Offs + M To Offs + N - 1# Step 1
                A(Offs + i, i_) = A(Pivots(Offs + i), i_)
            Next i_
            i1_ = (0#) - (Offs + M)
            For i_ = Offs + M To Offs + N - 1# Step 1
                A(Pivots(Offs + i), i_) = Tmp(i_ + i1_)
            Next i_
        Next i
        Call CMatrixLeftTRSM(M, N - M, A, Offs, Offs, False, True, 0#, A, Offs, Offs + M)
        Exit Sub
    End If
    
    '
    ' Non-kernel case
    '
    Call ABLASComplexSplitLength(A, N, N1, N2)
    Call CMatrixPLURec(A, Offs, M, N1, Pivots, Tmp)
    If N2 > 0# Then
        For i = 0# To N1 - 1# Step 1
            If Offs + i <> Pivots(Offs + i) Then
                i1_ = (Offs + N1) - (0#)
                For i_ = 0# To N2 - 1# Step 1
                    Tmp(i_) = A(Offs + i, i_ + i1_)
                Next i_
                For i_ = Offs + N1 To Offs + N - 1# Step 1
                    A(Offs + i, i_) = A(Pivots(Offs + i), i_)
                Next i_
                i1_ = (0#) - (Offs + N1)
                For i_ = Offs + N1 To Offs + N - 1# Step 1
                    A(Pivots(Offs + i), i_) = Tmp(i_ + i1_)
                Next i_
            End If
        Next i
        Call CMatrixLeftTRSM(N1, N2, A, Offs, Offs, False, True, 0#, A, Offs, Offs + N1)
        Call CMatrixGEMM(M - N1, N - N1, N1, C_Complex(-1#), A, Offs + N1, Offs, 0#, A, Offs, Offs + N1, 0#, C_Complex(1#), A, Offs + N1, Offs + N1)
        Call CMatrixPLURec(A, Offs + N1, M - N1, N - N1, Pivots, Tmp)
        For i = 0# To N2 - 1# Step 1
            If Offs + N1 + i <> Pivots(Offs + N1 + i) Then
                i1_ = (Offs) - (0#)
                For i_ = 0# To N1 - 1# Step 1
                    Tmp(i_) = A(Offs + N1 + i, i_ + i1_)
                Next i_
                For i_ = Offs To Offs + N1 - 1# Step 1
                    A(Offs + N1 + i, i_) = A(Pivots(Offs + N1 + i), i_)
                Next i_
                i1_ = (0#) - (Offs)
                For i_ = Offs To Offs + N1 - 1# Step 1
                    A(Pivots(Offs + N1 + i), i_) = Tmp(i_ + i1_)
                Next i_
            End If
        Next i
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Recurrent real LU subroutine.
'Never call it directly.
'
'  -- ALGLIB routine --
'     04.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub RMatrixPLURec(ByRef A() As Double, _
         ByVal Offs As Long, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Pivots() As Long, _
         ByRef Tmp() As Double)
    Dim i As Long
    Dim N1 As Long
    Dim N2 As Long
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' Kernel case
    '
    If MinInt(M, N) <= ABLASBlockSize(A) Then
        Call RMatrixPLU2(A, Offs, M, N, Pivots, Tmp)
        Exit Sub
    End If
    
    '
    ' Preliminary step, make M>=N.
    '
    ' A = (A1 A2), where A1 is square
    ' Factorize A1, update A2
    '
    If N > M Then
        Call RMatrixPLURec(A, Offs, M, M, Pivots, Tmp)
        For i = 0# To M - 1# Step 1
            i1_ = (Offs + M) - (0#)
            For i_ = 0# To N - M - 1# Step 1
                Tmp(i_) = A(Offs + i, i_ + i1_)
            Next i_
            For i_ = Offs + M To Offs + N - 1# Step 1
                A(Offs + i, i_) = A(Pivots(Offs + i), i_)
            Next i_
            i1_ = (0#) - (Offs + M)
            For i_ = Offs + M To Offs + N - 1# Step 1
                A(Pivots(Offs + i), i_) = Tmp(i_ + i1_)
            Next i_
        Next i
        Call RMatrixLeftTRSM(M, N - M, A, Offs, Offs, False, True, 0#, A, Offs, Offs + M)
        Exit Sub
    End If
    
    '
    ' Non-kernel case
    '
    Call ABLASSplitLength(A, N, N1, N2)
    Call RMatrixPLURec(A, Offs, M, N1, Pivots, Tmp)
    If N2 > 0# Then
        For i = 0# To N1 - 1# Step 1
            If Offs + i <> Pivots(Offs + i) Then
                i1_ = (Offs + N1) - (0#)
                For i_ = 0# To N2 - 1# Step 1
                    Tmp(i_) = A(Offs + i, i_ + i1_)
                Next i_
                For i_ = Offs + N1 To Offs + N - 1# Step 1
                    A(Offs + i, i_) = A(Pivots(Offs + i), i_)
                Next i_
                i1_ = (0#) - (Offs + N1)
                For i_ = Offs + N1 To Offs + N - 1# Step 1
                    A(Pivots(Offs + i), i_) = Tmp(i_ + i1_)
                Next i_
            End If
        Next i
        Call RMatrixLeftTRSM(N1, N2, A, Offs, Offs, False, True, 0#, A, Offs, Offs + N1)
        Call RMatrixGEMM(M - N1, N - N1, N1, -1#, A, Offs + N1, Offs, 0#, A, Offs, Offs + N1, 0#, 1#, A, Offs + N1, Offs + N1)
        Call RMatrixPLURec(A, Offs + N1, M - N1, N - N1, Pivots, Tmp)
        For i = 0# To N2 - 1# Step 1
            If Offs + N1 + i <> Pivots(Offs + N1 + i) Then
                i1_ = (Offs) - (0#)
                For i_ = 0# To N1 - 1# Step 1
                    Tmp(i_) = A(Offs + N1 + i, i_ + i1_)
                Next i_
                For i_ = Offs To Offs + N1 - 1# Step 1
                    A(Offs + N1 + i, i_) = A(Pivots(Offs + N1 + i), i_)
                Next i_
                i1_ = (0#) - (Offs)
                For i_ = Offs To Offs + N1 - 1# Step 1
                    A(Pivots(Offs + N1 + i), i_) = Tmp(i_ + i1_)
                Next i_
            End If
        Next i
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Complex LUP kernel
'
'  -- ALGLIB routine --
'     10.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub CMatrixLUP2(ByRef A() As Complex, _
         ByVal Offs As Long, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Pivots() As Long, _
         ByRef Tmp() As Complex)
    Dim i As Long
    Dim j As Long
    Dim JP As Long
    Dim S As Complex
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' Quick return if possible
    '
    If M = 0# Or N = 0# Then
        Exit Sub
    End If
    
    '
    ' main cycle
    '
    For j = 0# To MinInt(M - 1#, N - 1#) Step 1
        
        '
        ' Find pivot, swap columns
        '
        JP = j
        For i = j + 1# To N - 1# Step 1
            If AbsComplex(A(Offs + j, Offs + i)) > AbsComplex(A(Offs + j, Offs + JP)) Then
                JP = i
            End If
        Next i
        Pivots(Offs + j) = Offs + JP
        If JP <> j Then
            i1_ = (Offs) - (0#)
            For i_ = 0# To M - 1# Step 1
                Tmp(i_) = A(i_ + i1_, Offs + j)
            Next i_
            For i_ = Offs To Offs + M - 1# Step 1
                A(i_, Offs + j) = A(i_, Offs + JP)
            Next i_
            i1_ = (0#) - (Offs)
            For i_ = Offs To Offs + M - 1# Step 1
                A(i_, Offs + JP) = Tmp(i_ + i1_)
            Next i_
        End If
        
        '
        ' LU decomposition of 1x(N-J) matrix
        '
        If C_NotEqualR(A(Offs + j, Offs + j), 0#) And j + 1# <= N - 1# Then
            S = C_RDiv(1#, A(Offs + j, Offs + j))
            For i_ = Offs + j + 1# To Offs + N - 1# Step 1
                A(Offs + j, i_) = C_Mul(S, A(Offs + j, i_))
            Next i_
        End If
        
        '
        ' Update trailing (M-J-1)x(N-J-1) matrix
        '
        If j < MinInt(M - 1#, N - 1#) Then
            i1_ = (Offs + j + 1#) - (0#)
            For i_ = 0# To M - j - 2# Step 1
                Tmp(i_) = A(i_ + i1_, Offs + j)
            Next i_
            i1_ = (Offs + j + 1#) - (M)
            For i_ = M To M + N - j - 2# Step 1
                Tmp(i_) = C_Opposite(A(Offs + j, i_ + i1_))
            Next i_
            Call CMatrixRank1(M - j - 1#, N - j - 1#, A, Offs + j + 1#, Offs + j + 1#, Tmp, 0#, Tmp, M)
        End If
    Next j
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Real LUP kernel
'
'  -- ALGLIB routine --
'     10.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub RMatrixLUP2(ByRef A() As Double, _
         ByVal Offs As Long, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Pivots() As Long, _
         ByRef Tmp() As Double)
    Dim i As Long
    Dim j As Long
    Dim JP As Long
    Dim S As Double
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' Quick return if possible
    '
    If M = 0# Or N = 0# Then
        Exit Sub
    End If
    
    '
    ' main cycle
    '
    For j = 0# To MinInt(M - 1#, N - 1#) Step 1
        
        '
        ' Find pivot, swap columns
        '
        JP = j
        For i = j + 1# To N - 1# Step 1
            If Abs(A(Offs + j, Offs + i)) > Abs(A(Offs + j, Offs + JP)) Then
                JP = i
            End If
        Next i
        Pivots(Offs + j) = Offs + JP
        If JP <> j Then
            i1_ = (Offs) - (0#)
            For i_ = 0# To M - 1# Step 1
                Tmp(i_) = A(i_ + i1_, Offs + j)
            Next i_
            For i_ = Offs To Offs + M - 1# Step 1
                A(i_, Offs + j) = A(i_, Offs + JP)
            Next i_
            i1_ = (0#) - (Offs)
            For i_ = Offs To Offs + M - 1# Step 1
                A(i_, Offs + JP) = Tmp(i_ + i1_)
            Next i_
        End If
        
        '
        ' LU decomposition of 1x(N-J) matrix
        '
        If A(Offs + j, Offs + j) <> 0# And j + 1# <= N - 1# Then
            S = 1# / A(Offs + j, Offs + j)
            For i_ = Offs + j + 1# To Offs + N - 1# Step 1
                A(Offs + j, i_) = S * A(Offs + j, i_)
            Next i_
        End If
        
        '
        ' Update trailing (M-J-1)x(N-J-1) matrix
        '
        If j < MinInt(M - 1#, N - 1#) Then
            i1_ = (Offs + j + 1#) - (0#)
            For i_ = 0# To M - j - 2# Step 1
                Tmp(i_) = A(i_ + i1_, Offs + j)
            Next i_
            i1_ = (Offs + j + 1#) - (M)
            For i_ = M To M + N - j - 2# Step 1
                Tmp(i_) = -A(Offs + j, i_ + i1_)
            Next i_
            Call RMatrixRank1(M - j - 1#, N - j - 1#, A, Offs + j + 1#, Offs + j + 1#, Tmp, 0#, Tmp, M)
        End If
    Next j
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Complex PLU kernel
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     June 30, 1992
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub CMatrixPLU2(ByRef A() As Complex, _
         ByVal Offs As Long, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Pivots() As Long, _
         ByRef Tmp() As Complex)
    Dim i As Long
    Dim j As Long
    Dim JP As Long
    Dim S As Complex
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' Quick return if possible
    '
    If M = 0# Or N = 0# Then
        Exit Sub
    End If
    For j = 0# To MinInt(M - 1#, N - 1#) Step 1
        
        '
        ' Find pivot and test for singularity.
        '
        JP = j
        For i = j + 1# To M - 1# Step 1
            If AbsComplex(A(Offs + i, Offs + j)) > AbsComplex(A(Offs + JP, Offs + j)) Then
                JP = i
            End If
        Next i
        Pivots(Offs + j) = Offs + JP
        If C_NotEqualR(A(Offs + JP, Offs + j), 0#) Then
            
            '
            'Apply the interchange to rows
            '
            If JP <> j Then
                For i = 0# To N - 1# Step 1
                    S = A(Offs + j, Offs + i)
                    A(Offs + j, Offs + i) = A(Offs + JP, Offs + i)
                    A(Offs + JP, Offs + i) = S
                Next i
            End If
            
            '
            'Compute elements J+1:M of J-th column.
            '
            If j + 1# <= M - 1# Then
                S = C_RDiv(1#, A(Offs + j, Offs + j))
                For i_ = Offs + j + 1# To Offs + M - 1# Step 1
                    A(i_, Offs + j) = C_Mul(S, A(i_, Offs + j))
                Next i_
            End If
        End If
        If j < MinInt(M, N) - 1# Then
            
            '
            'Update trailing submatrix.
            '
            i1_ = (Offs + j + 1#) - (0#)
            For i_ = 0# To M - j - 2# Step 1
                Tmp(i_) = A(i_ + i1_, Offs + j)
            Next i_
            i1_ = (Offs + j + 1#) - (M)
            For i_ = M To M + N - j - 2# Step 1
                Tmp(i_) = C_Opposite(A(Offs + j, i_ + i1_))
            Next i_
            Call CMatrixRank1(M - j - 1#, N - j - 1#, A, Offs + j + 1#, Offs + j + 1#, Tmp, 0#, Tmp, M)
        End If
    Next j
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Real PLU kernel
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     June 30, 1992
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub RMatrixPLU2(ByRef A() As Double, _
         ByVal Offs As Long, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Pivots() As Long, _
         ByRef Tmp() As Double)
    Dim i As Long
    Dim j As Long
    Dim JP As Long
    Dim S As Double
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' Quick return if possible
    '
    If M = 0# Or N = 0# Then
        Exit Sub
    End If
    For j = 0# To MinInt(M - 1#, N - 1#) Step 1
        
        '
        ' Find pivot and test for singularity.
        '
        JP = j
        For i = j + 1# To M - 1# Step 1
            If Abs(A(Offs + i, Offs + j)) > Abs(A(Offs + JP, Offs + j)) Then
                JP = i
            End If
        Next i
        Pivots(Offs + j) = Offs + JP
        If A(Offs + JP, Offs + j) <> 0# Then
            
            '
            'Apply the interchange to rows
            '
            If JP <> j Then
                For i = 0# To N - 1# Step 1
                    S = A(Offs + j, Offs + i)
                    A(Offs + j, Offs + i) = A(Offs + JP, Offs + i)
                    A(Offs + JP, Offs + i) = S
                Next i
            End If
            
            '
            'Compute elements J+1:M of J-th column.
            '
            If j + 1# <= M - 1# Then
                S = 1# / A(Offs + j, Offs + j)
                For i_ = Offs + j + 1# To Offs + M - 1# Step 1
                    A(i_, Offs + j) = S * A(i_, Offs + j)
                Next i_
            End If
        End If
        If j < MinInt(M, N) - 1# Then
            
            '
            'Update trailing submatrix.
            '
            i1_ = (Offs + j + 1#) - (0#)
            For i_ = 0# To M - j - 2# Step 1
                Tmp(i_) = A(i_ + i1_, Offs + j)
            Next i_
            i1_ = (Offs + j + 1#) - (M)
            For i_ = M To M + N - j - 2# Step 1
                Tmp(i_) = -A(Offs + j, i_ + i1_)
            Next i_
            Call RMatrixRank1(M - j - 1#, N - j - 1#, A, Offs + j + 1#, Offs + j + 1#, Tmp, 0#, Tmp, M)
        End If
    Next j
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Recursive computational subroutine for HPDMatrixCholesky
'
'  -- ALGLIB routine --
'     15.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Function HPDMatrixCholeskyRec(ByRef A() As Complex, _
         ByVal Offs As Long, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef Tmp() As Complex) As Boolean
    Dim Result As Boolean
    Dim N1 As Long
    Dim N2 As Long
    
    '
    ' check N
    '
    If N < 1# Then
        Result = False
        HPDMatrixCholeskyRec = Result
        Exit Function
    End If
    
    '
    ' special cases
    '
    If N = 1# Then
        If A(Offs, Offs).X > 0# Then
            A(Offs, Offs) = C_Complex(Sqr(A(Offs, Offs).X))
            Result = True
        Else
            Result = False
        End If
        HPDMatrixCholeskyRec = Result
        Exit Function
    End If
    If N <= ABLASComplexBlockSize(A) Then
        Result = HPDMatrixCholesky2(A, Offs, N, IsUpper, Tmp)
        HPDMatrixCholeskyRec = Result
        Exit Function
    End If
    
    '
    ' general case: split task in cache-oblivious manner
    '
    Result = True
    Call ABLASComplexSplitLength(A, N, N1, N2)
    Result = HPDMatrixCholeskyRec(A, Offs, N1, IsUpper, Tmp)
    If Not Result Then
        HPDMatrixCholeskyRec = Result
        Exit Function
    End If
    If N2 > 0# Then
        If IsUpper Then
            Call CMatrixLeftTRSM(N1, N2, A, Offs, Offs, IsUpper, False, 2#, A, Offs, Offs + N1)
            Call CMatrixSYRK(N2, N1, -1#, A, Offs, Offs + N1, 2#, 1#, A, Offs + N1, Offs + N1, IsUpper)
        Else
            Call CMatrixRightTRSM(N2, N1, A, Offs, Offs, IsUpper, False, 2#, A, Offs + N1, Offs)
            Call CMatrixSYRK(N2, N1, -1#, A, Offs + N1, Offs, 0#, 1#, A, Offs + N1, Offs + N1, IsUpper)
        End If
        Result = HPDMatrixCholeskyRec(A, Offs + N1, N2, IsUpper, Tmp)
        If Not Result Then
            HPDMatrixCholeskyRec = Result
            Exit Function
        End If
    End If
    HPDMatrixCholeskyRec = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Recursive computational subroutine for SPDMatrixCholesky
'
'  -- ALGLIB routine --
'     15.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Function SPDMatrixCholeskyRec(ByRef A() As Double, _
         ByVal Offs As Long, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef Tmp() As Double) As Boolean
    Dim Result As Boolean
    Dim N1 As Long
    Dim N2 As Long
    
    '
    ' check N
    '
    If N < 1# Then
        Result = False
        SPDMatrixCholeskyRec = Result
        Exit Function
    End If
    
    '
    ' special cases
    '
    If N = 1# Then
        If A(Offs, Offs) > 0# Then
            A(Offs, Offs) = Sqr(A(Offs, Offs))
            Result = True
        Else
            Result = False
        End If
        SPDMatrixCholeskyRec = Result
        Exit Function
    End If
    If N <= ABLASBlockSize(A) Then
        Result = SPDMatrixCholesky2(A, Offs, N, IsUpper, Tmp)
        SPDMatrixCholeskyRec = Result
        Exit Function
    End If
    
    '
    ' general case: split task in cache-oblivious manner
    '
    Result = True
    Call ABLASSplitLength(A, N, N1, N2)
    Result = SPDMatrixCholeskyRec(A, Offs, N1, IsUpper, Tmp)
    If Not Result Then
        SPDMatrixCholeskyRec = Result
        Exit Function
    End If
    If N2 > 0# Then
        If IsUpper Then
            Call RMatrixLeftTRSM(N1, N2, A, Offs, Offs, IsUpper, False, 1#, A, Offs, Offs + N1)
            Call RMatrixSYRK(N2, N1, -1#, A, Offs, Offs + N1, 1#, 1#, A, Offs + N1, Offs + N1, IsUpper)
        Else
            Call RMatrixRightTRSM(N2, N1, A, Offs, Offs, IsUpper, False, 1#, A, Offs + N1, Offs)
            Call RMatrixSYRK(N2, N1, -1#, A, Offs + N1, Offs, 0#, 1#, A, Offs + N1, Offs + N1, IsUpper)
        End If
        Result = SPDMatrixCholeskyRec(A, Offs + N1, N2, IsUpper, Tmp)
        If Not Result Then
            SPDMatrixCholeskyRec = Result
            Exit Function
        End If
    End If
    SPDMatrixCholeskyRec = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Level-2 Hermitian Cholesky subroutine.
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     February 29, 1992
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Function HPDMatrixCholesky2(ByRef AAA() As Complex, _
         ByVal Offs As Long, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef Tmp() As Complex) As Boolean
    Dim Result As Boolean
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim J1 As Long
    Dim J2 As Long
    Dim AJJ As Double
    Dim V As Complex
    Dim R As Double
    Dim i_ As Long
    Dim i1_ As Long
    Result = True
    If N < 0# Then
        Result = False
        HPDMatrixCholesky2 = Result
        Exit Function
    End If
    
    '
    ' Quick return if possible
    '
    If N = 0# Then
        HPDMatrixCholesky2 = Result
        Exit Function
    End If
    If IsUpper Then
        
        '
        ' Compute the Cholesky factorization A = U'*U.
        '
        For j = 0# To N - 1# Step 1
            
            '
            ' Compute U(J,J) and test for non-positive-definiteness.
            '
            V = C_Complex(0#)
            For i_ = Offs To Offs + j - 1# Step 1
                V = C_Add(V, C_Mul(Conj(AAA(i_, Offs + j)), AAA(i_, Offs + j)))
            Next i_
            AJJ = C_Sub(AAA(Offs + j, Offs + j), V).X
            If AJJ <= 0# Then
                AAA(Offs + j, Offs + j) = C_Complex(AJJ)
                Result = False
                HPDMatrixCholesky2 = Result
                Exit Function
            End If
            AJJ = Sqr(AJJ)
            AAA(Offs + j, Offs + j) = C_Complex(AJJ)
            
            '
            ' Compute elements J+1:N-1 of row J.
            '
            If j < N - 1# Then
                If j > 0# Then
                    i1_ = (Offs) - (0#)
                    For i_ = 0# To j - 1# Step 1
                        Tmp(i_) = C_Opposite(Conj(AAA(i_ + i1_, Offs + j)))
                    Next i_
                    Call CMatrixMV(N - j - 1#, j, AAA, Offs, Offs + j + 1#, 1#, Tmp, 0#, Tmp, N)
                    i1_ = (N) - (Offs + j + 1#)
                    For i_ = Offs + j + 1# To Offs + N - 1# Step 1
                        AAA(Offs + j, i_) = C_Add(AAA(Offs + j, i_), Tmp(i_ + i1_))
                    Next i_
                End If
                R = 1# / AJJ
                For i_ = Offs + j + 1# To Offs + N - 1# Step 1
                    AAA(Offs + j, i_) = C_MulR(AAA(Offs + j, i_), R)
                Next i_
            End If
        Next j
    Else
        
        '
        ' Compute the Cholesky factorization A = L*L'.
        '
        For j = 0# To N - 1# Step 1
            
            '
            ' Compute L(J+1,J+1) and test for non-positive-definiteness.
            '
            V = C_Complex(0#)
            For i_ = Offs To Offs + j - 1# Step 1
                V = C_Add(V, C_Mul(Conj(AAA(Offs + j, i_)), AAA(Offs + j, i_)))
            Next i_
            AJJ = C_Sub(AAA(Offs + j, Offs + j), V).X
            If AJJ <= 0# Then
                AAA(Offs + j, Offs + j) = C_Complex(AJJ)
                Result = False
                HPDMatrixCholesky2 = Result
                Exit Function
            End If
            AJJ = Sqr(AJJ)
            AAA(Offs + j, Offs + j) = C_Complex(AJJ)
            
            '
            ' Compute elements J+1:N of column J.
            '
            If j < N - 1# Then
                If j > 0# Then
                    i1_ = (Offs) - (0#)
                    For i_ = 0# To j - 1# Step 1
                        Tmp(i_) = Conj(AAA(Offs + j, i_ + i1_))
                    Next i_
                    Call CMatrixMV(N - j - 1#, j, AAA, Offs + j + 1#, Offs, 0#, Tmp, 0#, Tmp, N)
                    For i = 0# To N - j - 2# Step 1
                        AAA(Offs + j + 1# + i, Offs + j) = C_DivR(C_Sub(AAA(Offs + j + 1# + i, Offs + j), Tmp(N + i)), AJJ)
                    Next i
                Else
                    For i = 0# To N - j - 2# Step 1
                        AAA(Offs + j + 1# + i, Offs + j) = C_DivR(AAA(Offs + j + 1# + i, Offs + j), AJJ)
                    Next i
                End If
            End If
        Next j
    End If
    HPDMatrixCholesky2 = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Level-2 Cholesky subroutine
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     February 29, 1992
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Function SPDMatrixCholesky2(ByRef AAA() As Double, _
         ByVal Offs As Long, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef Tmp() As Double) As Boolean
    Dim Result As Boolean
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim J1 As Long
    Dim J2 As Long
    Dim AJJ As Double
    Dim V As Double
    Dim R As Double
    Dim i_ As Long
    Dim i1_ As Long
    Result = True
    If N < 0# Then
        Result = False
        SPDMatrixCholesky2 = Result
        Exit Function
    End If
    
    '
    ' Quick return if possible
    '
    If N = 0# Then
        SPDMatrixCholesky2 = Result
        Exit Function
    End If
    If IsUpper Then
        
        '
        ' Compute the Cholesky factorization A = U'*U.
        '
        For j = 0# To N - 1# Step 1
            
            '
            ' Compute U(J,J) and test for non-positive-definiteness.
            '
            V = 0#
            For i_ = Offs To Offs + j - 1# Step 1
                V = V + AAA(i_, Offs + j) * AAA(i_, Offs + j)
            Next i_
            AJJ = AAA(Offs + j, Offs + j) - V
            If AJJ <= 0# Then
                AAA(Offs + j, Offs + j) = AJJ
                Result = False
                SPDMatrixCholesky2 = Result
                Exit Function
            End If
            AJJ = Sqr(AJJ)
            AAA(Offs + j, Offs + j) = AJJ
            
            '
            ' Compute elements J+1:N-1 of row J.
            '
            If j < N - 1# Then
                If j > 0# Then
                    i1_ = (Offs) - (0#)
                    For i_ = 0# To j - 1# Step 1
                        Tmp(i_) = -AAA(i_ + i1_, Offs + j)
                    Next i_
                    Call RMatrixMV(N - j - 1#, j, AAA, Offs, Offs + j + 1#, 1#, Tmp, 0#, Tmp, N)
                    i1_ = (N) - (Offs + j + 1#)
                    For i_ = Offs + j + 1# To Offs + N - 1# Step 1
                        AAA(Offs + j, i_) = AAA(Offs + j, i_) + Tmp(i_ + i1_)
                    Next i_
                End If
                R = 1# / AJJ
                For i_ = Offs + j + 1# To Offs + N - 1# Step 1
                    AAA(Offs + j, i_) = R * AAA(Offs + j, i_)
                Next i_
            End If
        Next j
    Else
        
        '
        ' Compute the Cholesky factorization A = L*L'.
        '
        For j = 0# To N - 1# Step 1
            
            '
            ' Compute L(J+1,J+1) and test for non-positive-definiteness.
            '
            V = 0#
            For i_ = Offs To Offs + j - 1# Step 1
                V = V + AAA(Offs + j, i_) * AAA(Offs + j, i_)
            Next i_
            AJJ = AAA(Offs + j, Offs + j) - V
            If AJJ <= 0# Then
                AAA(Offs + j, Offs + j) = AJJ
                Result = False
                SPDMatrixCholesky2 = Result
                Exit Function
            End If
            AJJ = Sqr(AJJ)
            AAA(Offs + j, Offs + j) = AJJ
            
            '
            ' Compute elements J+1:N of column J.
            '
            If j < N - 1# Then
                If j > 0# Then
                    i1_ = (Offs) - (0#)
                    For i_ = 0# To j - 1# Step 1
                        Tmp(i_) = AAA(Offs + j, i_ + i1_)
                    Next i_
                    Call RMatrixMV(N - j - 1#, j, AAA, Offs + j + 1#, Offs, 0#, Tmp, 0#, Tmp, N)
                    For i = 0# To N - j - 2# Step 1
                        AAA(Offs + j + 1# + i, Offs + j) = (AAA(Offs + j + 1# + i, Offs + j) - Tmp(N + i)) / AJJ
                    Next i
                Else
                    For i = 0# To N - j - 2# Step 1
                        AAA(Offs + j + 1# + i, Offs + j) = AAA(Offs + j + 1# + i, Offs + j) / AJJ
                    Next i
                End If
            End If
        Next j
    End If
    SPDMatrixCholesky2 = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2005-2007, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Singular value decomposition of a rectangular matrix.
'
'The algorithm calculates the singular value decomposition of a matrix of
'size MxN: A = U * S * V^T
'
'The algorithm finds the singular values and, optionally, matrices U and V^T.
'The algorithm can find both first min(M,N) columns of matrix U and rows of
'matrix V^T (singular vectors), and matrices U and V^T wholly (of sizes MxM
'and NxN respectively).
'
'Take into account that the subroutine does not return matrix V but V^T.
'
'Input parameters:
'    A           -   matrix to be decomposed.
'                    Array whose indexes range within [0..M-1, 0..N-1].
'    M           -   number of rows in matrix A.
'    N           -   number of columns in matrix A.
'    UNeeded     -   0, 1 or 2. See the description of the parameter U.
'    VTNeeded    -   0, 1 or 2. See the description of the parameter VT.
'    AdditionalMemory -
'                    If the parameter:
'                     * equals 0, the algorithm doesnt use additional
'                       memory (lower requirements, lower performance).
'                     * equals 1, the algorithm uses additional
'                       memory of size min(M,N)*min(M,N) of real numbers.
'                       It often speeds up the algorithm.
'                     * equals 2, the algorithm uses additional
'                       memory of size M*min(M,N) of real numbers.
'                       It allows to get a maximum performance.
'                    The recommended value of the parameter is 2.
'
'Output parameters:
'    W           -   contains singular values in descending order.
'    U           -   if UNeeded=0, U isn't changed, the left singular vectors
'                    are not calculated.
'                    if Uneeded=1, U contains left singular vectors (first
'                    min(M,N) columns of matrix U). Array whose indexes range
'                    within [0..M-1, 0..Min(M,N)-1].
'                    if UNeeded=2, U contains matrix U wholly. Array whose
'                    indexes range within [0..M-1, 0..M-1].
'    VT          -   if VTNeeded=0, VT isnt changed, the right singular vectors
'                    are not calculated.
'                    if VTNeeded=1, VT contains right singular vectors (first
'                    min(M,N) rows of matrix V^T). Array whose indexes range
'                    within [0..min(M,N)-1, 0..N-1].
'                    if VTNeeded=2, VT contains matrix V^T wholly. Array whose
'                    indexes range within [0..N-1, 0..N-1].
'
'  -- ALGLIB --
'     Copyright 2005 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function RMatrixSVD(ByRef A_() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByVal UNeeded As Long, _
         ByVal VTNeeded As Long, _
         ByVal AdditionalMemory As Long, _
         ByRef w() As Double, _
         ByRef U() As Double, _
         ByRef VT() As Double) As Boolean
    Dim Result As Boolean
    Dim A() As Double
    Dim TauQ() As Double
    Dim TauP() As Double
    Dim Tau() As Double
    Dim E() As Double
    Dim WORK() As Double
    Dim T2() As Double
    Dim IsUpper As Boolean
    Dim MinMN As Long
    Dim NCU As Long
    Dim NRVT As Long
    Dim NRU As Long
    Dim NCVT As Long
    Dim i As Long
    Dim j As Long
    A = A_
    Result = True
    If M = 0# Or N = 0# Then
        RMatrixSVD = Result
        Exit Function
    End If
    
    '
    ' initialize
    '
    MinMN = MinInt(M, N)
    ReDim w(1# To MinMN)
    NCU = 0#
    NRU = 0#
    If UNeeded = 1# Then
        NRU = M
        NCU = MinMN
        ReDim U(0# To NRU - 1#, 0# To NCU - 1#)
    End If
    If UNeeded = 2# Then
        NRU = M
        NCU = M
        ReDim U(0# To NRU - 1#, 0# To NCU - 1#)
    End If
    NRVT = 0#
    NCVT = 0#
    If VTNeeded = 1# Then
        NRVT = MinMN
        NCVT = N
        ReDim VT(0# To NRVT - 1#, 0# To NCVT - 1#)
    End If
    If VTNeeded = 2# Then
        NRVT = N
        NCVT = N
        ReDim VT(0# To NRVT - 1#, 0# To NCVT - 1#)
    End If
    
    '
    ' M much larger than N
    ' Use bidiagonal reduction with QR-decomposition
    '
    If M > 1.6 * N Then
        If UNeeded = 0# Then
            
            '
            ' No left singular vectors to be computed
            '
            Call RMatrixQR(A, M, N, Tau)
            For i = 0# To N - 1# Step 1
                For j = 0# To i - 1# Step 1
                    A(i, j) = 0#
                Next j
            Next i
            Call RMatrixBD(A, N, N, TauQ, TauP)
            Call RMatrixBDUnpackPT(A, N, N, TauP, NRVT, VT)
            Call RMatrixBDUnpackDiagonals(A, N, N, IsUpper, w, E)
            Result = RMatrixBDSVD(w, E, N, IsUpper, False, U, 0#, A, 0#, VT, NCVT)
            RMatrixSVD = Result
            Exit Function
        Else
            
            '
            ' Left singular vectors (may be full matrix U) to be computed
            '
            Call RMatrixQR(A, M, N, Tau)
            Call RMatrixQRUnpackQ(A, M, N, Tau, NCU, U)
            For i = 0# To N - 1# Step 1
                For j = 0# To i - 1# Step 1
                    A(i, j) = 0#
                Next j
            Next i
            Call RMatrixBD(A, N, N, TauQ, TauP)
            Call RMatrixBDUnpackPT(A, N, N, TauP, NRVT, VT)
            Call RMatrixBDUnpackDiagonals(A, N, N, IsUpper, w, E)
            If AdditionalMemory < 1# Then
                
                '
                ' No additional memory can be used
                '
                Call RMatrixBDMultiplyByQ(A, N, N, TauQ, U, M, N, True, False)
                Result = RMatrixBDSVD(w, E, N, IsUpper, False, U, M, A, 0#, VT, NCVT)
            Else
                
                '
                ' Large U. Transforming intermediate matrix T2
                '
                ReDim WORK(1# To MaxInt(M, N))
                Call RMatrixBDUnpackQ(A, N, N, TauQ, N, T2)
                Call CopyMatrix(U, 0#, M - 1#, 0#, N - 1#, A, 0#, M - 1#, 0#, N - 1#)
                Call InplaceTranspose(T2, 0#, N - 1#, 0#, N - 1#, WORK)
                Result = RMatrixBDSVD(w, E, N, IsUpper, False, U, 0#, T2, N, VT, NCVT)
                Call MatrixMatrixMultiply(A, 0#, M - 1#, 0#, N - 1#, False, T2, 0#, N - 1#, 0#, N - 1#, True, 1#, U, 0#, M - 1#, 0#, N - 1#, 0#, WORK)
            End If
            RMatrixSVD = Result
            Exit Function
        End If
    End If
    
    '
    ' N much larger than M
    ' Use bidiagonal reduction with LQ-decomposition
    '
    If N > 1.6 * M Then
        If VTNeeded = 0# Then
            
            '
            ' No right singular vectors to be computed
            '
            Call RMatrixLQ(A, M, N, Tau)
            For i = 0# To M - 1# Step 1
                For j = i + 1# To M - 1# Step 1
                    A(i, j) = 0#
                Next j
            Next i
            Call RMatrixBD(A, M, M, TauQ, TauP)
            Call RMatrixBDUnpackQ(A, M, M, TauQ, NCU, U)
            Call RMatrixBDUnpackDiagonals(A, M, M, IsUpper, w, E)
            ReDim WORK(1# To M)
            Call InplaceTranspose(U, 0#, NRU - 1#, 0#, NCU - 1#, WORK)
            Result = RMatrixBDSVD(w, E, M, IsUpper, False, A, 0#, U, NRU, VT, 0#)
            Call InplaceTranspose(U, 0#, NRU - 1#, 0#, NCU - 1#, WORK)
            RMatrixSVD = Result
            Exit Function
        Else
            
            '
            ' Right singular vectors (may be full matrix VT) to be computed
            '
            Call RMatrixLQ(A, M, N, Tau)
            Call RMatrixLQUnpackQ(A, M, N, Tau, NRVT, VT)
            For i = 0# To M - 1# Step 1
                For j = i + 1# To M - 1# Step 1
                    A(i, j) = 0#
                Next j
            Next i
            Call RMatrixBD(A, M, M, TauQ, TauP)
            Call RMatrixBDUnpackQ(A, M, M, TauQ, NCU, U)
            Call RMatrixBDUnpackDiagonals(A, M, M, IsUpper, w, E)
            ReDim WORK(1# To MaxInt(M, N))
            Call InplaceTranspose(U, 0#, NRU - 1#, 0#, NCU - 1#, WORK)
            If AdditionalMemory < 1# Then
                
                '
                ' No additional memory available
                '
                Call RMatrixBDMultiplyByP(A, M, M, TauP, VT, M, N, False, True)
                Result = RMatrixBDSVD(w, E, M, IsUpper, False, A, 0#, U, NRU, VT, N)
            Else
                
                '
                ' Large VT. Transforming intermediate matrix T2
                '
                Call RMatrixBDUnpackPT(A, M, M, TauP, M, T2)
                Result = RMatrixBDSVD(w, E, M, IsUpper, False, A, 0#, U, NRU, T2, M)
                Call CopyMatrix(VT, 0#, M - 1#, 0#, N - 1#, A, 0#, M - 1#, 0#, N - 1#)
                Call MatrixMatrixMultiply(T2, 0#, M - 1#, 0#, M - 1#, False, A, 0#, M - 1#, 0#, N - 1#, False, 1#, VT, 0#, M - 1#, 0#, N - 1#, 0#, WORK)
            End If
            Call InplaceTranspose(U, 0#, NRU - 1#, 0#, NCU - 1#, WORK)
            RMatrixSVD = Result
            Exit Function
        End If
    End If
    
    '
    ' M<=N
    ' We can use inplace transposition of U to get rid of columnwise operations
    '
    If M <= N Then
        Call RMatrixBD(A, M, N, TauQ, TauP)
        Call RMatrixBDUnpackQ(A, M, N, TauQ, NCU, U)
        Call RMatrixBDUnpackPT(A, M, N, TauP, NRVT, VT)
        Call RMatrixBDUnpackDiagonals(A, M, N, IsUpper, w, E)
        ReDim WORK(1# To M)
        Call InplaceTranspose(U, 0#, NRU - 1#, 0#, NCU - 1#, WORK)
        Result = RMatrixBDSVD(w, E, MinMN, IsUpper, False, A, 0#, U, NRU, VT, NCVT)
        Call InplaceTranspose(U, 0#, NRU - 1#, 0#, NCU - 1#, WORK)
        RMatrixSVD = Result
        Exit Function
    End If
    
    '
    ' Simple bidiagonal reduction
    '
    Call RMatrixBD(A, M, N, TauQ, TauP)
    Call RMatrixBDUnpackQ(A, M, N, TauQ, NCU, U)
    Call RMatrixBDUnpackPT(A, M, N, TauP, NRVT, VT)
    Call RMatrixBDUnpackDiagonals(A, M, N, IsUpper, w, E)
    If AdditionalMemory < 2# Or UNeeded = 0# Then
        
        '
        ' We cant use additional memory or there is no need in such operations
        '
        Result = RMatrixBDSVD(w, E, MinMN, IsUpper, False, U, NRU, A, 0#, VT, NCVT)
    Else
        
        '
        ' We can use additional memory
        '
        ReDim T2(0# To MinMN - 1#, 0# To M - 1#)
        Call CopyAndTranspose(U, 0#, M - 1#, 0#, MinMN - 1#, T2, 0#, MinMN - 1#, 0#, M - 1#)
        Result = RMatrixBDSVD(w, E, MinMN, IsUpper, False, U, 0#, T2, M, VT, NCVT)
        Call CopyAndTranspose(T2, 0#, MinMN - 1#, 0#, M - 1#, U, 0#, M - 1#, 0#, MinMN - 1#)
    End If
    RMatrixSVD = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 1992-2007 The University of Tennessee.  All rights reserved.
'
'Contributors:
'    * Sergey Bochkanov (ALGLIB project). Translation from FORTRAN to
'      pseudocode.
'
'See subroutines comments for additional copyrights.
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Solving  a system  of linear equations  with a system matrix  given by its
'LDLT decomposition
'
'The algorithm solves systems with a square matrix only.
'
'Input parameters:
'    A       -   LDLT decomposition of the matrix (the result of the
'                SMatrixLDLT subroutine).
'    Pivots  -   row permutation table (the result of the SMatrixLDLT subroutine).
'    B       -   right side of a system.
'                Array whose index ranges within [0..N-1].
'    N       -   size of matrix A.
'    IsUpper -   points to the triangle of matrix A in which the LDLT
'                decomposition is stored.
'                If IsUpper=True, the decomposition has the form of U*D*U',
'                matrix U is stored in the upper triangle of  matrix A  (in
'                that case, the lower triangle isn't used and isn't changed
'                by the subroutine).
'                Similarly, if IsUpper=False, the decomposition has the form
'                of L*D*L' and the lower triangle stores matrix L.
'
'Output parameters:
'    X       -   solution of a system.
'                Array whose index ranges within [0..N-1].
'
'Result:
'    True, if the matrix is not singular. X contains the solution.
'    False, if the matrix is singular (the determinant of matrix D is equal
'to 0). In this case, X doesn't contain a solution.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function SMatrixLDLTSolve(ByRef A() As Double, _
         ByRef Pivots() As Long, _
         ByRef B_() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef X() As Double) As Boolean
    Dim Result As Boolean
    Dim B() As Double
    Dim i As Long
    Dim K As Long
    Dim KP As Long
    Dim AK As Double
    Dim AKM1 As Double
    Dim AKM1K As Double
    Dim BK As Double
    Dim BKM1 As Double
    Dim DENOM As Double
    Dim V As Double
    Dim i_ As Long
    B = B_
    
    '
    ' Quick return if possible
    '
    Result = True
    If N = 0# Then
        SMatrixLDLTSolve = Result
        Exit Function
    End If
    
    '
    ' Check that the diagonal matrix D is nonsingular
    '
    If IsUpper Then
        
        '
        ' Upper triangular storage: examine D from bottom to top
        '
        For i = N - 1# To 0# Step -1
            If Pivots(i) >= 0# And A(i, i) = 0# Then
                Result = False
                SMatrixLDLTSolve = Result
                Exit Function
            End If
        Next i
    Else
        
        '
        ' Lower triangular storage: examine D from top to bottom.
        '
        For i = 0# To N - 1# Step 1
            If Pivots(i) >= 0# And A(i, i) = 0# Then
                Result = False
                SMatrixLDLTSolve = Result
                Exit Function
            End If
        Next i
    End If
    
    '
    ' Solve Ax = b
    '
    If IsUpper Then
        
        '
        ' Solve A*X = B, where A = U*D*U'.
        '
        ' First solve U*D*X = B, overwriting B with X.
        '
        ' K+1 is the main loop index, decreasing from N to 1 in steps of
        ' 1 or 2, depending on the size of the diagonal blocks.
        '
        K = N - 1#
        Do While K >= 0#
            If Pivots(K) >= 0# Then
                
                '
                ' 1 x 1 diagonal block
                '
                ' Interchange rows K+1 and IPIV(K+1).
                '
                KP = Pivots(K)
                If KP <> K Then
                    V = B(K)
                    B(K) = B(KP)
                    B(KP) = V
                End If
                
                '
                ' Multiply by inv(U(K+1)), where U(K+1) is the transformation
                ' stored in column K+1 of A.
                '
                V = B(K)
                For i_ = 0# To K - 1# Step 1
                    B(i_) = B(i_) - V * A(i_, K)
                Next i_
                
                '
                ' Multiply by the inverse of the diagonal block.
                '
                B(K) = B(K) / A(K, K)
                K = K - 1#
            Else
                
                '
                ' 2 x 2 diagonal block
                '
                ' Interchange rows K+1-1 and -IPIV(K+1).
                '
                KP = Pivots(K) + N
                If KP <> K - 1# Then
                    V = B(K - 1#)
                    B(K - 1#) = B(KP)
                    B(KP) = V
                End If
                
                '
                ' Multiply by inv(U(K+1)), where U(K+1) is the transformation
                ' stored in columns K+1-1 and K+1 of A.
                '
                V = B(K)
                For i_ = 0# To K - 2# Step 1
                    B(i_) = B(i_) - V * A(i_, K)
                Next i_
                V = B(K - 1#)
                For i_ = 0# To K - 2# Step 1
                    B(i_) = B(i_) - V * A(i_, K - 1#)
                Next i_
                
                '
                ' Multiply by the inverse of the diagonal block.
                '
                AKM1K = A(K - 1#, K)
                AKM1 = A(K - 1#, K - 1#) / AKM1K
                AK = A(K, K) / AKM1K
                DENOM = AKM1 * AK - 1#
                BKM1 = B(K - 1#) / AKM1K
                BK = B(K) / AKM1K
                B(K - 1#) = (AK * BKM1 - BK) / DENOM
                B(K) = (AKM1 * BK - BKM1) / DENOM
                K = K - 2#
            End If
        Loop
        
        '
        ' Next solve U'*X = B, overwriting B with X.
        '
        ' K+1 is the main loop index, increasing from 1 to N in steps of
        ' 1 or 2, depending on the size of the diagonal blocks.
        '
        K = 0#
        Do While K <= N - 1#
            If Pivots(K) >= 0# Then
                
                '
                ' 1 x 1 diagonal block
                '
                ' Multiply by inv(U'(K+1)), where U(K+1) is the transformation
                ' stored in column K+1 of A.
                '
                V = 0#
                For i_ = 0# To K - 1# Step 1
                    V = V + B(i_) * A(i_, K)
                Next i_
                B(K) = B(K) - V
                
                '
                ' Interchange rows K+1 and IPIV(K+1).
                '
                KP = Pivots(K)
                If KP <> K Then
                    V = B(K)
                    B(K) = B(KP)
                    B(KP) = V
                End If
                K = K + 1#
            Else
                
                '
                ' 2 x 2 diagonal block
                '
                ' Multiply by inv(U'(K+1+1)), where U(K+1+1) is the transformation
                ' stored in columns K+1 and K+1+1 of A.
                '
                V = 0#
                For i_ = 0# To K - 1# Step 1
                    V = V + B(i_) * A(i_, K)
                Next i_
                B(K) = B(K) - V
                V = 0#
                For i_ = 0# To K - 1# Step 1
                    V = V + B(i_) * A(i_, K + 1#)
                Next i_
                B(K + 1#) = B(K + 1#) - V
                
                '
                ' Interchange rows K+1 and -IPIV(K+1).
                '
                KP = Pivots(K) + N
                If KP <> K Then
                    V = B(K)
                    B(K) = B(KP)
                    B(KP) = V
                End If
                K = K + 2#
            End If
        Loop
    Else
        
        '
        ' Solve A*X = B, where A = L*D*L'.
        '
        ' First solve L*D*X = B, overwriting B with X.
        '
        ' K+1 is the main loop index, increasing from 1 to N in steps of
        ' 1 or 2, depending on the size of the diagonal blocks.
        '
        K = 0#
        Do While K <= N - 1#
            If Pivots(K) >= 0# Then
                
                '
                ' 1 x 1 diagonal block
                '
                ' Interchange rows K+1 and IPIV(K+1).
                '
                KP = Pivots(K)
                If KP <> K Then
                    V = B(K)
                    B(K) = B(KP)
                    B(KP) = V
                End If
                
                '
                ' Multiply by inv(L(K+1)), where L(K+1) is the transformation
                ' stored in column K+1 of A.
                '
                If K + 1# < N Then
                    V = B(K)
                    For i_ = K + 1# To N - 1# Step 1
                        B(i_) = B(i_) - V * A(i_, K)
                    Next i_
                End If
                
                '
                ' Multiply by the inverse of the diagonal block.
                '
                B(K) = B(K) / A(K, K)
                K = K + 1#
            Else
                
                '
                ' 2 x 2 diagonal block
                '
                ' Interchange rows K+1+1 and -IPIV(K+1).
                '
                KP = Pivots(K) + N
                If KP <> K + 1# Then
                    V = B(K + 1#)
                    B(K + 1#) = B(KP)
                    B(KP) = V
                End If
                
                '
                ' Multiply by inv(L(K+1)), where L(K+1) is the transformation
                ' stored in columns K+1 and K+1+1 of A.
                '
                If K + 1# < N - 1# Then
                    V = B(K)
                    For i_ = K + 2# To N - 1# Step 1
                        B(i_) = B(i_) - V * A(i_, K)
                    Next i_
                    V = B(K + 1#)
                    For i_ = K + 2# To N - 1# Step 1
                        B(i_) = B(i_) - V * A(i_, K + 1#)
                    Next i_
                End If
                
                '
                ' Multiply by the inverse of the diagonal block.
                '
                AKM1K = A(K + 1#, K)
                AKM1 = A(K, K) / AKM1K
                AK = A(K + 1#, K + 1#) / AKM1K
                DENOM = AKM1 * AK - 1#
                BKM1 = B(K) / AKM1K
                BK = B(K + 1#) / AKM1K
                B(K) = (AK * BKM1 - BK) / DENOM
                B(K + 1#) = (AKM1 * BK - BKM1) / DENOM
                K = K + 2#
            End If
        Loop
        
        '
        ' Next solve L'*X = B, overwriting B with X.
        '
        ' K+1 is the main loop index, decreasing from N to 1 in steps of
        ' 1 or 2, depending on the size of the diagonal blocks.
        '
        K = N - 1#
        Do While K >= 0#
            If Pivots(K) >= 0# Then
                
                '
                ' 1 x 1 diagonal block
                '
                ' Multiply by inv(L'(K+1)), where L(K+1) is the transformation
                ' stored in column K+1 of A.
                '
                If K + 1# < N Then
                    V = 0#
                    For i_ = K + 1# To N - 1# Step 1
                        V = V + B(i_) * A(i_, K)
                    Next i_
                    B(K) = B(K) - V
                End If
                
                '
                ' Interchange rows K+1 and IPIV(K+1).
                '
                KP = Pivots(K)
                If KP <> K Then
                    V = B(K)
                    B(K) = B(KP)
                    B(KP) = V
                End If
                K = K - 1#
            Else
                
                '
                ' 2 x 2 diagonal block
                '
                ' Multiply by inv(L'(K+1-1)), where L(K+1-1) is the transformation
                ' stored in columns K+1-1 and K+1 of A.
                '
                If K + 1# < N Then
                    V = 0#
                    For i_ = K + 1# To N - 1# Step 1
                        V = V + B(i_) * A(i_, K)
                    Next i_
                    B(K) = B(K) - V
                    V = 0#
                    For i_ = K + 1# To N - 1# Step 1
                        V = V + B(i_) * A(i_, K - 1#)
                    Next i_
                    B(K - 1#) = B(K - 1#) - V
                End If
                
                '
                ' Interchange rows K+1 and -IPIV(K+1).
                '
                KP = Pivots(K) + N
                If KP <> K Then
                    V = B(K)
                    B(K) = B(KP)
                    B(KP) = V
                End If
                K = K - 2#
            End If
        Loop
    End If
    ReDim X(0# To N - 1#)
    For i_ = 0# To N - 1# Step 1
        X(i_) = B(i_)
    Next i_
    SMatrixLDLTSolve = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Solving a system of linear equations with a symmetric system matrix
'
'Input parameters:
'    A       -   system matrix (upper or lower triangle).
'                Array whose indexes range within [0..N-1, 0..N-1].
'    B       -   right side of a system.
'                Array whose index ranges within [0..N-1].
'    N       -   size of matrix A.
'    IsUpper -   If IsUpper = True, A contains the upper triangle,
'                otherwise A contains the lower triangle.
'
'Output parameters:
'    X       -   solution of a system.
'                Array whose index ranges within [0..N-1].
'
'Result:
'    True, if the matrix is not singular. X contains the solution.
'    False, if the matrix is singular (the determinant of the matrix is equal
'to 0). In this case, X doesn't contain a solution.
'
'  -- ALGLIB --
'     Copyright 2005 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function SMatrixSolve(ByRef A_() As Double, _
         ByRef B() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef X() As Double) As Boolean
    Dim Result As Boolean
    Dim A() As Double
    Dim Pivots() As Long
    A = A_
    Call SMatrixLDLT(A, N, IsUpper, Pivots)
    Result = SMatrixLDLTSolve(A, Pivots, B, N, IsUpper, X)
    SMatrixSolve = Result
End Function
Public Function SolveSystemLDLT(ByRef A() As Double, _
         ByRef Pivots() As Long, _
         ByRef B_() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef X() As Double) As Boolean
    Dim Result As Boolean
    Dim B() As Double
    Dim i As Long
    Dim K As Long
    Dim KP As Long
    Dim KM1 As Long
    Dim KM2 As Long
    Dim KP1 As Long
    Dim KP2 As Long
    Dim AK As Double
    Dim AKM1 As Double
    Dim AKM1K As Double
    Dim BK As Double
    Dim BKM1 As Double
    Dim DENOM As Double
    Dim V As Double
    Dim i_ As Long
    B = B_
    
    '
    ' Quick return if possible
    '
    Result = True
    If N = 0# Then
        SolveSystemLDLT = Result
        Exit Function
    End If
    
    '
    ' Check that the diagonal matrix D is nonsingular
    '
    If IsUpper Then
        
        '
        ' Upper triangular storage: examine D from bottom to top
        '
        For i = N To 1# Step -1
            If Pivots(i) > 0# And A(i, i) = 0# Then
                Result = False
                SolveSystemLDLT = Result
                Exit Function
            End If
        Next i
    Else
        
        '
        ' Lower triangular storage: examine D from top to bottom.
        '
        For i = 1# To N Step 1
            If Pivots(i) > 0# And A(i, i) = 0# Then
                Result = False
                SolveSystemLDLT = Result
                Exit Function
            End If
        Next i
    End If
    
    '
    ' Solve Ax = b
    '
    If IsUpper Then
        
        '
        ' Solve A*X = B, where A = U*D*U'.
        '
        ' First solve U*D*X = B, overwriting B with X.
        '
        ' K is the main loop index, decreasing from N to 1 in steps of
        ' 1 or 2, depending on the size of the diagonal blocks.
        '
        K = N
        Do While K >= 1#
            If Pivots(K) > 0# Then
                
                '
                ' 1 x 1 diagonal block
                '
                ' Interchange rows K and IPIV(K).
                '
                KP = Pivots(K)
                If KP <> K Then
                    V = B(K)
                    B(K) = B(KP)
                    B(KP) = V
                End If
                
                '
                ' Multiply by inv(U(K)), where U(K) is the transformation
                ' stored in column K of A.
                '
                KM1 = K - 1#
                V = B(K)
                For i_ = 1# To KM1 Step 1
                    B(i_) = B(i_) - V * A(i_, K)
                Next i_
                
                '
                ' Multiply by the inverse of the diagonal block.
                '
                B(K) = B(K) / A(K, K)
                K = K - 1#
            Else
                
                '
                ' 2 x 2 diagonal block
                '
                ' Interchange rows K-1 and -IPIV(K).
                '
                KP = -Pivots(K)
                If KP <> K - 1# Then
                    V = B(K - 1#)
                    B(K - 1#) = B(KP)
                    B(KP) = V
                End If
                
                '
                ' Multiply by inv(U(K)), where U(K) is the transformation
                ' stored in columns K-1 and K of A.
                '
                KM2 = K - 2#
                KM1 = K - 1#
                V = B(K)
                For i_ = 1# To KM2 Step 1
                    B(i_) = B(i_) - V * A(i_, K)
                Next i_
                V = B(K - 1#)
                For i_ = 1# To KM2 Step 1
                    B(i_) = B(i_) - V * A(i_, KM1)
                Next i_
                
                '
                ' Multiply by the inverse of the diagonal block.
                '
                AKM1K = A(K - 1#, K)
                AKM1 = A(K - 1#, K - 1#) / AKM1K
                AK = A(K, K) / AKM1K
                DENOM = AKM1 * AK - 1#
                BKM1 = B(K - 1#) / AKM1K
                BK = B(K) / AKM1K
                B(K - 1#) = (AK * BKM1 - BK) / DENOM
                B(K) = (AKM1 * BK - BKM1) / DENOM
                K = K - 2#
            End If
        Loop
        
        '
        ' Next solve U'*X = B, overwriting B with X.
        '
        ' K is the main loop index, increasing from 1 to N in steps of
        ' 1 or 2, depending on the size of the diagonal blocks.
        '
        K = 1#
        Do While K <= N
            If Pivots(K) > 0# Then
                
                '
                ' 1 x 1 diagonal block
                '
                ' Multiply by inv(U'(K)), where U(K) is the transformation
                ' stored in column K of A.
                '
                KM1 = K - 1#
                V = 0#
                For i_ = 1# To KM1 Step 1
                    V = V + B(i_) * A(i_, K)
                Next i_
                B(K) = B(K) - V
                
                '
                ' Interchange rows K and IPIV(K).
                '
                KP = Pivots(K)
                If KP <> K Then
                    V = B(K)
                    B(K) = B(KP)
                    B(KP) = V
                End If
                K = K + 1#
            Else
                
                '
                ' 2 x 2 diagonal block
                '
                ' Multiply by inv(U'(K+1)), where U(K+1) is the transformation
                ' stored in columns K and K+1 of A.
                '
                KM1 = K - 1#
                KP1 = K + 1#
                V = 0#
                For i_ = 1# To KM1 Step 1
                    V = V + B(i_) * A(i_, K)
                Next i_
                B(K) = B(K) - V
                V = 0#
                For i_ = 1# To KM1 Step 1
                    V = V + B(i_) * A(i_, KP1)
                Next i_
                B(K + 1#) = B(K + 1#) - V
                
                '
                ' Interchange rows K and -IPIV(K).
                '
                KP = -Pivots(K)
                If KP <> K Then
                    V = B(K)
                    B(K) = B(KP)
                    B(KP) = V
                End If
                K = K + 2#
            End If
        Loop
    Else
        
        '
        ' Solve A*X = B, where A = L*D*L'.
        '
        ' First solve L*D*X = B, overwriting B with X.
        '
        ' K is the main loop index, increasing from 1 to N in steps of
        ' 1 or 2, depending on the size of the diagonal blocks.
        '
        K = 1#
        Do While K <= N
            If Pivots(K) > 0# Then
                
                '
                ' 1 x 1 diagonal block
                '
                ' Interchange rows K and IPIV(K).
                '
                KP = Pivots(K)
                If KP <> K Then
                    V = B(K)
                    B(K) = B(KP)
                    B(KP) = V
                End If
                
                '
                ' Multiply by inv(L(K)), where L(K) is the transformation
                ' stored in column K of A.
                '
                If K < N Then
                    KP1 = K + 1#
                    V = B(K)
                    For i_ = KP1 To N Step 1
                        B(i_) = B(i_) - V * A(i_, K)
                    Next i_
                End If
                
                '
                ' Multiply by the inverse of the diagonal block.
                '
                B(K) = B(K) / A(K, K)
                K = K + 1#
            Else
                
                '
                ' 2 x 2 diagonal block
                '
                ' Interchange rows K+1 and -IPIV(K).
                '
                KP = -Pivots(K)
                If KP <> K + 1# Then
                    V = B(K + 1#)
                    B(K + 1#) = B(KP)
                    B(KP) = V
                End If
                
                '
                ' Multiply by inv(L(K)), where L(K) is the transformation
                ' stored in columns K and K+1 of A.
                '
                If K < N - 1# Then
                    KP1 = K + 1#
                    KP2 = K + 2#
                    V = B(K)
                    For i_ = KP2 To N Step 1
                        B(i_) = B(i_) - V * A(i_, K)
                    Next i_
                    V = B(K + 1#)
                    For i_ = KP2 To N Step 1
                        B(i_) = B(i_) - V * A(i_, KP1)
                    Next i_
                End If
                
                '
                ' Multiply by the inverse of the diagonal block.
                '
                AKM1K = A(K + 1#, K)
                AKM1 = A(K, K) / AKM1K
                AK = A(K + 1#, K + 1#) / AKM1K
                DENOM = AKM1 * AK - 1#
                BKM1 = B(K) / AKM1K
                BK = B(K + 1#) / AKM1K
                B(K) = (AK * BKM1 - BK) / DENOM
                B(K + 1#) = (AKM1 * BK - BKM1) / DENOM
                K = K + 2#
            End If
        Loop
        
        '
        ' Next solve L'*X = B, overwriting B with X.
        '
        ' K is the main loop index, decreasing from N to 1 in steps of
        ' 1 or 2, depending on the size of the diagonal blocks.
        '
        K = N
        Do While K >= 1#
            If Pivots(K) > 0# Then
                
                '
                ' 1 x 1 diagonal block
                '
                ' Multiply by inv(L'(K)), where L(K) is the transformation
                ' stored in column K of A.
                '
                If K < N Then
                    KP1 = K + 1#
                    V = 0#
                    For i_ = KP1 To N Step 1
                        V = V + B(i_) * A(i_, K)
                    Next i_
                    B(K) = B(K) - V
                End If
                
                '
                ' Interchange rows K and IPIV(K).
                '
                KP = Pivots(K)
                If KP <> K Then
                    V = B(K)
                    B(K) = B(KP)
                    B(KP) = V
                End If
                K = K - 1#
            Else
                
                '
                ' 2 x 2 diagonal block
                '
                ' Multiply by inv(L'(K-1)), where L(K-1) is the transformation
                ' stored in columns K-1 and K of A.
                '
                If K < N Then
                    KP1 = K + 1#
                    KM1 = K - 1#
                    V = 0#
                    For i_ = KP1 To N Step 1
                        V = V + B(i_) * A(i_, K)
                    Next i_
                    B(K) = B(K) - V
                    V = 0#
                    For i_ = KP1 To N Step 1
                        V = V + B(i_) * A(i_, KM1)
                    Next i_
                    B(K - 1#) = B(K - 1#) - V
                End If
                
                '
                ' Interchange rows K and -IPIV(K).
                '
                KP = -Pivots(K)
                If KP <> K Then
                    V = B(K)
                    B(K) = B(KP)
                    B(KP) = V
                End If
                K = K - 2#
            End If
        Loop
    End If
    ReDim X(1# To N)
    For i_ = 1# To N Step 1
        X(i_) = B(i_)
    Next i_
    SolveSystemLDLT = Result
End Function
Public Function SolveSymmetricSystem(ByRef A_() As Double, _
         ByRef B_() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef X() As Double) As Boolean
    Dim Result As Boolean
    Dim A() As Double
    Dim B() As Double
    Dim Pivots() As Long
    A = A_
    B = B_
    Call LDLTDecomposition(A, N, IsUpper, Pivots)
    Result = SolveSystemLDLT(A, Pivots, B, N, IsUpper, X)
    SolveSymmetricSystem = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 1992-2007 The University of Tennessee.  All rights reserved.
'
'Contributors:
'    * Sergey Bochkanov (ALGLIB project). Translation from FORTRAN to
'      pseudocode.
'
'See subroutines comments for additional copyrights.
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Condition number estimate of a symmetric matrix
'
'The algorithm calculates a lower bound of the condition number. In this
'case, the algorithm does not return a lower bound of the condition number,
'but an inverse number (to avoid an overflow in case of a singular matrix).
'
'It should be noted that 1-norm and inf-norm condition numbers of symmetric
'matrices are equal, so the algorithm doesn't take into account the
'differences between these types of norms.
'
'Input parameters:
'    A       -   symmetric definite matrix which is given by its upper or
'                lower triangle depending on IsUpper.
'                Array with elements [0..N-1, 0..N-1].
'    N       -   size of matrix A.
'    IsUpper -   storage format.
'
'Result:
'    1/LowerBound(cond(A))
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function SMatrixRCond(ByRef A() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean) As Double
    Dim Result As Double
    Dim i As Long
    Dim j As Long
    Dim A1() As Double
    ReDim A1(1# To N, 1# To N)
    For i = 1# To N Step 1
        If IsUpper Then
            For j = i To N Step 1
                A1(i, j) = A(i - 1#, j - 1#)
            Next j
        Else
            For j = 1# To i Step 1
                A1(i, j) = A(i - 1#, j - 1#)
            Next j
        End If
    Next i
    Result = RCondSymmetric(A1, N, IsUpper)
    SMatrixRCond = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Condition number estimate of a matrix given by LDLT-decomposition
'
'The algorithm calculates a lower bound of the condition number. In this
'case, the algorithm does not return a lower bound of the condition number,
'but an inverse number (to avoid an overflow in case of a singular matrix).
'
'It should be noted that 1-norm and inf-norm condition numbers of symmetric
'matrices are equal, so the algorithm doesn't take into account the
'differences between these types of norms.
'
'Input parameters:
'    L       -   LDLT-decomposition of matrix A given by the upper or lower
'                triangle depending on IsUpper.
'                Output of SMatrixLDLT subroutine.
'    Pivots  -   table of permutations which were made during LDLT-decomposition,
'                Output of SMatrixLDLT subroutine.
'    N       -   size of matrix A.
'    IsUpper -   storage format.
'
'Result:
'    1/LowerBound(cond(A))
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function SMatrixLDLTRCond(ByRef L() As Double, _
         ByRef Pivots() As Long, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean) As Double
    Dim Result As Double
    Dim i As Long
    Dim j As Long
    Dim L1() As Double
    Dim P1() As Long
    ReDim L1(1# To N, 1# To N)
    For i = 1# To N Step 1
        If IsUpper Then
            For j = i To N Step 1
                L1(i, j) = L(i - 1#, j - 1#)
            Next j
        Else
            For j = 1# To i Step 1
                L1(i, j) = L(i - 1#, j - 1#)
            Next j
        End If
    Next i
    ReDim P1(1# To N)
    For i = 1# To N Step 1
        If Pivots(i - 1#) >= 0# Then
            P1(i) = Pivots(i - 1#) + 1#
        Else
            P1(i) = -(Pivots(i - 1#) + N + 1#)
        End If
    Next i
    Result = RCondLDLT(L1, P1, N, IsUpper)
    SMatrixLDLTRCond = Result
End Function
Public Function RCondSymmetric(ByRef A_() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean) As Double
    Dim Result As Double
    Dim A() As Double
    Dim i As Long
    Dim j As Long
    Dim IM As Long
    Dim JM As Long
    Dim V As Double
    Dim Nrm As Double
    Dim Pivots() As Long
    A = A_
    Nrm = 0#
    For j = 1# To N Step 1
        V = 0#
        For i = 1# To N Step 1
            IM = i
            JM = j
            If IsUpper And j < i Then
                IM = j
                JM = i
            End If
            If Not IsUpper And j > i Then
                IM = j
                JM = i
            End If
            V = V + Abs(A(IM, JM))
        Next i
        Nrm = MaxReal(Nrm, V)
    Next j
    Call LDLTDecomposition(A, N, IsUpper, Pivots)
    Call InternalLDLTRCond(A, Pivots, N, IsUpper, True, Nrm, V)
    Result = V
    RCondSymmetric = Result
End Function
Public Function RCondLDLT(ByRef L() As Double, _
         ByRef Pivots() As Long, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean) As Double
    Dim Result As Double
    Dim V As Double
    Call InternalLDLTRCond(L, Pivots, N, IsUpper, False, 0#, V)
    Result = V
    RCondLDLT = Result
End Function
Public Sub InternalLDLTRCond(ByRef L() As Double, _
         ByRef Pivots() As Long, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByVal IsNormProvided As Boolean, _
         ByVal ANORM As Double, _
         ByRef RCOND As Double)
    Dim i As Long
    Dim KASE As Long
    Dim K As Long
    Dim KM1 As Long
    Dim KM2 As Long
    Dim KP1 As Long
    Dim KP2 As Long
    Dim AINVNM As Double
    Dim WORK0() As Double
    Dim WORK1() As Double
    Dim WORK2() As Double
    Dim IWORK() As Long
    Dim V As Double
    Dim i_ As Long
    
    '
    ' Check that the diagonal matrix D is nonsingular.
    '
    RCOND = 0#
    If IsUpper Then
        For i = N To 1# Step -1
            If Pivots(i) > 0# And L(i, i) = 0# Then
                Exit Sub
            End If
        Next i
    Else
        For i = 1# To N Step 1
            If Pivots(i) > 0# And L(i, i) = 0# Then
                Exit Sub
            End If
        Next i
    End If
    
    '
    ' Estimate the norm of A.
    '
    If Not IsNormProvided Then
        KASE = 0#
        ANORM = 0#
        Do While True
            Call IterativeEstimate1Norm(N, WORK1, WORK0, IWORK, ANORM, KASE)
            If KASE = 0# Then
                Exit Do
            End If
            If IsUpper Then
                
                '
                ' Multiply by U'
                '
                K = N
                Do While K >= 1#
                    If Pivots(K) > 0# Then
                        
                        '
                        ' P(k)
                        '
                        V = WORK0(K)
                        WORK0(K) = WORK0(Pivots(K))
                        WORK0(Pivots(K)) = V
                        
                        '
                        ' U(k)
                        '
                        KM1 = K - 1#
                        V = 0#
                        For i_ = 1# To KM1 Step 1
                            V = V + WORK0(i_) * L(i_, K)
                        Next i_
                        WORK0(K) = WORK0(K) + V
                        
                        '
                        ' Next k
                        '
                        K = K - 1#
                    Else
                        
                        '
                        ' P(k)
                        '
                        V = WORK0(K - 1#)
                        WORK0(K - 1#) = WORK0(-Pivots(K - 1#))
                        WORK0(-Pivots(K - 1#)) = V
                        
                        '
                        ' U(k)
                        '
                        KM1 = K - 1#
                        KM2 = K - 2#
                        V = 0#
                        For i_ = 1# To KM2 Step 1
                            V = V + WORK0(i_) * L(i_, KM1)
                        Next i_
                        WORK0(KM1) = WORK0(KM1) + V
                        V = 0#
                        For i_ = 1# To KM2 Step 1
                            V = V + WORK0(i_) * L(i_, K)
                        Next i_
                        WORK0(K) = WORK0(K) + V
                        
                        '
                        ' Next k
                        '
                        K = K - 2#
                    End If
                Loop
                
                '
                ' Multiply by D
                '
                K = N
                Do While K >= 1#
                    If Pivots(K) > 0# Then
                        WORK0(K) = WORK0(K) * L(K, K)
                        K = K - 1#
                    Else
                        V = WORK0(K - 1#)
                        WORK0(K - 1#) = L(K - 1#, K - 1#) * WORK0(K - 1#) + L(K - 1#, K) * WORK0(K)
                        WORK0(K) = L(K - 1#, K) * V + L(K, K) * WORK0(K)
                        K = K - 2#
                    End If
                Loop
                
                '
                ' Multiply by U
                '
                K = 1#
                Do While K <= N
                    If Pivots(K) > 0# Then
                        
                        '
                        ' U(k)
                        '
                        KM1 = K - 1#
                        V = WORK0(K)
                        For i_ = 1# To KM1 Step 1
                            WORK0(i_) = WORK0(i_) + V * L(i_, K)
                        Next i_
                        
                        '
                        ' P(k)
                        '
                        V = WORK0(K)
                        WORK0(K) = WORK0(Pivots(K))
                        WORK0(Pivots(K)) = V
                        
                        '
                        ' Next k
                        '
                        K = K + 1#
                    Else
                        
                        '
                        ' U(k)
                        '
                        KM1 = K - 1#
                        KP1 = K + 1#
                        V = WORK0(K)
                        For i_ = 1# To KM1 Step 1
                            WORK0(i_) = WORK0(i_) + V * L(i_, K)
                        Next i_
                        V = WORK0(KP1)
                        For i_ = 1# To KM1 Step 1
                            WORK0(i_) = WORK0(i_) + V * L(i_, KP1)
                        Next i_
                        
                        '
                        ' P(k)
                        '
                        V = WORK0(K)
                        WORK0(K) = WORK0(-Pivots(K))
                        WORK0(-Pivots(K)) = V
                        
                        '
                        ' Next k
                        '
                        K = K + 2#
                    End If
                Loop
            Else
                
                '
                ' Multiply by L'
                '
                K = 1#
                Do While K <= N
                    If Pivots(K) > 0# Then
                        
                        '
                        ' P(k)
                        '
                        V = WORK0(K)
                        WORK0(K) = WORK0(Pivots(K))
                        WORK0(Pivots(K)) = V
                        
                        '
                        ' L(k)
                        '
                        KP1 = K + 1#
                        V = 0#
                        For i_ = KP1 To N Step 1
                            V = V + WORK0(i_) * L(i_, K)
                        Next i_
                        WORK0(K) = WORK0(K) + V
                        
                        '
                        ' Next k
                        '
                        K = K + 1#
                    Else
                        
                        '
                        ' P(k)
                        '
                        V = WORK0(K + 1#)
                        WORK0(K + 1#) = WORK0(-Pivots(K + 1#))
                        WORK0(-Pivots(K + 1#)) = V
                        
                        '
                        ' L(k)
                        '
                        KP1 = K + 1#
                        KP2 = K + 2#
                        V = 0#
                        For i_ = KP2 To N Step 1
                            V = V + WORK0(i_) * L(i_, K)
                        Next i_
                        WORK0(K) = WORK0(K) + V
                        V = 0#
                        For i_ = KP2 To N Step 1
                            V = V + WORK0(i_) * L(i_, KP1)
                        Next i_
                        WORK0(KP1) = WORK0(KP1) + V
                        
                        '
                        ' Next k
                        '
                        K = K + 2#
                    End If
                Loop
                
                '
                ' Multiply by D
                '
                K = N
                Do While K >= 1#
                    If Pivots(K) > 0# Then
                        WORK0(K) = WORK0(K) * L(K, K)
                        K = K - 1#
                    Else
                        V = WORK0(K - 1#)
                        WORK0(K - 1#) = L(K - 1#, K - 1#) * WORK0(K - 1#) + L(K, K - 1#) * WORK0(K)
                        WORK0(K) = L(K, K - 1#) * V + L(K, K) * WORK0(K)
                        K = K - 2#
                    End If
                Loop
                
                '
                ' Multiply by L
                '
                K = N
                Do While K >= 1#
                    If Pivots(K) > 0# Then
                        
                        '
                        ' L(k)
                        '
                        KP1 = K + 1#
                        V = WORK0(K)
                        For i_ = KP1 To N Step 1
                            WORK0(i_) = WORK0(i_) + V * L(i_, K)
                        Next i_
                        
                        '
                        ' P(k)
                        '
                        V = WORK0(K)
                        WORK0(K) = WORK0(Pivots(K))
                        WORK0(Pivots(K)) = V
                        
                        '
                        ' Next k
                        '
                        K = K - 1#
                    Else
                        
                        '
                        ' L(k)
                        '
                        KP1 = K + 1#
                        KM1 = K - 1#
                        V = WORK0(K)
                        For i_ = KP1 To N Step 1
                            WORK0(i_) = WORK0(i_) + V * L(i_, K)
                        Next i_
                        V = WORK0(KM1)
                        For i_ = KP1 To N Step 1
                            WORK0(i_) = WORK0(i_) + V * L(i_, KM1)
                        Next i_
                        
                        '
                        ' P(k)
                        '
                        V = WORK0(K)
                        WORK0(K) = WORK0(-Pivots(K))
                        WORK0(-Pivots(K)) = V
                        
                        '
                        ' Next k
                        '
                        K = K - 2#
                    End If
                Loop
            End If
        Loop
    End If
    
    '
    ' Quick return if possible
    '
    RCOND = 0#
    If N = 0# Then
        RCOND = 1#
        Exit Sub
    End If
    If ANORM = 0# Then
        Exit Sub
    End If
    
    '
    ' Estimate the 1-norm of inv(A).
    '
    KASE = 0#
    Do While True
        Call IterativeEstimate1Norm(N, WORK1, WORK0, IWORK, AINVNM, KASE)
        If KASE = 0# Then
            Exit Do
        End If
        Call SolveSystemLDLT(L, Pivots, WORK0, N, IsUpper, WORK2)
        For i_ = 1# To N Step 1
            WORK0(i_) = WORK2(i_)
        Next i_
    Loop
    
    '
    ' Compute the estimate of the reciprocal condition number.
    '
    If AINVNM <> 0# Then
        V = 1# / AINVNM
        RCOND = V / ANORM
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2005-2007, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Algorithm for solving the following generalized symmetric positive-definite
'eigenproblem:
'    A*x = lambda*B*x (1) or
'    A*B*x = lambda*x (2) or
'    B*A*x = lambda*x (3).
'where A is a symmetric matrix, B - symmetric positive-definite matrix.
'The problem is solved by reducing it to an ordinary  symmetric  eigenvalue
'problem.
'
'Input parameters:
'    A           -   symmetric matrix which is given by its upper or lower
'                    triangular part.
'                    Array whose indexes range within [0..N-1, 0..N-1].
'    N           -   size of matrices A and B.
'    IsUpperA    -   storage format of matrix A.
'    B           -   symmetric positive-definite matrix which is given by
'                    its upper or lower triangular part.
'                    Array whose indexes range within [0..N-1, 0..N-1].
'    IsUpperB    -   storage format of matrix B.
'    ZNeeded     -   if ZNeeded is equal to:
'                     * 0, the eigenvectors are not returned;
'                     * 1, the eigenvectors are returned.
'    ProblemType -   if ProblemType is equal to:
'                     * 1, the following problem is solved: A*x = lambda*B*x;
'                     * 2, the following problem is solved: A*B*x = lambda*x;
'                     * 3, the following problem is solved: B*A*x = lambda*x.
'
'Output parameters:
'    D           -   eigenvalues in ascending order.
'                    Array whose index ranges within [0..N-1].
'    Z           -   if ZNeeded is equal to:
'                     * 0, Z hasnt changed;
'                     * 1, Z contains eigenvectors.
'                    Array whose indexes range within [0..N-1, 0..N-1].
'                    The eigenvectors are stored in matrix columns. It should
'                    be noted that the eigenvectors in such problems do not
'                    form an orthogonal system.
'
'Result:
'    True, if the problem was solved successfully.
'    False, if the error occurred during the Cholesky decomposition of matrix
'    B (the matrix isnt positive-definite) or during the work of the iterative
'    algorithm for solving the symmetric eigenproblem.
'
'See also the GeneralizedSymmetricDefiniteEVDReduce subroutine.
'
'  -- ALGLIB --
'     Copyright 1.28.2006 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function SMatrixGEVD(ByRef A_() As Double, _
         ByVal N As Long, _
         ByVal IsUpperA As Boolean, _
         ByRef B() As Double, _
         ByVal IsUpperB As Boolean, _
         ByVal ZNeeded As Long, _
         ByVal ProblemType As Long, _
         ByRef D() As Double, _
         ByRef z() As Double) As Boolean
    Dim Result As Boolean
    Dim A() As Double
    Dim R() As Double
    Dim T() As Double
    Dim IsUpperR As Boolean
    Dim J1 As Long
    Dim J2 As Long
    Dim J1INC As Long
    Dim J2INC As Long
    Dim i As Long
    Dim j As Long
    Dim V As Double
    Dim i_ As Long
    A = A_
    
    '
    ' Reduce and solve
    '
    Result = SMatrixGEVDReduce(A, N, IsUpperA, B, IsUpperB, ProblemType, R, IsUpperR)
    If Not Result Then
        SMatrixGEVD = Result
        Exit Function
    End If
    Result = SMatrixEVD(A, N, ZNeeded, IsUpperA, D, T)
    If Not Result Then
        SMatrixGEVD = Result
        Exit Function
    End If
    
    '
    ' Transform eigenvectors if needed
    '
    If ZNeeded <> 0# Then
        
        '
        ' fill Z with zeros
        '
        ReDim z(0# To N - 1#, 0# To N - 1#)
        For j = 0# To N - 1# Step 1
            z(0#, j) = 0#
        Next j
        For i = 1# To N - 1# Step 1
            For i_ = 0# To N - 1# Step 1
                z(i, i_) = z(0#, i_)
            Next i_
        Next i
        
        '
        ' Setup R properties
        '
        If IsUpperR Then
            J1 = 0#
            J2 = N - 1#
            J1INC = 1#
            J2INC = 0#
        Else
            J1 = 0#
            J2 = 0#
            J1INC = 0#
            J2INC = 1#
        End If
        
        '
        ' Calculate R*Z
        '
        For i = 0# To N - 1# Step 1
            For j = J1 To J2 Step 1
                V = R(i, j)
                For i_ = 0# To N - 1# Step 1
                    z(i, i_) = z(i, i_) + V * T(j, i_)
                Next i_
            Next j
            J1 = J1 + J1INC
            J2 = J2 + J2INC
        Next i
    End If
    SMatrixGEVD = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Algorithm for reduction of the following generalized symmetric positive-
'definite eigenvalue problem:
'    A*x = lambda*B*x (1) or
'    A*B*x = lambda*x (2) or
'    B*A*x = lambda*x (3)
'to the symmetric eigenvalues problem C*y = lambda*y (eigenvalues of this and
'the given problems are the same, and the eigenvectors of the given problem
'could be obtained by multiplying the obtained eigenvectors by the
'transformation matrix x = R*y).
'
'Here A is a symmetric matrix, B - symmetric positive-definite matrix.
'
'Input parameters:
'    A           -   symmetric matrix which is given by its upper or lower
'                    triangular part.
'                    Array whose indexes range within [0..N-1, 0..N-1].
'    N           -   size of matrices A and B.
'    IsUpperA    -   storage format of matrix A.
'    B           -   symmetric positive-definite matrix which is given by
'                    its upper or lower triangular part.
'                    Array whose indexes range within [0..N-1, 0..N-1].
'    IsUpperB    -   storage format of matrix B.
'    ProblemType -   if ProblemType is equal to:
'                     * 1, the following problem is solved: A*x = lambda*B*x;
'                     * 2, the following problem is solved: A*B*x = lambda*x;
'                     * 3, the following problem is solved: B*A*x = lambda*x.
'
'Output parameters:
'    A           -   symmetric matrix which is given by its upper or lower
'                    triangle depending on IsUpperA. Contains matrix C.
'                    Array whose indexes range within [0..N-1, 0..N-1].
'    R           -   upper triangular or low triangular transformation matrix
'                    which is used to obtain the eigenvectors of a given problem
'                    as the product of eigenvectors of C (from the right) and
'                    matrix R (from the left). If the matrix is upper
'                    triangular, the elements below the main diagonal
'                    are equal to 0 (and vice versa). Thus, we can perform
'                    the multiplication without taking into account the
'                    internal structure (which is an easier though less
'                    effective way).
'                    Array whose indexes range within [0..N-1, 0..N-1].
'    IsUpperR    -   type of matrix R (upper or lower triangular).
'
'Result:
'    True, if the problem was reduced successfully.
'    False, if the error occurred during the Cholesky decomposition of
'        matrix B (the matrix is not positive-definite).
'
'  -- ALGLIB --
'     Copyright 1.28.2006 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function SMatrixGEVDReduce(ByRef A() As Double, _
         ByVal N As Long, _
         ByVal IsUpperA As Boolean, _
         ByRef B() As Double, _
         ByVal IsUpperB As Boolean, _
         ByVal ProblemType As Long, _
         ByRef R() As Double, _
         ByRef IsUpperR As Boolean) As Boolean
    Dim Result As Boolean
    Dim T() As Double
    Dim W1() As Double
    Dim W2() As Double
    Dim W3() As Double
    Dim i As Long
    Dim j As Long
    Dim V As Double
    Dim Rep As MatInvReport
    Dim Info As Long
    Dim i_ As Long
    Dim i1_ As Long
    Result = True
    
    '
    ' Problem 1:  A*x = lambda*B*x
    '
    ' Reducing to:
    '     C*y = lambda*y
    '     C = L^(-1) * A * L^(-T)
    '     x = L^(-T) * y
    '
    If ProblemType = 1# Then
        
        '
        ' Factorize B in T: B = LL'
        '
        ReDim T(0# To N - 1#, 0# To N - 1#)
        If IsUpperB Then
            For i = 0# To N - 1# Step 1
                For i_ = i To N - 1# Step 1
                    T(i_, i) = B(i, i_)
                Next i_
            Next i
        Else
            For i = 0# To N - 1# Step 1
                For i_ = 0# To i Step 1
                    T(i, i_) = B(i, i_)
                Next i_
            Next i
        End If
        If Not SPDMatrixCholesky(T, N, False) Then
            Result = False
            SMatrixGEVDReduce = Result
            Exit Function
        End If
        
        '
        ' Invert L in T
        '
        Call RMatrixTRInverse(T, N, False, False, Info, Rep)
        If Info <= 0# Then
            Result = False
            SMatrixGEVDReduce = Result
            Exit Function
        End If
        
        '
        ' Build L^(-1) * A * L^(-T) in R
        '
        ReDim W1(1# To N)
        ReDim W2(1# To N)
        ReDim R(0# To N - 1#, 0# To N - 1#)
        For j = 1# To N Step 1
            
            '
            ' Form w2 = A * l'(j) (here l'(j) is j-th column of L^(-T))
            '
            i1_ = (0#) - (1#)
            For i_ = 1# To j Step 1
                W1(i_) = T(j - 1#, i_ + i1_)
            Next i_
            Call SymmetricMatrixVectorMultiply(A, IsUpperA, 0#, j - 1#, W1, 1#, W2)
            If IsUpperA Then
                Call MatrixVectorMultiply(A, 0#, j - 1#, j, N - 1#, True, W1, 1#, j, 1#, W2, j + 1#, N, 0#)
            Else
                Call MatrixVectorMultiply(A, j, N - 1#, 0#, j - 1#, False, W1, 1#, j, 1#, W2, j + 1#, N, 0#)
            End If
            
            '
            ' Form l(i)*w2 (here l(i) is i-th row of L^(-1))
            '
            For i = 1# To N Step 1
                i1_ = (1#) - (0#)
                V = 0#
                For i_ = 0# To i - 1# Step 1
                    V = V + T(i - 1#, i_) * W2(i_ + i1_)
                Next i_
                R(i - 1#, j - 1#) = V
            Next i
        Next j
        
        '
        ' Copy R to A
        '
        For i = 0# To N - 1# Step 1
            For i_ = 0# To N - 1# Step 1
                A(i, i_) = R(i, i_)
            Next i_
        Next i
        
        '
        ' Copy L^(-1) from T to R and transpose
        '
        IsUpperR = True
        For i = 0# To N - 1# Step 1
            For j = 0# To i - 1# Step 1
                R(i, j) = 0#
            Next j
        Next i
        For i = 0# To N - 1# Step 1
            For i_ = i To N - 1# Step 1
                R(i, i_) = T(i_, i)
            Next i_
        Next i
        SMatrixGEVDReduce = Result
        Exit Function
    End If
    
    '
    ' Problem 2:  A*B*x = lambda*x
    ' or
    ' problem 3:  B*A*x = lambda*x
    '
    ' Reducing to:
    '     C*y = lambda*y
    '     C = U * A * U'
    '     B = U'* U
    '
    If ProblemType = 2# Or ProblemType = 3# Then
        
        '
        ' Factorize B in T: B = U'*U
        '
        ReDim T(0# To N - 1#, 0# To N - 1#)
        If IsUpperB Then
            For i = 0# To N - 1# Step 1
                For i_ = i To N - 1# Step 1
                    T(i, i_) = B(i, i_)
                Next i_
            Next i
        Else
            For i = 0# To N - 1# Step 1
                For i_ = i To N - 1# Step 1
                    T(i, i_) = B(i_, i)
                Next i_
            Next i
        End If
        If Not SPDMatrixCholesky(T, N, True) Then
            Result = False
            SMatrixGEVDReduce = Result
            Exit Function
        End If
        
        '
        ' Build U * A * U' in R
        '
        ReDim W1(1# To N)
        ReDim W2(1# To N)
        ReDim W3(1# To N)
        ReDim R(0# To N - 1#, 0# To N - 1#)
        For j = 1# To N Step 1
            
            '
            ' Form w2 = A * u'(j) (here u'(j) is j-th column of U')
            '
            i1_ = (j - 1#) - (1#)
            For i_ = 1# To N - j + 1# Step 1
                W1(i_) = T(j - 1#, i_ + i1_)
            Next i_
            Call SymmetricMatrixVectorMultiply(A, IsUpperA, j - 1#, N - 1#, W1, 1#, W3)
            i1_ = (1#) - (j)
            For i_ = j To N Step 1
                W2(i_) = W3(i_ + i1_)
            Next i_
            i1_ = (j - 1#) - (j)
            For i_ = j To N Step 1
                W1(i_) = T(j - 1#, i_ + i1_)
            Next i_
            If IsUpperA Then
                Call MatrixVectorMultiply(A, 0#, j - 2#, j - 1#, N - 1#, False, W1, j, N, 1#, W2, 1#, j - 1#, 0#)
            Else
                Call MatrixVectorMultiply(A, j - 1#, N - 1#, 0#, j - 2#, True, W1, j, N, 1#, W2, 1#, j - 1#, 0#)
            End If
            
            '
            ' Form u(i)*w2 (here u(i) is i-th row of U)
            '
            For i = 1# To N Step 1
                i1_ = (i) - (i - 1#)
                V = 0#
                For i_ = i - 1# To N - 1# Step 1
                    V = V + T(i - 1#, i_) * W2(i_ + i1_)
                Next i_
                R(i - 1#, j - 1#) = V
            Next i
        Next j
        
        '
        ' Copy R to A
        '
        For i = 0# To N - 1# Step 1
            For i_ = 0# To N - 1# Step 1
                A(i, i_) = R(i, i_)
            Next i_
        Next i
        If ProblemType = 2# Then
            
            '
            ' Invert U in T
            '
            Call RMatrixTRInverse(T, N, True, False, Info, Rep)
            If Info <= 0# Then
                Result = False
                SMatrixGEVDReduce = Result
                Exit Function
            End If
            
            '
            ' Copy U^-1 from T to R
            '
            IsUpperR = True
            For i = 0# To N - 1# Step 1
                For j = 0# To i - 1# Step 1
                    R(i, j) = 0#
                Next j
            Next i
            For i = 0# To N - 1# Step 1
                For i_ = i To N - 1# Step 1
                    R(i, i_) = T(i, i_)
                Next i_
            Next i
        Else
            
            '
            ' Copy U from T to R and transpose
            '
            IsUpperR = False
            For i = 0# To N - 1# Step 1
                For j = i + 1# To N - 1# Step 1
                    R(i, j) = 0#
                Next j
            Next i
            For i = 0# To N - 1# Step 1
                For i_ = i To N - 1# Step 1
                    R(i_, i) = T(i, i_)
                Next i_
            Next i
        End If
    End If
    SMatrixGEVDReduce = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 1992-2007 The University of Tennessee.  All rights reserved.
'
'Contributors:
'    * Sergey Bochkanov (ALGLIB project). Translation from FORTRAN to
'      pseudocode.
'
'See subroutines comments for additional copyrights.
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Inversion of a symmetric indefinite matrix
'
'The algorithm gets an LDLT-decomposition as an input, generates matrix A^-1
'and saves the lower or upper triangle of an inverse matrix depending on the
'input (U*D*U' or L*D*L').
'
'Input parameters:
'    A       -   LDLT-decomposition of the matrix,
'                Output of subroutine SMatrixLDLT.
'    N       -   size of matrix A.
'    IsUpper -   storage format. If IsUpper = True, then the symmetric matrix
'                is given as decomposition A = U*D*U' and this decomposition
'                is stored in the upper triangle of matrix A and on the main
'                diagonal, and the lower triangle of matrix A is not used.
'    Pivots  -   a table of permutations, output of subroutine SMatrixLDLT.
'
'Output parameters:
'    A       -   inverse of the matrix, whose LDLT-decomposition was stored
'                in matrix A as a subroutine input.
'                Array with elements [0..N-1, 0..N-1].
'                If IsUpper = True, then A contains the upper triangle of
'                matrix A^-1, and the elements below the main diagonal are
'                not used nor changed. The same applies if IsUpper = False.
'
'Result:
'    True, if the matrix is not singular.
'    False, if the matrix is singular and could not be inverted.
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     March 31, 1993
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function SMatrixLDLTInverse(ByRef A() As Double, _
         ByRef Pivots() As Long, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean) As Boolean
    Dim Result As Boolean
    Dim WORK() As Double
    Dim WORK2() As Double
    Dim i As Long
    Dim K As Long
    Dim KP As Long
    Dim KSTEP As Long
    Dim AK As Double
    Dim AKKP1 As Double
    Dim AKP1 As Double
    Dim D As Double
    Dim T As Double
    Dim temp As Double
    Dim KM1 As Long
    Dim KP1 As Long
    Dim L As Long
    Dim I1 As Long
    Dim I2 As Long
    Dim V As Double
    Dim i_ As Long
    Dim i1_ As Long
    ReDim WORK(1# To N)
    ReDim WORK2(1# To N)
    Result = True
    
    '
    ' Quick return if possible
    '
    If N = 0# Then
        SMatrixLDLTInverse = Result
        Exit Function
    End If
    
    '
    ' Check that the diagonal matrix D is nonsingular.
    '
    For i = 0# To N - 1# Step 1
        If Pivots(i) >= 0# And A(i, i) = 0# Then
            Result = False
            SMatrixLDLTInverse = Result
            Exit Function
        End If
    Next i
    If IsUpper Then
        
        '
        ' Compute inv(A) from the factorization A = U*D*U'.
        '
        ' K+1 is the main loop index, increasing from 1 to N in steps of
        ' 1 or 2, depending on the size of the diagonal blocks.
        '
        K = 0#
        Do While K <= N - 1#
            If Pivots(K) >= 0# Then
                
                '
                ' 1 x 1 diagonal block
                '
                ' Invert the diagonal block.
                '
                A(K, K) = 1# / A(K, K)
                
                '
                ' Compute column K+1 of the inverse.
                '
                If K > 0# Then
                    i1_ = (0#) - (1#)
                    For i_ = 1# To K Step 1
                        WORK(i_) = A(i_ + i1_, K)
                    Next i_
                    Call SymmetricMatrixVectorMultiply(A, IsUpper, 1# - 1#, K + 1# - 1# - 1#, WORK, -1#, WORK2)
                    i1_ = (1#) - (0#)
                    For i_ = 0# To K - 1# Step 1
                        A(i_, K) = WORK2(i_ + i1_)
                    Next i_
                    V = 0#
                    For i_ = 1# To K Step 1
                        V = V + WORK2(i_) * WORK(i_)
                    Next i_
                    A(K, K) = A(K, K) - V
                End If
                KSTEP = 1#
            Else
                
                '
                ' 2 x 2 diagonal block
                '
                ' Invert the diagonal block.
                '
                T = Abs(A(K, K + 1#))
                AK = A(K, K) / T
                AKP1 = A(K + 1#, K + 1#) / T
                AKKP1 = A(K, K + 1#) / T
                D = T * (AK * AKP1 - 1#)
                A(K, K) = AKP1 / D
                A(K + 1#, K + 1#) = AK / D
                A(K, K + 1#) = -(AKKP1 / D)
                
                '
                ' Compute columns K+1 and K+1+1 of the inverse.
                '
                If K > 0# Then
                    i1_ = (0#) - (1#)
                    For i_ = 1# To K Step 1
                        WORK(i_) = A(i_ + i1_, K)
                    Next i_
                    Call SymmetricMatrixVectorMultiply(A, IsUpper, 0#, K - 1#, WORK, -1#, WORK2)
                    i1_ = (1#) - (0#)
                    For i_ = 0# To K - 1# Step 1
                        A(i_, K) = WORK2(i_ + i1_)
                    Next i_
                    V = 0#
                    For i_ = 1# To K Step 1
                        V = V + WORK(i_) * WORK2(i_)
                    Next i_
                    A(K, K) = A(K, K) - V
                    V = 0#
                    For i_ = 0# To K - 1# Step 1
                        V = V + A(i_, K) * A(i_, K + 1#)
                    Next i_
                    A(K, K + 1#) = A(K, K + 1#) - V
                    i1_ = (0#) - (1#)
                    For i_ = 1# To K Step 1
                        WORK(i_) = A(i_ + i1_, K + 1#)
                    Next i_
                    Call SymmetricMatrixVectorMultiply(A, IsUpper, 0#, K - 1#, WORK, -1#, WORK2)
                    i1_ = (1#) - (0#)
                    For i_ = 0# To K - 1# Step 1
                        A(i_, K + 1#) = WORK2(i_ + i1_)
                    Next i_
                    V = 0#
                    For i_ = 1# To K Step 1
                        V = V + WORK(i_) * WORK2(i_)
                    Next i_
                    A(K + 1#, K + 1#) = A(K + 1#, K + 1#) - V
                End If
                KSTEP = 2#
            End If
            If Pivots(K) >= 0# Then
                KP = Pivots(K)
            Else
                KP = N + Pivots(K)
            End If
            If KP <> K Then
                
                '
                ' Interchange rows and columns K and KP in the leading
                ' submatrix
                '
                i1_ = (0#) - (1#)
                For i_ = 1# To KP Step 1
                    WORK(i_) = A(i_ + i1_, K)
                Next i_
                For i_ = 0# To KP - 1# Step 1
                    A(i_, K) = A(i_, KP)
                Next i_
                i1_ = (1#) - (0#)
                For i_ = 0# To KP - 1# Step 1
                    A(i_, KP) = WORK(i_ + i1_)
                Next i_
                i1_ = (KP + 1#) - (1#)
                For i_ = 1# To K - 1# - KP Step 1
                    WORK(i_) = A(i_ + i1_, K)
                Next i_
                For i_ = KP + 1# To K - 1# Step 1
                    A(i_, K) = A(KP, i_)
                Next i_
                i1_ = (1#) - (KP + 1#)
                For i_ = KP + 1# To K - 1# Step 1
                    A(KP, i_) = WORK(i_ + i1_)
                Next i_
                temp = A(K, K)
                A(K, K) = A(KP, KP)
                A(KP, KP) = temp
                If KSTEP = 2# Then
                    temp = A(K, K + 1#)
                    A(K, K + 1#) = A(KP, K + 1#)
                    A(KP, K + 1#) = temp
                End If
            End If
            K = K + KSTEP
        Loop
    Else
        
        '
        ' Compute inv(A) from the factorization A = L*D*L'.
        '
        ' K is the main loop index, increasing from 0 to N-1 in steps of
        ' 1 or 2, depending on the size of the diagonal blocks.
        '
        K = N - 1#
        Do While K >= 0#
            If Pivots(K) >= 0# Then
                
                '
                ' 1 x 1 diagonal block
                '
                ' Invert the diagonal block.
                '
                A(K, K) = 1# / A(K, K)
                
                '
                ' Compute column K+1 of the inverse.
                '
                If K < N - 1# Then
                    i1_ = (K + 1#) - (1#)
                    For i_ = 1# To N - K - 1# Step 1
                        WORK(i_) = A(i_ + i1_, K)
                    Next i_
                    Call SymmetricMatrixVectorMultiply(A, IsUpper, K + 1#, N - 1#, WORK, -1#, WORK2)
                    i1_ = (1#) - (K + 1#)
                    For i_ = K + 1# To N - 1# Step 1
                        A(i_, K) = WORK2(i_ + i1_)
                    Next i_
                    V = 0#
                    For i_ = 1# To N - K - 1# Step 1
                        V = V + WORK(i_) * WORK2(i_)
                    Next i_
                    A(K, K) = A(K, K) - V
                End If
                KSTEP = 1#
            Else
                
                '
                ' 2 x 2 diagonal block
                '
                ' Invert the diagonal block.
                '
                T = Abs(A(K, K - 1#))
                AK = A(K - 1#, K - 1#) / T
                AKP1 = A(K, K) / T
                AKKP1 = A(K, K - 1#) / T
                D = T * (AK * AKP1 - 1#)
                A(K - 1#, K - 1#) = AKP1 / D
                A(K, K) = AK / D
                A(K, K - 1#) = -(AKKP1 / D)
                
                '
                ' Compute columns K+1-1 and K+1 of the inverse.
                '
                If K < N - 1# Then
                    i1_ = (K + 1#) - (1#)
                    For i_ = 1# To N - K - 1# Step 1
                        WORK(i_) = A(i_ + i1_, K)
                    Next i_
                    Call SymmetricMatrixVectorMultiply(A, IsUpper, K + 1#, N - 1#, WORK, -1#, WORK2)
                    i1_ = (1#) - (K + 1#)
                    For i_ = K + 1# To N - 1# Step 1
                        A(i_, K) = WORK2(i_ + i1_)
                    Next i_
                    V = 0#
                    For i_ = 1# To N - K - 1# Step 1
                        V = V + WORK(i_) * WORK2(i_)
                    Next i_
                    A(K, K) = A(K, K) - V
                    V = 0#
                    For i_ = K + 1# To N - 1# Step 1
                        V = V + A(i_, K) * A(i_, K - 1#)
                    Next i_
                    A(K, K - 1#) = A(K, K - 1#) - V
                    i1_ = (K + 1#) - (1#)
                    For i_ = 1# To N - K - 1# Step 1
                        WORK(i_) = A(i_ + i1_, K - 1#)
                    Next i_
                    Call SymmetricMatrixVectorMultiply(A, IsUpper, K + 1#, N - 1#, WORK, -1#, WORK2)
                    i1_ = (1#) - (K + 1#)
                    For i_ = K + 1# To N - 1# Step 1
                        A(i_, K - 1#) = WORK2(i_ + i1_)
                    Next i_
                    V = 0#
                    For i_ = 1# To N - K - 1# Step 1
                        V = V + WORK(i_) * WORK2(i_)
                    Next i_
                    A(K - 1#, K - 1#) = A(K - 1#, K - 1#) - V
                End If
                KSTEP = 2#
            End If
            If Pivots(K) >= 0# Then
                KP = Pivots(K)
            Else
                KP = Pivots(K) + N
            End If
            If KP <> K Then
                
                '
                ' Interchange rows and columns K and KP
                '
                If KP < N - 1# Then
                    i1_ = (KP + 1#) - (1#)
                    For i_ = 1# To N - KP - 1# Step 1
                        WORK(i_) = A(i_ + i1_, K)
                    Next i_
                    For i_ = KP + 1# To N - 1# Step 1
                        A(i_, K) = A(i_, KP)
                    Next i_
                    i1_ = (1#) - (KP + 1#)
                    For i_ = KP + 1# To N - 1# Step 1
                        A(i_, KP) = WORK(i_ + i1_)
                    Next i_
                End If
                i1_ = (K + 1#) - (1#)
                For i_ = 1# To KP - K - 1# Step 1
                    WORK(i_) = A(i_ + i1_, K)
                Next i_
                For i_ = K + 1# To KP - 1# Step 1
                    A(i_, K) = A(KP, i_)
                Next i_
                i1_ = (1#) - (K + 1#)
                For i_ = K + 1# To KP - 1# Step 1
                    A(KP, i_) = WORK(i_ + i1_)
                Next i_
                temp = A(K, K)
                A(K, K) = A(KP, KP)
                A(KP, KP) = temp
                If KSTEP = 2# Then
                    temp = A(K, K - 1#)
                    A(K, K - 1#) = A(KP, K - 1#)
                    A(KP, K - 1#) = temp
                End If
            End If
            K = K - KSTEP
        Loop
    End If
    SMatrixLDLTInverse = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Inversion of a symmetric indefinite matrix
'
'Given a lower or upper triangle of matrix A, the algorithm generates
'matrix A^-1 and saves the lower or upper triangle depending on the input.
'
'Input parameters:
'    A       -   matrix to be inverted (upper or lower triangle).
'                Array with elements [0..N-1, 0..N-1].
'    N       -   size of matrix A.
'    IsUpper -   storage format. If IsUpper = True, then the upper
'                triangle of matrix A is given, otherwise the lower
'                triangle is given.
'
'Output parameters:
'    A       -   inverse of matrix A.
'                Array with elements [0..N-1, 0..N-1].
'                If IsUpper = True, then A contains the upper triangle of
'                matrix A^-1, and the elements below the main diagonal are
'                not used nor changed.
'                The same applies if IsUpper = False.
'
'Result:
'    True, if the matrix is not singular.
'    False, if the matrix is singular and could not be inverted.
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     March 31, 1993
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function SMatrixInverse(ByRef A() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean) As Boolean
    Dim Result As Boolean
    Dim Pivots() As Long
    Call SMatrixLDLT(A, N, IsUpper, Pivots)
    Result = SMatrixLDLTInverse(A, Pivots, N, IsUpper)
    SMatrixInverse = Result
End Function
Public Function InverseLDLT(ByRef A() As Double, _
         ByRef Pivots() As Long, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean) As Boolean
    Dim Result As Boolean
    Dim WORK() As Double
    Dim WORK2() As Double
    Dim i As Long
    Dim K As Long
    Dim KP As Long
    Dim KSTEP As Long
    Dim AK As Double
    Dim AKKP1 As Double
    Dim AKP1 As Double
    Dim D As Double
    Dim T As Double
    Dim temp As Double
    Dim KM1 As Long
    Dim KP1 As Long
    Dim L As Long
    Dim I1 As Long
    Dim I2 As Long
    Dim V As Double
    Dim i_ As Long
    Dim i1_ As Long
    ReDim WORK(1# To N)
    ReDim WORK2(1# To N)
    Result = True
    
    '
    ' Quick return if possible
    '
    If N = 0# Then
        InverseLDLT = Result
        Exit Function
    End If
    
    '
    ' Check that the diagonal matrix D is nonsingular.
    '
    For i = 1# To N Step 1
        If Pivots(i) > 0# And A(i, i) = 0# Then
            Result = False
            InverseLDLT = Result
            Exit Function
        End If
    Next i
    If IsUpper Then
        
        '
        ' Compute inv(A) from the factorization A = U*D*U'.
        '
        ' K is the main loop index, increasing from 1 to N in steps of
        ' 1 or 2, depending on the size of the diagonal blocks.
        '
        K = 1#
        Do While K <= N
            If Pivots(K) > 0# Then
                
                '
                ' 1 x 1 diagonal block
                '
                ' Invert the diagonal block.
                '
                A(K, K) = 1# / A(K, K)
                
                '
                ' Compute column K of the inverse.
                '
                If K > 1# Then
                    KM1 = K - 1#
                    For i_ = 1# To KM1 Step 1
                        WORK(i_) = A(i_, K)
                    Next i_
                    Call SymmetricMatrixVectorMultiply(A, IsUpper, 1#, K - 1#, WORK, -1#, WORK2)
                    For i_ = 1# To KM1 Step 1
                        A(i_, K) = WORK2(i_)
                    Next i_
                    V = 0#
                    For i_ = 1# To KM1 Step 1
                        V = V + WORK2(i_) * WORK(i_)
                    Next i_
                    A(K, K) = A(K, K) - V
                End If
                KSTEP = 1#
            Else
                
                '
                ' 2 x 2 diagonal block
                '
                ' Invert the diagonal block.
                '
                T = Abs(A(K, K + 1#))
                AK = A(K, K) / T
                AKP1 = A(K + 1#, K + 1#) / T
                AKKP1 = A(K, K + 1#) / T
                D = T * (AK * AKP1 - 1#)
                A(K, K) = AKP1 / D
                A(K + 1#, K + 1#) = AK / D
                A(K, K + 1#) = -(AKKP1 / D)
                
                '
                ' Compute columns K and K+1 of the inverse.
                '
                If K > 1# Then
                    KM1 = K - 1#
                    KP1 = K + 1#
                    For i_ = 1# To KM1 Step 1
                        WORK(i_) = A(i_, K)
                    Next i_
                    Call SymmetricMatrixVectorMultiply(A, IsUpper, 1#, K - 1#, WORK, -1#, WORK2)
                    For i_ = 1# To KM1 Step 1
                        A(i_, K) = WORK2(i_)
                    Next i_
                    V = 0#
                    For i_ = 1# To KM1 Step 1
                        V = V + WORK(i_) * WORK2(i_)
                    Next i_
                    A(K, K) = A(K, K) - V
                    V = 0#
                    For i_ = 1# To KM1 Step 1
                        V = V + A(i_, K) * A(i_, KP1)
                    Next i_
                    A(K, K + 1#) = A(K, K + 1#) - V
                    For i_ = 1# To KM1 Step 1
                        WORK(i_) = A(i_, KP1)
                    Next i_
                    Call SymmetricMatrixVectorMultiply(A, IsUpper, 1#, K - 1#, WORK, -1#, WORK2)
                    For i_ = 1# To KM1 Step 1
                        A(i_, KP1) = WORK2(i_)
                    Next i_
                    V = 0#
                    For i_ = 1# To KM1 Step 1
                        V = V + WORK(i_) * WORK2(i_)
                    Next i_
                    A(K + 1#, K + 1#) = A(K + 1#, K + 1#) - V
                End If
                KSTEP = 2#
            End If
            KP = Abs(Pivots(K))
            If KP <> K Then
                
                '
                ' Interchange rows and columns K and KP in the leading
                ' submatrix A(1:k+1,1:k+1)
                '
                L = KP - 1#
                For i_ = 1# To L Step 1
                    WORK(i_) = A(i_, K)
                Next i_
                For i_ = 1# To L Step 1
                    A(i_, K) = A(i_, KP)
                Next i_
                For i_ = 1# To L Step 1
                    A(i_, KP) = WORK(i_)
                Next i_
                L = K - KP - 1#
                I1 = KP + 1#
                I2 = K - 1#
                i1_ = (I1) - (1#)
                For i_ = 1# To L Step 1
                    WORK(i_) = A(i_ + i1_, K)
                Next i_
                For i_ = I1 To I2 Step 1
                    A(i_, K) = A(KP, i_)
                Next i_
                i1_ = (1#) - (I1)
                For i_ = I1 To I2 Step 1
                    A(KP, i_) = WORK(i_ + i1_)
                Next i_
                temp = A(K, K)
                A(K, K) = A(KP, KP)
                A(KP, KP) = temp
                If KSTEP = 2# Then
                    temp = A(K, K + 1#)
                    A(K, K + 1#) = A(KP, K + 1#)
                    A(KP, K + 1#) = temp
                End If
            End If
            K = K + KSTEP
        Loop
    Else
        
        '
        ' Compute inv(A) from the factorization A = L*D*L'.
        '
        ' K is the main loop index, increasing from 1 to N in steps of
        ' 1 or 2, depending on the size of the diagonal blocks.
        '
        K = N
        Do While K >= 1#
            If Pivots(K) > 0# Then
                
                '
                ' 1 x 1 diagonal block
                '
                ' Invert the diagonal block.
                '
                A(K, K) = 1# / A(K, K)
                
                '
                ' Compute column K of the inverse.
                '
                If K < N Then
                    KP1 = K + 1#
                    KM1 = K - 1#
                    L = N - K
                    i1_ = (KP1) - (1#)
                    For i_ = 1# To L Step 1
                        WORK(i_) = A(i_ + i1_, K)
                    Next i_
                    Call SymmetricMatrixVectorMultiply(A, IsUpper, K + 1#, N, WORK, -1#, WORK2)
                    i1_ = (1#) - (KP1)
                    For i_ = KP1 To N Step 1
                        A(i_, K) = WORK2(i_ + i1_)
                    Next i_
                    V = 0#
                    For i_ = 1# To L Step 1
                        V = V + WORK(i_) * WORK2(i_)
                    Next i_
                    A(K, K) = A(K, K) - V
                End If
                KSTEP = 1#
            Else
                
                '
                ' 2 x 2 diagonal block
                '
                ' Invert the diagonal block.
                '
                T = Abs(A(K, K - 1#))
                AK = A(K - 1#, K - 1#) / T
                AKP1 = A(K, K) / T
                AKKP1 = A(K, K - 1#) / T
                D = T * (AK * AKP1 - 1#)
                A(K - 1#, K - 1#) = AKP1 / D
                A(K, K) = AK / D
                A(K, K - 1#) = -(AKKP1 / D)
                
                '
                ' Compute columns K-1 and K of the inverse.
                '
                If K < N Then
                    KP1 = K + 1#
                    KM1 = K - 1#
                    L = N - K
                    i1_ = (KP1) - (1#)
                    For i_ = 1# To L Step 1
                        WORK(i_) = A(i_ + i1_, K)
                    Next i_
                    Call SymmetricMatrixVectorMultiply(A, IsUpper, K + 1#, N, WORK, -1#, WORK2)
                    i1_ = (1#) - (KP1)
                    For i_ = KP1 To N Step 1
                        A(i_, K) = WORK2(i_ + i1_)
                    Next i_
                    V = 0#
                    For i_ = 1# To L Step 1
                        V = V + WORK(i_) * WORK2(i_)
                    Next i_
                    A(K, K) = A(K, K) - V
                    V = 0#
                    For i_ = KP1 To N Step 1
                        V = V + A(i_, K) * A(i_, KM1)
                    Next i_
                    A(K, K - 1#) = A(K, K - 1#) - V
                    i1_ = (KP1) - (1#)
                    For i_ = 1# To L Step 1
                        WORK(i_) = A(i_ + i1_, KM1)
                    Next i_
                    Call SymmetricMatrixVectorMultiply(A, IsUpper, K + 1#, N, WORK, -1#, WORK2)
                    i1_ = (1#) - (KP1)
                    For i_ = KP1 To N Step 1
                        A(i_, KM1) = WORK2(i_ + i1_)
                    Next i_
                    V = 0#
                    For i_ = 1# To L Step 1
                        V = V + WORK(i_) * WORK2(i_)
                    Next i_
                    A(K - 1#, K - 1#) = A(K - 1#, K - 1#) - V
                End If
                KSTEP = 2#
            End If
            KP = Abs(Pivots(K))
            If KP <> K Then
                
                '
                ' Interchange rows and columns K and KP in the trailing
                ' submatrix A(k-1:n,k-1:n)
                '
                If KP < N Then
                    L = N - KP
                    KP1 = KP + 1#
                    i1_ = (KP1) - (1#)
                    For i_ = 1# To L Step 1
                        WORK(i_) = A(i_ + i1_, K)
                    Next i_
                    For i_ = KP1 To N Step 1
                        A(i_, K) = A(i_, KP)
                    Next i_
                    i1_ = (1#) - (KP1)
                    For i_ = KP1 To N Step 1
                        A(i_, KP) = WORK(i_ + i1_)
                    Next i_
                End If
                L = KP - K - 1#
                I1 = K + 1#
                I2 = KP - 1#
                i1_ = (I1) - (1#)
                For i_ = 1# To L Step 1
                    WORK(i_) = A(i_ + i1_, K)
                Next i_
                For i_ = I1 To I2 Step 1
                    A(i_, K) = A(KP, i_)
                Next i_
                i1_ = (1#) - (I1)
                For i_ = I1 To I2 Step 1
                    A(KP, i_) = WORK(i_ + i1_)
                Next i_
                temp = A(K, K)
                A(K, K) = A(KP, KP)
                A(KP, KP) = temp
                If KSTEP = 2# Then
                    temp = A(K, K - 1#)
                    A(K, K - 1#) = A(KP, K - 1#)
                    A(KP, K - 1#) = temp
                End If
            End If
            K = K - KSTEP
        Loop
    End If
    InverseLDLT = Result
End Function
Public Function InverseSymmetricIndefinite(ByRef A() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean) As Boolean
    Dim Result As Boolean
    Dim Pivots() As Long
    Call LDLTDecomposition(A, N, IsUpper, Pivots)
    Result = InverseLDLT(A, Pivots, N, IsUpper)
    InverseSymmetricIndefinite = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2005-2007, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Determinant calculation of the matrix given by LDLT decomposition.
'
'Input parameters:
'    A       -   LDLT-decomposition of the matrix,
'                output of subroutine SMatrixLDLT.
'    Pivots  -   table of permutations which were made during
'                LDLT decomposition, output of subroutine SMatrixLDLT.
'    N       -   size of matrix A.
'    IsUpper -   matrix storage format. The value is equal to the input
'                parameter of subroutine SMatrixLDLT.
'
'Result:
'    matrix determinant.
'
'  -- ALGLIB --
'     Copyright 2005-2008 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function SMatrixLDLTDet(ByRef A() As Double, _
         ByRef Pivots() As Long, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean) As Double
    Dim Result As Double
    Dim K As Long
    Result = 1#
    If IsUpper Then
        K = 0#
        Do While K < N
            If Pivots(K) >= 0# Then
                Result = Result * A(K, K)
                K = K + 1#
            Else
                Result = Result * (A(K, K) * A(K + 1#, K + 1#) - A(K, K + 1#) * A(K, K + 1#))
                K = K + 2#
            End If
        Loop
    Else
        K = N - 1#
        Do While K >= 0#
            If Pivots(K) >= 0# Then
                Result = Result * A(K, K)
                K = K - 1#
            Else
                Result = Result * (A(K - 1#, K - 1#) * A(K, K) - A(K, K - 1#) * A(K, K - 1#))
                K = K - 2#
            End If
        Loop
    End If
    SMatrixLDLTDet = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Determinant calculation of the symmetric matrix
'
'Input parameters:
'    A       -   matrix. Array with elements [0..N-1, 0..N-1].
'    N       -   size of matrix A.
'    IsUpper -   if IsUpper = True, then symmetric matrix A is given by its
'                upper triangle, and the lower triangle isnt used by
'                subroutine. Similarly, if IsUpper = False, then A is given
'                by its lower triangle.
'
'Result:
'    determinant of matrix A.
'
'  -- ALGLIB --
'     Copyright 2005-2008 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function SMatrixDet(ByRef A_() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean) As Double
    Dim Result As Double
    Dim A() As Double
    Dim Pivots() As Long
    A = A_
    Call SMatrixLDLT(A, N, IsUpper, Pivots)
    Result = SMatrixLDLTDet(A, Pivots, N, IsUpper)
    SMatrixDet = Result
End Function
Public Function DeterminantLDLT(ByRef A() As Double, _
         ByRef Pivots() As Long, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean) As Double
    Dim Result As Double
    Dim K As Long
    Result = 1#
    If IsUpper Then
        K = 1#
        Do While K <= N
            If Pivots(K) > 0# Then
                Result = Result * A(K, K)
                K = K + 1#
            Else
                Result = Result * (A(K, K) * A(K + 1#, K + 1#) - A(K, K + 1#) * A(K, K + 1#))
                K = K + 2#
            End If
        Loop
    Else
        K = N
        Do While K >= 1#
            If Pivots(K) > 0# Then
                Result = Result * A(K, K)
                K = K - 1#
            Else
                Result = Result * (A(K - 1#, K - 1#) * A(K, K) - A(K, K - 1#) * A(K, K - 1#))
                K = K - 2#
            End If
        Loop
    End If
    DeterminantLDLT = Result
End Function
Public Function DeterminantSymmetric(ByRef A_() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean) As Double
    Dim Result As Double
    Dim A() As Double
    Dim Pivots() As Long
    A = A_
    Call LDLTDecomposition(A, N, IsUpper, Pivots)
    Result = DeterminantLDLT(A, Pivots, N, IsUpper)
    DeterminantSymmetric = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 1992-2007 The University of Tennessee.  All rights reserved.
'
'Contributors:
'    * Sergey Bochkanov (ALGLIB project). Translation from FORTRAN to
'      pseudocode.
'
'See subroutines comments for additional copyrights.
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
Public Sub SymmetricMatrixVectorMultiply(ByRef A() As Double, _
         ByVal IsUpper As Boolean, _
         ByVal I1 As Long, _
         ByVal I2 As Long, _
         ByRef X() As Double, _
         ByVal Alpha As Double, _
         ByRef y() As Double)
    Dim i As Long
    Dim BA1 As Long
    Dim BA2 As Long
    Dim BY1 As Long
    Dim BY2 As Long
    Dim BX1 As Long
    Dim BX2 As Long
    Dim N As Long
    Dim V As Double
    Dim i_ As Long
    Dim i1_ As Long
    N = I2 - I1 + 1#
    If N <= 0# Then
        Exit Sub
    End If
    '
    ' Let A = L + D + U, where
    '  L is strictly lower triangular (main diagonal is zero)
    '  D is diagonal
    '  U is strictly upper triangular (main diagonal is zero)
    '
    ' A*x = L*x + D*x + U*x
    '
    ' Calculate D*x first
    '
    For i = I1 To I2 Step 1
        y(i - I1 + 1#) = A(i, i) * X(i - I1 + 1#)
    Next i
    '
    ' Add L*x + U*x
    '
    If IsUpper Then
        For i = I1 To I2 - 1# Step 1
            '
            ' Add L*x to the result
            '
            V = X(i - I1 + 1#)
            BY1 = i - I1 + 2#
            BY2 = N
            BA1 = i + 1#
            BA2 = I2
            i1_ = (BA1) - (BY1)
            For i_ = BY1 To BY2 Step 1
                y(i_) = y(i_) + V * A(i, i_ + i1_)
            Next i_
            '
            ' Add U*x to the result
            '
            BX1 = i - I1 + 2#
            BX2 = N
            BA1 = i + 1#
            BA2 = I2
            i1_ = (BA1) - (BX1)
            V = 0#
            For i_ = BX1 To BX2 Step 1
                V = V + X(i_) * A(i, i_ + i1_)
            Next i_
            y(i - I1 + 1#) = y(i - I1 + 1#) + V
        Next i
    Else
        For i = I1 + 1# To I2 Step 1
            '
            ' Add L*x to the result
            '
            BX1 = 1#
            BX2 = i - I1
            BA1 = I1
            BA2 = i - 1#
            i1_ = (BA1) - (BX1)
            V = 0#
            For i_ = BX1 To BX2 Step 1
                V = V + X(i_) * A(i, i_ + i1_)
            Next i_
            y(i - I1 + 1#) = y(i - I1 + 1#) + V
            '
            ' Add U*x to the result
            '
            V = X(i - I1 + 1#)
            BY1 = 1#
            BY2 = i - I1
            BA1 = I1
            BA2 = i - 1#
            i1_ = (BA1) - (BY1)
            For i_ = BY1 To BY2 Step 1
                y(i_) = y(i_) + V * A(i, i_ + i1_)
            Next i_
        Next i
    End If
    For i_ = 1# To N Step 1
        y(i_) = Alpha * y(i_)
    Next i_
End Sub
Public Sub SymmetricRank2Update(ByRef A() As Double, _
         ByVal IsUpper As Boolean, _
         ByVal I1 As Long, _
         ByVal I2 As Long, _
         ByRef X() As Double, _
         ByRef y() As Double, _
         ByRef T() As Double, _
         ByVal Alpha As Double)
    Dim i As Long
    Dim TP1 As Long
    Dim TP2 As Long
    Dim V As Double
    Dim i_ As Long
    Dim i1_ As Long
    If IsUpper Then
        For i = I1 To I2 Step 1
            TP1 = i + 1# - I1
            TP2 = I2 - I1 + 1#
            V = X(i + 1# - I1)
            For i_ = TP1 To TP2 Step 1
                T(i_) = V * y(i_)
            Next i_
            V = y(i + 1# - I1)
            For i_ = TP1 To TP2 Step 1
                T(i_) = T(i_) + V * X(i_)
            Next i_
            For i_ = TP1 To TP2 Step 1
                T(i_) = Alpha * T(i_)
            Next i_
            i1_ = (TP1) - (i)
            For i_ = i To I2 Step 1
                A(i, i_) = A(i, i_) + T(i_ + i1_)
            Next i_
        Next i
    Else
        For i = I1 To I2 Step 1
            TP1 = 1#
            TP2 = i + 1# - I1
            V = X(i + 1# - I1)
            For i_ = TP1 To TP2 Step 1
                T(i_) = V * y(i_)
            Next i_
            V = y(i + 1# - I1)
            For i_ = TP1 To TP2 Step 1
                T(i_) = T(i_) + V * X(i_)
            Next i_
            For i_ = TP1 To TP2 Step 1
                T(i_) = Alpha * T(i_)
            Next i_
            i1_ = (TP1) - (I1)
            For i_ = I1 To i Step 1
                A(i, i_) = A(i, i_) + T(i_ + i1_)
            Next i_
        Next i
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This file is a part of ALGLIB project.
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Real implementation of CMatrixScaledTRSafeSolve
'
'  -- ALGLIB routine --
'     21.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function RMatrixScaledTRSafeSolve(ByRef A() As Double, _
         ByVal SA As Double, _
         ByVal N As Long, _
         ByRef X() As Double, _
         ByVal IsUpper As Boolean, _
         ByVal Trans As Long, _
         ByVal Isunit As Boolean, _
         ByVal MaxGrowth As Double) As Boolean
    Dim Result As Boolean
    Dim LnMax As Double
    Dim NrmB As Double
    Dim NrmX As Double
    Dim i As Long
    Dim Alpha As Complex
    Dim Beta As Complex
    Dim VR As Double
    Dim CX As Complex
    Dim Tmp() As Double
    Dim i_ As Long
    Result = True
    LnMax = log(MaxRealNumber)
    '
    ' Quick return if possible
    '
    If N <= 0# Then
        RMatrixScaledTRSafeSolve = Result
        Exit Function
    End If
    '
    ' Load norms: right part and X
    '
    NrmB = 0#
    For i = 0# To N - 1# Step 1
        NrmB = MaxReal(NrmB, Abs(X(i)))
    Next i
    NrmX = 0#
    '
    ' Solve
    '
    ReDim Tmp(0 To N - 1)
    Result = True
    If IsUpper And Trans = 0# Then
        '
        ' U*x = b
        '
        For i = N - 1# To 0# Step -1
            '
            ' Task is reduced to alpha*x[i] = beta
            '
            If Isunit Then
                Alpha = C_Complex(SA)
            Else
                Alpha = C_Complex(A(i, i) * SA)
            End If
            If i < N - 1# Then
                For i_ = i + 1# To N - 1# Step 1
                    Tmp(i_) = SA * A(i, i_)
                Next i_
                VR = 0#
                For i_ = i + 1# To N - 1# Step 1
                    VR = VR + Tmp(i_) * X(i_)
                Next i_
                Beta = C_Complex(X(i) - VR)
            Else
                Beta = C_Complex(X(i))
            End If
            '
            ' solve alpha*x[i] = beta
            '
            Result = CBasicSolveAndUpdate(Alpha, Beta, LnMax, NrmB, MaxGrowth, NrmX, CX)
            If Not Result Then
                RMatrixScaledTRSafeSolve = Result
                Exit Function
            End If
            X(i) = CX.X
        Next i
        RMatrixScaledTRSafeSolve = Result
        Exit Function
    End If
    If Not IsUpper And Trans = 0# Then
        '
        ' L*x = b
        '
        For i = 0# To N - 1# Step 1
            '
            ' Task is reduced to alpha*x[i] = beta
            '
            If Isunit Then
                Alpha = C_Complex(SA)
            Else
                Alpha = C_Complex(A(i, i) * SA)
            End If
            If i > 0# Then
                For i_ = 0# To i - 1# Step 1
                    Tmp(i_) = SA * A(i, i_)
                Next i_
                VR = 0#
                For i_ = 0# To i - 1# Step 1
                    VR = VR + Tmp(i_) * X(i_)
                Next i_
                Beta = C_Complex(X(i) - VR)
            Else
                Beta = C_Complex(X(i))
            End If
            '
            ' solve alpha*x[i] = beta
            '
            Result = CBasicSolveAndUpdate(Alpha, Beta, LnMax, NrmB, MaxGrowth, NrmX, CX)
            If Not Result Then
                RMatrixScaledTRSafeSolve = Result
                Exit Function
            End If
            X(i) = CX.X
        Next i
        RMatrixScaledTRSafeSolve = Result
        Exit Function
    End If
    If IsUpper And Trans = 1# Then
        '
        ' U^T*x = b
        '
        For i = 0# To N - 1# Step 1
            '
            ' Task is reduced to alpha*x[i] = beta
            '
            If Isunit Then
                Alpha = C_Complex(SA)
            Else
                Alpha = C_Complex(A(i, i) * SA)
            End If
            Beta = C_Complex(X(i))
            '
            ' solve alpha*x[i] = beta
            '
            Result = CBasicSolveAndUpdate(Alpha, Beta, LnMax, NrmB, MaxGrowth, NrmX, CX)
            If Not Result Then
                RMatrixScaledTRSafeSolve = Result
                Exit Function
            End If
            X(i) = CX.X
            '
            ' update the rest of right part
            '
            If i < N - 1# Then
                VR = CX.X
                For i_ = i + 1# To N - 1# Step 1
                    Tmp(i_) = SA * A(i, i_)
                Next i_
                For i_ = i + 1# To N - 1# Step 1
                    X(i_) = X(i_) - VR * Tmp(i_)
                Next i_
            End If
        Next i
        RMatrixScaledTRSafeSolve = Result
        Exit Function
    End If
    If Not IsUpper And Trans = 1# Then
        '
        ' L^T*x = b
        '
        For i = N - 1# To 0# Step -1
            '
            ' Task is reduced to alpha*x[i] = beta
            '
            If Isunit Then
                Alpha = C_Complex(SA)
            Else
                Alpha = C_Complex(A(i, i) * SA)
            End If
            Beta = C_Complex(X(i))
            '
            ' solve alpha*x[i] = beta
            '
            Result = CBasicSolveAndUpdate(Alpha, Beta, LnMax, NrmB, MaxGrowth, NrmX, CX)
            If Not Result Then
                RMatrixScaledTRSafeSolve = Result
                Exit Function
            End If
            X(i) = CX.X
            '
            ' update the rest of right part
            '
            If i > 0# Then
                VR = CX.X
                For i_ = 0# To i - 1# Step 1
                    Tmp(i_) = SA * A(i, i_)
                Next i_
                For i_ = 0# To i - 1# Step 1
                    X(i_) = X(i_) - VR * Tmp(i_)
                Next i_
            End If
        Next i
        RMatrixScaledTRSafeSolve = Result
        Exit Function
    End If
    Result = False
    RMatrixScaledTRSafeSolve = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal subroutine for safe solution of
'
'    SA*op(A)=b
'
'where  A  is  NxN  upper/lower  triangular/unitriangular  matrix, op(A) is
'either identity transform, transposition or Hermitian transposition, SA is
'a scaling factor such that max(|SA*A[i,j]|) is close to 1.0 in magnutude.
'
'This subroutine  limits  relative  growth  of  solution  (in inf-norm)  by
'MaxGrowth,  returning  False  if  growth  exceeds MaxGrowth. Degenerate or
'near-degenerate matrices are handled correctly (False is returned) as long
'as MaxGrowth is significantly less than MaxRealNumber/norm(b).
'
'  -- ALGLIB routine --
'     21.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function CMatrixScaledTRSafeSolve(ByRef A() As Complex, _
         ByVal SA As Double, _
         ByVal N As Long, _
         ByRef X() As Complex, _
         ByVal IsUpper As Boolean, _
         ByVal Trans As Long, _
         ByVal Isunit As Boolean, _
         ByVal MaxGrowth As Double) As Boolean
    Dim Result As Boolean
    Dim LnMax As Double
    Dim NrmB As Double
    Dim NrmX As Double
    Dim i As Long
    Dim Alpha As Complex
    Dim Beta As Complex
    Dim VC As Complex
    Dim Tmp() As Complex
    Dim i_ As Long
    Result = True
    LnMax = log(MaxRealNumber)
    '
    ' Quick return if possible
    '
    If N <= 0# Then
        CMatrixScaledTRSafeSolve = Result
        Exit Function
    End If
    '
    ' Load norms: right part and X
    '
    NrmB = 0#
    For i = 0# To N - 1# Step 1
        NrmB = MaxReal(NrmB, AbsComplex(X(i)))
    Next i
    NrmX = 0#
    '
    ' Solve
    '
    ReDim Tmp(0 To N - 1)
    Result = True
    If IsUpper And Trans = 0# Then
        '
        ' U*x = b
        '
        For i = N - 1# To 0# Step -1
            '
            ' Task is reduced to alpha*x[i] = beta
            '
            If Isunit Then
                Alpha = C_Complex(SA)
            Else
                Alpha = C_MulR(A(i, i), SA)
            End If
            If i < N - 1# Then
                For i_ = i + 1# To N - 1# Step 1
                    Tmp(i_) = C_MulR(A(i, i_), SA)
                Next i_
                VC = C_Complex(0#)
                For i_ = i + 1# To N - 1# Step 1
                    VC = C_Add(VC, C_Mul(Tmp(i_), X(i_)))
                Next i_
                Beta = C_Sub(X(i), VC)
            Else
                Beta = X(i)
            End If
            '
            ' solve alpha*x[i] = beta
            '
            Result = CBasicSolveAndUpdate(Alpha, Beta, LnMax, NrmB, MaxGrowth, NrmX, VC)
            If Not Result Then
                CMatrixScaledTRSafeSolve = Result
                Exit Function
            End If
            X(i) = VC
        Next i
        CMatrixScaledTRSafeSolve = Result
        Exit Function
    End If
    If Not IsUpper And Trans = 0# Then
        '
        ' L*x = b
        '
        For i = 0# To N - 1# Step 1
            '
            ' Task is reduced to alpha*x[i] = beta
            '
            If Isunit Then
                Alpha = C_Complex(SA)
            Else
                Alpha = C_MulR(A(i, i), SA)
            End If
            If i > 0# Then
                For i_ = 0# To i - 1# Step 1
                    Tmp(i_) = C_MulR(A(i, i_), SA)
                Next i_
                VC = C_Complex(0#)
                For i_ = 0# To i - 1# Step 1
                    VC = C_Add(VC, C_Mul(Tmp(i_), X(i_)))
                Next i_
                Beta = C_Sub(X(i), VC)
            Else
                Beta = X(i)
            End If
            '
            ' solve alpha*x[i] = beta
            '
            Result = CBasicSolveAndUpdate(Alpha, Beta, LnMax, NrmB, MaxGrowth, NrmX, VC)
            If Not Result Then
                CMatrixScaledTRSafeSolve = Result
                Exit Function
            End If
            X(i) = VC
        Next i
        CMatrixScaledTRSafeSolve = Result
        Exit Function
    End If
    If IsUpper And Trans = 1# Then
        '
        ' U^T*x = b
        '
        For i = 0# To N - 1# Step 1
            '
            ' Task is reduced to alpha*x[i] = beta
            '
            If Isunit Then
                Alpha = C_Complex(SA)
            Else
                Alpha = C_MulR(A(i, i), SA)
            End If
            Beta = X(i)
            '
            ' solve alpha*x[i] = beta
            '
            Result = CBasicSolveAndUpdate(Alpha, Beta, LnMax, NrmB, MaxGrowth, NrmX, VC)
            If Not Result Then
                CMatrixScaledTRSafeSolve = Result
                Exit Function
            End If
            X(i) = VC
            '
            ' update the rest of right part
            '
            If i < N - 1# Then
                For i_ = i + 1# To N - 1# Step 1
                    Tmp(i_) = C_MulR(A(i, i_), SA)
                Next i_
                For i_ = i + 1# To N - 1# Step 1
                    X(i_) = C_Sub(X(i_), C_Mul(VC, Tmp(i_)))
                Next i_
            End If
        Next i
        CMatrixScaledTRSafeSolve = Result
        Exit Function
    End If
    If Not IsUpper And Trans = 1# Then
        '
        ' L^T*x = b
        '
        For i = N - 1# To 0# Step -1
            '
            ' Task is reduced to alpha*x[i] = beta
            '
            If Isunit Then
                Alpha = C_Complex(SA)
            Else
                Alpha = C_MulR(A(i, i), SA)
            End If
            Beta = X(i)
            '
            ' solve alpha*x[i] = beta
            '
            Result = CBasicSolveAndUpdate(Alpha, Beta, LnMax, NrmB, MaxGrowth, NrmX, VC)
            If Not Result Then
                CMatrixScaledTRSafeSolve = Result
                Exit Function
            End If
            X(i) = VC
            '
            ' update the rest of right part
            '
            If i > 0# Then
                For i_ = 0# To i - 1# Step 1
                    Tmp(i_) = C_MulR(A(i, i_), SA)
                Next i_
                For i_ = 0# To i - 1# Step 1
                    X(i_) = C_Sub(X(i_), C_Mul(VC, Tmp(i_)))
                Next i_
            End If
        Next i
        CMatrixScaledTRSafeSolve = Result
        Exit Function
    End If
    If IsUpper And Trans = 2# Then
        '
        ' U^H*x = b
        '
        For i = 0# To N - 1# Step 1
            '
            ' Task is reduced to alpha*x[i] = beta
            '
            If Isunit Then
                Alpha = C_Complex(SA)
            Else
                Alpha = C_MulR(Conj(A(i, i)), SA)
            End If
            Beta = X(i)
            '
            ' solve alpha*x[i] = beta
            '
            Result = CBasicSolveAndUpdate(Alpha, Beta, LnMax, NrmB, MaxGrowth, NrmX, VC)
            If Not Result Then
                CMatrixScaledTRSafeSolve = Result
                Exit Function
            End If
            X(i) = VC
            '
            ' update the rest of right part
            '
            If i < N - 1# Then
                For i_ = i + 1# To N - 1# Step 1
                    Tmp(i_) = C_MulR(Conj(A(i, i_)), SA)
                Next i_
                For i_ = i + 1# To N - 1# Step 1
                    X(i_) = C_Sub(X(i_), C_Mul(VC, Tmp(i_)))
                Next i_
            End If
        Next i
        CMatrixScaledTRSafeSolve = Result
        Exit Function
    End If
    If Not IsUpper And Trans = 2# Then
        '
        ' L^T*x = b
        '
        For i = N - 1# To 0# Step -1
            '
            ' Task is reduced to alpha*x[i] = beta
            '
            If Isunit Then
                Alpha = C_Complex(SA)
            Else
                Alpha = C_MulR(Conj(A(i, i)), SA)
            End If
            Beta = X(i)
            '
            ' solve alpha*x[i] = beta
            '
            Result = CBasicSolveAndUpdate(Alpha, Beta, LnMax, NrmB, MaxGrowth, NrmX, VC)
            If Not Result Then
                CMatrixScaledTRSafeSolve = Result
                Exit Function
            End If
            X(i) = VC
            '
            ' update the rest of right part
            '
            If i > 0# Then
                For i_ = 0# To i - 1# Step 1
                    Tmp(i_) = C_MulR(Conj(A(i, i_)), SA)
                Next i_
                For i_ = 0# To i - 1# Step 1
                    X(i_) = C_Sub(X(i_), C_Mul(VC, Tmp(i_)))
                Next i_
            End If
        Next i
        CMatrixScaledTRSafeSolve = Result
        Exit Function
    End If
    Result = False
    CMatrixScaledTRSafeSolve = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'complex basic solver-updater for reduced linear system
'
'    alpha*x[i] = beta
'
'solves this equation and updates it in overlfow-safe manner (keeping track
'of relative growth of solution).
'
'Parameters:
'    Alpha   -   alpha
'    Beta    -   beta
'    LnMax   -   precomputed Ln(MaxRealNumber)
'    BNorm   -   inf-norm of b (right part of original system)
'    MaxGrowth-  maximum growth of norm(x) relative to norm(b)
'    XNorm   -   inf-norm of other components of X (which are already processed)
'                it is updated by CBasicSolveAndUpdate.
'    X       -   solution
'
'  -- ALGLIB routine --
'     26.01.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Function CBasicSolveAndUpdate(ByRef Alpha_ As Complex, _
         ByRef Beta_ As Complex, _
         ByVal LnMax As Double, _
         ByVal BNorm As Double, _
         ByVal MaxGrowth As Double, _
         ByRef XNorm As Double, _
         ByRef X As Complex) As Boolean
    Dim Result As Boolean
    Dim Alpha As Complex
    Dim Beta As Complex
    Dim V As Double
    Alpha = Alpha_
    Beta = Beta_
    Result = False
    If C_EqualR(Alpha, 0#) Then
        CBasicSolveAndUpdate = Result
        Exit Function
    End If
    If C_NotEqualR(Beta, 0#) Then
        '
        ' alpha*x[i]=beta
        '
        V = log(AbsComplex(Beta)) - log(AbsComplex(Alpha))
        If V > LnMax Then
            CBasicSolveAndUpdate = Result
            Exit Function
        End If
        X = C_Div(Beta, Alpha)
    Else
        '
        ' alpha*x[i]=0
        '
        X = C_Complex(0#)
    End If
    '
    ' update NrmX, test growth limit
    '
    XNorm = MaxReal(XNorm, AbsComplex(X))
    If XNorm > MaxGrowth * BNorm Then
        CBasicSolveAndUpdate = Result
        Exit Function
    End If
    Result = True
    CBasicSolveAndUpdate = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 1992-2007 The University of Tennessee.  All rights reserved.
'
'Contributors:
'    * Sergey Bochkanov (ALGLIB project). Translation from FORTRAN to
'      pseudocode.
'
'See subroutines comments for additional copyrights.
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Estimate of a matrix condition number (1-norm)
'
'The algorithm calculates a lower bound of the condition number. In this case,
'the algorithm does not return a lower bound of the condition number, but an
'inverse number (to avoid an overflow in case of a singular matrix).
'
'Input parameters:
'    A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
'    N   -   size of matrix A.
'
'Result: 1/LowerBound(cond(A))
'
'NOTE:
'    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
'    0.0 is returned in such cases.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function RMatrixRCond1(ByRef A_() As Double, ByVal N As Long) As Double
    Dim Result As Double
    Dim A() As Double
    Dim i As Long
    Dim j As Long
    Dim V As Double
    Dim Nrm As Double
    Dim Pivots() As Long
    Dim T() As Double
    A = A_
    ReDim T(0 To N - 1)
    For i = 0# To N - 1# Step 1
        T(i) = 0#
    Next i
    For i = 0# To N - 1# Step 1
        For j = 0# To N - 1# Step 1
            T(j) = T(j) + Abs(A(i, j))
        Next j
    Next i
    Nrm = 0#
    For i = 0# To N - 1# Step 1
        Nrm = MaxReal(Nrm, T(i))
    Next i
    Call RMatrixLU(A, N, N, Pivots)
    Call RMatrixRCondLUInternal(A, N, True, True, Nrm, V)
    Result = V
    RMatrixRCond1 = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Estimate of a matrix condition number (infinity-norm).
'
'The algorithm calculates a lower bound of the condition number. In this case,
'the algorithm does not return a lower bound of the condition number, but an
'inverse number (to avoid an overflow in case of a singular matrix).
'
'Input parameters:
'    A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
'    N   -   size of matrix A.
'
'Result: 1/LowerBound(cond(A))
'
'NOTE:
'    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
'    0.0 is returned in such cases.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function RMatrixRCondInf(ByRef A_() As Double, _
         ByVal N As Long) As Double
    Dim Result As Double
    Dim A() As Double
    Dim i As Long
    Dim j As Long
    Dim V As Double
    Dim Nrm As Double
    Dim Pivots() As Long
    A = A_
    Nrm = 0#
    For i = 0# To N - 1# Step 1
        V = 0#
        For j = 0# To N - 1# Step 1
            V = V + Abs(A(i, j))
        Next j
        Nrm = MaxReal(Nrm, V)
    Next i
    Call RMatrixLU(A, N, N, Pivots)
    Call RMatrixRCondLUInternal(A, N, False, True, Nrm, V)
    Result = V
    RMatrixRCondInf = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Condition number estimate of a symmetric positive definite matrix.
'
'The algorithm calculates a lower bound of the condition number. In this case,
'the algorithm does not return a lower bound of the condition number, but an
'inverse number (to avoid an overflow in case of a singular matrix).
'
'It should be noted that 1-norm and inf-norm of condition numbers of symmetric
'matrices are equal, so the algorithm doesn't take into account the
'differences between these types of norms.
'
'Input parameters:
'    A       -   symmetric positive definite matrix which is given by its
'                upper or lower triangle depending on the value of
'                IsUpper. Array with elements [0..N-1, 0..N-1].
'    N       -   size of matrix A.
'    IsUpper -   storage format.
'
'Result:
'    1/LowerBound(cond(A)), if matrix A is positive definite,
'   -1, if matrix A is not positive definite, and its condition number
'    could not be found by this algorithm.
'
'NOTE:
'    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
'    0.0 is returned in such cases.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function SPDMatrixRCond(ByRef A_() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean) As Double
    Dim Result As Double
    Dim A() As Double
    Dim i As Long
    Dim j As Long
    Dim J1 As Long
    Dim J2 As Long
    Dim V As Double
    Dim Nrm As Double
    Dim T() As Double
    A = A_
    ReDim T(0 To N - 1)
    For i = 0# To N - 1# Step 1
        T(i) = 0#
    Next i
    For i = 0# To N - 1# Step 1
        If IsUpper Then
            J1 = i
            J2 = N - 1#
        Else
            J1 = 0#
            J2 = i
        End If
        For j = J1 To J2 Step 1
            If i = j Then
                T(i) = T(i) + Abs(A(i, i))
            Else
                T(i) = T(i) + Abs(A(i, j))
                T(j) = T(j) + Abs(A(i, j))
            End If
        Next j
    Next i
    Nrm = 0#
    For i = 0# To N - 1# Step 1
        Nrm = MaxReal(Nrm, T(i))
    Next i
    If SPDMatrixCholesky(A, N, IsUpper) Then
        Call SPDMatrixRCondCholeskyInternal(A, N, IsUpper, True, Nrm, V)
        Result = V
    Else
        Result = -1#
    End If
    SPDMatrixRCond = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Triangular matrix: estimate of a condition number (1-norm)
'
'The algorithm calculates a lower bound of the condition number. In this case,
'the algorithm does not return a lower bound of the condition number, but an
'inverse number (to avoid an overflow in case of a singular matrix).
'
'Input parameters:
'    A       -   matrix. Array[0..N-1, 0..N-1].
'    N       -   size of A.
'    IsUpper -   True, if the matrix is upper triangular.
'    IsUnit  -   True, if the matrix has a unit diagonal.
'
'Result: 1/LowerBound(cond(A))
'
'NOTE:
'    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
'    0.0 is returned in such cases.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function RMatrixTRRCond1(ByRef A() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByVal Isunit As Boolean) As Double
    Dim Result As Double
    Dim i As Long
    Dim j As Long
    Dim V As Double
    Dim Nrm As Double
    Dim Pivots() As Long
    Dim T() As Double
    Dim J1 As Long
    Dim J2 As Long
    ReDim T(0 To N - 1)
    For i = 0# To N - 1# Step 1
        T(i) = 0#
    Next i
    For i = 0# To N - 1# Step 1
        If IsUpper Then
            J1 = i + 1#
            J2 = N - 1#
        Else
            J1 = 0#
            J2 = i - 1#
        End If
        For j = J1 To J2 Step 1
            T(j) = T(j) + Abs(A(i, j))
        Next j
        If Isunit Then
            T(i) = T(i) + 1#
        Else
            T(i) = T(i) + Abs(A(i, i))
        End If
    Next i
    Nrm = 0#
    For i = 0# To N - 1# Step 1
        Nrm = MaxReal(Nrm, T(i))
    Next i
    Call RMatrixRCondTRInternal(A, N, IsUpper, Isunit, True, Nrm, V)
    Result = V
    RMatrixTRRCond1 = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Triangular matrix: estimate of a matrix condition number (infinity-norm).
'
'The algorithm calculates a lower bound of the condition number. In this case,
'the algorithm does not return a lower bound of the condition number, but an
'inverse number (to avoid an overflow in case of a singular matrix).
'
'Input parameters:
'    A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
'    N   -   size of matrix A.
'    IsUpper -   True, if the matrix is upper triangular.
'    IsUnit  -   True, if the matrix has a unit diagonal.
'
'Result: 1/LowerBound(cond(A))
'
'NOTE:
'    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
'    0.0 is returned in such cases.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function RMatrixTRRCondInf(ByRef A() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByVal Isunit As Boolean) As Double
    Dim Result As Double
    Dim i As Long
    Dim j As Long
    Dim V As Double
    Dim Nrm As Double
    Dim Pivots() As Long
    Dim J1 As Long
    Dim J2 As Long
    Nrm = 0#
    For i = 0# To N - 1# Step 1
        If IsUpper Then
            J1 = i + 1#
            J2 = N - 1#
        Else
            J1 = 0#
            J2 = i - 1#
        End If
        V = 0#
        For j = J1 To J2 Step 1
            V = V + Abs(A(i, j))
        Next j
        If Isunit Then
            V = V + 1#
        Else
            V = V + Abs(A(i, i))
        End If
        Nrm = MaxReal(Nrm, V)
    Next i
    Call RMatrixRCondTRInternal(A, N, IsUpper, Isunit, False, Nrm, V)
    Result = V
    RMatrixTRRCondInf = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Condition number estimate of a Hermitian positive definite matrix.
'
'The algorithm calculates a lower bound of the condition number. In this case,
'the algorithm does not return a lower bound of the condition number, but an
'inverse number (to avoid an overflow in case of a singular matrix).
'
'It should be noted that 1-norm and inf-norm of condition numbers of symmetric
'matrices are equal, so the algorithm doesn't take into account the
'differences between these types of norms.
'
'Input parameters:
'    A       -   Hermitian positive definite matrix which is given by its
'                upper or lower triangle depending on the value of
'                IsUpper. Array with elements [0..N-1, 0..N-1].
'    N       -   size of matrix A.
'    IsUpper -   storage format.
'
'Result:
'    1/LowerBound(cond(A)), if matrix A is positive definite,
'   -1, if matrix A is not positive definite, and its condition number
'    could not be found by this algorithm.
'
'NOTE:
'    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
'    0.0 is returned in such cases.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function HPDMatrixRCond(ByRef A_() As Complex, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean) As Double
    Dim Result As Double
    Dim A() As Complex
    Dim i As Long
    Dim j As Long
    Dim J1 As Long
    Dim J2 As Long
    Dim V As Double
    Dim Nrm As Double
    Dim T() As Double
    A = A_
    ReDim T(0 To N - 1)
    For i = 0# To N - 1# Step 1
        T(i) = 0#
    Next i
    For i = 0# To N - 1# Step 1
        If IsUpper Then
            J1 = i
            J2 = N - 1#
        Else
            J1 = 0#
            J2 = i
        End If
        For j = J1 To J2 Step 1
            If i = j Then
                T(i) = T(i) + AbsComplex(A(i, i))
            Else
                T(i) = T(i) + AbsComplex(A(i, j))
                T(j) = T(j) + AbsComplex(A(i, j))
            End If
        Next j
    Next i
    Nrm = 0#
    For i = 0# To N - 1# Step 1
        Nrm = MaxReal(Nrm, T(i))
    Next i
    If HPDMatrixCholesky(A, N, IsUpper) Then
        Call HPDMatrixRCondCholeskyInternal(A, N, IsUpper, True, Nrm, V)
        Result = V
    Else
        Result = -1#
    End If
    HPDMatrixRCond = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Estimate of a matrix condition number (1-norm)
'
'The algorithm calculates a lower bound of the condition number. In this case,
'the algorithm does not return a lower bound of the condition number, but an
'inverse number (to avoid an overflow in case of a singular matrix).
'
'Input parameters:
'    A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
'    N   -   size of matrix A.
'
'Result: 1/LowerBound(cond(A))
'
'NOTE:
'    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
'    0.0 is returned in such cases.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function CMatrixRCond1(ByRef A_() As Complex, ByVal N As Long) As Double
    Dim Result As Double
    Dim A() As Complex
    Dim i As Long
    Dim j As Long
    Dim V As Double
    Dim Nrm As Double
    Dim Pivots() As Long
    Dim T() As Double
    A = A_
    ReDim T(0 To N - 1)
    For i = 0# To N - 1# Step 1
        T(i) = 0#
    Next i
    For i = 0# To N - 1# Step 1
        For j = 0# To N - 1# Step 1
            T(j) = T(j) + AbsComplex(A(i, j))
        Next j
    Next i
    Nrm = 0#
    For i = 0# To N - 1# Step 1
        Nrm = MaxReal(Nrm, T(i))
    Next i
    Call CMatrixLU(A, N, N, Pivots)
    Call CMatrixRCondLUInternal(A, N, True, True, Nrm, V)
    Result = V
    CMatrixRCond1 = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Estimate of a matrix condition number (infinity-norm).
'
'The algorithm calculates a lower bound of the condition number. In this case,
'the algorithm does not return a lower bound of the condition number, but an
'inverse number (to avoid an overflow in case of a singular matrix).
'
'Input parameters:
'    A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
'    N   -   size of matrix A.
'
'Result: 1/LowerBound(cond(A))
'
'NOTE:
'    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
'    0.0 is returned in such cases.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function CMatrixRCondInf(ByRef A_() As Complex, _
         ByVal N As Long) As Double
    Dim Result As Double
    Dim A() As Complex
    Dim i As Long
    Dim j As Long
    Dim V As Double
    Dim Nrm As Double
    Dim Pivots() As Long
    A = A_
    Nrm = 0#
    For i = 0# To N - 1# Step 1
        V = 0#
        For j = 0# To N - 1# Step 1
            V = V + AbsComplex(A(i, j))
        Next j
        Nrm = MaxReal(Nrm, V)
    Next i
    Call CMatrixLU(A, N, N, Pivots)
    Call CMatrixRCondLUInternal(A, N, False, True, Nrm, V)
    Result = V
    CMatrixRCondInf = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Estimate of the condition number of a matrix given by its LU decomposition (1-norm)
'
'The algorithm calculates a lower bound of the condition number. In this case,
'the algorithm does not return a lower bound of the condition number, but an
'inverse number (to avoid an overflow in case of a singular matrix).
'
'Input parameters:
'    LUA         -   LU decomposition of a matrix in compact form. Output of
'                    the RMatrixLU subroutine.
'    N           -   size of matrix A.
'
'Result: 1/LowerBound(cond(A))
'
'NOTE:
'    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
'    0.0 is returned in such cases.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function RMatrixLURCond1(ByRef LUA() As Double, _
         ByVal N As Long) As Double
    Dim Result As Double
    Dim V As Double
    Call RMatrixRCondLUInternal(LUA, N, True, False, 0#, V)
    Result = V
    RMatrixLURCond1 = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Estimate of the condition number of a matrix given by its LU decomposition
'(infinity norm).
'
'The algorithm calculates a lower bound of the condition number. In this case,
'the algorithm does not return a lower bound of the condition number, but an
'inverse number (to avoid an overflow in case of a singular matrix).
'
'Input parameters:
'    LUA     -   LU decomposition of a matrix in compact form. Output of
'                the RMatrixLU subroutine.
'    N       -   size of matrix A.
'
'Result: 1/LowerBound(cond(A))
'
'NOTE:
'    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
'    0.0 is returned in such cases.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function RMatrixLURCondInf(ByRef LUA() As Double, _
         ByVal N As Long) As Double
    Dim Result As Double
    Dim V As Double
    Call RMatrixRCondLUInternal(LUA, N, False, False, 0#, V)
    Result = V
    RMatrixLURCondInf = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Condition number estimate of a symmetric positive definite matrix given by
'Cholesky decomposition.
'
'The algorithm calculates a lower bound of the condition number. In this
'case, the algorithm does not return a lower bound of the condition number,
'but an inverse number (to avoid an overflow in case of a singular matrix).
'
'It should be noted that 1-norm and inf-norm condition numbers of symmetric
'matrices are equal, so the algorithm doesn't take into account the
'differences between these types of norms.
'
'Input parameters:
'    CD  - Cholesky decomposition of matrix A,
'          output of SMatrixCholesky subroutine.
'    N   - size of matrix A.
'
'Result: 1/LowerBound(cond(A))
'
'NOTE:
'    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
'    0.0 is returned in such cases.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function SPDMatrixCholeskyRCond(ByRef A() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean) As Double
    Dim Result As Double
    Dim V As Double
    Call SPDMatrixRCondCholeskyInternal(A, N, IsUpper, False, 0#, V)
    Result = V
    SPDMatrixCholeskyRCond = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Condition number estimate of a Hermitian positive definite matrix given by
'Cholesky decomposition.
'
'The algorithm calculates a lower bound of the condition number. In this
'case, the algorithm does not return a lower bound of the condition number,
'but an inverse number (to avoid an overflow in case of a singular matrix).
'
'It should be noted that 1-norm and inf-norm condition numbers of symmetric
'matrices are equal, so the algorithm doesn't take into account the
'differences between these types of norms.
'
'Input parameters:
'    CD  - Cholesky decomposition of matrix A,
'          output of SMatrixCholesky subroutine.
'    N   - size of matrix A.
'
'Result: 1/LowerBound(cond(A))
'
'NOTE:
'    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
'    0.0 is returned in such cases.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function HPDMatrixCholeskyRCond(ByRef A() As Complex, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean) As Double
    Dim Result As Double
    Dim V As Double
    Call HPDMatrixRCondCholeskyInternal(A, N, IsUpper, False, 0#, V)
    Result = V
    HPDMatrixCholeskyRCond = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Estimate of the condition number of a matrix given by its LU decomposition (1-norm)
'
'The algorithm calculates a lower bound of the condition number. In this case,
'the algorithm does not return a lower bound of the condition number, but an
'inverse number (to avoid an overflow in case of a singular matrix).
'
'Input parameters:
'    LUA         -   LU decomposition of a matrix in compact form. Output of
'                    the CMatrixLU subroutine.
'    N           -   size of matrix A.
'
'Result: 1/LowerBound(cond(A))
'
'NOTE:
'    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
'    0.0 is returned in such cases.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function CMatrixLURCond1(ByRef LUA() As Complex, _
         ByVal N As Long) As Double
    Dim Result As Double
    Dim V As Double
    Call CMatrixRCondLUInternal(LUA, N, True, False, 0#, V)
    Result = V
    CMatrixLURCond1 = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Estimate of the condition number of a matrix given by its LU decomposition
'(infinity norm).
'
'The algorithm calculates a lower bound of the condition number. In this case,
'the algorithm does not return a lower bound of the condition number, but an
'inverse number (to avoid an overflow in case of a singular matrix).
'
'Input parameters:
'    LUA     -   LU decomposition of a matrix in compact form. Output of
'                the CMatrixLU subroutine.
'    N       -   size of matrix A.
'
'Result: 1/LowerBound(cond(A))
'
'NOTE:
'    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
'    0.0 is returned in such cases.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function CMatrixLURCondInf(ByRef LUA() As Complex, _
         ByVal N As Long) As Double
    Dim Result As Double
    Dim V As Double
    Call CMatrixRCondLUInternal(LUA, N, False, False, 0#, V)
    Result = V
    CMatrixLURCondInf = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Triangular matrix: estimate of a condition number (1-norm)
'
'The algorithm calculates a lower bound of the condition number. In this case,
'the algorithm does not return a lower bound of the condition number, but an
'inverse number (to avoid an overflow in case of a singular matrix).
'
'Input parameters:
'    A       -   matrix. Array[0..N-1, 0..N-1].
'    N       -   size of A.
'    IsUpper -   True, if the matrix is upper triangular.
'    IsUnit  -   True, if the matrix has a unit diagonal.
'
'Result: 1/LowerBound(cond(A))
'
'NOTE:
'    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
'    0.0 is returned in such cases.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function CMatrixTRRCond1(ByRef A() As Complex, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByVal Isunit As Boolean) As Double
    Dim Result As Double
    Dim i As Long
    Dim j As Long
    Dim V As Double
    Dim Nrm As Double
    Dim Pivots() As Long
    Dim T() As Double
    Dim J1 As Long
    Dim J2 As Long
    ReDim T(0 To N - 1)
    For i = 0# To N - 1# Step 1
        T(i) = 0#
    Next i
    For i = 0# To N - 1# Step 1
        If IsUpper Then
            J1 = i + 1#
            J2 = N - 1#
        Else
            J1 = 0#
            J2 = i - 1#
        End If
        For j = J1 To J2 Step 1
            T(j) = T(j) + AbsComplex(A(i, j))
        Next j
        If Isunit Then
            T(i) = T(i) + 1#
        Else
            T(i) = T(i) + AbsComplex(A(i, i))
        End If
    Next i
    Nrm = 0#
    For i = 0# To N - 1# Step 1
        Nrm = MaxReal(Nrm, T(i))
    Next i
    Call CMatrixRCondTRInternal(A, N, IsUpper, Isunit, True, Nrm, V)
    Result = V
    CMatrixTRRCond1 = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Triangular matrix: estimate of a matrix condition number (infinity-norm).
'
'The algorithm calculates a lower bound of the condition number. In this case,
'the algorithm does not return a lower bound of the condition number, but an
'inverse number (to avoid an overflow in case of a singular matrix).
'
'Input parameters:
'    A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
'    N   -   size of matrix A.
'    IsUpper -   True, if the matrix is upper triangular.
'    IsUnit  -   True, if the matrix has a unit diagonal.
'
'Result: 1/LowerBound(cond(A))
'
'NOTE:
'    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
'    0.0 is returned in such cases.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function CMatrixTRRCondInf(ByRef A() As Complex, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByVal Isunit As Boolean) As Double
    Dim Result As Double
    Dim i As Long
    Dim j As Long
    Dim V As Double
    Dim Nrm As Double
    Dim Pivots() As Long
    Dim J1 As Long
    Dim J2 As Long
    Nrm = 0#
    For i = 0# To N - 1# Step 1
        If IsUpper Then
            J1 = i + 1#
            J2 = N - 1#
        Else
            J1 = 0#
            J2 = i - 1#
        End If
        V = 0#
        For j = J1 To J2 Step 1
            V = V + AbsComplex(A(i, j))
        Next j
        If Isunit Then
            V = V + 1#
        Else
            V = V + AbsComplex(A(i, i))
        End If
        Nrm = MaxReal(Nrm, V)
    Next i
    Call CMatrixRCondTRInternal(A, N, IsUpper, Isunit, False, Nrm, V)
    Result = V
    CMatrixTRRCondInf = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Threshold for rcond: matrices with condition number beyond this  threshold
'are considered singular.
'
'Threshold must be far enough from underflow, at least Sqr(Threshold)  must
'be greater than underflow.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function RCondThreshold() As Double
    Dim Result As Double
    Result = Sqr(Sqr(MinRealNumber))
    RCondThreshold = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal subroutine for condition number estimation
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     February 29, 1992
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub RMatrixRCondTRInternal(ByRef A() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByVal Isunit As Boolean, _
         ByVal OneNorm As Boolean, _
         ByVal ANORM As Double, _
         ByRef RC As Double)
    Dim EX() As Double
    Dim EV() As Double
    Dim IWORK() As Long
    Dim Tmp() As Double
    Dim V As Double
    Dim i As Long
    Dim j As Long
    Dim KASE As Long
    Dim KASE1 As Long
    Dim J1 As Long
    Dim J2 As Long
    Dim AINVNM As Double
    Dim MaxGrowth As Double
    Dim S As Double
    Dim MUpper As Boolean
    Dim MTrans As Boolean
    Dim Munit As Boolean
    '
    ' RC=0 if something happens
    '
    RC = 0#
    '
    ' init
    '
    If OneNorm Then
        KASE1 = 1#
    Else
        KASE1 = 2#
    End If
    MUpper = True
    MTrans = True
    Munit = True
    ReDim IWORK(0 To N + 1# - 1)
    ReDim Tmp(0 To N - 1)
    '
    ' prepare parameters for triangular solver
    '
    MaxGrowth = 1# / RCondThreshold()
    S = 0#
    For i = 0# To N - 1# Step 1
        If IsUpper Then
            J1 = i + 1#
            J2 = N - 1#
        Else
            J1 = 0#
            J2 = i - 1#
        End If
        For j = J1 To J2 Step 1
            S = MaxReal(S, Abs(A(i, j)))
        Next j
        If Isunit Then
            S = MaxReal(S, 1#)
        Else
            S = MaxReal(S, Abs(A(i, i)))
        End If
    Next i
    If S = 0# Then
        S = 1#
    End If
    S = 1# / S
    '
    ' Scale according to S
    '
    ANORM = ANORM * S
    '
    ' Quick return if possible
    ' We assume that ANORM<>0 after this block
    '
    If ANORM = 0# Then
        Exit Sub
    End If
    If N = 1# Then
        RC = 1#
        Exit Sub
    End If
    '
    ' Estimate the norm of inv(A).
    '
    AINVNM = 0#
    KASE = 0#
    Do While True
        Call RMatrixEstimateNorm(N, EV, EX, IWORK, AINVNM, KASE)
        If KASE = 0# Then
            Exit Do
        End If
        '
        ' from 1-based array to 0-based
        '
        For i = 0# To N - 1# Step 1
            EX(i) = EX(i + 1#)
        Next i
        '
        ' multiply by inv(A) or inv(A')
        '
        If KASE = KASE1 Then
            '
            ' multiply by inv(A)
            '
            If Not RMatrixScaledTRSafeSolve(A, S, N, EX, IsUpper, 0#, Isunit, MaxGrowth) Then
                Exit Sub
            End If
        Else
            '
            ' multiply by inv(A')
            '
            If Not RMatrixScaledTRSafeSolve(A, S, N, EX, IsUpper, 1#, Isunit, MaxGrowth) Then
                Exit Sub
            End If
        End If
        '
        ' from 0-based array to 1-based
        '
        For i = N - 1# To 0# Step -1
            EX(i + 1#) = EX(i)
        Next i
    Loop
    '
    ' Compute the estimate of the reciprocal condition number.
    '
    If AINVNM <> 0# Then
        RC = 1# / AINVNM
        RC = RC / ANORM
        If RC < RCondThreshold() Then
            RC = 0#
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Condition number estimation
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     March 31, 1993
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub CMatrixRCondTRInternal(ByRef A() As Complex, _
         ByRef N As Long, _
         ByVal IsUpper As Boolean, _
         ByVal Isunit As Boolean, _
         ByVal OneNorm As Boolean, _
         ByVal ANORM As Double, _
         ByRef RC As Double)
    Dim EX() As Complex
    Dim CWORK2() As Complex
    Dim CWORK3() As Complex
    Dim CWORK4() As Complex
    Dim ISAVE() As Long
    Dim RSAVE() As Double
    Dim KASE As Long
    Dim KASE1 As Long
    Dim AINVNM As Double
    Dim V As Complex
    Dim i As Long
    Dim j As Long
    Dim J1 As Long
    Dim J2 As Long
    Dim S As Double
    Dim MaxGrowth As Double
    '
    ' RC=0 if something happens
    '
    RC = 0#
    '
    ' init
    '
    If N <= 0# Then
        Exit Sub
    End If
    If N = 0# Then
        RC = 1#
        Exit Sub
    End If
    ReDim CWORK2(0 To N + 1# - 1)
    '
    ' prepare parameters for triangular solver
    '
    MaxGrowth = 1# / RCondThreshold()
    S = 0#
    For i = 0# To N - 1# Step 1
        If IsUpper Then
            J1 = i + 1#
            J2 = N - 1#
        Else
            J1 = 0#
            J2 = i - 1#
        End If
        For j = J1 To J2 Step 1
            S = MaxReal(S, AbsComplex(A(i, j)))
        Next j
        If Isunit Then
            S = MaxReal(S, 1#)
        Else
            S = MaxReal(S, AbsComplex(A(i, i)))
        End If
    Next i
    If S = 0# Then
        S = 1#
    End If
    S = 1# / S
    '
    ' Scale according to S
    '
    ANORM = ANORM * S
    '
    ' Quick return if possible
    '
    If ANORM = 0# Then
        Exit Sub
    End If
    '
    ' Estimate the norm of inv(A).
    '
    AINVNM = 0#
    If OneNorm Then
        KASE1 = 1#
    Else
        KASE1 = 2#
    End If
    KASE = 0#
    Do While True
        Call CMatrixEstimateNorm(N, CWORK4, EX, AINVNM, KASE, ISAVE, RSAVE)
        If KASE = 0# Then
            Exit Do
        End If
        '
        ' From 1-based to 0-based
        '
        For i = 0# To N - 1# Step 1
            EX(i) = EX(i + 1#)
        Next i
        '
        ' multiply by inv(A) or inv(A')
        '
        If KASE = KASE1 Then
            '
            ' multiply by inv(A)
            '
            If Not CMatrixScaledTRSafeSolve(A, S, N, EX, IsUpper, 0#, Isunit, MaxGrowth) Then
                Exit Sub
            End If
        Else
            '
            ' multiply by inv(A')
            '
            If Not CMatrixScaledTRSafeSolve(A, S, N, EX, IsUpper, 2#, Isunit, MaxGrowth) Then
                Exit Sub
            End If
        End If
        '
        ' from 0-based to 1-based
        '
        For i = N - 1# To 0# Step -1
            EX(i + 1#) = EX(i)
        Next i
    Loop
    '
    ' Compute the estimate of the reciprocal condition number.
    '
    If AINVNM <> 0# Then
        RC = 1# / AINVNM
        RC = RC / ANORM
        If RC < RCondThreshold() Then
            RC = 0#
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal subroutine for condition number estimation
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     February 29, 1992
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub SPDMatrixRCondCholeskyInternal(ByRef CHA() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByVal IsNormProvided As Boolean, _
         ByVal ANORM As Double, _
         ByRef RC As Double)
    Dim i As Long
    Dim j As Long
    Dim KASE As Long
    Dim AINVNM As Double
    Dim EX() As Double
    Dim EV() As Double
    Dim Tmp() As Double
    Dim IWORK() As Long
    Dim SA As Double
    Dim V As Double
    Dim MaxGrowth As Double
    Dim i_ As Long
    Dim i1_ As Long
    ReDim Tmp(0 To N - 1)
    '
    ' RC=0 if something happens
    '
    RC = 0#
    '
    ' prepare parameters for triangular solver
    '
    MaxGrowth = 1# / RCondThreshold()
    SA = 0#
    If IsUpper Then
        For i = 0# To N - 1# Step 1
            For j = i To N - 1# Step 1
                SA = MaxReal(SA, AbsComplex(C_Complex(CHA(i, j))))
            Next j
        Next i
    Else
        For i = 0# To N - 1# Step 1
            For j = 0# To i Step 1
                SA = MaxReal(SA, AbsComplex(C_Complex(CHA(i, j))))
            Next j
        Next i
    End If
    If SA = 0# Then
        SA = 1#
    End If
    SA = 1# / SA
    '
    ' Estimate the norm of A.
    '
    If Not IsNormProvided Then
        KASE = 0#
        ANORM = 0#
        Do While True
            Call RMatrixEstimateNorm(N, EV, EX, IWORK, ANORM, KASE)
            If KASE = 0# Then
                Exit Do
            End If
            If IsUpper Then
                '
                ' Multiply by U
                '
                For i = 1# To N Step 1
                    i1_ = (i) - (i - 1#)
                    V = 0#
                    For i_ = i - 1# To N - 1# Step 1
                        V = V + CHA(i - 1#, i_) * EX(i_ + i1_)
                    Next i_
                    EX(i) = V
                Next i
                For i_ = 1# To N Step 1
                    EX(i_) = SA * EX(i_)
                Next i_
                '
                ' Multiply by U'
                '
                For i = 0# To N - 1# Step 1
                    Tmp(i) = 0#
                Next i
                For i = 0# To N - 1# Step 1
                    V = EX(i + 1#)
                    For i_ = i To N - 1# Step 1
                        Tmp(i_) = Tmp(i_) + V * CHA(i, i_)
                    Next i_
                Next i
                i1_ = (0#) - (1#)
                For i_ = 1# To N Step 1
                    EX(i_) = Tmp(i_ + i1_)
                Next i_
                For i_ = 1# To N Step 1
                    EX(i_) = SA * EX(i_)
                Next i_
            Else
                '
                ' Multiply by L'
                '
                For i = 0# To N - 1# Step 1
                    Tmp(i) = 0#
                Next i
                For i = 0# To N - 1# Step 1
                    V = EX(i + 1#)
                    For i_ = 0# To i Step 1
                        Tmp(i_) = Tmp(i_) + V * CHA(i, i_)
                    Next i_
                Next i
                i1_ = (0#) - (1#)
                For i_ = 1# To N Step 1
                    EX(i_) = Tmp(i_ + i1_)
                Next i_
                For i_ = 1# To N Step 1
                    EX(i_) = SA * EX(i_)
                Next i_
                '
                ' Multiply by L
                '
                For i = N To 1# Step -1
                    i1_ = (1#) - (0#)
                    V = 0#
                    For i_ = 0# To i - 1# Step 1
                        V = V + CHA(i - 1#, i_) * EX(i_ + i1_)
                    Next i_
                    EX(i) = V
                Next i
                For i_ = 1# To N Step 1
                    EX(i_) = SA * EX(i_)
                Next i_
            End If
        Loop
    End If
    '
    ' Quick return if possible
    '
    If ANORM = 0# Then
        Exit Sub
    End If
    If N = 1# Then
        RC = 1#
        Exit Sub
    End If
    '
    ' Estimate the 1-norm of inv(A).
    '
    KASE = 0#
    Do While True
        Call RMatrixEstimateNorm(N, EV, EX, IWORK, AINVNM, KASE)
        If KASE = 0# Then
            Exit Do
        End If
        For i = 0# To N - 1# Step 1
            EX(i) = EX(i + 1#)
        Next i
        If IsUpper Then
            '
            ' Multiply by inv(U').
            '
            If Not RMatrixScaledTRSafeSolve(CHA, SA, N, EX, IsUpper, 1#, False, MaxGrowth) Then
                Exit Sub
            End If
            '
            ' Multiply by inv(U).
            '
            If Not RMatrixScaledTRSafeSolve(CHA, SA, N, EX, IsUpper, 0#, False, MaxGrowth) Then
                Exit Sub
            End If
        Else
            '
            ' Multiply by inv(L).
            '
            If Not RMatrixScaledTRSafeSolve(CHA, SA, N, EX, IsUpper, 0#, False, MaxGrowth) Then
                Exit Sub
            End If
            '
            ' Multiply by inv(L').
            '
            If Not RMatrixScaledTRSafeSolve(CHA, SA, N, EX, IsUpper, 1#, False, MaxGrowth) Then
                Exit Sub
            End If
        End If
        For i = N - 1# To 0# Step -1
            EX(i + 1#) = EX(i)
        Next i
    Loop
    '
    ' Compute the estimate of the reciprocal condition number.
    '
    If AINVNM <> 0# Then
        V = 1# / AINVNM
        RC = V / ANORM
        If RC < RCondThreshold() Then
            RC = 0#
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal subroutine for condition number estimation
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     February 29, 1992
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub HPDMatrixRCondCholeskyInternal(ByRef CHA() As Complex, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByVal IsNormProvided As Boolean, _
         ByVal ANORM As Double, _
         ByRef RC As Double)
    Dim ISAVE() As Long
    Dim RSAVE() As Double
    Dim EX() As Complex
    Dim EV() As Complex
    Dim Tmp() As Complex
    Dim KASE As Long
    Dim AINVNM As Double
    Dim V As Complex
    Dim i As Long
    Dim j As Long
    Dim SA As Double
    Dim MaxGrowth As Double
    Dim i_ As Long
    Dim i1_ As Long
    ReDim Tmp(0 To N - 1)
    '
    ' RC=0 if something happens
    '
    RC = 0#
    '
    ' prepare parameters for triangular solver
    '
    MaxGrowth = 1# / RCondThreshold()
    SA = 0#
    If IsUpper Then
        For i = 0# To N - 1# Step 1
            For j = i To N - 1# Step 1
                SA = MaxReal(SA, AbsComplex(CHA(i, j)))
            Next j
        Next i
    Else
        For i = 0# To N - 1# Step 1
            For j = 0# To i Step 1
                SA = MaxReal(SA, AbsComplex(CHA(i, j)))
            Next j
        Next i
    End If
    If SA = 0# Then
        SA = 1#
    End If
    SA = 1# / SA
    '
    ' Estimate the norm of A
    '
    If Not IsNormProvided Then
        ANORM = 0#
        KASE = 0#
        Do While True
            Call CMatrixEstimateNorm(N, EV, EX, ANORM, KASE, ISAVE, RSAVE)
            If KASE = 0# Then
                Exit Do
            End If
            If IsUpper Then
                '
                ' Multiply by U
                '
                For i = 1# To N Step 1
                    i1_ = (i) - (i - 1#)
                    V = C_Complex(0#)
                    For i_ = i - 1# To N - 1# Step 1
                        V = C_Add(V, C_Mul(CHA(i - 1#, i_), EX(i_ + i1_)))
                    Next i_
                    EX(i) = V
                Next i
                For i_ = 1# To N Step 1
                    EX(i_) = C_MulR(EX(i_), SA)
                Next i_
                '
                ' Multiply by U'
                '
                For i = 0# To N - 1# Step 1
                    Tmp(i) = C_Complex(0#)
                Next i
                For i = 0# To N - 1# Step 1
                    V = EX(i + 1#)
                    For i_ = i To N - 1# Step 1
                        Tmp(i_) = C_Add(Tmp(i_), C_Mul(V, Conj(CHA(i, i_))))
                    Next i_
                Next i
                i1_ = (0#) - (1#)
                For i_ = 1# To N Step 1
                    EX(i_) = Tmp(i_ + i1_)
                Next i_
                For i_ = 1# To N Step 1
                    EX(i_) = C_MulR(EX(i_), SA)
                Next i_
            Else
                '
                ' Multiply by L'
                '
                For i = 0# To N - 1# Step 1
                    Tmp(i) = C_Complex(0#)
                Next i
                For i = 0# To N - 1# Step 1
                    V = EX(i + 1#)
                    For i_ = 0# To i Step 1
                        Tmp(i_) = C_Add(Tmp(i_), C_Mul(V, Conj(CHA(i, i_))))
                    Next i_
                Next i
                i1_ = (0#) - (1#)
                For i_ = 1# To N Step 1
                    EX(i_) = Tmp(i_ + i1_)
                Next i_
                For i_ = 1# To N Step 1
                    EX(i_) = C_MulR(EX(i_), SA)
                Next i_
                '
                ' Multiply by L
                '
                For i = N To 1# Step -1
                    i1_ = (1#) - (0#)
                    V = C_Complex(0#)
                    For i_ = 0# To i - 1# Step 1
                        V = C_Add(V, C_Mul(CHA(i - 1#, i_), EX(i_ + i1_)))
                    Next i_
                    EX(i) = V
                Next i
                For i_ = 1# To N Step 1
                    EX(i_) = C_MulR(EX(i_), SA)
                Next i_
            End If
        Loop
    End If
    '
    ' Quick return if possible
    ' After this block we assume that ANORM<>0
    '
    If ANORM = 0# Then
        Exit Sub
    End If
    If N = 1# Then
        RC = 1#
        Exit Sub
    End If
    '
    ' Estimate the norm of inv(A).
    '
    AINVNM = 0#
    KASE = 0#
    Do While True
        Call CMatrixEstimateNorm(N, EV, EX, AINVNM, KASE, ISAVE, RSAVE)
        If KASE = 0# Then
            Exit Do
        End If
        For i = 0# To N - 1# Step 1
            EX(i) = EX(i + 1#)
        Next i
        If IsUpper Then
            '
            ' Multiply by inv(U').
            '
            If Not CMatrixScaledTRSafeSolve(CHA, SA, N, EX, IsUpper, 2#, False, MaxGrowth) Then
                Exit Sub
            End If
            '
            ' Multiply by inv(U).
            '
            If Not CMatrixScaledTRSafeSolve(CHA, SA, N, EX, IsUpper, 0#, False, MaxGrowth) Then
                Exit Sub
            End If
        Else
            '
            ' Multiply by inv(L).
            '
            If Not CMatrixScaledTRSafeSolve(CHA, SA, N, EX, IsUpper, 0#, False, MaxGrowth) Then
                Exit Sub
            End If
            '
            ' Multiply by inv(L').
            '
            If Not CMatrixScaledTRSafeSolve(CHA, SA, N, EX, IsUpper, 2#, False, MaxGrowth) Then
                Exit Sub
            End If
        End If
        For i = N - 1# To 0# Step -1
            EX(i + 1#) = EX(i)
        Next i
    Loop
    '
    ' Compute the estimate of the reciprocal condition number.
    '
    If AINVNM <> 0# Then
        RC = 1# / AINVNM
        RC = RC / ANORM
        If RC < RCondThreshold() Then
            RC = 0#
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal subroutine for condition number estimation
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     February 29, 1992
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub RMatrixRCondLUInternal(ByRef LUA() As Double, _
         ByVal N As Long, _
         ByVal OneNorm As Boolean, _
         ByVal IsANormProvided As Boolean, _
         ByVal ANORM As Double, _
         ByRef RC As Double)
    Dim EX() As Double
    Dim EV() As Double
    Dim IWORK() As Long
    Dim Tmp() As Double
    Dim V As Double
    Dim i As Long
    Dim j As Long
    Dim KASE As Long
    Dim KASE1 As Long
    Dim AINVNM As Double
    Dim MaxGrowth As Double
    Dim SU As Double
    Dim SL As Double
    Dim MUpper As Boolean
    Dim MTrans As Boolean
    Dim Munit As Boolean
    Dim i_ As Long
    Dim i1_ As Long
    '
    ' RC=0 if something happens
    '
    RC = 0#
    '
    ' init
    '
    If OneNorm Then
        KASE1 = 1#
    Else
        KASE1 = 2#
    End If
    MUpper = True
    MTrans = True
    Munit = True
    ReDim IWORK(0 To N + 1# - 1)
    ReDim Tmp(0 To N - 1)
    '
    ' prepare parameters for triangular solver
    '
    MaxGrowth = 1# / RCondThreshold()
    SU = 0#
    SL = 1#
    For i = 0# To N - 1# Step 1
        For j = 0# To i - 1# Step 1
            SL = MaxReal(SL, Abs(LUA(i, j)))
        Next j
        For j = i To N - 1# Step 1
            SU = MaxReal(SU, Abs(LUA(i, j)))
        Next j
    Next i
    If SU = 0# Then
        SU = 1#
    End If
    SU = 1# / SU
    SL = 1# / SL
    '
    ' Estimate the norm of A.
    '
    If Not IsANormProvided Then
        KASE = 0#
        ANORM = 0#
        Do While True
            Call RMatrixEstimateNorm(N, EV, EX, IWORK, ANORM, KASE)
            If KASE = 0# Then
                Exit Do
            End If
            If KASE = KASE1 Then
                '
                ' Multiply by U
                '
                For i = 1# To N Step 1
                    i1_ = (i) - (i - 1#)
                    V = 0#
                    For i_ = i - 1# To N - 1# Step 1
                        V = V + LUA(i - 1#, i_) * EX(i_ + i1_)
                    Next i_
                    EX(i) = V
                Next i
                '
                ' Multiply by L
                '
                For i = N To 1# Step -1
                    If i > 1# Then
                        i1_ = (1#) - (0#)
                        V = 0#
                        For i_ = 0# To i - 2# Step 1
                            V = V + LUA(i - 1#, i_) * EX(i_ + i1_)
                        Next i_
                    Else
                        V = 0#
                    End If
                    EX(i) = EX(i) + V
                Next i
            Else
                '
                ' Multiply by L'
                '
                For i = 0# To N - 1# Step 1
                    Tmp(i) = 0#
                Next i
                For i = 0# To N - 1# Step 1
                    V = EX(i + 1#)
                    If i >= 1# Then
                        For i_ = 0# To i - 1# Step 1
                            Tmp(i_) = Tmp(i_) + V * LUA(i, i_)
                        Next i_
                    End If
                    Tmp(i) = Tmp(i) + V
                Next i
                i1_ = (0#) - (1#)
                For i_ = 1# To N Step 1
                    EX(i_) = Tmp(i_ + i1_)
                Next i_
                '
                ' Multiply by U'
                '
                For i = 0# To N - 1# Step 1
                    Tmp(i) = 0#
                Next i
                For i = 0# To N - 1# Step 1
                    V = EX(i + 1#)
                    For i_ = i To N - 1# Step 1
                        Tmp(i_) = Tmp(i_) + V * LUA(i, i_)
                    Next i_
                Next i
                i1_ = (0#) - (1#)
                For i_ = 1# To N Step 1
                    EX(i_) = Tmp(i_ + i1_)
                Next i_
            End If
        Loop
    End If
    '
    ' Scale according to SU/SL
    '
    ANORM = ANORM * SU * SL
    '
    ' Quick return if possible
    ' We assume that ANORM<>0 after this block
    '
    If ANORM = 0# Then
        Exit Sub
    End If
    If N = 1# Then
        RC = 1#
        Exit Sub
    End If
    '
    ' Estimate the norm of inv(A).
    '
    AINVNM = 0#
    KASE = 0#
    Do While True
        Call RMatrixEstimateNorm(N, EV, EX, IWORK, AINVNM, KASE)
        If KASE = 0# Then
            Exit Do
        End If
        '
        ' from 1-based array to 0-based
        '
        For i = 0# To N - 1# Step 1
            EX(i) = EX(i + 1#)
        Next i
        '
        ' multiply by inv(A) or inv(A')
        '
        If KASE = KASE1 Then
            '
            ' Multiply by inv(L).
            '
            If Not RMatrixScaledTRSafeSolve(LUA, SL, N, EX, Not MUpper, 0#, Munit, MaxGrowth) Then
                Exit Sub
            End If
            '
            ' Multiply by inv(U).
            '
            If Not RMatrixScaledTRSafeSolve(LUA, SU, N, EX, MUpper, 0#, Not Munit, MaxGrowth) Then
                Exit Sub
            End If
        Else
            '
            ' Multiply by inv(U').
            '
            If Not RMatrixScaledTRSafeSolve(LUA, SU, N, EX, MUpper, 1#, Not Munit, MaxGrowth) Then
                Exit Sub
            End If
            '
            ' Multiply by inv(L').
            '
            If Not RMatrixScaledTRSafeSolve(LUA, SL, N, EX, Not MUpper, 1#, Munit, MaxGrowth) Then
                Exit Sub
            End If
        End If
        '
        ' from 0-based array to 1-based
        '
        For i = N - 1# To 0# Step -1
            EX(i + 1#) = EX(i)
        Next i
    Loop
    '
    ' Compute the estimate of the reciprocal condition number.
    '
    If AINVNM <> 0# Then
        RC = 1# / AINVNM
        RC = RC / ANORM
        If RC < RCondThreshold() Then
            RC = 0#
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Condition number estimation
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     March 31, 1993
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub CMatrixRCondLUInternal(ByRef LUA() As Complex, _
         ByRef N As Long, _
         ByVal OneNorm As Boolean, _
         ByVal IsANormProvided As Boolean, _
         ByVal ANORM As Double, _
         ByRef RC As Double)
    Dim EX() As Complex
    Dim CWORK2() As Complex
    Dim CWORK3() As Complex
    Dim CWORK4() As Complex
    Dim ISAVE() As Long
    Dim RSAVE() As Double
    Dim KASE As Long
    Dim KASE1 As Long
    Dim AINVNM As Double
    Dim V As Complex
    Dim i As Long
    Dim j As Long
    Dim SU As Double
    Dim SL As Double
    Dim MaxGrowth As Double
    Dim i_ As Long
    Dim i1_ As Long
    If N <= 0# Then
        Exit Sub
    End If
    ReDim CWORK2(0 To N + 1# - 1)
    RC = 0#
    If N = 0# Then
        RC = 1#
        Exit Sub
    End If
    '
    ' prepare parameters for triangular solver
    '
    MaxGrowth = 1# / RCondThreshold()
    SU = 0#
    SL = 1#
    For i = 0# To N - 1# Step 1
        For j = 0# To i - 1# Step 1
            SL = MaxReal(SL, AbsComplex(LUA(i, j)))
        Next j
        For j = i To N - 1# Step 1
            SU = MaxReal(SU, AbsComplex(LUA(i, j)))
        Next j
    Next i
    If SU = 0# Then
        SU = 1#
    End If
    SU = 1# / SU
    SL = 1# / SL
    '
    ' Estimate the norm of SU*SL*A.
    '
    If Not IsANormProvided Then
        ANORM = 0#
        If OneNorm Then
            KASE1 = 1#
        Else
            KASE1 = 2#
        End If
        KASE = 0#
        Do
            Call CMatrixEstimateNorm(N, CWORK4, EX, ANORM, KASE, ISAVE, RSAVE)
            If KASE <> 0# Then
                If KASE = KASE1 Then
                    '
                    ' Multiply by U
                    '
                    For i = 1# To N Step 1
                        i1_ = (i) - (i - 1#)
                        V = C_Complex(0#)
                        For i_ = i - 1# To N - 1# Step 1
                            V = C_Add(V, C_Mul(LUA(i - 1#, i_), EX(i_ + i1_)))
                        Next i_
                        EX(i) = V
                    Next i
                    '
                    ' Multiply by L
                    '
                    For i = N To 1# Step -1
                        V = C_Complex(0#)
                        If i > 1# Then
                            i1_ = (1#) - (0#)
                            V = C_Complex(0#)
                            For i_ = 0# To i - 2# Step 1
                                V = C_Add(V, C_Mul(LUA(i - 1#, i_), EX(i_ + i1_)))
                            Next i_
                        End If
                        EX(i) = C_Add(V, EX(i))
                    Next i
                Else
                    '
                    ' Multiply by L'
                    '
                    For i = 1# To N Step 1
                        CWORK2(i) = C_Complex(0#)
                    Next i
                    For i = 1# To N Step 1
                        V = EX(i)
                        If i > 1# Then
                            i1_ = (0#) - (1#)
                            For i_ = 1# To i - 1# Step 1
                                CWORK2(i_) = C_Add(CWORK2(i_), C_Mul(V, Conj(LUA(i - 1#, i_ + i1_))))
                            Next i_
                        End If
                        CWORK2(i) = C_Add(CWORK2(i), V)
                    Next i
                    '
                    ' Multiply by U'
                    '
                    For i = 1# To N Step 1
                        EX(i) = C_Complex(0#)
                    Next i
                    For i = 1# To N Step 1
                        V = CWORK2(i)
                        i1_ = (i - 1#) - (i)
                        For i_ = i To N Step 1
                            EX(i_) = C_Add(EX(i_), C_Mul(V, Conj(LUA(i - 1#, i_ + i1_))))
                        Next i_
                    Next i
                End If
            End If
        Loop Until KASE = 0#
    End If
    '
    ' Scale according to SU/SL
    '
    ANORM = ANORM * SU * SL
    '
    ' Quick return if possible
    '
    If ANORM = 0# Then
        Exit Sub
    End If
    '
    ' Estimate the norm of inv(A).
    '
    AINVNM = 0#
    If OneNorm Then
        KASE1 = 1#
    Else
        KASE1 = 2#
    End If
    KASE = 0#
    Do While True
        Call CMatrixEstimateNorm(N, CWORK4, EX, AINVNM, KASE, ISAVE, RSAVE)
        If KASE = 0# Then
            Exit Do
        End If
        '
        ' From 1-based to 0-based
        '
        For i = 0# To N - 1# Step 1
            EX(i) = EX(i + 1#)
        Next i
        '
        ' multiply by inv(A) or inv(A')
        '
        If KASE = KASE1 Then
            '
            ' Multiply by inv(L).
            '
            If Not CMatrixScaledTRSafeSolve(LUA, SL, N, EX, False, 0#, True, MaxGrowth) Then
                RC = 0#
                Exit Sub
            End If
            '
            ' Multiply by inv(U).
            '
            If Not CMatrixScaledTRSafeSolve(LUA, SU, N, EX, True, 0#, False, MaxGrowth) Then
                RC = 0#
                Exit Sub
            End If
        Else
            '
            ' Multiply by inv(U').
            '
            If Not CMatrixScaledTRSafeSolve(LUA, SU, N, EX, True, 2#, False, MaxGrowth) Then
                RC = 0#
                Exit Sub
            End If
            '
            ' Multiply by inv(L').
            '
            If Not CMatrixScaledTRSafeSolve(LUA, SL, N, EX, False, 2#, True, MaxGrowth) Then
                RC = 0#
                Exit Sub
            End If
        End If
        '
        ' from 0-based to 1-based
        '
        For i = N - 1# To 0# Step -1
            EX(i + 1#) = EX(i)
        Next i
    Loop
    '
    ' Compute the estimate of the reciprocal condition number.
    '
    If AINVNM <> 0# Then
        RC = 1# / AINVNM
        RC = RC / ANORM
        If RC < RCondThreshold() Then
            RC = 0#
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal subroutine for matrix norm estimation
'
'  -- LAPACK auxiliary routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     February 29, 1992
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub RMatrixEstimateNorm(ByVal N As Long, _
         ByRef V() As Double, _
         ByRef X() As Double, _
         ByRef ISGN() As Long, _
         ByRef EST As Double, _
         ByRef KASE As Long)
    Dim ITMAX As Long
    Dim i As Long
    Dim T As Double
    Dim Flg As Boolean
    Dim PosITER As Long
    Dim PosJ As Long
    Dim PosJLAST As Long
    Dim PosJUMP As Long
    Dim PosALTSGN As Long
    Dim PosESTOLD As Long
    Dim PosTEMP As Long
    Dim i_ As Long
    ITMAX = 5#
    PosALTSGN = N + 1#
    PosESTOLD = N + 2#
    PosTEMP = N + 3#
    PosITER = N + 1#
    PosJ = N + 2#
    PosJLAST = N + 3#
    PosJUMP = N + 4#
    If KASE = 0# Then
        ReDim V(0 To N + 4# - 1)
        ReDim X(0 To N + 1# - 1)
        ReDim ISGN(0 To N + 5# - 1)
        T = 1# / N
        For i = 1# To N Step 1
            X(i) = T
        Next i
        KASE = 1#
        ISGN(PosJUMP) = 1#
        Exit Sub
    End If
    '
    '     ................ ENTRY   (JUMP = 1)
    '     FIRST ITERATION.  X HAS BEEN OVERWRITTEN BY A*X.
    '
    If ISGN(PosJUMP) = 1# Then
        If N = 1# Then
            V(1#) = X(1#)
            EST = Abs(V(1#))
            KASE = 0#
            Exit Sub
        End If
        EST = 0#
        For i = 1# To N Step 1
            EST = EST + Abs(X(i))
        Next i
        For i = 1# To N Step 1
            If X(i) >= 0# Then
                X(i) = 1#
            Else
                X(i) = -1#
            End If
            ISGN(i) = Sgn(X(i))
        Next i
        KASE = 2#
        ISGN(PosJUMP) = 2#
        Exit Sub
    End If
    '
    '     ................ ENTRY   (JUMP = 2)
    '     FIRST ITERATION.  X HAS BEEN OVERWRITTEN BY TRANDPOSE(A)*X.
    '
    If ISGN(PosJUMP) = 2# Then
        ISGN(PosJ) = 1#
        For i = 2# To N Step 1
            If Abs(X(i)) > Abs(X(ISGN(PosJ))) Then
                ISGN(PosJ) = i
            End If
        Next i
        ISGN(PosITER) = 2#
        '
        ' MAIN LOOP - ITERATIONS 2,3,...,ITMAX.
        '
        For i = 1# To N Step 1
            X(i) = 0#
        Next i
        X(ISGN(PosJ)) = 1#
        KASE = 1#
        ISGN(PosJUMP) = 3#
        Exit Sub
    End If
    '
    '     ................ ENTRY   (JUMP = 3)
    '     X HAS BEEN OVERWRITTEN BY A*X.
    '
    If ISGN(PosJUMP) = 3# Then
        For i_ = 1# To N Step 1
            V(i_) = X(i_)
        Next i_
        V(PosESTOLD) = EST
        EST = 0#
        For i = 1# To N Step 1
            EST = EST + Abs(V(i))
        Next i
        Flg = False
        For i = 1# To N Step 1
            If X(i) >= 0# And ISGN(i) < 0# Or X(i) < 0# And ISGN(i) >= 0# Then
                Flg = True
            End If
        Next i
        '
        ' REPEATED SIGN VECTOR DETECTED, HENCE ALGORITHM HAS CONVERGED.
        ' OR MAY BE CYCLING.
        '
        If Not Flg Or EST <= V(PosESTOLD) Then
            V(PosALTSGN) = 1#
            For i = 1# To N Step 1
                X(i) = V(PosALTSGN) * (1# + (i - 1#) / (N - 1#))
                V(PosALTSGN) = -V(PosALTSGN)
            Next i
            KASE = 1#
            ISGN(PosJUMP) = 5#
            Exit Sub
        End If
        For i = 1# To N Step 1
            If X(i) >= 0# Then
                X(i) = 1#
                ISGN(i) = 1#
            Else
                X(i) = -1#
                ISGN(i) = -1#
            End If
        Next i
        KASE = 2#
        ISGN(PosJUMP) = 4#
        Exit Sub
    End If
    '
    '     ................ ENTRY   (JUMP = 4)
    '     X HAS BEEN OVERWRITTEN BY TRANDPOSE(A)*X.
    '
    If ISGN(PosJUMP) = 4# Then
        ISGN(PosJLAST) = ISGN(PosJ)
        ISGN(PosJ) = 1#
        For i = 2# To N Step 1
            If Abs(X(i)) > Abs(X(ISGN(PosJ))) Then
                ISGN(PosJ) = i
            End If
        Next i
        If X(ISGN(PosJLAST)) <> Abs(X(ISGN(PosJ))) And ISGN(PosITER) < ITMAX Then
            ISGN(PosITER) = ISGN(PosITER) + 1#
            For i = 1# To N Step 1
                X(i) = 0#
            Next i
            X(ISGN(PosJ)) = 1#
            KASE = 1#
            ISGN(PosJUMP) = 3#
            Exit Sub
        End If
        '
        ' ITERATION COMPLETE.  FINAL STAGE.
        '
        V(PosALTSGN) = 1#
        For i = 1# To N Step 1
            X(i) = V(PosALTSGN) * (1# + (i - 1#) / (N - 1#))
            V(PosALTSGN) = -V(PosALTSGN)
        Next i
        KASE = 1#
        ISGN(PosJUMP) = 5#
        Exit Sub
    End If
    '
    '     ................ ENTRY   (JUMP = 5)
    '     X HAS BEEN OVERWRITTEN BY A*X.
    '
    If ISGN(PosJUMP) = 5# Then
        V(PosTEMP) = 0#
        For i = 1# To N Step 1
            V(PosTEMP) = V(PosTEMP) + Abs(X(i))
        Next i
        V(PosTEMP) = 2# * V(PosTEMP) / (3# * N)
        If V(PosTEMP) > EST Then
            For i_ = 1# To N Step 1
                V(i_) = X(i_)
            Next i_
            EST = V(PosTEMP)
        End If
        KASE = 0#
        Exit Sub
    End If
End Sub
Private Sub CMatrixEstimateNorm(ByRef N As Long, _
         ByRef V() As Complex, _
         ByRef X() As Complex, _
         ByRef EST As Double, _
         ByRef KASE As Long, _
         ByRef ISAVE() As Long, _
         ByRef RSAVE() As Double)
    Dim ITMAX As Long
    Dim i As Long
    Dim ITER As Long
    Dim j As Long
    Dim JLAST As Long
    Dim JUMP As Long
    Dim ABSXI As Double
    Dim ALTSGN As Double
    Dim ESTOLD As Double
    Dim SAFMIN As Double
    Dim temp As Double
    Dim i_ As Long
    '
    'Executable Statements ..
    '
    ITMAX = 5#
    SAFMIN = MinRealNumber
    If KASE = 0# Then
        ReDim V(0 To N + 1# - 1)
        ReDim X(0 To N + 1# - 1)
        ReDim ISAVE(0 To 5# - 1)
        ReDim RSAVE(0 To 4# - 1)
        For i = 1# To N Step 1
            X(i) = C_Complex(1# / N)
        Next i
        KASE = 1#
        JUMP = 1#
        Call InternalComplexRCondSaveAll(ISAVE, RSAVE, i, ITER, j, JLAST, JUMP, ABSXI, ALTSGN, ESTOLD, temp)
        Exit Sub
    End If
    Call InternalComplexRCondLoadAll(ISAVE, RSAVE, i, ITER, j, JLAST, JUMP, ABSXI, ALTSGN, ESTOLD, temp)
    '
    ' ENTRY   (JUMP = 1)
    ' FIRST ITERATION.  X HAS BEEN OVERWRITTEN BY A*X.
    '
    If JUMP = 1# Then
        If N = 1# Then
            V(1#) = X(1#)
            EST = AbsComplex(V(1#))
            KASE = 0#
            Call InternalComplexRCondSaveAll(ISAVE, RSAVE, i, ITER, j, JLAST, JUMP, ABSXI, ALTSGN, ESTOLD, temp)
            Exit Sub
        End If
        EST = InternalComplexRCondSCSUM1(X, N)
        For i = 1# To N Step 1
            ABSXI = AbsComplex(X(i))
            If ABSXI > SAFMIN Then
                X(i) = C_DivR(X(i), ABSXI)
            Else
                X(i) = C_Complex(1#)
            End If
        Next i
        KASE = 2#
        JUMP = 2#
        Call InternalComplexRCondSaveAll(ISAVE, RSAVE, i, ITER, j, JLAST, JUMP, ABSXI, ALTSGN, ESTOLD, temp)
        Exit Sub
    End If
    '
    ' ENTRY   (JUMP = 2)
    ' FIRST ITERATION.  X HAS BEEN OVERWRITTEN BY CTRANS(A)*X.
    '
    If JUMP = 2# Then
        j = InternalComplexRCondICMAX1(X, N)
        ITER = 2#
        '
        ' MAIN LOOP - ITERATIONS 2,3,...,ITMAX.
        '
        For i = 1# To N Step 1
            X(i) = C_Complex(0#)
        Next i
        X(j) = C_Complex(1#)
        KASE = 1#
        JUMP = 3#
        Call InternalComplexRCondSaveAll(ISAVE, RSAVE, i, ITER, j, JLAST, JUMP, ABSXI, ALTSGN, ESTOLD, temp)
        Exit Sub
    End If
    '
    ' ENTRY   (JUMP = 3)
    ' X HAS BEEN OVERWRITTEN BY A*X.
    '
    If JUMP = 3# Then
        For i_ = 1# To N Step 1
            V(i_) = X(i_)
        Next i_
        ESTOLD = EST
        EST = InternalComplexRCondSCSUM1(V, N)
        '
        ' TEST FOR CYCLING.
        '
        If EST <= ESTOLD Then
            '
            ' ITERATION COMPLETE.  FINAL STAGE.
            '
            ALTSGN = 1#
            For i = 1# To N Step 1
                X(i) = C_Complex(ALTSGN * (1# + (i - 1#) / (N - 1#)))
                ALTSGN = -ALTSGN
            Next i
            KASE = 1#
            JUMP = 5#
            Call InternalComplexRCondSaveAll(ISAVE, RSAVE, i, ITER, j, JLAST, JUMP, ABSXI, ALTSGN, ESTOLD, temp)
            Exit Sub
        End If
        For i = 1# To N Step 1
            ABSXI = AbsComplex(X(i))
            If ABSXI > SAFMIN Then
                X(i) = C_DivR(X(i), ABSXI)
            Else
                X(i) = C_Complex(1#)
            End If
        Next i
        KASE = 2#
        JUMP = 4#
        Call InternalComplexRCondSaveAll(ISAVE, RSAVE, i, ITER, j, JLAST, JUMP, ABSXI, ALTSGN, ESTOLD, temp)
        Exit Sub
    End If
    '
    ' ENTRY   (JUMP = 4)
    ' X HAS BEEN OVERWRITTEN BY CTRANS(A)*X.
    '
    If JUMP = 4# Then
        JLAST = j
        j = InternalComplexRCondICMAX1(X, N)
        If AbsComplex(X(JLAST)) <> AbsComplex(X(j)) And ITER < ITMAX Then
            ITER = ITER + 1#
            '
            ' MAIN LOOP - ITERATIONS 2,3,...,ITMAX.
            '
            For i = 1# To N Step 1
                X(i) = C_Complex(0#)
            Next i
            X(j) = C_Complex(1#)
            KASE = 1#
            JUMP = 3#
            Call InternalComplexRCondSaveAll(ISAVE, RSAVE, i, ITER, j, JLAST, JUMP, ABSXI, ALTSGN, ESTOLD, temp)
            Exit Sub
        End If
        '
        ' ITERATION COMPLETE.  FINAL STAGE.
        '
        ALTSGN = 1#
        For i = 1# To N Step 1
            X(i) = C_Complex(ALTSGN * (1# + (i - 1#) / (N - 1#)))
            ALTSGN = -ALTSGN
        Next i
        KASE = 1#
        JUMP = 5#
        Call InternalComplexRCondSaveAll(ISAVE, RSAVE, i, ITER, j, JLAST, JUMP, ABSXI, ALTSGN, ESTOLD, temp)
        Exit Sub
    End If
    '
    ' ENTRY   (JUMP = 5)
    ' X HAS BEEN OVERWRITTEN BY A*X.
    '
    If JUMP = 5# Then
        temp = 2# * (InternalComplexRCondSCSUM1(X, N) / (3# * N))
        If temp > EST Then
            For i_ = 1# To N Step 1
                V(i_) = X(i_)
            Next i_
            EST = temp
        End If
        KASE = 0#
        Call InternalComplexRCondSaveAll(ISAVE, RSAVE, i, ITER, j, JLAST, JUMP, ABSXI, ALTSGN, ESTOLD, temp)
        Exit Sub
    End If
End Sub
Private Function InternalComplexRCondSCSUM1(ByRef X() As Complex, _
         ByVal N As Long) As Double
    Dim Result As Double
    Dim i As Long
    Result = 0#
    For i = 1# To N Step 1
        Result = Result + AbsComplex(X(i))
    Next i
    InternalComplexRCondSCSUM1 = Result
End Function
Private Function InternalComplexRCondICMAX1(ByRef X() As Complex, _
         ByVal N As Long) As Long
    Dim Result As Long
    Dim i As Long
    Dim M As Double
    Result = 1#
    M = AbsComplex(X(1#))
    For i = 2# To N Step 1
        If AbsComplex(X(i)) > M Then
            Result = i
            M = AbsComplex(X(i))
        End If
    Next i
    InternalComplexRCondICMAX1 = Result
End Function
Private Sub InternalComplexRCondSaveAll(ByRef ISAVE() As Long, _
         ByRef RSAVE() As Double, _
         ByRef i As Long, _
         ByRef ITER As Long, _
         ByRef j As Long, _
         ByRef JLAST As Long, _
         ByRef JUMP As Long, _
         ByRef ABSXI As Double, _
         ByRef ALTSGN As Double, _
         ByRef ESTOLD As Double, _
         ByRef temp As Double)
    ISAVE(0#) = i
    ISAVE(1#) = ITER
    ISAVE(2#) = j
    ISAVE(3#) = JLAST
    ISAVE(4#) = JUMP
    RSAVE(0#) = ABSXI
    RSAVE(1#) = ALTSGN
    RSAVE(2#) = ESTOLD
    RSAVE(3#) = temp
End Sub
Private Sub InternalComplexRCondLoadAll(ByRef ISAVE() As Long, _
         ByRef RSAVE() As Double, _
         ByRef i As Long, _
         ByRef ITER As Long, _
         ByRef j As Long, _
         ByRef JLAST As Long, _
         ByRef JUMP As Long, _
         ByRef ABSXI As Double, _
         ByRef ALTSGN As Double, _
         ByRef ESTOLD As Double, _
         ByRef temp As Double)
    i = ISAVE(0#)
    ITER = ISAVE(1#)
    j = ISAVE(2#)
    JLAST = ISAVE(3#)
    JUMP = ISAVE(4#)
    ABSXI = RSAVE(0#)
    ALTSGN = RSAVE(1#)
    ESTOLD = RSAVE(2#)
    temp = RSAVE(3#)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2005-2010 Sergey Bochkanov.
'
'Additional copyrights:
'    1992-2007 The University of Tennessee (as indicated in subroutines
'    comments).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'QR decomposition of a rectangular matrix of size MxN
'
'Input parameters:
'    A   -   matrix A whose indexes range within [0..M-1, 0..N-1].
'    M   -   number of rows in matrix A.
'    N   -   number of columns in matrix A.
'
'Output parameters:
'    A   -   matrices Q and R in compact form (see below).
'    Tau -   array of scalar factors which are used to form
'            matrix Q. Array whose index ranges within [0.. Min(M-1,N-1)].
'
'Matrix A is represented as A = QR, where Q is an orthogonal matrix of size
'MxM, R - upper triangular (or upper trapezoid) matrix of size M x N.
'
'The elements of matrix R are located on and above the main diagonal of
'matrix A. The elements which are located in Tau array and below the main
'diagonal of matrix A are used to form matrix Q as follows:
'
'Matrix Q is represented as a product of elementary reflections
'
'Q = H(0)*H(2)*...*H(k-1),
'
'where k = min(m,n), and each H(i) is in the form
'
'H(i) = 1 - tau * v * (v^T)
'
'where tau is a scalar stored in Tau[I]; v - real vector,
'so that v(0:i-1) = 0, v(i) = 1, v(i+1:m-1) stored in A(i+1:m-1,i).
'
'  -- ALGLIB routine --
'     17.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixQR(ByRef A() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Tau() As Double)
    Dim WORK() As Double
    Dim T() As Double
    Dim TauBuf() As Double
    Dim MinMN As Long
    Dim TmpA() As Double
    Dim TmpT() As Double
    Dim TmpR() As Double
    Dim BlockStart As Long
    Dim BlockSize As Long
    Dim RowsCount As Long
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim V As Double
    Dim i_ As Long
    Dim i1_ As Long
    If M <= 0# Or N <= 0# Then
        Exit Sub
    End If
    MinMN = MinInt(M, N)
    ReDim WORK(0 To MaxInt(M, N) + 1# - 1)
    ReDim T(0 To MaxInt(M, N) + 1# - 1)
    ReDim Tau(0 To MinMN - 1)
    ReDim TauBuf(0 To MinMN - 1)
    ReDim TmpA(0 To M - 1, 0 To ABLASBlockSize(A) - 1)
    ReDim TmpT(0 To ABLASBlockSize(A) - 1, 0 To 2# * ABLASBlockSize(A) - 1)
    ReDim TmpR(0 To 2# * ABLASBlockSize(A) - 1, 0 To N - 1)
    
    '
    ' Blocked code
    '
    BlockStart = 0#
    Do While BlockStart <> MinMN
        
        '
        ' Determine block size
        '
        BlockSize = MinMN - BlockStart
        If BlockSize > ABLASBlockSize(A) Then
            BlockSize = ABLASBlockSize(A)
        End If
        RowsCount = M - BlockStart
        
        '
        ' QR decomposition of submatrix.
        ' Matrix is copied to temporary storage to solve
        ' some TLB issues arising from non-contiguous memory
        ' access pattern.
        '
        Call RMatrixCopy(RowsCount, BlockSize, A, BlockStart, BlockStart, TmpA, 0#, 0#)
        Call RMatrixQRBaseCase(TmpA, RowsCount, BlockSize, WORK, T, TauBuf)
        Call RMatrixCopy(RowsCount, BlockSize, TmpA, 0#, 0#, A, BlockStart, BlockStart)
        i1_ = (0#) - (BlockStart)
        For i_ = BlockStart To BlockStart + BlockSize - 1# Step 1
            Tau(i_) = TauBuf(i_ + i1_)
        Next i_
        
        '
        ' Update the rest, choose between:
        ' a) Level 2 algorithm (when the rest of the matrix is small enough)
        ' b) blocked algorithm, see algorithm 5 from  'A storage efficient WY
        '    representation for products of Householder transformations',
        '    by R. Schreiber and C. Van Loan.
        '
        If BlockStart + BlockSize <= N - 1# Then
            If N - BlockStart - BlockSize >= 2# * ABLASBlockSize(A) Or RowsCount >= 4# * ABLASBlockSize(A) Then
                
                '
                ' Prepare block reflector
                '
                Call RMatrixBlockReflector(TmpA, TauBuf, True, RowsCount, BlockSize, TmpT, WORK)
                
                '
                ' Multiply the rest of A by Q'.
                '
                ' Q  = E + Y*T*Y'  = E + TmpA*TmpT*TmpA'
                ' Q' = E + Y*T'*Y' = E + TmpA*TmpT'*TmpA'
                '
                Call RMatrixGEMM(BlockSize, N - BlockStart - BlockSize, RowsCount, 1#, TmpA, 0#, 0#, 1#, A, BlockStart, BlockStart + BlockSize, 0#, 0#, TmpR, 0#, 0#)
                Call RMatrixGEMM(BlockSize, N - BlockStart - BlockSize, BlockSize, 1#, TmpT, 0#, 0#, 1#, TmpR, 0#, 0#, 0#, 0#, TmpR, BlockSize, 0#)
                Call RMatrixGEMM(RowsCount, N - BlockStart - BlockSize, BlockSize, 1#, TmpA, 0#, 0#, 0#, TmpR, BlockSize, 0#, 0#, 1#, A, BlockStart, BlockStart + BlockSize)
            Else
                
                '
                ' Level 2 algorithm
                '
                For i = 0# To BlockSize - 1# Step 1
                    i1_ = (i) - (1#)
                    For i_ = 1# To RowsCount - i Step 1
                        T(i_) = TmpA(i_ + i1_, i)
                    Next i_
                    T(1#) = 1#
                    Call ApplyReflectionFromTheLeft(A, TauBuf(i), T, BlockStart + i, M - 1#, BlockStart + BlockSize, N - 1#, WORK)
                Next i
            End If
        End If
        
        '
        ' Advance
        '
        BlockStart = BlockStart + BlockSize
    Loop
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'LQ decomposition of a rectangular matrix of size MxN
'
'Input parameters:
'    A   -   matrix A whose indexes range within [0..M-1, 0..N-1].
'    M   -   number of rows in matrix A.
'    N   -   number of columns in matrix A.
'
'Output parameters:
'    A   -   matrices L and Q in compact form (see below)
'    Tau -   array of scalar factors which are used to form
'            matrix Q. Array whose index ranges within [0..Min(M,N)-1].
'
'Matrix A is represented as A = LQ, where Q is an orthogonal matrix of size
'MxM, L - lower triangular (or lower trapezoid) matrix of size M x N.
'
'The elements of matrix L are located on and below  the  main  diagonal  of
'matrix A. The elements which are located in Tau array and above  the  main
'diagonal of matrix A are used to form matrix Q as follows:
'
'Matrix Q is represented as a product of elementary reflections
'
'Q = H(k-1)*H(k-2)*...*H(1)*H(0),
'
'where k = min(m,n), and each H(i) is of the form
'
'H(i) = 1 - tau * v * (v^T)
'
'where tau is a scalar stored in Tau[I]; v - real vector, so that v(0:i-1)=0,
'v(i) = 1, v(i+1:n-1) stored in A(i,i+1:n-1).
'
'  -- ALGLIB routine --
'     17.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixLQ(ByRef A() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Tau() As Double)
    Dim WORK() As Double
    Dim T() As Double
    Dim TauBuf() As Double
    Dim MinMN As Long
    Dim TmpA() As Double
    Dim TmpT() As Double
    Dim TmpR() As Double
    Dim BlockStart As Long
    Dim BlockSize As Long
    Dim ColumnsCount As Long
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim V As Double
    Dim i_ As Long
    Dim i1_ As Long
    If M <= 0# Or N <= 0# Then
        Exit Sub
    End If
    MinMN = MinInt(M, N)
    ReDim WORK(0 To MaxInt(M, N) + 1# - 1)
    ReDim T(0 To MaxInt(M, N) + 1# - 1)
    ReDim Tau(0 To MinMN - 1)
    ReDim TauBuf(0 To MinMN - 1)
    ReDim TmpA(0 To ABLASBlockSize(A) - 1, 0 To N - 1)
    ReDim TmpT(0 To ABLASBlockSize(A) - 1, 0 To 2# * ABLASBlockSize(A) - 1)
    ReDim TmpR(0 To M - 1, 0 To 2# * ABLASBlockSize(A) - 1)
    
    '
    ' Blocked code
    '
    BlockStart = 0#
    Do While BlockStart <> MinMN
        
        '
        ' Determine block size
        '
        BlockSize = MinMN - BlockStart
        If BlockSize > ABLASBlockSize(A) Then
            BlockSize = ABLASBlockSize(A)
        End If
        ColumnsCount = N - BlockStart
        
        '
        ' LQ decomposition of submatrix.
        ' Matrix is copied to temporary storage to solve
        ' some TLB issues arising from non-contiguous memory
        ' access pattern.
        '
        Call RMatrixCopy(BlockSize, ColumnsCount, A, BlockStart, BlockStart, TmpA, 0#, 0#)
        Call RMatrixLQBaseCase(TmpA, BlockSize, ColumnsCount, WORK, T, TauBuf)
        Call RMatrixCopy(BlockSize, ColumnsCount, TmpA, 0#, 0#, A, BlockStart, BlockStart)
        i1_ = (0#) - (BlockStart)
        For i_ = BlockStart To BlockStart + BlockSize - 1# Step 1
            Tau(i_) = TauBuf(i_ + i1_)
        Next i_
        
        '
        ' Update the rest, choose between:
        ' a) Level 2 algorithm (when the rest of the matrix is small enough)
        ' b) blocked algorithm, see algorithm 5 from  'A storage efficient WY
        '    representation for products of Householder transformations',
        '    by R. Schreiber and C. Van Loan.
        '
        If BlockStart + BlockSize <= M - 1# Then
            If M - BlockStart - BlockSize >= 2# * ABLASBlockSize(A) Then
                
                '
                ' Prepare block reflector
                '
                Call RMatrixBlockReflector(TmpA, TauBuf, False, ColumnsCount, BlockSize, TmpT, WORK)
                
                '
                ' Multiply the rest of A by Q.
                '
                ' Q  = E + Y*T*Y'  = E + TmpA'*TmpT*TmpA
                '
                Call RMatrixGEMM(M - BlockStart - BlockSize, BlockSize, ColumnsCount, 1#, A, BlockStart + BlockSize, BlockStart, 0#, TmpA, 0#, 0#, 1#, 0#, TmpR, 0#, 0#)
                Call RMatrixGEMM(M - BlockStart - BlockSize, BlockSize, BlockSize, 1#, TmpR, 0#, 0#, 0#, TmpT, 0#, 0#, 0#, 0#, TmpR, 0#, BlockSize)
                Call RMatrixGEMM(M - BlockStart - BlockSize, ColumnsCount, BlockSize, 1#, TmpR, 0#, BlockSize, 0#, TmpA, 0#, 0#, 0#, 1#, A, BlockStart + BlockSize, BlockStart)
            Else
                
                '
                ' Level 2 algorithm
                '
                For i = 0# To BlockSize - 1# Step 1
                    i1_ = (i) - (1#)
                    For i_ = 1# To ColumnsCount - i Step 1
                        T(i_) = TmpA(i, i_ + i1_)
                    Next i_
                    T(1#) = 1#
                    Call ApplyReflectionFromTheRight(A, TauBuf(i), T, BlockStart + BlockSize, M - 1#, BlockStart + i, N - 1#, WORK)
                Next i
            End If
        End If
        
        '
        ' Advance
        '
        BlockStart = BlockStart + BlockSize
    Loop
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'QR decomposition of a rectangular complex matrix of size MxN
'
'Input parameters:
'    A   -   matrix A whose indexes range within [0..M-1, 0..N-1]
'    M   -   number of rows in matrix A.
'    N   -   number of columns in matrix A.
'
'Output parameters:
'    A   -   matrices Q and R in compact form
'    Tau -   array of scalar factors which are used to form matrix Q. Array
'            whose indexes range within [0.. Min(M,N)-1]
'
'Matrix A is represented as A = QR, where Q is an orthogonal matrix of size
'MxM, R - upper triangular (or upper trapezoid) matrix of size MxN.
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     September 30, 1994
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixQR(ByRef A() As Complex, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Tau() As Complex)
    Dim WORK() As Complex
    Dim T() As Complex
    Dim TauBuf() As Complex
    Dim MinMN As Long
    Dim TmpA() As Complex
    Dim TmpT() As Complex
    Dim TmpR() As Complex
    Dim BlockStart As Long
    Dim BlockSize As Long
    Dim RowsCount As Long
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim V As Complex
    Dim i_ As Long
    Dim i1_ As Long
    If M <= 0# Or N <= 0# Then
        Exit Sub
    End If
    MinMN = MinInt(M, N)
    ReDim WORK(0 To MaxInt(M, N) + 1# - 1)
    ReDim T(0 To MaxInt(M, N) + 1# - 1)
    ReDim Tau(0 To MinMN - 1)
    ReDim TauBuf(0 To MinMN - 1)
    ReDim TmpA(0 To M - 1, 0 To ABLASComplexBlockSize(A) - 1)
    ReDim TmpT(0 To ABLASComplexBlockSize(A) - 1, 0 To ABLASComplexBlockSize(A) - 1)
    ReDim TmpR(0 To 2# * ABLASComplexBlockSize(A) - 1, 0 To N - 1)
    
    '
    ' Blocked code
    '
    BlockStart = 0#
    Do While BlockStart <> MinMN
        
        '
        ' Determine block size
        '
        BlockSize = MinMN - BlockStart
        If BlockSize > ABLASComplexBlockSize(A) Then
            BlockSize = ABLASComplexBlockSize(A)
        End If
        RowsCount = M - BlockStart
        
        '
        ' QR decomposition of submatrix.
        ' Matrix is copied to temporary storage to solve
        ' some TLB issues arising from non-contiguous memory
        ' access pattern.
        '
        Call CMatrixCopy(RowsCount, BlockSize, A, BlockStart, BlockStart, TmpA, 0#, 0#)
        Call CMatrixQRBaseCase(TmpA, RowsCount, BlockSize, WORK, T, TauBuf)
        Call CMatrixCopy(RowsCount, BlockSize, TmpA, 0#, 0#, A, BlockStart, BlockStart)
        i1_ = (0#) - (BlockStart)
        For i_ = BlockStart To BlockStart + BlockSize - 1# Step 1
            Tau(i_) = TauBuf(i_ + i1_)
        Next i_
        
        '
        ' Update the rest, choose between:
        ' a) Level 2 algorithm (when the rest of the matrix is small enough)
        ' b) blocked algorithm, see algorithm 5 from  'A storage efficient WY
        '    representation for products of Householder transformations',
        '    by R. Schreiber and C. Van Loan.
        '
        If BlockStart + BlockSize <= N - 1# Then
            If N - BlockStart - BlockSize >= 2# * ABLASComplexBlockSize(A) Then
                
                '
                ' Prepare block reflector
                '
                Call CMatrixBlockReflector(TmpA, TauBuf, True, RowsCount, BlockSize, TmpT, WORK)
                
                '
                ' Multiply the rest of A by Q'.
                '
                ' Q  = E + Y*T*Y'  = E + TmpA*TmpT*TmpA'
                ' Q' = E + Y*T'*Y' = E + TmpA*TmpT'*TmpA'
                '
                Call CMatrixGEMM(BlockSize, N - BlockStart - BlockSize, RowsCount, C_Complex(1#), TmpA, 0#, 0#, 2#, A, BlockStart, BlockStart + BlockSize, 0#, C_Complex(0#), TmpR, 0#, 0#)
                Call CMatrixGEMM(BlockSize, N - BlockStart - BlockSize, BlockSize, C_Complex(1#), TmpT, 0#, 0#, 2#, TmpR, 0#, 0#, 0#, C_Complex(0#), TmpR, BlockSize, 0#)
                Call CMatrixGEMM(RowsCount, N - BlockStart - BlockSize, BlockSize, C_Complex(1#), TmpA, 0#, 0#, 0#, TmpR, BlockSize, 0#, 0#, C_Complex(1#), A, BlockStart, BlockStart + BlockSize)
            Else
                
                '
                ' Level 2 algorithm
                '
                For i = 0# To BlockSize - 1# Step 1
                    i1_ = (i) - (1#)
                    For i_ = 1# To RowsCount - i Step 1
                        T(i_) = TmpA(i_ + i1_, i)
                    Next i_
                    T(1#) = C_Complex(1#)
                    Call ComplexApplyReflectionFromTheLeft(A, Conj(TauBuf(i)), T, BlockStart + i, M - 1#, BlockStart + BlockSize, N - 1#, WORK)
                Next i
            End If
        End If
        
        '
        ' Advance
        '
        BlockStart = BlockStart + BlockSize
    Loop
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'LQ decomposition of a rectangular complex matrix of size MxN
'
'Input parameters:
'    A   -   matrix A whose indexes range within [0..M-1, 0..N-1]
'    M   -   number of rows in matrix A.
'    N   -   number of columns in matrix A.
'
'Output parameters:
'    A   -   matrices Q and L in compact form
'    Tau -   array of scalar factors which are used to form matrix Q. Array
'            whose indexes range within [0.. Min(M,N)-1]
'
'Matrix A is represented as A = LQ, where Q is an orthogonal matrix of size
'MxM, L - lower triangular (or lower trapezoid) matrix of size MxN.
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     September 30, 1994
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixLQ(ByRef A() As Complex, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Tau() As Complex)
    Dim WORK() As Complex
    Dim T() As Complex
    Dim TauBuf() As Complex
    Dim MinMN As Long
    Dim TmpA() As Complex
    Dim TmpT() As Complex
    Dim TmpR() As Complex
    Dim BlockStart As Long
    Dim BlockSize As Long
    Dim ColumnsCount As Long
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim V As Complex
    Dim i_ As Long
    Dim i1_ As Long
    If M <= 0# Or N <= 0# Then
        Exit Sub
    End If
    MinMN = MinInt(M, N)
    ReDim WORK(0 To MaxInt(M, N) + 1# - 1)
    ReDim T(0 To MaxInt(M, N) + 1# - 1)
    ReDim Tau(0 To MinMN - 1)
    ReDim TauBuf(0 To MinMN - 1)
    ReDim TmpA(0 To ABLASComplexBlockSize(A) - 1, 0 To N - 1)
    ReDim TmpT(0 To ABLASComplexBlockSize(A) - 1, 0 To ABLASComplexBlockSize(A) - 1)
    ReDim TmpR(0 To M - 1, 0 To 2# * ABLASComplexBlockSize(A) - 1)
    
    '
    ' Blocked code
    '
    BlockStart = 0#
    Do While BlockStart <> MinMN
        
        '
        ' Determine block size
        '
        BlockSize = MinMN - BlockStart
        If BlockSize > ABLASComplexBlockSize(A) Then
            BlockSize = ABLASComplexBlockSize(A)
        End If
        ColumnsCount = N - BlockStart
        
        '
        ' LQ decomposition of submatrix.
        ' Matrix is copied to temporary storage to solve
        ' some TLB issues arising from non-contiguous memory
        ' access pattern.
        '
        Call CMatrixCopy(BlockSize, ColumnsCount, A, BlockStart, BlockStart, TmpA, 0#, 0#)
        Call CMatrixLQBaseCase(TmpA, BlockSize, ColumnsCount, WORK, T, TauBuf)
        Call CMatrixCopy(BlockSize, ColumnsCount, TmpA, 0#, 0#, A, BlockStart, BlockStart)
        i1_ = (0#) - (BlockStart)
        For i_ = BlockStart To BlockStart + BlockSize - 1# Step 1
            Tau(i_) = TauBuf(i_ + i1_)
        Next i_
        
        '
        ' Update the rest, choose between:
        ' a) Level 2 algorithm (when the rest of the matrix is small enough)
        ' b) blocked algorithm, see algorithm 5 from  'A storage efficient WY
        '    representation for products of Householder transformations',
        '    by R. Schreiber and C. Van Loan.
        '
        If BlockStart + BlockSize <= M - 1# Then
            If M - BlockStart - BlockSize >= 2# * ABLASComplexBlockSize(A) Then
                
                '
                ' Prepare block reflector
                '
                Call CMatrixBlockReflector(TmpA, TauBuf, False, ColumnsCount, BlockSize, TmpT, WORK)
                
                '
                ' Multiply the rest of A by Q.
                '
                ' Q  = E + Y*T*Y'  = E + TmpA'*TmpT*TmpA
                '
                Call CMatrixGEMM(M - BlockStart - BlockSize, BlockSize, ColumnsCount, C_Complex(1#), A, BlockStart + BlockSize, BlockStart, 0#, TmpA, 0#, 0#, 2#, C_Complex(0#), TmpR, 0#, 0#)
                Call CMatrixGEMM(M - BlockStart - BlockSize, BlockSize, BlockSize, C_Complex(1#), TmpR, 0#, 0#, 0#, TmpT, 0#, 0#, 0#, C_Complex(0#), TmpR, 0#, BlockSize)
                Call CMatrixGEMM(M - BlockStart - BlockSize, ColumnsCount, BlockSize, C_Complex(1#), TmpR, 0#, BlockSize, 0#, TmpA, 0#, 0#, 0#, C_Complex(1#), A, BlockStart + BlockSize, BlockStart)
            Else
                
                '
                ' Level 2 algorithm
                '
                For i = 0# To BlockSize - 1# Step 1
                    i1_ = (i) - (1#)
                    For i_ = 1# To ColumnsCount - i Step 1
                        T(i_) = Conj(TmpA(i, i_ + i1_))
                    Next i_
                    T(1#) = C_Complex(1#)
                    Call ComplexApplyReflectionFromTheRight(A, TauBuf(i), T, BlockStart + BlockSize, M - 1#, BlockStart + i, N - 1#, WORK)
                Next i
            End If
        End If
        
        '
        ' Advance
        '
        BlockStart = BlockStart + BlockSize
    Loop
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Partial unpacking of matrix Q from the QR decomposition of a matrix A
'
'Input parameters:
'    A       -   matrices Q and R in compact form.
'                Output of RMatrixQR subroutine.
'    M       -   number of rows in given matrix A. M>=0.
'    N       -   number of columns in given matrix A. N>=0.
'    Tau     -   scalar factors which are used to form Q.
'                Output of the RMatrixQR subroutine.
'    QColumns -  required number of columns of matrix Q. M>=QColumns>=0.
'
'Output parameters:
'    Q       -   first QColumns columns of matrix Q.
'                Array whose indexes range within [0..M-1, 0..QColumns-1].
'                If QColumns=0, the array remains unchanged.
'
'  -- ALGLIB routine --
'     17.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixQRUnpackQ(ByRef A() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Tau() As Double, _
         ByVal QColumns As Long, _
         ByRef q() As Double)
    Dim WORK() As Double
    Dim T() As Double
    Dim TauBuf() As Double
    Dim MinMN As Long
    Dim RefCnt As Long
    Dim TmpA() As Double
    Dim TmpT() As Double
    Dim TmpR() As Double
    Dim BlockStart As Long
    Dim BlockSize As Long
    Dim RowsCount As Long
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim V As Double
    Dim i_ As Long
    Dim i1_ As Long
    If M <= 0# Or N <= 0# Or QColumns <= 0# Then
        Exit Sub
    End If
    
    '
    ' init
    '
    MinMN = MinInt(M, N)
    RefCnt = MinInt(MinMN, QColumns)
    ReDim q(0 To M - 1, 0 To QColumns - 1)
    For i = 0# To M - 1# Step 1
        For j = 0# To QColumns - 1# Step 1
            If i = j Then
                q(i, j) = 1#
            Else
                q(i, j) = 0#
            End If
        Next j
    Next i
    ReDim WORK(0 To MaxInt(M, QColumns) + 1# - 1)
    ReDim T(0 To MaxInt(M, QColumns) + 1# - 1)
    ReDim TauBuf(0 To MinMN - 1)
    ReDim TmpA(0 To M - 1, 0 To ABLASBlockSize(A) - 1)
    ReDim TmpT(0 To ABLASBlockSize(A) - 1, 0 To 2# * ABLASBlockSize(A) - 1)
    ReDim TmpR(0 To 2# * ABLASBlockSize(A) - 1, 0 To QColumns - 1)
    
    '
    ' Blocked code
    '
    BlockStart = ABLASBlockSize(A) * (RefCnt \ ABLASBlockSize(A))
    BlockSize = RefCnt - BlockStart
    Do While BlockStart >= 0#
        RowsCount = M - BlockStart
        
        '
        ' Copy current block
        '
        Call RMatrixCopy(RowsCount, BlockSize, A, BlockStart, BlockStart, TmpA, 0#, 0#)
        i1_ = (BlockStart) - (0#)
        For i_ = 0# To BlockSize - 1# Step 1
            TauBuf(i_) = Tau(i_ + i1_)
        Next i_
        
        '
        ' Update, choose between:
        ' a) Level 2 algorithm (when the rest of the matrix is small enough)
        ' b) blocked algorithm, see algorithm 5 from  'A storage efficient WY
        '    representation for products of Householder transformations',
        '    by R. Schreiber and C. Van Loan.
        '
        If QColumns >= 2# * ABLASBlockSize(A) Then
            
            '
            ' Prepare block reflector
            '
            Call RMatrixBlockReflector(TmpA, TauBuf, True, RowsCount, BlockSize, TmpT, WORK)
            
            '
            ' Multiply matrix by Q.
            '
            ' Q  = E + Y*T*Y'  = E + TmpA*TmpT*TmpA'
            '
            Call RMatrixGEMM(BlockSize, QColumns, RowsCount, 1#, TmpA, 0#, 0#, 1#, q, BlockStart, 0#, 0#, 0#, TmpR, 0#, 0#)
            Call RMatrixGEMM(BlockSize, QColumns, BlockSize, 1#, TmpT, 0#, 0#, 0#, TmpR, 0#, 0#, 0#, 0#, TmpR, BlockSize, 0#)
            Call RMatrixGEMM(RowsCount, QColumns, BlockSize, 1#, TmpA, 0#, 0#, 0#, TmpR, BlockSize, 0#, 0#, 1#, q, BlockStart, 0#)
        Else
            
            '
            ' Level 2 algorithm
            '
            For i = BlockSize - 1# To 0# Step -1
                i1_ = (i) - (1#)
                For i_ = 1# To RowsCount - i Step 1
                    T(i_) = TmpA(i_ + i1_, i)
                Next i_
                T(1#) = 1#
                Call ApplyReflectionFromTheLeft(q, TauBuf(i), T, BlockStart + i, M - 1#, 0#, QColumns - 1#, WORK)
            Next i
        End If
        
        '
        ' Advance
        '
        BlockStart = BlockStart - ABLASBlockSize(A)
        BlockSize = ABLASBlockSize(A)
    Loop
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Unpacking of matrix R from the QR decomposition of a matrix A
'
'Input parameters:
'    A       -   matrices Q and R in compact form.
'                Output of RMatrixQR subroutine.
'    M       -   number of rows in given matrix A. M>=0.
'    N       -   number of columns in given matrix A. N>=0.
'
'Output parameters:
'    R       -   matrix R, array[0..M-1, 0..N-1].
'
'  -- ALGLIB routine --
'     17.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixQRUnpackR(ByRef A() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef R() As Double)
    Dim i As Long
    Dim K As Long
    Dim i_ As Long
    If M <= 0# Or N <= 0# Then
        Exit Sub
    End If
    K = MinInt(M, N)
    ReDim R(0 To M - 1, 0 To N - 1)
    For i = 0# To N - 1# Step 1
        R(0#, i) = 0#
    Next i
    For i = 1# To M - 1# Step 1
        For i_ = 0# To N - 1# Step 1
            R(i, i_) = R(0#, i_)
        Next i_
    Next i
    For i = 0# To K - 1# Step 1
        For i_ = i To N - 1# Step 1
            R(i, i_) = A(i, i_)
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Partial unpacking of matrix Q from the LQ decomposition of a matrix A
'
'Input parameters:
'    A       -   matrices L and Q in compact form.
'                Output of RMatrixLQ subroutine.
'    M       -   number of rows in given matrix A. M>=0.
'    N       -   number of columns in given matrix A. N>=0.
'    Tau     -   scalar factors which are used to form Q.
'                Output of the RMatrixLQ subroutine.
'    QRows   -   required number of rows in matrix Q. N>=QRows>=0.
'
'Output parameters:
'    Q       -   first QRows rows of matrix Q. Array whose indexes range
'                within [0..QRows-1, 0..N-1]. If QRows=0, the array remains
'                unchanged.
'
'  -- ALGLIB routine --
'     17.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixLQUnpackQ(ByRef A() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Tau() As Double, _
         ByVal QRows As Long, _
         ByRef q() As Double)
    Dim WORK() As Double
    Dim T() As Double
    Dim TauBuf() As Double
    Dim MinMN As Long
    Dim RefCnt As Long
    Dim TmpA() As Double
    Dim TmpT() As Double
    Dim TmpR() As Double
    Dim BlockStart As Long
    Dim BlockSize As Long
    Dim ColumnsCount As Long
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim V As Double
    Dim i_ As Long
    Dim i1_ As Long
    If M <= 0# Or N <= 0# Or QRows <= 0# Then
        Exit Sub
    End If
    
    '
    ' init
    '
    MinMN = MinInt(M, N)
    RefCnt = MinInt(MinMN, QRows)
    ReDim WORK(0 To MaxInt(M, N) + 1# - 1)
    ReDim T(0 To MaxInt(M, N) + 1# - 1)
    ReDim TauBuf(0 To MinMN - 1)
    ReDim TmpA(0 To ABLASBlockSize(A) - 1, 0 To N - 1)
    ReDim TmpT(0 To ABLASBlockSize(A) - 1, 0 To 2# * ABLASBlockSize(A) - 1)
    ReDim TmpR(0 To QRows - 1, 0 To 2# * ABLASBlockSize(A) - 1)
    ReDim q(0 To QRows - 1, 0 To N - 1)
    For i = 0# To QRows - 1# Step 1
        For j = 0# To N - 1# Step 1
            If i = j Then
                q(i, j) = 1#
            Else
                q(i, j) = 0#
            End If
        Next j
    Next i
    
    '
    ' Blocked code
    '
    BlockStart = ABLASBlockSize(A) * (RefCnt \ ABLASBlockSize(A))
    BlockSize = RefCnt - BlockStart
    Do While BlockStart >= 0#
        ColumnsCount = N - BlockStart
        
        '
        ' Copy submatrix
        '
        Call RMatrixCopy(BlockSize, ColumnsCount, A, BlockStart, BlockStart, TmpA, 0#, 0#)
        i1_ = (BlockStart) - (0#)
        For i_ = 0# To BlockSize - 1# Step 1
            TauBuf(i_) = Tau(i_ + i1_)
        Next i_
        
        '
        ' Update matrix, choose between:
        ' a) Level 2 algorithm (when the rest of the matrix is small enough)
        ' b) blocked algorithm, see algorithm 5 from  'A storage efficient WY
        '    representation for products of Householder transformations',
        '    by R. Schreiber and C. Van Loan.
        '
        If QRows >= 2# * ABLASBlockSize(A) Then
            
            '
            ' Prepare block reflector
            '
            Call RMatrixBlockReflector(TmpA, TauBuf, False, ColumnsCount, BlockSize, TmpT, WORK)
            
            '
            ' Multiply the rest of A by Q'.
            '
            ' Q'  = E + Y*T'*Y'  = E + TmpA'*TmpT'*TmpA
            '
            Call RMatrixGEMM(QRows, BlockSize, ColumnsCount, 1#, q, 0#, BlockStart, 0#, TmpA, 0#, 0#, 1#, 0#, TmpR, 0#, 0#)
            Call RMatrixGEMM(QRows, BlockSize, BlockSize, 1#, TmpR, 0#, 0#, 0#, TmpT, 0#, 0#, 1#, 0#, TmpR, 0#, BlockSize)
            Call RMatrixGEMM(QRows, ColumnsCount, BlockSize, 1#, TmpR, 0#, BlockSize, 0#, TmpA, 0#, 0#, 0#, 1#, q, 0#, BlockStart)
        Else
            
            '
            ' Level 2 algorithm
            '
            For i = BlockSize - 1# To 0# Step -1
                i1_ = (i) - (1#)
                For i_ = 1# To ColumnsCount - i Step 1
                    T(i_) = TmpA(i, i_ + i1_)
                Next i_
                T(1#) = 1#
                Call ApplyReflectionFromTheRight(q, TauBuf(i), T, 0#, QRows - 1#, BlockStart + i, N - 1#, WORK)
            Next i
        End If
        
        '
        ' Advance
        '
        BlockStart = BlockStart - ABLASBlockSize(A)
        BlockSize = ABLASBlockSize(A)
    Loop
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Unpacking of matrix L from the LQ decomposition of a matrix A
'
'Input parameters:
'    A       -   matrices Q and L in compact form.
'                Output of RMatrixLQ subroutine.
'    M       -   number of rows in given matrix A. M>=0.
'    N       -   number of columns in given matrix A. N>=0.
'
'Output parameters:
'    L       -   matrix L, array[0..M-1, 0..N-1].
'
'  -- ALGLIB routine --
'     17.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixLQUnpackL(ByRef A() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef L() As Double)
    Dim i As Long
    Dim K As Long
    Dim i_ As Long
    If M <= 0# Or N <= 0# Then
        Exit Sub
    End If
    ReDim L(0 To M - 1, 0 To N - 1)
    For i = 0# To N - 1# Step 1
        L(0#, i) = 0#
    Next i
    For i = 1# To M - 1# Step 1
        For i_ = 0# To N - 1# Step 1
            L(i, i_) = L(0#, i_)
        Next i_
    Next i
    For i = 0# To M - 1# Step 1
        K = MinInt(i, N - 1#)
        For i_ = 0# To K Step 1
            L(i, i_) = A(i, i_)
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Partial unpacking of matrix Q from QR decomposition of a complex matrix A.
'
'Input parameters:
'    A           -   matrices Q and R in compact form.
'                    Output of CMatrixQR subroutine .
'    M           -   number of rows in matrix A. M>=0.
'    N           -   number of columns in matrix A. N>=0.
'    Tau         -   scalar factors which are used to form Q.
'                    Output of CMatrixQR subroutine .
'    QColumns    -   required number of columns in matrix Q. M>=QColumns>=0.
'
'Output parameters:
'    Q           -   first QColumns columns of matrix Q.
'                    Array whose index ranges within [0..M-1, 0..QColumns-1].
'                    If QColumns=0, array isn't changed.
'
'  -- ALGLIB routine --
'     17.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixQRUnpackQ(ByRef A() As Complex, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Tau() As Complex, _
         ByVal QColumns As Long, _
         ByRef q() As Complex)
    Dim WORK() As Complex
    Dim T() As Complex
    Dim TauBuf() As Complex
    Dim MinMN As Long
    Dim RefCnt As Long
    Dim TmpA() As Complex
    Dim TmpT() As Complex
    Dim TmpR() As Complex
    Dim BlockStart As Long
    Dim BlockSize As Long
    Dim RowsCount As Long
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim V As Complex
    Dim i_ As Long
    Dim i1_ As Long
    If M <= 0# Or N <= 0# Then
        Exit Sub
    End If
    
    '
    ' init
    '
    MinMN = MinInt(M, N)
    RefCnt = MinInt(MinMN, QColumns)
    ReDim WORK(0 To MaxInt(M, N) + 1# - 1)
    ReDim T(0 To MaxInt(M, N) + 1# - 1)
    ReDim TauBuf(0 To MinMN - 1)
    ReDim TmpA(0 To M - 1, 0 To ABLASComplexBlockSize(A) - 1)
    ReDim TmpT(0 To ABLASComplexBlockSize(A) - 1, 0 To ABLASComplexBlockSize(A) - 1)
    ReDim TmpR(0 To 2# * ABLASComplexBlockSize(A) - 1, 0 To QColumns - 1)
    ReDim q(0 To M - 1, 0 To QColumns - 1)
    For i = 0# To M - 1# Step 1
        For j = 0# To QColumns - 1# Step 1
            If i = j Then
                q(i, j) = C_Complex(1#)
            Else
                q(i, j) = C_Complex(0#)
            End If
        Next j
    Next i
    
    '
    ' Blocked code
    '
    BlockStart = ABLASComplexBlockSize(A) * (RefCnt \ ABLASComplexBlockSize(A))
    BlockSize = RefCnt - BlockStart
    Do While BlockStart >= 0#
        RowsCount = M - BlockStart
        
        '
        ' QR decomposition of submatrix.
        ' Matrix is copied to temporary storage to solve
        ' some TLB issues arising from non-contiguous memory
        ' access pattern.
        '
        Call CMatrixCopy(RowsCount, BlockSize, A, BlockStart, BlockStart, TmpA, 0#, 0#)
        i1_ = (BlockStart) - (0#)
        For i_ = 0# To BlockSize - 1# Step 1
            TauBuf(i_) = Tau(i_ + i1_)
        Next i_
        
        '
        ' Update matrix, choose between:
        ' a) Level 2 algorithm (when the rest of the matrix is small enough)
        ' b) blocked algorithm, see algorithm 5 from  'A storage efficient WY
        '    representation for products of Householder transformations',
        '    by R. Schreiber and C. Van Loan.
        '
        If QColumns >= 2# * ABLASComplexBlockSize(A) Then
            
            '
            ' Prepare block reflector
            '
            Call CMatrixBlockReflector(TmpA, TauBuf, True, RowsCount, BlockSize, TmpT, WORK)
            
            '
            ' Multiply the rest of A by Q.
            '
            ' Q  = E + Y*T*Y'  = E + TmpA*TmpT*TmpA'
            '
            Call CMatrixGEMM(BlockSize, QColumns, RowsCount, C_Complex(1#), TmpA, 0#, 0#, 2#, q, BlockStart, 0#, 0#, C_Complex(0#), TmpR, 0#, 0#)
            Call CMatrixGEMM(BlockSize, QColumns, BlockSize, C_Complex(1#), TmpT, 0#, 0#, 0#, TmpR, 0#, 0#, 0#, C_Complex(0#), TmpR, BlockSize, 0#)
            Call CMatrixGEMM(RowsCount, QColumns, BlockSize, C_Complex(1#), TmpA, 0#, 0#, 0#, TmpR, BlockSize, 0#, 0#, C_Complex(1#), q, BlockStart, 0#)
        Else
            
            '
            ' Level 2 algorithm
            '
            For i = BlockSize - 1# To 0# Step -1
                i1_ = (i) - (1#)
                For i_ = 1# To RowsCount - i Step 1
                    T(i_) = TmpA(i_ + i1_, i)
                Next i_
                T(1#) = C_Complex(1#)
                Call ComplexApplyReflectionFromTheLeft(q, TauBuf(i), T, BlockStart + i, M - 1#, 0#, QColumns - 1#, WORK)
            Next i
        End If
        
        '
        ' Advance
        '
        BlockStart = BlockStart - ABLASComplexBlockSize(A)
        BlockSize = ABLASComplexBlockSize(A)
    Loop
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Unpacking of matrix R from the QR decomposition of a matrix A
'
'Input parameters:
'    A       -   matrices Q and R in compact form.
'                Output of CMatrixQR subroutine.
'    M       -   number of rows in given matrix A. M>=0.
'    N       -   number of columns in given matrix A. N>=0.
'
'Output parameters:
'    R       -   matrix R, array[0..M-1, 0..N-1].
'
'  -- ALGLIB routine --
'     17.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixQRUnpackR(ByRef A() As Complex, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef R() As Complex)
    Dim i As Long
    Dim K As Long
    Dim i_ As Long
    If M <= 0# Or N <= 0# Then
        Exit Sub
    End If
    K = MinInt(M, N)
    ReDim R(0 To M - 1, 0 To N - 1)
    For i = 0# To N - 1# Step 1
        R(0#, i) = C_Complex(0#)
    Next i
    For i = 1# To M - 1# Step 1
        For i_ = 0# To N - 1# Step 1
            R(i, i_) = R(0#, i_)
        Next i_
    Next i
    For i = 0# To K - 1# Step 1
        For i_ = i To N - 1# Step 1
            R(i, i_) = A(i, i_)
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Partial unpacking of matrix Q from LQ decomposition of a complex matrix A.
'
'Input parameters:
'    A           -   matrices Q and R in compact form.
'                    Output of CMatrixLQ subroutine .
'    M           -   number of rows in matrix A. M>=0.
'    N           -   number of columns in matrix A. N>=0.
'    Tau         -   scalar factors which are used to form Q.
'                    Output of CMatrixLQ subroutine .
'    QRows       -   required number of rows in matrix Q. N>=QColumns>=0.
'
'Output parameters:
'    Q           -   first QRows rows of matrix Q.
'                    Array whose index ranges within [0..QRows-1, 0..N-1].
'                    If QRows=0, array isn't changed.
'
'  -- ALGLIB routine --
'     17.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixLQUnpackQ(ByRef A() As Complex, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Tau() As Complex, _
         ByVal QRows As Long, _
         ByRef q() As Complex)
    Dim WORK() As Complex
    Dim T() As Complex
    Dim TauBuf() As Complex
    Dim MinMN As Long
    Dim RefCnt As Long
    Dim TmpA() As Complex
    Dim TmpT() As Complex
    Dim TmpR() As Complex
    Dim BlockStart As Long
    Dim BlockSize As Long
    Dim ColumnsCount As Long
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim V As Complex
    Dim i_ As Long
    Dim i1_ As Long
    If M <= 0# Or N <= 0# Then
        Exit Sub
    End If
    
    '
    ' Init
    '
    MinMN = MinInt(M, N)
    RefCnt = MinInt(MinMN, QRows)
    ReDim WORK(0 To MaxInt(M, N) + 1# - 1)
    ReDim T(0 To MaxInt(M, N) + 1# - 1)
    ReDim TauBuf(0 To MinMN - 1)
    ReDim TmpA(0 To ABLASComplexBlockSize(A) - 1, 0 To N - 1)
    ReDim TmpT(0 To ABLASComplexBlockSize(A) - 1, 0 To ABLASComplexBlockSize(A) - 1)
    ReDim TmpR(0 To QRows - 1, 0 To 2# * ABLASComplexBlockSize(A) - 1)
    ReDim q(0 To QRows - 1, 0 To N - 1)
    For i = 0# To QRows - 1# Step 1
        For j = 0# To N - 1# Step 1
            If i = j Then
                q(i, j) = C_Complex(1#)
            Else
                q(i, j) = C_Complex(0#)
            End If
        Next j
    Next i
    
    '
    ' Blocked code
    '
    BlockStart = ABLASComplexBlockSize(A) * (RefCnt \ ABLASComplexBlockSize(A))
    BlockSize = RefCnt - BlockStart
    Do While BlockStart >= 0#
        ColumnsCount = N - BlockStart
        
        '
        ' LQ decomposition of submatrix.
        ' Matrix is copied to temporary storage to solve
        ' some TLB issues arising from non-contiguous memory
        ' access pattern.
        '
        Call CMatrixCopy(BlockSize, ColumnsCount, A, BlockStart, BlockStart, TmpA, 0#, 0#)
        i1_ = (BlockStart) - (0#)
        For i_ = 0# To BlockSize - 1# Step 1
            TauBuf(i_) = Tau(i_ + i1_)
        Next i_
        
        '
        ' Update matrix, choose between:
        ' a) Level 2 algorithm (when the rest of the matrix is small enough)
        ' b) blocked algorithm, see algorithm 5 from  'A storage efficient WY
        '    representation for products of Householder transformations',
        '    by R. Schreiber and C. Van Loan.
        '
        If QRows >= 2# * ABLASComplexBlockSize(A) Then
            
            '
            ' Prepare block reflector
            '
            Call CMatrixBlockReflector(TmpA, TauBuf, False, ColumnsCount, BlockSize, TmpT, WORK)
            
            '
            ' Multiply the rest of A by Q'.
            '
            ' Q'  = E + Y*T'*Y'  = E + TmpA'*TmpT'*TmpA
            '
            Call CMatrixGEMM(QRows, BlockSize, ColumnsCount, C_Complex(1#), q, 0#, BlockStart, 0#, TmpA, 0#, 0#, 2#, C_Complex(0#), TmpR, 0#, 0#)
            Call CMatrixGEMM(QRows, BlockSize, BlockSize, C_Complex(1#), TmpR, 0#, 0#, 0#, TmpT, 0#, 0#, 2#, C_Complex(0#), TmpR, 0#, BlockSize)
            Call CMatrixGEMM(QRows, ColumnsCount, BlockSize, C_Complex(1#), TmpR, 0#, BlockSize, 0#, TmpA, 0#, 0#, 0#, C_Complex(1#), q, 0#, BlockStart)
        Else
            
            '
            ' Level 2 algorithm
            '
            For i = BlockSize - 1# To 0# Step -1
                i1_ = (i) - (1#)
                For i_ = 1# To ColumnsCount - i Step 1
                    T(i_) = Conj(TmpA(i, i_ + i1_))
                Next i_
                T(1#) = C_Complex(1#)
                Call ComplexApplyReflectionFromTheRight(q, Conj(TauBuf(i)), T, 0#, QRows - 1#, BlockStart + i, N - 1#, WORK)
            Next i
        End If
        
        '
        ' Advance
        '
        BlockStart = BlockStart - ABLASComplexBlockSize(A)
        BlockSize = ABLASComplexBlockSize(A)
    Loop
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Unpacking of matrix L from the LQ decomposition of a matrix A
'
'Input parameters:
'    A       -   matrices Q and L in compact form.
'                Output of CMatrixLQ subroutine.
'    M       -   number of rows in given matrix A. M>=0.
'    N       -   number of columns in given matrix A. N>=0.
'
'Output parameters:
'    L       -   matrix L, array[0..M-1, 0..N-1].
'
'  -- ALGLIB routine --
'     17.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixLQUnpackL(ByRef A() As Complex, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef L() As Complex)
    Dim i As Long
    Dim K As Long
    Dim i_ As Long
    If M <= 0# Or N <= 0# Then
        Exit Sub
    End If
    ReDim L(0 To M - 1, 0 To N - 1)
    For i = 0# To N - 1# Step 1
        L(0#, i) = C_Complex(0#)
    Next i
    For i = 1# To M - 1# Step 1
        For i_ = 0# To N - 1# Step 1
            L(i, i_) = L(0#, i_)
        Next i_
    Next i
    For i = 0# To M - 1# Step 1
        K = MinInt(i, N - 1#)
        For i_ = 0# To K Step 1
            L(i, i_) = A(i, i_)
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Reduction of a rectangular matrix to  bidiagonal form
'
'The algorithm reduces the rectangular matrix A to  bidiagonal form by
'orthogonal transformations P and Q: A = Q*B*P.
'
'Input parameters:
'    A       -   source matrix. array[0..M-1, 0..N-1]
'    M       -   number of rows in matrix A.
'    N       -   number of columns in matrix A.
'
'Output parameters:
'    A       -   matrices Q, B, P in compact form (see below).
'    TauQ    -   scalar factors which are used to form matrix Q.
'    TauP    -   scalar factors which are used to form matrix P.
'
'The main diagonal and one of the  secondary  diagonals  of  matrix  A  are
'replaced with bidiagonal  matrix  B.  Other  elements  contain  elementary
'reflections which form MxM matrix Q and NxN matrix P, respectively.
'
'If M>=N, B is the upper  bidiagonal  MxN  matrix  and  is  stored  in  the
'corresponding  elements  of  matrix  A.  Matrix  Q  is  represented  as  a
'product   of   elementary   reflections   Q = H(0)*H(1)*...*H(n-1),  where
'H(i) = 1-tau*v*v'. Here tau is a scalar which is stored  in  TauQ[i],  and
'vector v has the following  structure:  v(0:i-1)=0, v(i)=1, v(i+1:m-1)  is
'stored   in   elements   A(i+1:m-1,i).   Matrix   P  is  as  follows:  P =
'G(0)*G(1)*...*G(n-2), where G(i) = 1 - tau*u*u'. Tau is stored in TauP[i],
'u(0:i)=0, u(i+1)=1, u(i+2:n-1) is stored in elements A(i,i+2:n-1).
'
'If M<N, B is the  lower  bidiagonal  MxN  matrix  and  is  stored  in  the
'corresponding   elements  of  matrix  A.  Q = H(0)*H(1)*...*H(m-2),  where
'H(i) = 1 - tau*v*v', tau is stored in TauQ, v(0:i)=0, v(i+1)=1, v(i+2:m-1)
'is    stored    in   elements   A(i+2:m-1,i).    P = G(0)*G(1)*...*G(m-1),
'G(i) = 1-tau*u*u', tau is stored in  TauP,  u(0:i-1)=0, u(i)=1, u(i+1:n-1)
'is stored in A(i,i+1:n-1).
'
'EXAMPLE:
'
'm=6, n=5 (m > n):               m=5, n=6 (m < n):
'
'(  d   e   u1  u1  u1 )         (  d   u1  u1  u1  u1  u1 )
'(  v1  d   e   u2  u2 )         (  e   d   u2  u2  u2  u2 )
'(  v1  v2  d   e   u3 )         (  v1  e   d   u3  u3  u3 )
'(  v1  v2  v3  d   e  )         (  v1  v2  e   d   u4  u4 )
'(  v1  v2  v3  v4  d  )         (  v1  v2  v3  e   d   u5 )
'(  v1  v2  v3  v4  v5 )
'
'Here vi and ui are vectors which form H(i) and G(i), and d and e -
'are the diagonal and off-diagonal elements of matrix B.
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     September 30, 1994.
'     Sergey Bochkanov, ALGLIB project, translation from FORTRAN to
'     pseudocode, 2007-2010.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixBD(ByRef A() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef TauQ() As Double, _
         ByRef TauP() As Double)
    Dim WORK() As Double
    Dim T() As Double
    Dim MinMN As Long
    Dim MaxMN As Long
    Dim i As Long
    Dim LTau As Double
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' Prepare
    '
    If N <= 0# Or M <= 0# Then
        Exit Sub
    End If
    MinMN = MinInt(M, N)
    MaxMN = MaxInt(M, N)
    ReDim WORK(0 To MaxMN + 1# - 1)
    ReDim T(0 To MaxMN + 1# - 1)
    If M >= N Then
        ReDim TauQ(0 To N - 1)
        ReDim TauP(0 To N - 1)
    Else
        ReDim TauQ(0 To M - 1)
        ReDim TauP(0 To M - 1)
    End If
    If M >= N Then
        
        '
        ' Reduce to upper bidiagonal form
        '
        For i = 0# To N - 1# Step 1
            
            '
            ' Generate elementary reflector H(i) to annihilate A(i+1:m-1,i)
            '
            i1_ = (i) - (1#)
            For i_ = 1# To M - i Step 1
                T(i_) = A(i_ + i1_, i)
            Next i_
            Call GenerateReflection(T, M - i, LTau)
            TauQ(i) = LTau
            i1_ = (1#) - (i)
            For i_ = i To M - 1# Step 1
                A(i_, i) = T(i_ + i1_)
            Next i_
            T(1#) = 1#
            
            '
            ' Apply H(i) to A(i:m-1,i+1:n-1) from the left
            '
            Call ApplyReflectionFromTheLeft(A, LTau, T, i, M - 1#, i + 1#, N - 1#, WORK)
            If i < N - 1# Then
                
                '
                ' Generate elementary reflector G(i) to annihilate
                ' A(i,i+2:n-1)
                '
                i1_ = (i + 1#) - (1#)
                For i_ = 1# To N - i - 1# Step 1
                    T(i_) = A(i, i_ + i1_)
                Next i_
                Call GenerateReflection(T, N - 1# - i, LTau)
                TauP(i) = LTau
                i1_ = (1#) - (i + 1#)
                For i_ = i + 1# To N - 1# Step 1
                    A(i, i_) = T(i_ + i1_)
                Next i_
                T(1#) = 1#
                
                '
                ' Apply G(i) to A(i+1:m-1,i+1:n-1) from the right
                '
                Call ApplyReflectionFromTheRight(A, LTau, T, i + 1#, M - 1#, i + 1#, N - 1#, WORK)
            Else
                TauP(i) = 0#
            End If
        Next i
    Else
        
        '
        ' Reduce to lower bidiagonal form
        '
        For i = 0# To M - 1# Step 1
            
            '
            ' Generate elementary reflector G(i) to annihilate A(i,i+1:n-1)
            '
            i1_ = (i) - (1#)
            For i_ = 1# To N - i Step 1
                T(i_) = A(i, i_ + i1_)
            Next i_
            Call GenerateReflection(T, N - i, LTau)
            TauP(i) = LTau
            i1_ = (1#) - (i)
            For i_ = i To N - 1# Step 1
                A(i, i_) = T(i_ + i1_)
            Next i_
            T(1#) = 1#
            
            '
            ' Apply G(i) to A(i+1:m-1,i:n-1) from the right
            '
            Call ApplyReflectionFromTheRight(A, LTau, T, i + 1#, M - 1#, i, N - 1#, WORK)
            If i < M - 1# Then
                
                '
                ' Generate elementary reflector H(i) to annihilate
                ' A(i+2:m-1,i)
                '
                i1_ = (i + 1#) - (1#)
                For i_ = 1# To M - 1# - i Step 1
                    T(i_) = A(i_ + i1_, i)
                Next i_
                Call GenerateReflection(T, M - 1# - i, LTau)
                TauQ(i) = LTau
                i1_ = (1#) - (i + 1#)
                For i_ = i + 1# To M - 1# Step 1
                    A(i_, i) = T(i_ + i1_)
                Next i_
                T(1#) = 1#
                
                '
                ' Apply H(i) to A(i+1:m-1,i+1:n-1) from the left
                '
                Call ApplyReflectionFromTheLeft(A, LTau, T, i + 1#, M - 1#, i + 1#, N - 1#, WORK)
            Else
                TauQ(i) = 0#
            End If
        Next i
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Unpacking matrix Q which reduces a matrix to bidiagonal form.
'
'Input parameters:
'    QP          -   matrices Q and P in compact form.
'                    Output of ToBidiagonal subroutine.
'    M           -   number of rows in matrix A.
'    N           -   number of columns in matrix A.
'    TAUQ        -   scalar factors which are used to form Q.
'                    Output of ToBidiagonal subroutine.
'    QColumns    -   required number of columns in matrix Q.
'                    M>=QColumns>=0.
'
'Output parameters:
'    Q           -   first QColumns columns of matrix Q.
'                    Array[0..M-1, 0..QColumns-1]
'                    If QColumns=0, the array is not modified.
'
'  -- ALGLIB --
'     2005-2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixBDUnpackQ(ByRef QP() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef TauQ() As Double, _
         ByVal QColumns As Long, _
         ByRef q() As Double)
    Dim i As Long
    Dim j As Long
    If M = 0# Or N = 0# Or QColumns = 0# Then
        Exit Sub
    End If
    
    '
    ' prepare Q
    '
    ReDim q(0 To M - 1, 0 To QColumns - 1)
    For i = 0# To M - 1# Step 1
        For j = 0# To QColumns - 1# Step 1
            If i = j Then
                q(i, j) = 1#
            Else
                q(i, j) = 0#
            End If
        Next j
    Next i
    
    '
    ' Calculate
    '
    Call RMatrixBDMultiplyByQ(QP, M, N, TauQ, q, M, QColumns, False, False)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Multiplication by matrix Q which reduces matrix A to  bidiagonal form.
'
'The algorithm allows pre- or post-multiply by Q or Q'.
'
'Input parameters:
'    QP          -   matrices Q and P in compact form.
'                    Output of ToBidiagonal subroutine.
'    M           -   number of rows in matrix A.
'    N           -   number of columns in matrix A.
'    TAUQ        -   scalar factors which are used to form Q.
'                    Output of ToBidiagonal subroutine.
'    Z           -   multiplied matrix.
'                    array[0..ZRows-1,0..ZColumns-1]
'    ZRows       -   number of rows in matrix Z. If FromTheRight=False,
'                    ZRows=M, otherwise ZRows can be arbitrary.
'    ZColumns    -   number of columns in matrix Z. If FromTheRight=True,
'                    ZColumns=M, otherwise ZColumns can be arbitrary.
'    FromTheRight -  pre- or post-multiply.
'    DoTranspose -   multiply by Q or Q'.
'
'Output parameters:
'    Z           -   product of Z and Q.
'                    Array[0..ZRows-1,0..ZColumns-1]
'                    If ZRows=0 or ZColumns=0, the array is not modified.
'
'  -- ALGLIB --
'     2005-2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixBDMultiplyByQ(ByRef QP() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef TauQ() As Double, _
         ByRef z() As Double, _
         ByVal ZRows As Long, _
         ByVal ZColumns As Long, _
         ByVal FromTheRight As Boolean, _
         ByVal DoTranspose As Boolean)
    Dim i As Long
    Dim I1 As Long
    Dim I2 As Long
    Dim IStep As Long
    Dim V() As Double
    Dim WORK() As Double
    Dim MX As Long
    Dim i_ As Long
    Dim i1_ As Long
    If M <= 0# Or N <= 0# Or ZRows <= 0# Or ZColumns <= 0# Then
        Exit Sub
    End If
    
    '
    ' init
    '
    MX = MaxInt(M, N)
    MX = MaxInt(MX, ZRows)
    MX = MaxInt(MX, ZColumns)
    ReDim V(0 To MX + 1# - 1)
    ReDim WORK(0 To MX + 1# - 1)
    If M >= N Then
        
        '
        ' setup
        '
        If FromTheRight Then
            I1 = 0#
            I2 = N - 1#
            IStep = 1#
        Else
            I1 = N - 1#
            I2 = 0#
            IStep = -1#
        End If
        If DoTranspose Then
            i = I1
            I1 = I2
            I2 = i
            IStep = -IStep
        End If
        
        '
        ' Process
        '
        i = I1
        Do
            i1_ = (i) - (1#)
            For i_ = 1# To M - i Step 1
                V(i_) = QP(i_ + i1_, i)
            Next i_
            V(1#) = 1#
            If FromTheRight Then
                Call ApplyReflectionFromTheRight(z, TauQ(i), V, 0#, ZRows - 1#, i, M - 1#, WORK)
            Else
                Call ApplyReflectionFromTheLeft(z, TauQ(i), V, i, M - 1#, 0#, ZColumns - 1#, WORK)
            End If
            i = i + IStep
        Loop Until i = I2 + IStep
    Else
        
        '
        ' setup
        '
        If FromTheRight Then
            I1 = 0#
            I2 = M - 2#
            IStep = 1#
        Else
            I1 = M - 2#
            I2 = 0#
            IStep = -1#
        End If
        If DoTranspose Then
            i = I1
            I1 = I2
            I2 = i
            IStep = -IStep
        End If
        
        '
        ' Process
        '
        If M - 1# > 0# Then
            i = I1
            Do
                i1_ = (i + 1#) - (1#)
                For i_ = 1# To M - i - 1# Step 1
                    V(i_) = QP(i_ + i1_, i)
                Next i_
                V(1#) = 1#
                If FromTheRight Then
                    Call ApplyReflectionFromTheRight(z, TauQ(i), V, 0#, ZRows - 1#, i + 1#, M - 1#, WORK)
                Else
                    Call ApplyReflectionFromTheLeft(z, TauQ(i), V, i + 1#, M - 1#, 0#, ZColumns - 1#, WORK)
                End If
                i = i + IStep
            Loop Until i = I2 + IStep
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Unpacking matrix P which reduces matrix A to bidiagonal form.
'The subroutine returns transposed matrix P.
'
'Input parameters:
'    QP      -   matrices Q and P in compact form.
'                Output of ToBidiagonal subroutine.
'    M       -   number of rows in matrix A.
'    N       -   number of columns in matrix A.
'    TAUP    -   scalar factors which are used to form P.
'                Output of ToBidiagonal subroutine.
'    PTRows  -   required number of rows of matrix P^T. N >= PTRows >= 0.
'
'Output parameters:
'    PT      -   first PTRows columns of matrix P^T
'                Array[0..PTRows-1, 0..N-1]
'                If PTRows=0, the array is not modified.
'
'  -- ALGLIB --
'     2005-2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixBDUnpackPT(ByRef QP() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef TauP() As Double, _
         ByVal PTRows As Long, _
         ByRef PT() As Double)
    Dim i As Long
    Dim j As Long
    If M = 0# Or N = 0# Or PTRows = 0# Then
        Exit Sub
    End If
    
    '
    ' prepare PT
    '
    ReDim PT(0 To PTRows - 1, 0 To N - 1)
    For i = 0# To PTRows - 1# Step 1
        For j = 0# To N - 1# Step 1
            If i = j Then
                PT(i, j) = 1#
            Else
                PT(i, j) = 0#
            End If
        Next j
    Next i
    
    '
    ' Calculate
    '
    Call RMatrixBDMultiplyByP(QP, M, N, TauP, PT, PTRows, N, True, True)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Multiplication by matrix P which reduces matrix A to  bidiagonal form.
'
'The algorithm allows pre- or post-multiply by P or P'.
'
'Input parameters:
'    QP          -   matrices Q and P in compact form.
'                    Output of RMatrixBD subroutine.
'    M           -   number of rows in matrix A.
'    N           -   number of columns in matrix A.
'    TAUP        -   scalar factors which are used to form P.
'                    Output of RMatrixBD subroutine.
'    Z           -   multiplied matrix.
'                    Array whose indexes range within [0..ZRows-1,0..ZColumns-1].
'    ZRows       -   number of rows in matrix Z. If FromTheRight=False,
'                    ZRows=N, otherwise ZRows can be arbitrary.
'    ZColumns    -   number of columns in matrix Z. If FromTheRight=True,
'                    ZColumns=N, otherwise ZColumns can be arbitrary.
'    FromTheRight -  pre- or post-multiply.
'    DoTranspose -   multiply by P or P'.
'
'Output parameters:
'    Z - product of Z and P.
'                Array whose indexes range within [0..ZRows-1,0..ZColumns-1].
'                If ZRows=0 or ZColumns=0, the array is not modified.
'
'  -- ALGLIB --
'     2005-2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixBDMultiplyByP(ByRef QP() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef TauP() As Double, _
         ByRef z() As Double, _
         ByVal ZRows As Long, _
         ByVal ZColumns As Long, _
         ByVal FromTheRight As Boolean, _
         ByVal DoTranspose As Boolean)
    Dim i As Long
    Dim V() As Double
    Dim WORK() As Double
    Dim MX As Long
    Dim I1 As Long
    Dim I2 As Long
    Dim IStep As Long
    Dim i_ As Long
    Dim i1_ As Long
    If M <= 0# Or N <= 0# Or ZRows <= 0# Or ZColumns <= 0# Then
        Exit Sub
    End If
    
    '
    ' init
    '
    MX = MaxInt(M, N)
    MX = MaxInt(MX, ZRows)
    MX = MaxInt(MX, ZColumns)
    ReDim V(0 To MX + 1# - 1)
    ReDim WORK(0 To MX + 1# - 1)
    If M >= N Then
        
        '
        ' setup
        '
        If FromTheRight Then
            I1 = N - 2#
            I2 = 0#
            IStep = -1#
        Else
            I1 = 0#
            I2 = N - 2#
            IStep = 1#
        End If
        If Not DoTranspose Then
            i = I1
            I1 = I2
            I2 = i
            IStep = -IStep
        End If
        
        '
        ' Process
        '
        If N - 1# > 0# Then
            i = I1
            Do
                i1_ = (i + 1#) - (1#)
                For i_ = 1# To N - 1# - i Step 1
                    V(i_) = QP(i, i_ + i1_)
                Next i_
                V(1#) = 1#
                If FromTheRight Then
                    Call ApplyReflectionFromTheRight(z, TauP(i), V, 0#, ZRows - 1#, i + 1#, N - 1#, WORK)
                Else
                    Call ApplyReflectionFromTheLeft(z, TauP(i), V, i + 1#, N - 1#, 0#, ZColumns - 1#, WORK)
                End If
                i = i + IStep
            Loop Until i = I2 + IStep
        End If
    Else
        
        '
        ' setup
        '
        If FromTheRight Then
            I1 = M - 1#
            I2 = 0#
            IStep = -1#
        Else
            I1 = 0#
            I2 = M - 1#
            IStep = 1#
        End If
        If Not DoTranspose Then
            i = I1
            I1 = I2
            I2 = i
            IStep = -IStep
        End If
        
        '
        ' Process
        '
        i = I1
        Do
            i1_ = (i) - (1#)
            For i_ = 1# To N - i Step 1
                V(i_) = QP(i, i_ + i1_)
            Next i_
            V(1#) = 1#
            If FromTheRight Then
                Call ApplyReflectionFromTheRight(z, TauP(i), V, 0#, ZRows - 1#, i, N - 1#, WORK)
            Else
                Call ApplyReflectionFromTheLeft(z, TauP(i), V, i, N - 1#, 0#, ZColumns - 1#, WORK)
            End If
            i = i + IStep
        Loop Until i = I2 + IStep
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Unpacking of the main and secondary diagonals of bidiagonal decomposition
'of matrix A.
'
'Input parameters:
'    B   -   output of RMatrixBD subroutine.
'    M   -   number of rows in matrix B.
'    N   -   number of columns in matrix B.
'
'Output parameters:
'    IsUpper -   True, if the matrix is upper bidiagonal.
'                otherwise IsUpper is False.
'    D       -   the main diagonal.
'                Array whose index ranges within [0..Min(M,N)-1].
'    E       -   the secondary diagonal (upper or lower, depending on
'                the value of IsUpper).
'                Array index ranges within [0..Min(M,N)-1], the last
'                element is not used.
'
'  -- ALGLIB --
'     2005-2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixBDUnpackDiagonals(ByRef B() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef IsUpper As Boolean, _
         ByRef D() As Double, _
         ByRef E() As Double)
    Dim i As Long
    IsUpper = M >= N
    If M <= 0# Or N <= 0# Then
        Exit Sub
    End If
    If IsUpper Then
        ReDim D(0 To N - 1)
        ReDim E(0 To N - 1)
        For i = 0# To N - 2# Step 1
            D(i) = B(i, i)
            E(i) = B(i, i + 1#)
        Next i
        D(N - 1#) = B(N - 1#, N - 1#)
    Else
        ReDim D(0 To M - 1)
        ReDim E(0 To M - 1)
        For i = 0# To M - 2# Step 1
            D(i) = B(i, i)
            E(i) = B(i + 1#, i)
        Next i
        D(M - 1#) = B(M - 1#, M - 1#)
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Reduction of a square matrix to  upper Hessenberg form: Q'*A*Q = H,
'where Q is an orthogonal matrix, H - Hessenberg matrix.
'
'Input parameters:
'    A       -   matrix A with elements [0..N-1, 0..N-1]
'    N       -   size of matrix A.
'
'Output parameters:
'    A       -   matrices Q and P in  compact form (see below).
'    Tau     -   array of scalar factors which are used to form matrix Q.
'                Array whose index ranges within [0..N-2]
'
'Matrix H is located on the main diagonal, on the lower secondary  diagonal
'and above the main diagonal of matrix A. The elements which are used to
'form matrix Q are situated in array Tau and below the lower secondary
'diagonal of matrix A as follows:
'
'Matrix Q is represented as a product of elementary reflections
'
'Q = H(0)*H(2)*...*H(n-2),
'
'where each H(i) is given by
'
'H(i) = 1 - tau * v * (v^T)
'
'where tau is a scalar stored in Tau[I]; v - is a real vector,
'so that v(0:i) = 0, v(i+1) = 1, v(i+2:n-1) stored in A(i+2:n-1,i).
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     October 31, 1992
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixHessenberg(ByRef A() As Double, _
         ByVal N As Long, _
         ByRef Tau() As Double)
    Dim i As Long
    Dim V As Double
    Dim T() As Double
    Dim WORK() As Double
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' Quick return if possible
    '
    If N <= 1# Then
        Exit Sub
    End If
    ReDim Tau(0# To N - 2#)
    ReDim T(1# To N)
    ReDim WORK(0# To N - 1#)
    For i = 0# To N - 2# Step 1
        
        '
        ' Compute elementary reflector H(i) to annihilate A(i+2:ihi,i)
        '
        i1_ = (i + 1#) - (1#)
        For i_ = 1# To N - i - 1# Step 1
            T(i_) = A(i_ + i1_, i)
        Next i_
        Call GenerateReflection(T, N - i - 1#, V)
        i1_ = (1#) - (i + 1#)
        For i_ = i + 1# To N - 1# Step 1
            A(i_, i) = T(i_ + i1_)
        Next i_
        Tau(i) = V
        T(1#) = 1#
        
        '
        ' Apply H(i) to A(1:ihi,i+1:ihi) from the right
        '
        Call ApplyReflectionFromTheRight(A, V, T, 0#, N - 1#, i + 1#, N - 1#, WORK)
        
        '
        ' Apply H(i) to A(i+1:ihi,i+1:n) from the left
        '
        Call ApplyReflectionFromTheLeft(A, V, T, i + 1#, N - 1#, i + 1#, N - 1#, WORK)
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Unpacking matrix Q which reduces matrix A to upper Hessenberg form
'
'Input parameters:
'    A   -   output of RMatrixHessenberg subroutine.
'    N   -   size of matrix A.
'    Tau -   scalar factors which are used to form Q.
'            Output of RMatrixHessenberg subroutine.
'
'Output parameters:
'    Q   -   matrix Q.
'            Array whose indexes range within [0..N-1, 0..N-1].
'
'  -- ALGLIB --
'     2005-2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixHessenbergUnpackQ(ByRef A() As Double, _
         ByVal N As Long, _
         ByRef Tau() As Double, _
         ByRef q() As Double)
    Dim i As Long
    Dim j As Long
    Dim V() As Double
    Dim WORK() As Double
    Dim i_ As Long
    Dim i1_ As Long
    If N = 0# Then
        Exit Sub
    End If
    
    '
    ' init
    '
    ReDim q(0# To N - 1#, 0# To N - 1#)
    ReDim V(0# To N - 1#)
    ReDim WORK(0# To N - 1#)
    For i = 0# To N - 1# Step 1
        For j = 0# To N - 1# Step 1
            If i = j Then
                q(i, j) = 1#
            Else
                q(i, j) = 0#
            End If
        Next j
    Next i
    
    '
    ' unpack Q
    '
    For i = 0# To N - 2# Step 1
        
        '
        ' Apply H(i)
        '
        i1_ = (i + 1#) - (1#)
        For i_ = 1# To N - i - 1# Step 1
            V(i_) = A(i_ + i1_, i)
        Next i_
        V(1#) = 1#
        Call ApplyReflectionFromTheRight(q, Tau(i), V, 0#, N - 1#, i + 1#, N - 1#, WORK)
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Unpacking matrix H (the result of matrix A reduction to upper Hessenberg form)
'
'Input parameters:
'    A   -   output of RMatrixHessenberg subroutine.
'    N   -   size of matrix A.
'
'Output parameters:
'    H   -   matrix H. Array whose indexes range within [0..N-1, 0..N-1].
'
'  -- ALGLIB --
'     2005-2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixHessenbergUnpackH(ByRef A() As Double, _
         ByVal N As Long, _
         ByRef H() As Double)
    Dim i As Long
    Dim j As Long
    Dim V() As Double
    Dim WORK() As Double
    Dim i_ As Long
    If N = 0# Then
        Exit Sub
    End If
    ReDim H(0# To N - 1#, 0# To N - 1#)
    For i = 0# To N - 1# Step 1
        For j = 0# To i - 2# Step 1
            H(i, j) = 0#
        Next j
        j = MaxInt(0#, i - 1#)
        For i_ = j To N - 1# Step 1
            H(i, i_) = A(i, i_)
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Reduction of a symmetric matrix which is given by its higher or lower
'triangular part to a tridiagonal matrix using orthogonal similarity
'transformation: Q'*A*Q=T.
'
'Input parameters:
'    A       -   matrix to be transformed
'                array with elements [0..N-1, 0..N-1].
'    N       -   size of matrix A.
'    IsUpper -   storage format. If IsUpper = True, then matrix A is given
'                by its upper triangle, and the lower triangle is not used
'                and not modified by the algorithm, and vice versa
'                if IsUpper = False.
'
'Output parameters:
'    A       -   matrices T and Q in  compact form (see lower)
'    Tau     -   array of factors which are forming matrices H(i)
'                array with elements [0..N-2].
'    D       -   main diagonal of symmetric matrix T.
'                array with elements [0..N-1].
'    E       -   secondary diagonal of symmetric matrix T.
'                array with elements [0..N-2].
'
'
'  If IsUpper=True, the matrix Q is represented as a product of elementary
'  reflectors
'
'     Q = H(n-2) . . . H(2) H(0).
'
'  Each H(i) has the form
'
'     H(i) = I - tau * v * v'
'
'  where tau is a real scalar, and v is a real vector with
'  v(i+1:n-1) = 0, v(i) = 1, v(0:i-1) is stored on exit in
'  A(0:i-1,i+1), and tau in TAU(i).
'
'  If IsUpper=False, the matrix Q is represented as a product of elementary
'  reflectors
'
'     Q = H(0) H(2) . . . H(n-2).
'
'  Each H(i) has the form
'
'     H(i) = I - tau * v * v'
'
'  where tau is a real scalar, and v is a real vector with
'  v(0:i) = 0, v(i+1) = 1, v(i+2:n-1) is stored on exit in A(i+2:n-1,i),
'  and tau in TAU(i).
'
'  The contents of A on exit are illustrated by the following examples
'  with n = 5:
'
'  if UPLO = 'U':                       if UPLO = 'L':
'
'    (  d   e   v1  v2  v3 )              (  d                  )
'    (      d   e   v2  v3 )              (  e   d              )
'    (          d   e   v3 )              (  v0  e   d          )
'    (              d   e  )              (  v0  v1  e   d      )
'    (                  d  )              (  v0  v1  v2  e   d  )
'
'  where d and e denote diagonal and off-diagonal elements of T, and vi
'  denotes an element of the vector defining H(i).
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     October 31, 1992
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub SMatrixTD(ByRef A() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef Tau() As Double, _
         ByRef D() As Double, _
         ByRef E() As Double)
    Dim i As Long
    Dim Alpha As Double
    Dim TauI As Double
    Dim V As Double
    Dim T() As Double
    Dim T2() As Double
    Dim T3() As Double
    Dim i_ As Long
    Dim i1_ As Long
    If N <= 0# Then
        Exit Sub
    End If
    ReDim T(1# To N)
    ReDim T2(1# To N)
    ReDim T3(1# To N)
    If N > 1# Then
        ReDim Tau(0# To N - 2#)
    End If
    ReDim D(0# To N - 1#)
    If N > 1# Then
        ReDim E(0# To N - 2#)
    End If
    If IsUpper Then
        
        '
        ' Reduce the upper triangle of A
        '
        For i = N - 2# To 0# Step -1
            
            '
            ' Generate elementary reflector H() = E - tau * v * v'
            '
            If i >= 1# Then
                i1_ = (0#) - (2#)
                For i_ = 2# To i + 1# Step 1
                    T(i_) = A(i_ + i1_, i + 1#)
                Next i_
            End If
            T(1#) = A(i, i + 1#)
            Call GenerateReflection(T, i + 1#, TauI)
            If i >= 1# Then
                i1_ = (2#) - (0#)
                For i_ = 0# To i - 1# Step 1
                    A(i_, i + 1#) = T(i_ + i1_)
                Next i_
            End If
            A(i, i + 1#) = T(1#)
            E(i) = A(i, i + 1#)
            If TauI <> 0# Then
                
                '
                ' Apply H from both sides to A
                '
                A(i, i + 1#) = 1#
                
                '
                ' Compute  x := tau * A * v  storing x in TAU
                '
                i1_ = (0#) - (1#)
                For i_ = 1# To i + 1# Step 1
                    T(i_) = A(i_ + i1_, i + 1#)
                Next i_
                Call SymmetricMatrixVectorMultiply(A, IsUpper, 0#, i, T, TauI, T3)
                i1_ = (1#) - (0#)
                For i_ = 0# To i Step 1
                    Tau(i_) = T3(i_ + i1_)
                Next i_
                
                '
                ' Compute  w := x - 1/2 * tau * (x'*v) * v
                '
                V = 0#
                For i_ = 0# To i Step 1
                    V = V + Tau(i_) * A(i_, i + 1#)
                Next i_
                Alpha = -(0.5 * TauI * V)
                For i_ = 0# To i Step 1
                    Tau(i_) = Tau(i_) + Alpha * A(i_, i + 1#)
                Next i_
                
                '
                ' Apply the transformation as a rank-2 update:
                '    A := A - v * w' - w * v'
                '
                i1_ = (0#) - (1#)
                For i_ = 1# To i + 1# Step 1
                    T(i_) = A(i_ + i1_, i + 1#)
                Next i_
                i1_ = (0#) - (1#)
                For i_ = 1# To i + 1# Step 1
                    T3(i_) = Tau(i_ + i1_)
                Next i_
                Call SymmetricRank2Update(A, IsUpper, 0#, i, T, T3, T2, -1#)
                A(i, i + 1#) = E(i)
            End If
            D(i + 1#) = A(i + 1#, i + 1#)
            Tau(i) = TauI
        Next i
        D(0#) = A(0#, 0#)
    Else
        
        '
        ' Reduce the lower triangle of A
        '
        For i = 0# To N - 2# Step 1
            
            '
            ' Generate elementary reflector H = E - tau * v * v'
            '
            i1_ = (i + 1#) - (1#)
            For i_ = 1# To N - i - 1# Step 1
                T(i_) = A(i_ + i1_, i)
            Next i_
            Call GenerateReflection(T, N - i - 1#, TauI)
            i1_ = (1#) - (i + 1#)
            For i_ = i + 1# To N - 1# Step 1
                A(i_, i) = T(i_ + i1_)
            Next i_
            E(i) = A(i + 1#, i)
            If TauI <> 0# Then
                
                '
                ' Apply H from both sides to A
                '
                A(i + 1#, i) = 1#
                
                '
                ' Compute  x := tau * A * v  storing y in TAU
                '
                i1_ = (i + 1#) - (1#)
                For i_ = 1# To N - i - 1# Step 1
                    T(i_) = A(i_ + i1_, i)
                Next i_
                Call SymmetricMatrixVectorMultiply(A, IsUpper, i + 1#, N - 1#, T, TauI, T2)
                i1_ = (1#) - (i)
                For i_ = i To N - 2# Step 1
                    Tau(i_) = T2(i_ + i1_)
                Next i_
                
                '
                ' Compute  w := x - 1/2 * tau * (x'*v) * v
                '
                i1_ = (i + 1#) - (i)
                V = 0#
                For i_ = i To N - 2# Step 1
                    V = V + Tau(i_) * A(i_ + i1_, i)
                Next i_
                Alpha = -(0.5 * TauI * V)
                i1_ = (i + 1#) - (i)
                For i_ = i To N - 2# Step 1
                    Tau(i_) = Tau(i_) + Alpha * A(i_ + i1_, i)
                Next i_
                
                '
                ' Apply the transformation as a rank-2 update:
                '     A := A - v * w' - w * v'
                '
                '
                i1_ = (i + 1#) - (1#)
                For i_ = 1# To N - i - 1# Step 1
                    T(i_) = A(i_ + i1_, i)
                Next i_
                i1_ = (i) - (1#)
                For i_ = 1# To N - i - 1# Step 1
                    T2(i_) = Tau(i_ + i1_)
                Next i_
                Call SymmetricRank2Update(A, IsUpper, i + 1#, N - 1#, T, T2, T3, -1#)
                A(i + 1#, i) = E(i)
            End If
            D(i) = A(i, i)
            Tau(i) = TauI
        Next i
        D(N - 1#) = A(N - 1#, N - 1#)
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Unpacking matrix Q which reduces symmetric matrix to a tridiagonal
'form.
'
'Input parameters:
'    A       -   the result of a SMatrixTD subroutine
'    N       -   size of matrix A.
'    IsUpper -   storage format (a parameter of SMatrixTD subroutine)
'    Tau     -   the result of a SMatrixTD subroutine
'
'Output parameters:
'    Q       -   transformation matrix.
'                array with elements [0..N-1, 0..N-1].
'
'  -- ALGLIB --
'     Copyright 2005-2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub SMatrixTDUnpackQ(ByRef A() As Double, _
         ByRef N As Long, _
         ByRef IsUpper As Boolean, _
         ByRef Tau() As Double, _
         ByRef q() As Double)
    Dim i As Long
    Dim j As Long
    Dim V() As Double
    Dim WORK() As Double
    Dim i_ As Long
    Dim i1_ As Long
    If N = 0# Then
        Exit Sub
    End If
    
    '
    ' init
    '
    ReDim q(0# To N - 1#, 0# To N - 1#)
    ReDim V(1# To N)
    ReDim WORK(0# To N - 1#)
    For i = 0# To N - 1# Step 1
        For j = 0# To N - 1# Step 1
            If i = j Then
                q(i, j) = 1#
            Else
                q(i, j) = 0#
            End If
        Next j
    Next i
    
    '
    ' unpack Q
    '
    If IsUpper Then
        For i = 0# To N - 2# Step 1
            
            '
            ' Apply H(i)
            '
            i1_ = (0#) - (1#)
            For i_ = 1# To i + 1# Step 1
                V(i_) = A(i_ + i1_, i + 1#)
            Next i_
            V(i + 1#) = 1#
            Call ApplyReflectionFromTheLeft(q, Tau(i), V, 0#, i, 0#, N - 1#, WORK)
        Next i
    Else
        For i = N - 2# To 0# Step -1
            
            '
            ' Apply H(i)
            '
            i1_ = (i + 1#) - (1#)
            For i_ = 1# To N - i - 1# Step 1
                V(i_) = A(i_ + i1_, i)
            Next i_
            V(1#) = 1#
            Call ApplyReflectionFromTheLeft(q, Tau(i), V, i + 1#, N - 1#, 0#, N - 1#, WORK)
        Next i
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Reduction of a Hermitian matrix which is given  by  its  higher  or  lower
'triangular part to a real  tridiagonal  matrix  using  unitary  similarity
'transformation: Q'*A*Q = T.
'
'Input parameters:
'    A       -   matrix to be transformed
'                array with elements [0..N-1, 0..N-1].
'    N       -   size of matrix A.
'    IsUpper -   storage format. If IsUpper = True, then matrix A is  given
'                by its upper triangle, and the lower triangle is not  used
'                and not modified by the algorithm, and vice versa
'                if IsUpper = False.
'
'Output parameters:
'    A       -   matrices T and Q in  compact form (see lower)
'    Tau     -   array of factors which are forming matrices H(i)
'                array with elements [0..N-2].
'    D       -   main diagonal of real symmetric matrix T.
'                array with elements [0..N-1].
'    E       -   secondary diagonal of real symmetric matrix T.
'                array with elements [0..N-2].
'
'
'  If IsUpper=True, the matrix Q is represented as a product of elementary
'  reflectors
'
'     Q = H(n-2) . . . H(2) H(0).
'
'  Each H(i) has the form
'
'     H(i) = I - tau * v * v'
'
'  where tau is a complex scalar, and v is a complex vector with
'  v(i+1:n-1) = 0, v(i) = 1, v(0:i-1) is stored on exit in
'  A(0:i-1,i+1), and tau in TAU(i).
'
'  If IsUpper=False, the matrix Q is represented as a product of elementary
'  reflectors
'
'     Q = H(0) H(2) . . . H(n-2).
'
'  Each H(i) has the form
'
'     H(i) = I - tau * v * v'
'
'  where tau is a complex scalar, and v is a complex vector with
'  v(0:i) = 0, v(i+1) = 1, v(i+2:n-1) is stored on exit in A(i+2:n-1,i),
'  and tau in TAU(i).
'
'  The contents of A on exit are illustrated by the following examples
'  with n = 5:
'
'  if UPLO = 'U':                       if UPLO = 'L':
'
'    (  d   e   v1  v2  v3 )              (  d                  )
'    (      d   e   v2  v3 )              (  e   d              )
'    (          d   e   v3 )              (  v0  e   d          )
'    (              d   e  )              (  v0  v1  e   d      )
'    (                  d  )              (  v0  v1  v2  e   d  )
'
'where d and e denote diagonal and off-diagonal elements of T, and vi
'denotes an element of the vector defining H(i).
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     October 31, 1992
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub HMatrixTD(ByRef A() As Complex, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef Tau() As Complex, _
         ByRef D() As Double, _
         ByRef E() As Double)
    Dim i As Long
    Dim Alpha As Complex
    Dim TauI As Complex
    Dim V As Complex
    Dim T() As Complex
    Dim T2() As Complex
    Dim T3() As Complex
    Dim i_ As Long
    Dim i1_ As Long
    If N <= 0# Then
        Exit Sub
    End If
    For i = 0# To N - 1# Step 1
    Next i
    If N > 1# Then
        ReDim Tau(0# To N - 2#)
        ReDim E(0# To N - 2#)
    End If
    ReDim D(0# To N - 1#)
    ReDim T(0# To N - 1#)
    ReDim T2(0# To N - 1#)
    ReDim T3(0# To N - 1#)
    If IsUpper Then
        
        '
        ' Reduce the upper triangle of A
        '
        A(N - 1#, N - 1#) = C_Complex(A(N - 1#, N - 1#).X)
        For i = N - 2# To 0# Step -1
            
            '
            ' Generate elementary reflector H = I+1 - tau * v * v'
            '
            Alpha = A(i, i + 1#)
            T(1#) = Alpha
            If i >= 1# Then
                i1_ = (0#) - (2#)
                For i_ = 2# To i + 1# Step 1
                    T(i_) = A(i_ + i1_, i + 1#)
                Next i_
            End If
            Call ComplexGenerateReflection(T, i + 1#, TauI)
            If i >= 1# Then
                i1_ = (2#) - (0#)
                For i_ = 0# To i - 1# Step 1
                    A(i_, i + 1#) = T(i_ + i1_)
                Next i_
            End If
            Alpha = T(1#)
            E(i) = Alpha.X
            If C_NotEqualR(TauI, 0#) Then
                
                '
                ' Apply H(I+1) from both sides to A
                '
                A(i, i + 1#) = C_Complex(1#)
                
                '
                ' Compute  x := tau * A * v  storing x in TAU
                '
                i1_ = (0#) - (1#)
                For i_ = 1# To i + 1# Step 1
                    T(i_) = A(i_ + i1_, i + 1#)
                Next i_
                Call HermitianMatrixVectorMultiply(A, IsUpper, 0#, i, T, TauI, T2)
                i1_ = (1#) - (0#)
                For i_ = 0# To i Step 1
                    Tau(i_) = T2(i_ + i1_)
                Next i_
                
                '
                ' Compute  w := x - 1/2 * tau * (x'*v) * v
                '
                V = C_Complex(0#)
                For i_ = 0# To i Step 1
                    V = C_Add(V, C_Mul(Conj(Tau(i_)), A(i_, i + 1#)))
                Next i_
                Alpha = C_Opposite(C_Mul(C_MulR(TauI, 0.5), V))
                For i_ = 0# To i Step 1
                    Tau(i_) = C_Add(Tau(i_), C_Mul(Alpha, A(i_, i + 1#)))
                Next i_
                
                '
                ' Apply the transformation as a rank-2 update:
                '    A := A - v * w' - w * v'
                '
                i1_ = (0#) - (1#)
                For i_ = 1# To i + 1# Step 1
                    T(i_) = A(i_ + i1_, i + 1#)
                Next i_
                i1_ = (0#) - (1#)
                For i_ = 1# To i + 1# Step 1
                    T3(i_) = Tau(i_ + i1_)
                Next i_
                Call HermitianRank2Update(A, IsUpper, 0#, i, T, T3, T2, C_Complex(-1#))
            Else
                A(i, i) = C_Complex(A(i, i).X)
            End If
            A(i, i + 1#) = C_Complex(E(i))
            D(i + 1#) = A(i + 1#, i + 1#).X
            Tau(i) = TauI
        Next i
        D(0#) = A(0#, 0#).X
    Else
        
        '
        ' Reduce the lower triangle of A
        '
        A(0#, 0#) = C_Complex(A(0#, 0#).X)
        For i = 0# To N - 2# Step 1
            
            '
            ' Generate elementary reflector H = I - tau * v * v'
            '
            i1_ = (i + 1#) - (1#)
            For i_ = 1# To N - i - 1# Step 1
                T(i_) = A(i_ + i1_, i)
            Next i_
            Call ComplexGenerateReflection(T, N - i - 1#, TauI)
            i1_ = (1#) - (i + 1#)
            For i_ = i + 1# To N - 1# Step 1
                A(i_, i) = T(i_ + i1_)
            Next i_
            E(i) = A(i + 1#, i).X
            If C_NotEqualR(TauI, 0#) Then
                
                '
                ' Apply H(i) from both sides to A(i+1:n,i+1:n)
                '
                A(i + 1#, i) = C_Complex(1#)
                
                '
                ' Compute  x := tau * A * v  storing y in TAU
                '
                i1_ = (i + 1#) - (1#)
                For i_ = 1# To N - i - 1# Step 1
                    T(i_) = A(i_ + i1_, i)
                Next i_
                Call HermitianMatrixVectorMultiply(A, IsUpper, i + 1#, N - 1#, T, TauI, T2)
                i1_ = (1#) - (i)
                For i_ = i To N - 2# Step 1
                    Tau(i_) = T2(i_ + i1_)
                Next i_
                
                '
                ' Compute  w := x - 1/2 * tau * (x'*v) * v
                '
                i1_ = (i + 1#) - (i)
                V = C_Complex(0#)
                For i_ = i To N - 2# Step 1
                    V = C_Add(V, C_Mul(Conj(Tau(i_)), A(i_ + i1_, i)))
                Next i_
                Alpha = C_Opposite(C_Mul(C_MulR(TauI, 0.5), V))
                i1_ = (i + 1#) - (i)
                For i_ = i To N - 2# Step 1
                    Tau(i_) = C_Add(Tau(i_), C_Mul(Alpha, A(i_ + i1_, i)))
                Next i_
                
                '
                ' Apply the transformation as a rank-2 update:
                ' A := A - v * w' - w * v'
                '
                i1_ = (i + 1#) - (1#)
                For i_ = 1# To N - i - 1# Step 1
                    T(i_) = A(i_ + i1_, i)
                Next i_
                i1_ = (i) - (1#)
                For i_ = 1# To N - i - 1# Step 1
                    T2(i_) = Tau(i_ + i1_)
                Next i_
                Call HermitianRank2Update(A, IsUpper, i + 1#, N - 1#, T, T2, T3, C_Complex(-1#))
            Else
                A(i + 1#, i + 1#) = C_Complex(A(i + 1#, i + 1#).X)
            End If
            A(i + 1#, i) = C_Complex(E(i))
            D(i) = A(i, i).X
            Tau(i) = TauI
        Next i
        D(N - 1#) = A(N - 1#, N - 1#).X
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Unpacking matrix Q which reduces a Hermitian matrix to a real  tridiagonal
'form.
'
'Input parameters:
'    A       -   the result of a HMatrixTD subroutine
'    N       -   size of matrix A.
'    IsUpper -   storage format (a parameter of HMatrixTD subroutine)
'    Tau     -   the result of a HMatrixTD subroutine
'
'Output parameters:
'    Q       -   transformation matrix.
'                array with elements [0..N-1, 0..N-1].
'
'  -- ALGLIB --
'     Copyright 2005-2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub HMatrixTDUnpackQ(ByRef A() As Complex, _
         ByRef N As Long, _
         ByRef IsUpper As Boolean, _
         ByRef Tau() As Complex, _
         ByRef q() As Complex)
    Dim i As Long
    Dim j As Long
    Dim V() As Complex
    Dim WORK() As Complex
    Dim i_ As Long
    Dim i1_ As Long
    If N = 0# Then
        Exit Sub
    End If
    
    '
    ' init
    '
    ReDim q(0# To N - 1#, 0# To N - 1#)
    ReDim V(1# To N)
    ReDim WORK(0# To N - 1#)
    For i = 0# To N - 1# Step 1
        For j = 0# To N - 1# Step 1
            If i = j Then
                q(i, j) = C_Complex(1#)
            Else
                q(i, j) = C_Complex(0#)
            End If
        Next j
    Next i
    
    '
    ' unpack Q
    '
    If IsUpper Then
        For i = 0# To N - 2# Step 1
            
            '
            ' Apply H(i)
            '
            i1_ = (0#) - (1#)
            For i_ = 1# To i + 1# Step 1
                V(i_) = A(i_ + i1_, i + 1#)
            Next i_
            V(i + 1#) = C_Complex(1#)
            Call ComplexApplyReflectionFromTheLeft(q, Tau(i), V, 0#, i, 0#, N - 1#, WORK)
        Next i
    Else
        For i = N - 2# To 0# Step -1
            
            '
            ' Apply H(i)
            '
            i1_ = (i + 1#) - (1#)
            For i_ = 1# To N - i - 1# Step 1
                V(i_) = A(i_ + i1_, i)
            Next i_
            V(1#) = C_Complex(1#)
            Call ComplexApplyReflectionFromTheLeft(q, Tau(i), V, i + 1#, N - 1#, 0#, N - 1#, WORK)
        Next i
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Base case for real QR
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     September 30, 1994.
'     Sergey Bochkanov, ALGLIB project, translation from FORTRAN to
'     pseudocode, 2007-2010.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub RMatrixQRBaseCase(ByRef A() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef WORK() As Double, _
         ByRef T() As Double, _
         ByRef Tau() As Double)
    Dim i As Long
    Dim K As Long
    Dim MinMN As Long
    Dim Tmp As Double
    Dim i_ As Long
    Dim i1_ As Long
    MinMN = MinInt(M, N)
    
    '
    ' Test the input arguments
    '
    K = MinMN
    For i = 0# To K - 1# Step 1
        
        '
        ' Generate elementary reflector H(i) to annihilate A(i+1:m,i)
        '
        i1_ = (i) - (1#)
        For i_ = 1# To M - i Step 1
            T(i_) = A(i_ + i1_, i)
        Next i_
        Call GenerateReflection(T, M - i, Tmp)
        Tau(i) = Tmp
        i1_ = (1#) - (i)
        For i_ = i To M - 1# Step 1
            A(i_, i) = T(i_ + i1_)
        Next i_
        T(1#) = 1#
        If i < N Then
            
            '
            ' Apply H(i) to A(i:m-1,i+1:n-1) from the left
            '
            Call ApplyReflectionFromTheLeft(A, Tau(i), T, i, M - 1#, i + 1#, N - 1#, WORK)
        End If
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Base case for real LQ
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     September 30, 1994.
'     Sergey Bochkanov, ALGLIB project, translation from FORTRAN to
'     pseudocode, 2007-2010.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub RMatrixLQBaseCase(ByRef A() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef WORK() As Double, _
         ByRef T() As Double, _
         ByRef Tau() As Double)
    Dim i As Long
    Dim K As Long
    Dim MinMN As Long
    Dim Tmp As Double
    Dim i_ As Long
    Dim i1_ As Long
    MinMN = MinInt(M, N)
    K = MinInt(M, N)
    For i = 0# To K - 1# Step 1
        
        '
        ' Generate elementary reflector H(i) to annihilate A(i,i+1:n-1)
        '
        i1_ = (i) - (1#)
        For i_ = 1# To N - i Step 1
            T(i_) = A(i, i_ + i1_)
        Next i_
        Call GenerateReflection(T, N - i, Tmp)
        Tau(i) = Tmp
        i1_ = (1#) - (i)
        For i_ = i To N - 1# Step 1
            A(i, i_) = T(i_ + i1_)
        Next i_
        T(1#) = 1#
        If i < N Then
            
            '
            ' Apply H(i) to A(i+1:m,i:n) from the right
            '
            Call ApplyReflectionFromTheRight(A, Tau(i), T, i + 1#, M - 1#, i, N - 1#, WORK)
        End If
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Base case for complex QR
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     September 30, 1994.
'     Sergey Bochkanov, ALGLIB project, translation from FORTRAN to
'     pseudocode, 2007-2010.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub CMatrixQRBaseCase(ByRef A() As Complex, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef WORK() As Complex, _
         ByRef T() As Complex, _
         ByRef Tau() As Complex)
    Dim i As Long
    Dim K As Long
    Dim MMI As Long
    Dim MinMN As Long
    Dim Tmp As Complex
    Dim i_ As Long
    Dim i1_ As Long
    MinMN = MinInt(M, N)
    If MinMN <= 0# Then
        Exit Sub
    End If
    
    '
    ' Test the input arguments
    '
    K = MinInt(M, N)
    For i = 0# To K - 1# Step 1
        
        '
        ' Generate elementary reflector H(i) to annihilate A(i+1:m,i)
        '
        MMI = M - i
        i1_ = (i) - (1#)
        For i_ = 1# To MMI Step 1
            T(i_) = A(i_ + i1_, i)
        Next i_
        Call ComplexGenerateReflection(T, MMI, Tmp)
        Tau(i) = Tmp
        i1_ = (1#) - (i)
        For i_ = i To M - 1# Step 1
            A(i_, i) = T(i_ + i1_)
        Next i_
        T(1#) = C_Complex(1#)
        If i < N - 1# Then
            
            '
            ' Apply H'(i) to A(i:m,i+1:n) from the left
            '
            Call ComplexApplyReflectionFromTheLeft(A, Conj(Tau(i)), T, i, M - 1#, i + 1#, N - 1#, WORK)
        End If
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Base case for complex LQ
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     September 30, 1994.
'     Sergey Bochkanov, ALGLIB project, translation from FORTRAN to
'     pseudocode, 2007-2010.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub CMatrixLQBaseCase(ByRef A() As Complex, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef WORK() As Complex, _
         ByRef T() As Complex, _
         ByRef Tau() As Complex)
    Dim i As Long
    Dim MinMN As Long
    Dim Tmp As Complex
    Dim i_ As Long
    Dim i1_ As Long
    MinMN = MinInt(M, N)
    If MinMN <= 0# Then
        Exit Sub
    End If
    
    '
    ' Test the input arguments
    '
    For i = 0# To MinMN - 1# Step 1
        
        '
        ' Generate elementary reflector H(i)
        '
        ' NOTE: ComplexGenerateReflection() generates left reflector,
        ' i.e. H which reduces x by applyiong from the left, but we
        ' need RIGHT reflector. So we replace H=E-tau*v*v' by H^H,
        ' which changes v to conj(v).
        '
        i1_ = (i) - (1#)
        For i_ = 1# To N - i Step 1
            T(i_) = Conj(A(i, i_ + i1_))
        Next i_
        Call ComplexGenerateReflection(T, N - i, Tmp)
        Tau(i) = Tmp
        i1_ = (1#) - (i)
        For i_ = i To N - 1# Step 1
            A(i, i_) = Conj(T(i_ + i1_))
        Next i_
        T(1#) = C_Complex(1#)
        If i < M - 1# Then
            
            '
            ' Apply H'(i)
            '
            Call ComplexApplyReflectionFromTheRight(A, Tau(i), T, i + 1#, M - 1#, i, N - 1#, WORK)
        End If
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Generate block reflector:
'* fill unused parts of reflectors matrix by zeros
'* fill diagonal of reflectors matrix by ones
'* generate triangular factor T
'
'PARAMETERS:
'    A           -   either LengthA*BlockSize (if ColumnwiseA) or
'                    BlockSize*LengthA (if not ColumnwiseA) matrix of
'                    elementary reflectors.
'                    Modified on exit.
'    Tau         -   scalar factors
'    ColumnwiseA -   reflectors are stored in rows or in columns
'    LengthA     -   length of largest reflector
'    BlockSize   -   number of reflectors
'    T           -   array[BlockSize,2*BlockSize]. Left BlockSize*BlockSize
'                    submatrix stores triangular factor on exit.
'    WORK        -   array[BlockSize]
'
'  -- ALGLIB routine --
'     17.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub RMatrixBlockReflector(ByRef A() As Double, _
         ByRef Tau() As Double, _
         ByVal ColumnwiseA As Boolean, _
         ByVal LengthA As Long, _
         ByVal BlockSize As Long, _
         ByRef T() As Double, _
         ByRef WORK() As Double)
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim V As Double
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' fill beginning of new column with zeros,
    ' load 1.0 in the first non-zero element
    '
    For K = 0# To BlockSize - 1# Step 1
        If ColumnwiseA Then
            For i = 0# To K - 1# Step 1
                A(i, K) = 0#
            Next i
        Else
            For i = 0# To K - 1# Step 1
                A(K, i) = 0#
            Next i
        End If
        A(K, K) = 1#
    Next K
    
    '
    ' Calculate Gram matrix of A
    '
    For i = 0# To BlockSize - 1# Step 1
        For j = 0# To BlockSize - 1# Step 1
            T(i, BlockSize + j) = 0#
        Next j
    Next i
    For K = 0# To LengthA - 1# Step 1
        For j = 1# To BlockSize - 1# Step 1
            If ColumnwiseA Then
                V = A(K, j)
                If V <> 0# Then
                    i1_ = (0#) - (BlockSize)
                    For i_ = BlockSize To BlockSize + j - 1# Step 1
                        T(j, i_) = T(j, i_) + V * A(K, i_ + i1_)
                    Next i_
                End If
            Else
                V = A(j, K)
                If V <> 0# Then
                    i1_ = (0#) - (BlockSize)
                    For i_ = BlockSize To BlockSize + j - 1# Step 1
                        T(j, i_) = T(j, i_) + V * A(i_ + i1_, K)
                    Next i_
                End If
            End If
        Next j
    Next K
    
    '
    ' Prepare Y (stored in TmpA) and T (stored in TmpT)
    '
    For K = 0# To BlockSize - 1# Step 1
        
        '
        ' fill non-zero part of T, use pre-calculated Gram matrix
        '
        i1_ = (BlockSize) - (0#)
        For i_ = 0# To K - 1# Step 1
            WORK(i_) = T(K, i_ + i1_)
        Next i_
        For i = 0# To K - 1# Step 1
            V = 0#
            For i_ = i To K - 1# Step 1
                V = V + T(i, i_) * WORK(i_)
            Next i_
            T(i, K) = -(Tau(K) * V)
        Next i
        T(K, K) = -Tau(K)
        
        '
        ' Rest of T is filled by zeros
        '
        For i = K + 1# To BlockSize - 1# Step 1
            T(i, K) = 0#
        Next i
    Next K
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Generate block reflector (complex):
'* fill unused parts of reflectors matrix by zeros
'* fill diagonal of reflectors matrix by ones
'* generate triangular factor T
'
'
'  -- ALGLIB routine --
'     17.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub CMatrixBlockReflector(ByRef A() As Complex, _
         ByRef Tau() As Complex, _
         ByVal ColumnwiseA As Boolean, _
         ByVal LengthA As Long, _
         ByVal BlockSize As Long, _
         ByRef T() As Complex, _
         ByRef WORK() As Complex)
    Dim i As Long
    Dim K As Long
    Dim V As Complex
    Dim i_ As Long
    
    '
    ' Prepare Y (stored in TmpA) and T (stored in TmpT)
    '
    For K = 0# To BlockSize - 1# Step 1
        
        '
        ' fill beginning of new column with zeros,
        ' load 1.0 in the first non-zero element
        '
        If ColumnwiseA Then
            For i = 0# To K - 1# Step 1
                A(i, K) = C_Complex(0#)
            Next i
        Else
            For i = 0# To K - 1# Step 1
                A(K, i) = C_Complex(0#)
            Next i
        End If
        A(K, K) = C_Complex(1#)
        
        '
        ' fill non-zero part of T,
        '
        For i = 0# To K - 1# Step 1
            If ColumnwiseA Then
                V = C_Complex(0#)
                For i_ = K To LengthA - 1# Step 1
                    V = C_Add(V, C_Mul(Conj(A(i_, i)), A(i_, K)))
                Next i_
            Else
                V = C_Complex(0#)
                For i_ = K To LengthA - 1# Step 1
                    V = C_Add(V, C_Mul(A(i, i_), Conj(A(K, i_))))
                Next i_
            End If
            WORK(i) = V
        Next i
        For i = 0# To K - 1# Step 1
            V = C_Complex(0#)
            For i_ = i To K - 1# Step 1
                V = C_Add(V, C_Mul(T(i, i_), WORK(i_)))
            Next i_
            T(i, K) = C_Opposite(C_Mul(Tau(K), V))
        Next i
        T(K, K) = C_Opposite(Tau(K))
        
        '
        ' Rest of T is filled by zeros
        '
        For i = K + 1# To BlockSize - 1# Step 1
            T(i, K) = C_Complex(0#)
        Next i
    Next K
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 1992-2007 The University of Tennessee. All rights reserved.
'
'Contributors:
'    * Sergey Bochkanov (ALGLIB project). Translation from FORTRAN to
'      pseudocode.
'
'See subroutines comments for additional copyrights.
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Inversion of a matrix given by its LU decomposition.
'
'INPUT PARAMETERS:
'    A       -   LU decomposition of the matrix (output of RMatrixLU subroutine).
'    Pivots  -   table of permutations which were made during the LU decomposition
'                (the output of RMatrixLU subroutine).
'    N       -   size of matrix A.
'
'OUTPUT PARAMETERS:
'    Info    -   return code:
'                * -3    A is singular, or VERY close to singular.
'                        it is filled by zeros in such cases.
'                * -1    N<=0 was passed, or incorrect Pivots was passed
'                *  1    task is solved (but matrix A may be ill-conditioned,
'                        check R1/RInf parameters for condition numbers).
'    Rep     -   solver report, see below for more info
'    A       -   inverse of matrix A.
'                Array whose indexes range within [0..N-1, 0..N-1].
'
'SOLVER REPORT
'
'Subroutine sets following fields of the Rep structure:
'* R1        reciprocal of condition number: 1/cond(A), 1-norm.
'* RInf      reciprocal of condition number: 1/cond(A), inf-norm.
'
'  -- ALGLIB routine --
'     05.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixLUInverse(ByRef A() As Double, _
         ByRef Pivots() As Long, _
         ByVal N As Long, _
         ByRef Info As Long, _
         ByRef Rep As MatInvReport)
    Dim WORK() As Double
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim V As Double
    Info = 1#
    
    '
    ' Quick return if possible
    '
    If N = 0# Then
        Info = -1#
        Exit Sub
    End If
    For i = 0# To N - 1# Step 1
        If Pivots(i) > N - 1# Or Pivots(i) < i Then
            Info = -1#
            Exit Sub
        End If
    Next i
    
    '
    ' calculate condition numbers
    '
    Rep.R1 = RMatrixLURCond1(A, N)
    Rep.RInf = RMatrixLURCondInf(A, N)
    If Rep.R1 < RCondThreshold() Or Rep.RInf < RCondThreshold() Then
        For i = 0# To N - 1# Step 1
            For j = 0# To N - 1# Step 1
                A(i, j) = 0#
            Next j
        Next i
        Rep.R1 = 0#
        Rep.RInf = 0#
        Info = -3#
        Exit Sub
    End If
    
    '
    ' Call cache-oblivious code
    '
    ReDim WORK(0 To N - 1)
    Call RMatrixLUInverseRec(A, 0#, N, WORK, Info, Rep)
    
    '
    ' apply permutations
    '
    For i = 0# To N - 1# Step 1
        For j = N - 2# To 0# Step -1
            K = Pivots(j)
            V = A(i, j)
            A(i, j) = A(i, K)
            A(i, K) = V
        Next j
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Inversion of a general matrix.
'
'Input parameters:
'    A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
'    N   -   size of matrix A.
'
'Output parameters:
'    Info    -   return code, same as in RMatrixLUInverse
'    Rep     -   solver report, same as in RMatrixLUInverse
'    A       -   inverse of matrix A, same as in RMatrixLUInverse
'
'Result:
'    True, if the matrix is not singular.
'    False, if the matrix is singular.
'
'  -- ALGLIB --
'     Copyright 2005 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixInverse(ByRef A() As Double, _
         ByVal N As Long, _
         ByRef Info As Long, _
         ByRef Rep As MatInvReport)
    Dim Pivots() As Long
    Call RMatrixLU(A, N, N, Pivots)
    Call RMatrixLUInverse(A, Pivots, N, Info, Rep)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Inversion of a matrix given by its LU decomposition.
'
'INPUT PARAMETERS:
'    A       -   LU decomposition of the matrix (output of CMatrixLU subroutine).
'    Pivots  -   table of permutations which were made during the LU decomposition
'                (the output of CMatrixLU subroutine).
'    N       -   size of matrix A.
'
'OUTPUT PARAMETERS:
'    Info    -   return code, same as in RMatrixLUInverse
'    Rep     -   solver report, same as in RMatrixLUInverse
'    A       -   inverse of matrix A, same as in RMatrixLUInverse
'
'  -- ALGLIB routine --
'     05.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixLUInverse(ByRef A() As Complex, _
         ByRef Pivots() As Long, _
         ByVal N As Long, _
         ByRef Info As Long, _
         ByRef Rep As MatInvReport)
    Dim WORK() As Complex
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim V As Complex
    Info = 1#
    
    '
    ' Quick return if possible
    '
    If N = 0# Then
        Info = -1#
        Exit Sub
    End If
    For i = 0# To N - 1# Step 1
        If Pivots(i) > N - 1# Or Pivots(i) < i Then
            Info = -1#
            Exit Sub
        End If
    Next i
    
    '
    ' calculate condition numbers
    '
    Rep.R1 = CMatrixLURCond1(A, N)
    Rep.RInf = CMatrixLURCondInf(A, N)
    If Rep.R1 < RCondThreshold() Or Rep.RInf < RCondThreshold() Then
        For i = 0# To N - 1# Step 1
            For j = 0# To N - 1# Step 1
                A(i, j) = C_Complex(0#)
            Next j
        Next i
        Rep.R1 = 0#
        Rep.RInf = 0#
        Info = -3#
        Exit Sub
    End If
    
    '
    ' Call cache-oblivious code
    '
    ReDim WORK(0 To N - 1)
    Call CMatrixLUInverseRec(A, 0#, N, WORK, Info, Rep)
    
    '
    ' apply permutations
    '
    For i = 0# To N - 1# Step 1
        For j = N - 2# To 0# Step -1
            K = Pivots(j)
            V = A(i, j)
            A(i, j) = A(i, K)
            A(i, K) = V
        Next j
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Inversion of a general matrix.
'
'Input parameters:
'    A   -   matrix, array[0..N-1,0..N-1].
'    N   -   size of A.
'
'Output parameters:
'    Info    -   return code, same as in RMatrixLUInverse
'    Rep     -   solver report, same as in RMatrixLUInverse
'    A       -   inverse of matrix A, same as in RMatrixLUInverse
'
'  -- ALGLIB --
'     Copyright 2005 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixInverse(ByRef A() As Complex, _
         ByVal N As Long, _
         ByRef Info As Long, _
         ByRef Rep As MatInvReport)
    Dim Pivots() As Long
    Call CMatrixLU(A, N, N, Pivots)
    Call CMatrixLUInverse(A, Pivots, N, Info, Rep)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Inversion of a symmetric positive definite matrix which is given
'by Cholesky decomposition.
'
'Input parameters:
'    A       -   Cholesky decomposition of the matrix to be inverted:
'                A=U*U or A = L*L'.
'                Output of  SPDMatrixCholesky subroutine.
'    N       -   size of matrix A.
'    IsUpper    storage format.
'                If IsUpper = True, then matrix A is given as A = U'*U
'                (matrix contains upper triangle).
'                Similarly, if IsUpper = False, then A = L*L'.
'
'Output parameters:
'    Info    -   return code, same as in RMatrixLUInverse
'    Rep     -   solver report, same as in RMatrixLUInverse
'    A       -   inverse of matrix A, same as in RMatrixLUInverse
'
'  -- ALGLIB routine --
'     10.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub SPDMatrixCholeskyInverse(ByRef A() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef Info As Long, _
         ByRef Rep As MatInvReport)
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim V As Double
    Dim AJJ As Double
    Dim AII As Double
    Dim Tmp() As Double
    Dim Info2 As Long
    Dim Rep2 As MatInvReport
    If N < 1# Then
        Info = -1#
        Exit Sub
    End If
    Info = 1#
    
    '
    ' calculate condition numbers
    '
    Rep.R1 = SPDMatrixCholeskyRCond(A, N, IsUpper)
    Rep.RInf = Rep.R1
    If Rep.R1 < RCondThreshold() Or Rep.RInf < RCondThreshold() Then
        If IsUpper Then
            For i = 0# To N - 1# Step 1
                For j = i To N - 1# Step 1
                    A(i, j) = 0#
                Next j
            Next i
        Else
            For i = 0# To N - 1# Step 1
                For j = 0# To i Step 1
                    A(i, j) = 0#
                Next j
            Next i
        End If
        Rep.R1 = 0#
        Rep.RInf = 0#
        Info = -3#
        Exit Sub
    End If
    
    '
    ' Inverse
    '
    ReDim Tmp(0 To N - 1)
    Call SPDMatrixCholeskyInverseRec(A, 0#, N, IsUpper, Tmp)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Inversion of a symmetric positive definite matrix.
'
'Given an upper or lower triangle of a symmetric positive definite matrix,
'the algorithm generates matrix A^-1 and saves the upper or lower triangle
'depending on the input.
'
'Input parameters:
'    A       -   matrix to be inverted (upper or lower triangle).
'                Array with elements [0..N-1,0..N-1].
'    N       -   size of matrix A.
'    IsUpper -   storage format.
'                If IsUpper = True, then the upper triangle of matrix A is
'                given, otherwise the lower triangle is given.
'
'Output parameters:
'    Info    -   return code, same as in RMatrixLUInverse
'    Rep     -   solver report, same as in RMatrixLUInverse
'    A       -   inverse of matrix A, same as in RMatrixLUInverse
'
'  -- ALGLIB routine --
'     10.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub SPDMatrixInverse(ByRef A() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef Info As Long, _
         ByRef Rep As MatInvReport)
    If N < 1# Then
        Info = -1#
        Exit Sub
    End If
    Info = 1#
    If SPDMatrixCholesky(A, N, IsUpper) Then
        Call SPDMatrixCholeskyInverse(A, N, IsUpper, Info, Rep)
    Else
        Info = -3#
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Inversion of a Hermitian positive definite matrix which is given
'by Cholesky decomposition.
'
'Input parameters:
'    A       -   Cholesky decomposition of the matrix to be inverted:
'                A=U*U or A = L*L'.
'                Output of  HPDMatrixCholesky subroutine.
'    N       -   size of matrix A.
'    IsUpper    storage format.
'                If IsUpper = True, then matrix A is given as A = U'*U
'                (matrix contains upper triangle).
'                Similarly, if IsUpper = False, then A = L*L'.
'
'Output parameters:
'    Info    -   return code, same as in RMatrixLUInverse
'    Rep     -   solver report, same as in RMatrixLUInverse
'    A       -   inverse of matrix A, same as in RMatrixLUInverse
'
'  -- ALGLIB routine --
'     10.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub HPDMatrixCholeskyInverse(ByRef A() As Complex, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef Info As Long, _
         ByRef Rep As MatInvReport)
    Dim i As Long
    Dim j As Long
    Dim Info2 As Long
    Dim Rep2 As MatInvReport
    Dim Tmp() As Complex
    Dim V As Complex
    If N < 1# Then
        Info = -1#
        Exit Sub
    End If
    Info = 1#
    
    '
    ' calculate condition numbers
    '
    Rep.R1 = HPDMatrixCholeskyRCond(A, N, IsUpper)
    Rep.RInf = Rep.R1
    If Rep.R1 < RCondThreshold() Or Rep.RInf < RCondThreshold() Then
        If IsUpper Then
            For i = 0# To N - 1# Step 1
                For j = i To N - 1# Step 1
                    A(i, j) = C_Complex(0#)
                Next j
            Next i
        Else
            For i = 0# To N - 1# Step 1
                For j = 0# To i Step 1
                    A(i, j) = C_Complex(0#)
                Next j
            Next i
        End If
        Rep.R1 = 0#
        Rep.RInf = 0#
        Info = -3#
        Exit Sub
    End If
    
    '
    ' Inverse
    '
    ReDim Tmp(0 To N - 1)
    Call HPDMatrixCholeskyInverseRec(A, 0#, N, IsUpper, Tmp)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Inversion of a Hermitian positive definite matrix.
'
'Given an upper or lower triangle of a Hermitian positive definite matrix,
'the algorithm generates matrix A^-1 and saves the upper or lower triangle
'depending on the input.
'
'Input parameters:
'    A       -   matrix to be inverted (upper or lower triangle).
'                Array with elements [0..N-1,0..N-1].
'    N       -   size of matrix A.
'    IsUpper -   storage format.
'                If IsUpper = True, then the upper triangle of matrix A is
'                given, otherwise the lower triangle is given.
'
'Output parameters:
'    Info    -   return code, same as in RMatrixLUInverse
'    Rep     -   solver report, same as in RMatrixLUInverse
'    A       -   inverse of matrix A, same as in RMatrixLUInverse
'
'  -- ALGLIB routine --
'     10.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub HPDMatrixInverse(ByRef A() As Complex, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef Info As Long, _
         ByRef Rep As MatInvReport)
    If N < 1# Then
        Info = -1#
        Exit Sub
    End If
    Info = 1#
    If HPDMatrixCholesky(A, N, IsUpper) Then
        Call HPDMatrixCholeskyInverse(A, N, IsUpper, Info, Rep)
    Else
        Info = -3#
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Triangular matrix inverse (real)
'
'The subroutine inverts the following types of matrices:
'    * upper triangular
'    * upper triangular with unit diagonal
'    * lower triangular
'    * lower triangular with unit diagonal
'
'In case of an upper (lower) triangular matrix,  the  inverse  matrix  will
'also be upper (lower) triangular, and after the end of the algorithm,  the
'inverse matrix replaces the source matrix. The elements  below (above) the
'main diagonal are not changed by the algorithm.
'
'If  the matrix  has a unit diagonal, the inverse matrix also  has  a  unit
'diagonal, and the diagonal elements are not passed to the algorithm.
'
'Input parameters:
'    A       -   matrix, array[0..N-1, 0..N-1].
'    N       -   size of A.
'    IsUpper -   True, if the matrix is upper triangular.
'    IsUnit  -   True, if the matrix has a unit diagonal.
'
'Output parameters:
'    Info    -   same as for RMatrixLUInverse
'    Rep     -   same as for RMatrixLUInverse
'    A       -   same as for RMatrixLUInverse.
'
'  -- ALGLIB --
'     Copyright 05.02.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixTRInverse(ByRef A() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByVal Isunit As Boolean, _
         ByRef Info As Long, _
         ByRef Rep As MatInvReport)
    Dim i As Long
    Dim j As Long
    Dim Tmp() As Double
    If N < 1# Then
        Info = -1#
        Exit Sub
    End If
    Info = 1#
    
    '
    ' calculate condition numbers
    '
    Rep.R1 = RMatrixTRRCond1(A, N, IsUpper, Isunit)
    Rep.RInf = RMatrixTRRCondInf(A, N, IsUpper, Isunit)
    If Rep.R1 < RCondThreshold() Or Rep.RInf < RCondThreshold() Then
        For i = 0# To N - 1# Step 1
            For j = 0# To N - 1# Step 1
                A(i, j) = 0#
            Next j
        Next i
        Rep.R1 = 0#
        Rep.RInf = 0#
        Info = -3#
        Exit Sub
    End If
    
    '
    ' Invert
    '
    ReDim Tmp(0 To N - 1)
    Call RMatrixTRInverseRec(A, 0#, N, IsUpper, Isunit, Tmp, Info, Rep)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Triangular matrix inverse (complex)
'
'The subroutine inverts the following types of matrices:
'    * upper triangular
'    * upper triangular with unit diagonal
'    * lower triangular
'    * lower triangular with unit diagonal
'
'In case of an upper (lower) triangular matrix,  the  inverse  matrix  will
'also be upper (lower) triangular, and after the end of the algorithm,  the
'inverse matrix replaces the source matrix. The elements  below (above) the
'main diagonal are not changed by the algorithm.
'
'If  the matrix  has a unit diagonal, the inverse matrix also  has  a  unit
'diagonal, and the diagonal elements are not passed to the algorithm.
'
'Input parameters:
'    A       -   matrix, array[0..N-1, 0..N-1].
'    N       -   size of A.
'    IsUpper -   True, if the matrix is upper triangular.
'    IsUnit  -   True, if the matrix has a unit diagonal.
'
'Output parameters:
'    Info    -   same as for RMatrixLUInverse
'    Rep     -   same as for RMatrixLUInverse
'    A       -   same as for RMatrixLUInverse.
'
'  -- ALGLIB --
'     Copyright 05.02.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixTRInverse(ByRef A() As Complex, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByVal Isunit As Boolean, _
         ByRef Info As Long, _
         ByRef Rep As MatInvReport)
    Dim i As Long
    Dim j As Long
    Dim Tmp() As Complex
    If N < 1# Then
        Info = -1#
        Exit Sub
    End If
    Info = 1#
    
    '
    ' calculate condition numbers
    '
    Rep.R1 = CMatrixTRRCond1(A, N, IsUpper, Isunit)
    Rep.RInf = CMatrixTRRCondInf(A, N, IsUpper, Isunit)
    If Rep.R1 < RCondThreshold() Or Rep.RInf < RCondThreshold() Then
        For i = 0# To N - 1# Step 1
            For j = 0# To N - 1# Step 1
                A(i, j) = C_Complex(0#)
            Next j
        Next i
        Rep.R1 = 0#
        Rep.RInf = 0#
        Info = -3#
        Exit Sub
    End If
    
    '
    ' Invert
    '
    ReDim Tmp(0 To N - 1)
    Call CMatrixTRInverseRec(A, 0#, N, IsUpper, Isunit, Tmp, Info, Rep)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Triangular matrix inversion, recursive subroutine
'
'  -- ALGLIB --
'     05.02.2010, Bochkanov Sergey.
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     February 29, 1992.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub RMatrixTRInverseRec(ByRef A() As Double, _
         ByVal Offs As Long, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByVal Isunit As Boolean, _
         ByRef Tmp() As Double, _
         ByRef Info As Long, _
         ByRef Rep As MatInvReport)
    Dim N1 As Long
    Dim N2 As Long
    Dim i As Long
    Dim j As Long
    Dim V As Double
    Dim AJJ As Double
    Dim i_ As Long
    Dim i1_ As Long
    If N < 1# Then
        Info = -1#
        Exit Sub
    End If
    
    '
    ' Base case
    '
    If N <= ABLASBlockSize(A) Then
        If IsUpper Then
            
            '
            ' Compute inverse of upper triangular matrix.
            '
            For j = 0# To N - 1# Step 1
                If Not Isunit Then
                    If A(Offs + j, Offs + j) = 0# Then
                        Info = -3#
                        Exit Sub
                    End If
                    A(Offs + j, Offs + j) = 1# / A(Offs + j, Offs + j)
                    AJJ = -A(Offs + j, Offs + j)
                Else
                    AJJ = -1#
                End If
                
                '
                ' Compute elements 1:j-1 of j-th column.
                '
                If j > 0# Then
                    i1_ = (Offs + 0#) - (0#)
                    For i_ = 0# To j - 1# Step 1
                        Tmp(i_) = A(i_ + i1_, Offs + j)
                    Next i_
                    For i = 0# To j - 1# Step 1
                        If i < j - 1# Then
                            i1_ = (i + 1#) - (Offs + i + 1#)
                            V = 0#
                            For i_ = Offs + i + 1# To Offs + j - 1# Step 1
                                V = V + A(Offs + i, i_) * Tmp(i_ + i1_)
                            Next i_
                        Else
                            V = 0#
                        End If
                        If Not Isunit Then
                            A(Offs + i, Offs + j) = V + A(Offs + i, Offs + i) * Tmp(i)
                        Else
                            A(Offs + i, Offs + j) = V + Tmp(i)
                        End If
                    Next i
                    For i_ = Offs + 0# To Offs + j - 1# Step 1
                        A(i_, Offs + j) = AJJ * A(i_, Offs + j)
                    Next i_
                End If
            Next j
        Else
            
            '
            ' Compute inverse of lower triangular matrix.
            '
            For j = N - 1# To 0# Step -1
                If Not Isunit Then
                    If A(Offs + j, Offs + j) = 0# Then
                        Info = -3#
                        Exit Sub
                    End If
                    A(Offs + j, Offs + j) = 1# / A(Offs + j, Offs + j)
                    AJJ = -A(Offs + j, Offs + j)
                Else
                    AJJ = -1#
                End If
                If j < N - 1# Then
                    
                    '
                    ' Compute elements j+1:n of j-th column.
                    '
                    i1_ = (Offs + j + 1#) - (j + 1#)
                    For i_ = j + 1# To N - 1# Step 1
                        Tmp(i_) = A(i_ + i1_, Offs + j)
                    Next i_
                    For i = j + 1# To N - 1# Step 1
                        If i > j + 1# Then
                            i1_ = (j + 1#) - (Offs + j + 1#)
                            V = 0#
                            For i_ = Offs + j + 1# To Offs + i - 1# Step 1
                                V = V + A(Offs + i, i_) * Tmp(i_ + i1_)
                            Next i_
                        Else
                            V = 0#
                        End If
                        If Not Isunit Then
                            A(Offs + i, Offs + j) = V + A(Offs + i, Offs + i) * Tmp(i)
                        Else
                            A(Offs + i, Offs + j) = V + Tmp(i)
                        End If
                    Next i
                    For i_ = Offs + j + 1# To Offs + N - 1# Step 1
                        A(i_, Offs + j) = AJJ * A(i_, Offs + j)
                    Next i_
                End If
            Next j
        End If
        Exit Sub
    End If
    
    '
    ' Recursive case
    '
    Call ABLASSplitLength(A, N, N1, N2)
    If N2 > 0# Then
        If IsUpper Then
            For i = 0# To N1 - 1# Step 1
                For i_ = Offs + N1 To Offs + N - 1# Step 1
                    A(Offs + i, i_) = -1 * A(Offs + i, i_)
                Next i_
            Next i
            Call RMatrixLeftTRSM(N1, N2, A, Offs, Offs, IsUpper, Isunit, 0#, A, Offs, Offs + N1)
            Call RMatrixRightTRSM(N1, N2, A, Offs + N1, Offs + N1, IsUpper, Isunit, 0#, A, Offs, Offs + N1)
        Else
            For i = 0# To N2 - 1# Step 1
                For i_ = Offs To Offs + N1 - 1# Step 1
                    A(Offs + N1 + i, i_) = -1 * A(Offs + N1 + i, i_)
                Next i_
            Next i
            Call RMatrixRightTRSM(N2, N1, A, Offs, Offs, IsUpper, Isunit, 0#, A, Offs + N1, Offs)
            Call RMatrixLeftTRSM(N2, N1, A, Offs + N1, Offs + N1, IsUpper, Isunit, 0#, A, Offs + N1, Offs)
        End If
        Call RMatrixTRInverseRec(A, Offs + N1, N2, IsUpper, Isunit, Tmp, Info, Rep)
    End If
    Call RMatrixTRInverseRec(A, Offs, N1, IsUpper, Isunit, Tmp, Info, Rep)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Triangular matrix inversion, recursive subroutine
'
'  -- ALGLIB --
'     05.02.2010, Bochkanov Sergey.
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     February 29, 1992.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub CMatrixTRInverseRec(ByRef A() As Complex, _
         ByVal Offs As Long, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByVal Isunit As Boolean, _
         ByRef Tmp() As Complex, _
         ByRef Info As Long, _
         ByRef Rep As MatInvReport)
    Dim N1 As Long
    Dim N2 As Long
    Dim i As Long
    Dim j As Long
    Dim V As Complex
    Dim AJJ As Complex
    Dim i_ As Long
    Dim i1_ As Long
    If N < 1# Then
        Info = -1#
        Exit Sub
    End If
    
    '
    ' Base case
    '
    If N <= ABLASComplexBlockSize(A) Then
        If IsUpper Then
            
            '
            ' Compute inverse of upper triangular matrix.
            '
            For j = 0# To N - 1# Step 1
                If Not Isunit Then
                    If C_EqualR(A(Offs + j, Offs + j), 0#) Then
                        Info = -3#
                        Exit Sub
                    End If
                    A(Offs + j, Offs + j) = C_RDiv(1#, A(Offs + j, Offs + j))
                    AJJ = C_Opposite(A(Offs + j, Offs + j))
                Else
                    AJJ = C_Complex(-1#)
                End If
                
                '
                ' Compute elements 1:j-1 of j-th column.
                '
                If j > 0# Then
                    i1_ = (Offs + 0#) - (0#)
                    For i_ = 0# To j - 1# Step 1
                        Tmp(i_) = A(i_ + i1_, Offs + j)
                    Next i_
                    For i = 0# To j - 1# Step 1
                        If i < j - 1# Then
                            i1_ = (i + 1#) - (Offs + i + 1#)
                            V = C_Complex(0#)
                            For i_ = Offs + i + 1# To Offs + j - 1# Step 1
                                V = C_Add(V, C_Mul(A(Offs + i, i_), Tmp(i_ + i1_)))
                            Next i_
                        Else
                            V = C_Complex(0#)
                        End If
                        If Not Isunit Then
                            A(Offs + i, Offs + j) = C_Add(V, C_Mul(A(Offs + i, Offs + i), Tmp(i)))
                        Else
                            A(Offs + i, Offs + j) = C_Add(V, Tmp(i))
                        End If
                    Next i
                    For i_ = Offs + 0# To Offs + j - 1# Step 1
                        A(i_, Offs + j) = C_Mul(AJJ, A(i_, Offs + j))
                    Next i_
                End If
            Next j
        Else
            
            '
            ' Compute inverse of lower triangular matrix.
            '
            For j = N - 1# To 0# Step -1
                If Not Isunit Then
                    If C_EqualR(A(Offs + j, Offs + j), 0#) Then
                        Info = -3#
                        Exit Sub
                    End If
                    A(Offs + j, Offs + j) = C_RDiv(1#, A(Offs + j, Offs + j))
                    AJJ = C_Opposite(A(Offs + j, Offs + j))
                Else
                    AJJ = C_Complex(-1#)
                End If
                If j < N - 1# Then
                    
                    '
                    ' Compute elements j+1:n of j-th column.
                    '
                    i1_ = (Offs + j + 1#) - (j + 1#)
                    For i_ = j + 1# To N - 1# Step 1
                        Tmp(i_) = A(i_ + i1_, Offs + j)
                    Next i_
                    For i = j + 1# To N - 1# Step 1
                        If i > j + 1# Then
                            i1_ = (j + 1#) - (Offs + j + 1#)
                            V = C_Complex(0#)
                            For i_ = Offs + j + 1# To Offs + i - 1# Step 1
                                V = C_Add(V, C_Mul(A(Offs + i, i_), Tmp(i_ + i1_)))
                            Next i_
                        Else
                            V = C_Complex(0#)
                        End If
                        If Not Isunit Then
                            A(Offs + i, Offs + j) = C_Add(V, C_Mul(A(Offs + i, Offs + i), Tmp(i)))
                        Else
                            A(Offs + i, Offs + j) = C_Add(V, Tmp(i))
                        End If
                    Next i
                    For i_ = Offs + j + 1# To Offs + N - 1# Step 1
                        A(i_, Offs + j) = C_Mul(AJJ, A(i_, Offs + j))
                    Next i_
                End If
            Next j
        End If
        Exit Sub
    End If
    
    '
    ' Recursive case
    '
    Call ABLASComplexSplitLength(A, N, N1, N2)
    If N2 > 0# Then
        If IsUpper Then
            For i = 0# To N1 - 1# Step 1
                For i_ = Offs + N1 To Offs + N - 1# Step 1
                    A(Offs + i, i_) = C_MulR(A(Offs + i, i_), -1)
                Next i_
            Next i
            Call CMatrixLeftTRSM(N1, N2, A, Offs, Offs, IsUpper, Isunit, 0#, A, Offs, Offs + N1)
            Call CMatrixRightTRSM(N1, N2, A, Offs + N1, Offs + N1, IsUpper, Isunit, 0#, A, Offs, Offs + N1)
        Else
            For i = 0# To N2 - 1# Step 1
                For i_ = Offs To Offs + N1 - 1# Step 1
                    A(Offs + N1 + i, i_) = C_MulR(A(Offs + N1 + i, i_), -1)
                Next i_
            Next i
            Call CMatrixRightTRSM(N2, N1, A, Offs, Offs, IsUpper, Isunit, 0#, A, Offs + N1, Offs)
            Call CMatrixLeftTRSM(N2, N1, A, Offs + N1, Offs + N1, IsUpper, Isunit, 0#, A, Offs + N1, Offs)
        End If
        Call CMatrixTRInverseRec(A, Offs + N1, N2, IsUpper, Isunit, Tmp, Info, Rep)
    End If
    Call CMatrixTRInverseRec(A, Offs, N1, IsUpper, Isunit, Tmp, Info, Rep)
End Sub
Private Sub RMatrixLUInverseRec(ByRef A() As Double, _
         ByVal Offs As Long, _
         ByVal N As Long, _
         ByRef WORK() As Double, _
         ByRef Info As Long, _
         ByRef Rep As MatInvReport)
    Dim i As Long
    Dim IWS As Long
    Dim j As Long
    Dim JB As Long
    Dim JJ As Long
    Dim JP As Long
    Dim K As Long
    Dim V As Double
    Dim N1 As Long
    Dim N2 As Long
    Dim i_ As Long
    Dim i1_ As Long
    If N < 1# Then
        Info = -1#
        Exit Sub
    End If
    
    '
    ' Base case
    '
    If N <= ABLASBlockSize(A) Then
        
        '
        ' Form inv(U)
        '
        Call RMatrixTRInverseRec(A, Offs, N, True, False, WORK, Info, Rep)
        If Info <= 0# Then
            Exit Sub
        End If
        
        '
        ' Solve the equation inv(A)*L = inv(U) for inv(A).
        '
        For j = N - 1# To 0# Step -1
            
            '
            ' Copy current column of L to WORK and replace with zeros.
            '
            For i = j + 1# To N - 1# Step 1
                WORK(i) = A(Offs + i, Offs + j)
                A(Offs + i, Offs + j) = 0#
            Next i
            
            '
            ' Compute current column of inv(A).
            '
            If j < N - 1# Then
                For i = 0# To N - 1# Step 1
                    i1_ = (j + 1#) - (Offs + j + 1#)
                    V = 0#
                    For i_ = Offs + j + 1# To Offs + N - 1# Step 1
                        V = V + A(Offs + i, i_) * WORK(i_ + i1_)
                    Next i_
                    A(Offs + i, Offs + j) = A(Offs + i, Offs + j) - V
                Next i
            End If
        Next j
        Exit Sub
    End If
    
    '
    ' Recursive code:
    '
    '         ( L1      )   ( U1  U12 )
    ' A    =  (         ) * (         )
    '         ( L12  L2 )   (     U2  )
    '
    '         ( W   X )
    ' A^-1 =  (       )
    '         ( Y   Z )
    '
    Call ABLASSplitLength(A, N, N1, N2)
    
    '
    ' X := inv(U1)*U12*inv(U2)
    '
    Call RMatrixLeftTRSM(N1, N2, A, Offs, Offs, True, False, 0#, A, Offs, Offs + N1)
    Call RMatrixRightTRSM(N1, N2, A, Offs + N1, Offs + N1, True, False, 0#, A, Offs, Offs + N1)
    
    '
    ' Y := inv(L2)*L12*inv(L1)
    '
    Call RMatrixLeftTRSM(N2, N1, A, Offs + N1, Offs + N1, False, True, 0#, A, Offs + N1, Offs)
    Call RMatrixRightTRSM(N2, N1, A, Offs, Offs, False, True, 0#, A, Offs + N1, Offs)
    
    '
    ' W := inv(L1*U1)+X*Y
    '
    Call RMatrixLUInverseRec(A, Offs, N1, WORK, Info, Rep)
    If Info <= 0# Then
        Exit Sub
    End If
    Call RMatrixGEMM(N1, N1, N2, 1#, A, Offs, Offs + N1, 0#, A, Offs + N1, Offs, 0#, 1#, A, Offs, Offs)
    
    '
    ' X := -X*inv(L2)
    ' Y := -inv(U2)*Y
    '
    Call RMatrixRightTRSM(N1, N2, A, Offs + N1, Offs + N1, False, True, 0#, A, Offs, Offs + N1)
    For i = 0# To N1 - 1# Step 1
        For i_ = Offs + N1 To Offs + N - 1# Step 1
            A(Offs + i, i_) = -1 * A(Offs + i, i_)
        Next i_
    Next i
    Call RMatrixLeftTRSM(N2, N1, A, Offs + N1, Offs + N1, True, False, 0#, A, Offs + N1, Offs)
    For i = 0# To N2 - 1# Step 1
        For i_ = Offs To Offs + N1 - 1# Step 1
            A(Offs + N1 + i, i_) = -1 * A(Offs + N1 + i, i_)
        Next i_
    Next i
    
    '
    ' Z := inv(L2*U2)
    '
    Call RMatrixLUInverseRec(A, Offs + N1, N2, WORK, Info, Rep)
End Sub
Private Sub CMatrixLUInverseRec(ByRef A() As Complex, _
         ByVal Offs As Long, _
         ByVal N As Long, _
         ByRef WORK() As Complex, _
         ByRef Info As Long, _
         ByRef Rep As MatInvReport)
    Dim i As Long
    Dim IWS As Long
    Dim j As Long
    Dim JB As Long
    Dim JJ As Long
    Dim JP As Long
    Dim K As Long
    Dim V As Complex
    Dim N1 As Long
    Dim N2 As Long
    Dim i_ As Long
    Dim i1_ As Long
    If N < 1# Then
        Info = -1#
        Exit Sub
    End If
    
    '
    ' Base case
    '
    If N <= ABLASComplexBlockSize(A) Then
        
        '
        ' Form inv(U)
        '
        Call CMatrixTRInverseRec(A, Offs, N, True, False, WORK, Info, Rep)
        If Info <= 0# Then
            Exit Sub
        End If
        
        '
        ' Solve the equation inv(A)*L = inv(U) for inv(A).
        '
        For j = N - 1# To 0# Step -1
            
            '
            ' Copy current column of L to WORK and replace with zeros.
            '
            For i = j + 1# To N - 1# Step 1
                WORK(i) = A(Offs + i, Offs + j)
                A(Offs + i, Offs + j) = C_Complex(0#)
            Next i
            
            '
            ' Compute current column of inv(A).
            '
            If j < N - 1# Then
                For i = 0# To N - 1# Step 1
                    i1_ = (j + 1#) - (Offs + j + 1#)
                    V = C_Complex(0#)
                    For i_ = Offs + j + 1# To Offs + N - 1# Step 1
                        V = C_Add(V, C_Mul(A(Offs + i, i_), WORK(i_ + i1_)))
                    Next i_
                    A(Offs + i, Offs + j) = C_Sub(A(Offs + i, Offs + j), V)
                Next i
            End If
        Next j
        Exit Sub
    End If
    
    '
    ' Recursive code:
    '
    '         ( L1      )   ( U1  U12 )
    ' A    =  (         ) * (         )
    '         ( L12  L2 )   (     U2  )
    '
    '         ( W   X )
    ' A^-1 =  (       )
    '         ( Y   Z )
    '
    Call ABLASComplexSplitLength(A, N, N1, N2)
    
    '
    ' X := inv(U1)*U12*inv(U2)
    '
    Call CMatrixLeftTRSM(N1, N2, A, Offs, Offs, True, False, 0#, A, Offs, Offs + N1)
    Call CMatrixRightTRSM(N1, N2, A, Offs + N1, Offs + N1, True, False, 0#, A, Offs, Offs + N1)
    
    '
    ' Y := inv(L2)*L12*inv(L1)
    '
    Call CMatrixLeftTRSM(N2, N1, A, Offs + N1, Offs + N1, False, True, 0#, A, Offs + N1, Offs)
    Call CMatrixRightTRSM(N2, N1, A, Offs, Offs, False, True, 0#, A, Offs + N1, Offs)
    
    '
    ' W := inv(L1*U1)+X*Y
    '
    Call CMatrixLUInverseRec(A, Offs, N1, WORK, Info, Rep)
    If Info <= 0# Then
        Exit Sub
    End If
    Call CMatrixGEMM(N1, N1, N2, C_Complex(1#), A, Offs, Offs + N1, 0#, A, Offs + N1, Offs, 0#, C_Complex(1#), A, Offs, Offs)
    
    '
    ' X := -X*inv(L2)
    ' Y := -inv(U2)*Y
    '
    Call CMatrixRightTRSM(N1, N2, A, Offs + N1, Offs + N1, False, True, 0#, A, Offs, Offs + N1)
    For i = 0# To N1 - 1# Step 1
        For i_ = Offs + N1 To Offs + N - 1# Step 1
            A(Offs + i, i_) = C_MulR(A(Offs + i, i_), -1)
        Next i_
    Next i
    Call CMatrixLeftTRSM(N2, N1, A, Offs + N1, Offs + N1, True, False, 0#, A, Offs + N1, Offs)
    For i = 0# To N2 - 1# Step 1
        For i_ = Offs To Offs + N1 - 1# Step 1
            A(Offs + N1 + i, i_) = C_MulR(A(Offs + N1 + i, i_), -1)
        Next i_
    Next i
    
    '
    ' Z := inv(L2*U2)
    '
    Call CMatrixLUInverseRec(A, Offs + N1, N2, WORK, Info, Rep)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Recursive subroutine for SPD inversion.
'
'  -- ALGLIB routine --
'     10.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub SPDMatrixCholeskyInverseRec(ByRef A() As Double, _
         ByVal Offs As Long, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef Tmp() As Double)
    Dim i As Long
    Dim j As Long
    Dim V As Double
    Dim N1 As Long
    Dim N2 As Long
    Dim Info2 As Long
    Dim Rep2 As MatInvReport
    Dim i_ As Long
    Dim i1_ As Long
    If N < 1# Then
        Exit Sub
    End If
    
    '
    ' Base case
    '
    If N <= ABLASBlockSize(A) Then
        Call RMatrixTRInverseRec(A, Offs, N, IsUpper, False, Tmp, Info2, Rep2)
        If IsUpper Then
            
            '
            ' Compute the product U * U'.
            ' NOTE: we never assume that diagonal of U is real
            '
            For i = 0# To N - 1# Step 1
                If i = 0# Then
                    
                    '
                    ' 1x1 matrix
                    '
                    A(Offs + i, Offs + i) = Square(A(Offs + i, Offs + i))
                Else
                    
                    '
                    ' (I+1)x(I+1) matrix,
                    '
                    ' ( A11  A12 )   ( A11^H        )   ( A11*A11^H+A12*A12^H  A12*A22^H )
                    ' (          ) * (              ) = (                                )
                    ' (      A22 )   ( A12^H  A22^H )   ( A22*A12^H            A22*A22^H )
                    '
                    ' A11 is IxI, A22 is 1x1.
                    '
                    i1_ = (Offs) - (0#)
                    For i_ = 0# To i - 1# Step 1
                        Tmp(i_) = A(i_ + i1_, Offs + i)
                    Next i_
                    For j = 0# To i - 1# Step 1
                        V = A(Offs + j, Offs + i)
                        i1_ = (j) - (Offs + j)
                        For i_ = Offs + j To Offs + i - 1# Step 1
                            A(Offs + j, i_) = A(Offs + j, i_) + V * Tmp(i_ + i1_)
                        Next i_
                    Next j
                    V = A(Offs + i, Offs + i)
                    For i_ = Offs To Offs + i - 1# Step 1
                        A(i_, Offs + i) = V * A(i_, Offs + i)
                    Next i_
                    A(Offs + i, Offs + i) = Square(A(Offs + i, Offs + i))
                End If
            Next i
        Else
            
            '
            ' Compute the product L' * L
            ' NOTE: we never assume that diagonal of L is real
            '
            For i = 0# To N - 1# Step 1
                If i = 0# Then
                    
                    '
                    ' 1x1 matrix
                    '
                    A(Offs + i, Offs + i) = Square(A(Offs + i, Offs + i))
                Else
                    
                    '
                    ' (I+1)x(I+1) matrix,
                    '
                    ' ( A11^H  A21^H )   ( A11      )   ( A11^H*A11+A21^H*A21  A21^H*A22 )
                    ' (              ) * (          ) = (                                )
                    ' (        A22^H )   ( A21  A22 )   ( A22^H*A21            A22^H*A22 )
                    '
                    ' A11 is IxI, A22 is 1x1.
                    '
                    i1_ = (Offs) - (0#)
                    For i_ = 0# To i - 1# Step 1
                        Tmp(i_) = A(Offs + i, i_ + i1_)
                    Next i_
                    For j = 0# To i - 1# Step 1
                        V = A(Offs + i, Offs + j)
                        i1_ = (0#) - (Offs)
                        For i_ = Offs To Offs + j Step 1
                            A(Offs + j, i_) = A(Offs + j, i_) + V * Tmp(i_ + i1_)
                        Next i_
                    Next j
                    V = A(Offs + i, Offs + i)
                    For i_ = Offs To Offs + i - 1# Step 1
                        A(Offs + i, i_) = V * A(Offs + i, i_)
                    Next i_
                    A(Offs + i, Offs + i) = Square(A(Offs + i, Offs + i))
                End If
            Next i
        End If
        Exit Sub
    End If
    
    '
    ' Recursive code: triangular factor inversion merged with
    ' UU' or L'L multiplication
    '
    Call ABLASSplitLength(A, N, N1, N2)
    
    '
    ' form off-diagonal block of trangular inverse
    '
    If IsUpper Then
        For i = 0# To N1 - 1# Step 1
            For i_ = Offs + N1 To Offs + N - 1# Step 1
                A(Offs + i, i_) = -1 * A(Offs + i, i_)
            Next i_
        Next i
        Call RMatrixLeftTRSM(N1, N2, A, Offs, Offs, IsUpper, False, 0#, A, Offs, Offs + N1)
        Call RMatrixRightTRSM(N1, N2, A, Offs + N1, Offs + N1, IsUpper, False, 0#, A, Offs, Offs + N1)
    Else
        For i = 0# To N2 - 1# Step 1
            For i_ = Offs To Offs + N1 - 1# Step 1
                A(Offs + N1 + i, i_) = -1 * A(Offs + N1 + i, i_)
            Next i_
        Next i
        Call RMatrixRightTRSM(N2, N1, A, Offs, Offs, IsUpper, False, 0#, A, Offs + N1, Offs)
        Call RMatrixLeftTRSM(N2, N1, A, Offs + N1, Offs + N1, IsUpper, False, 0#, A, Offs + N1, Offs)
    End If
    
    '
    ' invert first diagonal block
    '
    Call SPDMatrixCholeskyInverseRec(A, Offs, N1, IsUpper, Tmp)
    
    '
    ' update first diagonal block with off-diagonal block,
    ' update off-diagonal block
    '
    If IsUpper Then
        Call RMatrixSYRK(N1, N2, 1#, A, Offs, Offs + N1, 0#, 1#, A, Offs, Offs, IsUpper)
        Call RMatrixRightTRSM(N1, N2, A, Offs + N1, Offs + N1, IsUpper, False, 1#, A, Offs, Offs + N1)
    Else
        Call RMatrixSYRK(N1, N2, 1#, A, Offs + N1, Offs, 1#, 1#, A, Offs, Offs, IsUpper)
        Call RMatrixLeftTRSM(N2, N1, A, Offs + N1, Offs + N1, IsUpper, False, 1#, A, Offs + N1, Offs)
    End If
    
    '
    ' invert second diagonal block
    '
    Call SPDMatrixCholeskyInverseRec(A, Offs + N1, N2, IsUpper, Tmp)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Recursive subroutine for HPD inversion.
'
'  -- ALGLIB routine --
'     10.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub HPDMatrixCholeskyInverseRec(ByRef A() As Complex, _
         ByVal Offs As Long, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef Tmp() As Complex)
    Dim i As Long
    Dim j As Long
    Dim V As Complex
    Dim N1 As Long
    Dim N2 As Long
    Dim Info2 As Long
    Dim Rep2 As MatInvReport
    Dim i_ As Long
    Dim i1_ As Long
    If N < 1# Then
        Exit Sub
    End If
    
    '
    ' Base case
    '
    If N <= ABLASComplexBlockSize(A) Then
        Call CMatrixTRInverseRec(A, Offs, N, IsUpper, False, Tmp, Info2, Rep2)
        If IsUpper Then
            
            '
            ' Compute the product U * U'.
            ' NOTE: we never assume that diagonal of U is real
            '
            For i = 0# To N - 1# Step 1
                If i = 0# Then
                    
                    '
                    ' 1x1 matrix
                    '
                    A(Offs + i, Offs + i) = C_Complex(Square(A(Offs + i, Offs + i).X) + Square(A(Offs + i, Offs + i).y))
                Else
                    
                    '
                    ' (I+1)x(I+1) matrix,
                    '
                    ' ( A11  A12 )   ( A11^H        )   ( A11*A11^H+A12*A12^H  A12*A22^H )
                    ' (          ) * (              ) = (                                )
                    ' (      A22 )   ( A12^H  A22^H )   ( A22*A12^H            A22*A22^H )
                    '
                    ' A11 is IxI, A22 is 1x1.
                    '
                    i1_ = (Offs) - (0#)
                    For i_ = 0# To i - 1# Step 1
                        Tmp(i_) = Conj(A(i_ + i1_, Offs + i))
                    Next i_
                    For j = 0# To i - 1# Step 1
                        V = A(Offs + j, Offs + i)
                        i1_ = (j) - (Offs + j)
                        For i_ = Offs + j To Offs + i - 1# Step 1
                            A(Offs + j, i_) = C_Add(A(Offs + j, i_), C_Mul(V, Tmp(i_ + i1_)))
                        Next i_
                    Next j
                    V = Conj(A(Offs + i, Offs + i))
                    For i_ = Offs To Offs + i - 1# Step 1
                        A(i_, Offs + i) = C_Mul(V, A(i_, Offs + i))
                    Next i_
                    A(Offs + i, Offs + i) = C_Complex(Square(A(Offs + i, Offs + i).X) + Square(A(Offs + i, Offs + i).y))
                End If
            Next i
        Else
            
            '
            ' Compute the product L' * L
            ' NOTE: we never assume that diagonal of L is real
            '
            For i = 0# To N - 1# Step 1
                If i = 0# Then
                    
                    '
                    ' 1x1 matrix
                    '
                    A(Offs + i, Offs + i) = C_Complex(Square(A(Offs + i, Offs + i).X) + Square(A(Offs + i, Offs + i).y))
                Else
                    
                    '
                    ' (I+1)x(I+1) matrix,
                    '
                    ' ( A11^H  A21^H )   ( A11      )   ( A11^H*A11+A21^H*A21  A21^H*A22 )
                    ' (              ) * (          ) = (                                )
                    ' (        A22^H )   ( A21  A22 )   ( A22^H*A21            A22^H*A22 )
                    '
                    ' A11 is IxI, A22 is 1x1.
                    '
                    i1_ = (Offs) - (0#)
                    For i_ = 0# To i - 1# Step 1
                        Tmp(i_) = A(Offs + i, i_ + i1_)
                    Next i_
                    For j = 0# To i - 1# Step 1
                        V = Conj(A(Offs + i, Offs + j))
                        i1_ = (0#) - (Offs)
                        For i_ = Offs To Offs + j Step 1
                            A(Offs + j, i_) = C_Add(A(Offs + j, i_), C_Mul(V, Tmp(i_ + i1_)))
                        Next i_
                    Next j
                    V = Conj(A(Offs + i, Offs + i))
                    For i_ = Offs To Offs + i - 1# Step 1
                        A(Offs + i, i_) = C_Mul(V, A(Offs + i, i_))
                    Next i_
                    A(Offs + i, Offs + i) = C_Complex(Square(A(Offs + i, Offs + i).X) + Square(A(Offs + i, Offs + i).y))
                End If
            Next i
        End If
        Exit Sub
    End If
    
    '
    ' Recursive code: triangular factor inversion merged with
    ' UU' or L'L multiplication
    '
    Call ABLASComplexSplitLength(A, N, N1, N2)
    
    '
    ' form off-diagonal block of trangular inverse
    '
    If IsUpper Then
        For i = 0# To N1 - 1# Step 1
            For i_ = Offs + N1 To Offs + N - 1# Step 1
                A(Offs + i, i_) = C_MulR(A(Offs + i, i_), -1)
            Next i_
        Next i
        Call CMatrixLeftTRSM(N1, N2, A, Offs, Offs, IsUpper, False, 0#, A, Offs, Offs + N1)
        Call CMatrixRightTRSM(N1, N2, A, Offs + N1, Offs + N1, IsUpper, False, 0#, A, Offs, Offs + N1)
    Else
        For i = 0# To N2 - 1# Step 1
            For i_ = Offs To Offs + N1 - 1# Step 1
                A(Offs + N1 + i, i_) = C_MulR(A(Offs + N1 + i, i_), -1)
            Next i_
        Next i
        Call CMatrixRightTRSM(N2, N1, A, Offs, Offs, IsUpper, False, 0#, A, Offs + N1, Offs)
        Call CMatrixLeftTRSM(N2, N1, A, Offs + N1, Offs + N1, IsUpper, False, 0#, A, Offs + N1, Offs)
    End If
    
    '
    ' invert first diagonal block
    '
    Call HPDMatrixCholeskyInverseRec(A, Offs, N1, IsUpper, Tmp)
    
    '
    ' update first diagonal block with off-diagonal block,
    ' update off-diagonal block
    '
    If IsUpper Then
        Call CMatrixSYRK(N1, N2, 1#, A, Offs, Offs + N1, 0#, 1#, A, Offs, Offs, IsUpper)
        Call CMatrixRightTRSM(N1, N2, A, Offs + N1, Offs + N1, IsUpper, False, 2#, A, Offs, Offs + N1)
    Else
        Call CMatrixSYRK(N1, N2, 1#, A, Offs + N1, Offs, 2#, 1#, A, Offs, Offs, IsUpper)
        Call CMatrixLeftTRSM(N2, N1, A, Offs + N1, Offs + N1, IsUpper, False, 2#, A, Offs + N1, Offs)
    End If
    
    '
    ' invert second diagonal block
    '
    Call HPDMatrixCholeskyInverseRec(A, Offs + N1, N2, IsUpper, Tmp)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2007, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Generation of a random uniformly distributed (Haar) orthogonal matrix
'
'INPUT PARAMETERS:
'    N   -   matrix size, N>=1
'
'OUTPUT PARAMETERS:
'    A   -   orthogonal NxN matrix, array[0..N-1,0..N-1]
'
'  -- ALGLIB routine --
'     04.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixRndOrthogonal(ByVal N As Long, ByRef A() As Double)
    Dim i As Long
    Dim j As Long
    ReDim A(0# To N - 1#, 0# To N - 1#)
    For i = 0# To N - 1# Step 1
        For j = 0# To N - 1# Step 1
            If i = j Then
                A(i, j) = 1#
            Else
                A(i, j) = 0#
            End If
        Next j
    Next i
    Call RMatrixRndOrthogonalFromTheRight(A, N, N)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Generation of random NxN matrix with given condition number and norm2(A)=1
'
'INPUT PARAMETERS:
'    N   -   matrix size
'    C   -   condition number (in 2-norm)
'
'OUTPUT PARAMETERS:
'    A   -   random matrix with norm2(A)=1 and cond(A)=C
'
'  -- ALGLIB routine --
'     04.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixRndCond(ByVal N As Long, _
         ByVal C As Double, _
         ByRef A() As Double)
    Dim i As Long
    Dim j As Long
    Dim L1 As Double
    Dim L2 As Double
    ReDim A(0# To N - 1#, 0# To N - 1#)
    If N = 1# Then
        
        '
        ' special case
        '
        A(0#, 0#) = 2# * RandomInteger(2#) - 1#
        Exit Sub
    End If
    L1 = 0#
    L2 = log(1# / C)
    For i = 0# To N - 1# Step 1
        For j = 0# To N - 1# Step 1
            A(i, j) = 0#
        Next j
    Next i
    A(0#, 0#) = Exp(L1)
    For i = 1# To N - 2# Step 1
        A(i, i) = Exp(Rnd() * (L2 - L1) + L1)
    Next i
    A(N - 1#, N - 1#) = Exp(L2)
    Call RMatrixRndOrthogonalFromTheLeft(A, N, N)
    Call RMatrixRndOrthogonalFromTheRight(A, N, N)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Generation of a random Haar distributed orthogonal complex matrix
'
'INPUT PARAMETERS:
'    N   -   matrix size, N>=1
'
'OUTPUT PARAMETERS:
'    A   -   orthogonal NxN matrix, array[0..N-1,0..N-1]
'
'  -- ALGLIB routine --
'     04.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixRndOrthogonal(ByVal N As Long, ByRef A() As Complex)
    Dim i As Long
    Dim j As Long
    ReDim A(0# To N - 1#, 0# To N - 1#)
    For i = 0# To N - 1# Step 1
        For j = 0# To N - 1# Step 1
            If i = j Then
                A(i, j) = C_Complex(1#)
            Else
                A(i, j) = C_Complex(0#)
            End If
        Next j
    Next i
    Call CMatrixRndOrthogonalFromTheRight(A, N, N)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Generation of random NxN complex matrix with given condition number C and
'norm2(A)=1
'
'INPUT PARAMETERS:
'    N   -   matrix size
'    C   -   condition number (in 2-norm)
'
'OUTPUT PARAMETERS:
'    A   -   random matrix with norm2(A)=1 and cond(A)=C
'
'  -- ALGLIB routine --
'     04.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixRndCond(ByVal N As Long, _
         ByVal C As Double, _
         ByRef A() As Complex)
    Dim i As Long
    Dim j As Long
    Dim L1 As Double
    Dim L2 As Double
    Dim State As HQRNDState
    Dim V As Complex
    ReDim A(0# To N - 1#, 0# To N - 1#)
    If N = 1# Then
        
        '
        ' special case
        '
        Call HQRNDRandomize(State)
        Call HQRNDUnit2(State, V.X, V.y)
        A(0#, 0#) = V
        Exit Sub
    End If
    L1 = 0#
    L2 = log(1# / C)
    For i = 0# To N - 1# Step 1
        For j = 0# To N - 1# Step 1
            A(i, j) = C_Complex(0#)
        Next j
    Next i
    A(0#, 0#) = C_Complex(Exp(L1))
    For i = 1# To N - 2# Step 1
        A(i, i) = C_Complex(Exp(Rnd() * (L2 - L1) + L1))
    Next i
    A(N - 1#, N - 1#) = C_Complex(Exp(L2))
    Call CMatrixRndOrthogonalFromTheLeft(A, N, N)
    Call CMatrixRndOrthogonalFromTheRight(A, N, N)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Generation of random NxN symmetric matrix with given condition number  and
'norm2(A)=1
'
'INPUT PARAMETERS:
'    N   -   matrix size
'    C   -   condition number (in 2-norm)
'
'OUTPUT PARAMETERS:
'    A   -   random matrix with norm2(A)=1 and cond(A)=C
'
'  -- ALGLIB routine --
'     04.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub SMatrixRndCond(ByVal N As Long, _
         ByVal C As Double, _
         ByRef A() As Double)
    Dim i As Long
    Dim j As Long
    Dim L1 As Double
    Dim L2 As Double
    ReDim A(0# To N - 1#, 0# To N - 1#)
    If N = 1# Then
        
        '
        ' special case
        '
        A(0#, 0#) = 2# * RandomInteger(2#) - 1#
        Exit Sub
    End If
    
    '
    ' Prepare matrix
    '
    L1 = 0#
    L2 = log(1# / C)
    For i = 0# To N - 1# Step 1
        For j = 0# To N - 1# Step 1
            A(i, j) = 0#
        Next j
    Next i
    A(0#, 0#) = Exp(L1)
    For i = 1# To N - 2# Step 1
        A(i, i) = (2# * RandomInteger(2#) - 1#) * Exp(Rnd() * (L2 - L1) + L1)
    Next i
    A(N - 1#, N - 1#) = Exp(L2)
    
    '
    ' Multiply
    '
    Call SMatrixRndMultiply(A, N)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Generation of random NxN symmetric positive definite matrix with given
'condition number and norm2(A)=1
'
'INPUT PARAMETERS:
'    N   -   matrix size
'    C   -   condition number (in 2-norm)
'
'OUTPUT PARAMETERS:
'    A   -   random SPD matrix with norm2(A)=1 and cond(A)=C
'
'  -- ALGLIB routine --
'     04.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub SPDMatrixRndCond(ByVal N As Long, _
         ByVal C As Double, _
         ByRef A() As Double)
    Dim i As Long
    Dim j As Long
    Dim L1 As Double
    Dim L2 As Double
    
    '
    ' Special cases
    '
    If N <= 0# Or C < 1# Then
        Exit Sub
    End If
    ReDim A(0# To N - 1#, 0# To N - 1#)
    If N = 1# Then
        A(0#, 0#) = 1#
        Exit Sub
    End If
    
    '
    ' Prepare matrix
    '
    L1 = 0#
    L2 = log(1# / C)
    For i = 0# To N - 1# Step 1
        For j = 0# To N - 1# Step 1
            A(i, j) = 0#
        Next j
    Next i
    A(0#, 0#) = Exp(L1)
    For i = 1# To N - 2# Step 1
        A(i, i) = Exp(Rnd() * (L2 - L1) + L1)
    Next i
    A(N - 1#, N - 1#) = Exp(L2)
    
    '
    ' Multiply
    '
    Call SMatrixRndMultiply(A, N)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Generation of random NxN Hermitian matrix with given condition number  and
'norm2(A)=1
'
'INPUT PARAMETERS:
'    N   -   matrix size
'    C   -   condition number (in 2-norm)
'
'OUTPUT PARAMETERS:
'    A   -   random matrix with norm2(A)=1 and cond(A)=C
'
'  -- ALGLIB routine --
'     04.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub HMatrixRndCond(ByVal N As Long, _
         ByVal C As Double, _
         ByRef A() As Complex)
    Dim i As Long
    Dim j As Long
    Dim L1 As Double
    Dim L2 As Double
    ReDim A(0# To N - 1#, 0# To N - 1#)
    If N = 1# Then
        
        '
        ' special case
        '
        A(0#, 0#) = C_Complex(2# * RandomInteger(2#) - 1#)
        Exit Sub
    End If
    
    '
    ' Prepare matrix
    '
    L1 = 0#
    L2 = log(1# / C)
    For i = 0# To N - 1# Step 1
        For j = 0# To N - 1# Step 1
            A(i, j) = C_Complex(0#)
        Next j
    Next i
    A(0#, 0#) = C_Complex(Exp(L1))
    For i = 1# To N - 2# Step 1
        A(i, i) = C_Complex((2# * RandomInteger(2#) - 1#) * Exp(Rnd() * (L2 - L1) + L1))
    Next i
    A(N - 1#, N - 1#) = C_Complex(Exp(L2))
    
    '
    ' Multiply
    '
    Call HMatrixRndMultiply(A, N)
    
    '
    ' post-process to ensure that matrix diagonal is real
    '
    For i = 0# To N - 1# Step 1
        A(i, i).y = 0#
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Generation of random NxN Hermitian positive definite matrix with given
'condition number and norm2(A)=1
'
'INPUT PARAMETERS:
'    N   -   matrix size
'    C   -   condition number (in 2-norm)
'
'OUTPUT PARAMETERS:
'    A   -   random HPD matrix with norm2(A)=1 and cond(A)=C
'
'  -- ALGLIB routine --
'     04.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub HPDMatrixRndCond(ByVal N As Long, _
         ByVal C As Double, _
         ByRef A() As Complex)
    Dim i As Long
    Dim j As Long
    Dim L1 As Double
    Dim L2 As Double
    
    '
    ' Special cases
    '
    If N <= 0# Or C < 1# Then
        Exit Sub
    End If
    ReDim A(0# To N - 1#, 0# To N - 1#)
    If N = 1# Then
        A(0#, 0#) = C_Complex(1#)
        Exit Sub
    End If
    
    '
    ' Prepare matrix
    '
    L1 = 0#
    L2 = log(1# / C)
    For i = 0# To N - 1# Step 1
        For j = 0# To N - 1# Step 1
            A(i, j) = C_Complex(0#)
        Next j
    Next i
    A(0#, 0#) = C_Complex(Exp(L1))
    For i = 1# To N - 2# Step 1
        A(i, i) = C_Complex(Exp(Rnd() * (L2 - L1) + L1))
    Next i
    A(N - 1#, N - 1#) = C_Complex(Exp(L2))
    
    '
    ' Multiply
    '
    Call HMatrixRndMultiply(A, N)
    
    '
    ' post-process to ensure that matrix diagonal is real
    '
    For i = 0# To N - 1# Step 1
        A(i, i).y = 0#
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Multiplication of MxN matrix by NxN random Haar distributed orthogonal matrix
'
'INPUT PARAMETERS:
'    A   -   matrix, array[0..M-1, 0..N-1]
'    M, N-   matrix size
'
'OUTPUT PARAMETERS:
'    A   -   A*Q, where Q is random NxN orthogonal matrix
'
'  -- ALGLIB routine --
'     04.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixRndOrthogonalFromTheRight(ByRef A() As Double, _
         ByVal M As Long, _
         ByVal N As Long)
    Dim Tau As Double
    Dim Lambda As Double
    Dim S As Long
    Dim i As Long
    Dim U1 As Double
    Dim U2 As Double
    Dim w() As Double
    Dim V() As Double
    Dim State As HQRNDState
    Dim i_ As Long
    If N = 1# Then
        
        '
        ' Special case
        '
        Tau = 2# * RandomInteger(2#) - 1#
        For i = 0# To M - 1# Step 1
            A(i, 0#) = A(i, 0#) * Tau
        Next i
        Exit Sub
    End If
    
    '
    ' General case.
    ' First pass.
    '
    ReDim w(0# To M - 1#)
    ReDim V(1# To N)
    Call HQRNDRandomize(State)
    For S = 2# To N Step 1
        
        '
        ' Prepare random normal v
        '
        Do
            i = 1#
            Do While i <= S
                Call HQRNDNormal2(State, U1, U2)
                V(i) = U1
                If i + 1# <= S Then
                    V(i + 1#) = U2
                End If
                i = i + 2#
            Loop
            Lambda = 0#
            For i_ = 1# To S Step 1
                Lambda = Lambda + V(i_) * V(i_)
            Next i_
        Loop Until Lambda <> 0#
        
        '
        ' Prepare and apply reflection
        '
        Call GenerateReflection(V, S, Tau)
        V(1#) = 1#
        Call ApplyReflectionFromTheRight(A, Tau, V, 0#, M - 1#, N - S, N - 1#, w)
    Next S
    
    '
    ' Second pass.
    '
    For i = 0# To N - 1# Step 1
        Tau = 2# * RandomInteger(2#) - 1#
        For i_ = 0# To M - 1# Step 1
            A(i_, i) = Tau * A(i_, i)
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Multiplication of MxN matrix by MxM random Haar distributed orthogonal matrix
'
'INPUT PARAMETERS:
'    A   -   matrix, array[0..M-1, 0..N-1]
'    M, N-   matrix size
'
'OUTPUT PARAMETERS:
'    A   -   Q*A, where Q is random MxM orthogonal matrix
'
'  -- ALGLIB routine --
'     04.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixRndOrthogonalFromTheLeft(ByRef A() As Double, _
         ByVal M As Long, _
         ByVal N As Long)
    Dim Tau As Double
    Dim Lambda As Double
    Dim S As Long
    Dim i As Long
    Dim j As Long
    Dim U1 As Double
    Dim U2 As Double
    Dim w() As Double
    Dim V() As Double
    Dim State As HQRNDState
    Dim i_ As Long
    If M = 1# Then
        
        '
        ' special case
        '
        Tau = 2# * RandomInteger(2#) - 1#
        For j = 0# To N - 1# Step 1
            A(0#, j) = A(0#, j) * Tau
        Next j
        Exit Sub
    End If
    
    '
    ' General case.
    ' First pass.
    '
    ReDim w(0# To N - 1#)
    ReDim V(1# To M)
    Call HQRNDRandomize(State)
    For S = 2# To M Step 1
        
        '
        ' Prepare random normal v
        '
        Do
            i = 1#
            Do While i <= S
                Call HQRNDNormal2(State, U1, U2)
                V(i) = U1
                If i + 1# <= S Then
                    V(i + 1#) = U2
                End If
                i = i + 2#
            Loop
            Lambda = 0#
            For i_ = 1# To S Step 1
                Lambda = Lambda + V(i_) * V(i_)
            Next i_
        Loop Until Lambda <> 0#
        
        '
        ' Prepare and apply reflection
        '
        Call GenerateReflection(V, S, Tau)
        V(1#) = 1#
        Call ApplyReflectionFromTheLeft(A, Tau, V, M - S, M - 1#, 0#, N - 1#, w)
    Next S
    
    '
    ' Second pass.
    '
    For i = 0# To M - 1# Step 1
        Tau = 2# * RandomInteger(2#) - 1#
        For i_ = 0# To N - 1# Step 1
            A(i, i_) = Tau * A(i, i_)
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Multiplication of MxN complex matrix by NxN random Haar distributed
'complex orthogonal matrix
'
'INPUT PARAMETERS:
'    A   -   matrix, array[0..M-1, 0..N-1]
'    M, N-   matrix size
'
'OUTPUT PARAMETERS:
'    A   -   A*Q, where Q is random NxN orthogonal matrix
'
'  -- ALGLIB routine --
'     04.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixRndOrthogonalFromTheRight(ByRef A() As Complex, _
         ByVal M As Long, _
         ByVal N As Long)
    Dim Lambda As Complex
    Dim Tau As Complex
    Dim S As Long
    Dim i As Long
    Dim w() As Complex
    Dim V() As Complex
    Dim State As HQRNDState
    Dim i_ As Long
    If N = 1# Then
        
        '
        ' Special case
        '
        Call HQRNDRandomize(State)
        Call HQRNDUnit2(State, Tau.X, Tau.y)
        For i = 0# To M - 1# Step 1
            A(i, 0#) = C_Mul(A(i, 0#), Tau)
        Next i
        Exit Sub
    End If
    
    '
    ' General case.
    ' First pass.
    '
    ReDim w(0# To M - 1#)
    ReDim V(1# To N)
    Call HQRNDRandomize(State)
    For S = 2# To N Step 1
        
        '
        ' Prepare random normal v
        '
        Do
            For i = 1# To S Step 1
                Call HQRNDNormal2(State, Tau.X, Tau.y)
                V(i) = Tau
            Next i
            Lambda = C_Complex(0#)
            For i_ = 1# To S Step 1
                Lambda = C_Add(Lambda, C_Mul(V(i_), Conj(V(i_))))
            Next i_
        Loop Until C_NotEqualR(Lambda, 0#)
        
        '
        ' Prepare and apply reflection
        '
        Call ComplexGenerateReflection(V, S, Tau)
        V(1#) = C_Complex(1#)
        Call ComplexApplyReflectionFromTheRight(A, Tau, V, 0#, M - 1#, N - S, N - 1#, w)
    Next S
    
    '
    ' Second pass.
    '
    For i = 0# To N - 1# Step 1
        Call HQRNDUnit2(State, Tau.X, Tau.y)
        For i_ = 0# To M - 1# Step 1
            A(i_, i) = C_Mul(Tau, A(i_, i))
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Multiplication of MxN complex matrix by MxM random Haar distributed
'complex orthogonal matrix
'
'INPUT PARAMETERS:
'    A   -   matrix, array[0..M-1, 0..N-1]
'    M, N-   matrix size
'
'OUTPUT PARAMETERS:
'    A   -   Q*A, where Q is random MxM orthogonal matrix
'
'  -- ALGLIB routine --
'     04.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixRndOrthogonalFromTheLeft(ByRef A() As Complex, _
         ByVal M As Long, _
         ByVal N As Long)
    Dim Tau As Complex
    Dim Lambda As Complex
    Dim S As Long
    Dim i As Long
    Dim j As Long
    Dim w() As Complex
    Dim V() As Complex
    Dim State As HQRNDState
    Dim i_ As Long
    If M = 1# Then
        
        '
        ' special case
        '
        Call HQRNDRandomize(State)
        Call HQRNDUnit2(State, Tau.X, Tau.y)
        For j = 0# To N - 1# Step 1
            A(0#, j) = C_Mul(A(0#, j), Tau)
        Next j
        Exit Sub
    End If
    
    '
    ' General case.
    ' First pass.
    '
    ReDim w(0# To N - 1#)
    ReDim V(1# To M)
    Call HQRNDRandomize(State)
    For S = 2# To M Step 1
        
        '
        ' Prepare random normal v
        '
        Do
            For i = 1# To S Step 1
                Call HQRNDNormal2(State, Tau.X, Tau.y)
                V(i) = Tau
            Next i
            Lambda = C_Complex(0#)
            For i_ = 1# To S Step 1
                Lambda = C_Add(Lambda, C_Mul(V(i_), Conj(V(i_))))
            Next i_
        Loop Until C_NotEqualR(Lambda, 0#)
        
        '
        ' Prepare and apply reflection
        '
        Call ComplexGenerateReflection(V, S, Tau)
        V(1#) = C_Complex(1#)
        Call ComplexApplyReflectionFromTheLeft(A, Tau, V, M - S, M - 1#, 0#, N - 1#, w)
    Next S
    
    '
    ' Second pass.
    '
    For i = 0# To M - 1# Step 1
        Call HQRNDUnit2(State, Tau.X, Tau.y)
        For i_ = 0# To N - 1# Step 1
            A(i, i_) = C_Mul(Tau, A(i, i_))
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Symmetric multiplication of NxN matrix by random Haar distributed
'orthogonal  matrix
'
'INPUT PARAMETERS:
'    A   -   matrix, array[0..N-1, 0..N-1]
'    N   -   matrix size
'
'OUTPUT PARAMETERS:
'    A   -   Q'*A*Q, where Q is random NxN orthogonal matrix
'
'  -- ALGLIB routine --
'     04.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub SMatrixRndMultiply(ByRef A() As Double, ByVal N As Long)
    Dim Tau As Double
    Dim Lambda As Double
    Dim S As Long
    Dim i As Long
    Dim U1 As Double
    Dim U2 As Double
    Dim w() As Double
    Dim V() As Double
    Dim State As HQRNDState
    Dim i_ As Long
    
    '
    ' General case.
    '
    ReDim w(0# To N - 1#)
    ReDim V(1# To N)
    Call HQRNDRandomize(State)
    For S = 2# To N Step 1
        
        '
        ' Prepare random normal v
        '
        Do
            i = 1#
            Do While i <= S
                Call HQRNDNormal2(State, U1, U2)
                V(i) = U1
                If i + 1# <= S Then
                    V(i + 1#) = U2
                End If
                i = i + 2#
            Loop
            Lambda = 0#
            For i_ = 1# To S Step 1
                Lambda = Lambda + V(i_) * V(i_)
            Next i_
        Loop Until Lambda <> 0#
        
        '
        ' Prepare and apply reflection
        '
        Call GenerateReflection(V, S, Tau)
        V(1#) = 1#
        Call ApplyReflectionFromTheRight(A, Tau, V, 0#, N - 1#, N - S, N - 1#, w)
        Call ApplyReflectionFromTheLeft(A, Tau, V, N - S, N - 1#, 0#, N - 1#, w)
    Next S
    
    '
    ' Second pass.
    '
    For i = 0# To N - 1# Step 1
        Tau = 2# * RandomInteger(2#) - 1#
        For i_ = 0# To N - 1# Step 1
            A(i_, i) = Tau * A(i_, i)
        Next i_
        For i_ = 0# To N - 1# Step 1
            A(i, i_) = Tau * A(i, i_)
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Hermitian multiplication of NxN matrix by random Haar distributed
'complex orthogonal matrix
'
'INPUT PARAMETERS:
'    A   -   matrix, array[0..N-1, 0..N-1]
'    N   -   matrix size
'
'OUTPUT PARAMETERS:
'    A   -   Q^H*A*Q, where Q is random NxN orthogonal matrix
'
'  -- ALGLIB routine --
'     04.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub HMatrixRndMultiply(ByRef A() As Complex, ByVal N As Long)
    Dim Tau As Complex
    Dim Lambda As Complex
    Dim S As Long
    Dim i As Long
    Dim w() As Complex
    Dim V() As Complex
    Dim State As HQRNDState
    Dim i_ As Long
    
    '
    ' General case.
    '
    ReDim w(0# To N - 1#)
    ReDim V(1# To N)
    Call HQRNDRandomize(State)
    For S = 2# To N Step 1
        
        '
        ' Prepare random normal v
        '
        Do
            For i = 1# To S Step 1
                Call HQRNDNormal2(State, Tau.X, Tau.y)
                V(i) = Tau
            Next i
            Lambda = C_Complex(0#)
            For i_ = 1# To S Step 1
                Lambda = C_Add(Lambda, C_Mul(V(i_), Conj(V(i_))))
            Next i_
        Loop Until C_NotEqualR(Lambda, 0#)
        
        '
        ' Prepare and apply reflection
        '
        Call ComplexGenerateReflection(V, S, Tau)
        V(1#) = C_Complex(1#)
        Call ComplexApplyReflectionFromTheRight(A, Tau, V, 0#, N - 1#, N - S, N - 1#, w)
        Call ComplexApplyReflectionFromTheLeft(A, Conj(Tau), V, N - S, N - 1#, 0#, N - 1#, w)
    Next S
    
    '
    ' Second pass.
    '
    For i = 0# To N - 1# Step 1
        Call HQRNDUnit2(State, Tau.X, Tau.y)
        For i_ = 0# To N - 1# Step 1
            A(i_, i) = C_Mul(Tau, A(i_, i))
        Next i_
        Tau = Conj(Tau)
        For i_ = 0# To N - 1# Step 1
            A(i, i_) = C_Mul(Tau, A(i, i_))
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2005-2007, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Determinant calculation of the matrix given by its LU decomposition.
'
'Input parameters:
'    A       -   LU decomposition of the matrix (output of
'                RMatrixLU subroutine).
'    Pivots  -   table of permutations which were made during
'                the LU decomposition.
'                Output of RMatrixLU subroutine.
'    N       -   size of matrix A.
'
'Result: matrix determinant.
'
'  -- ALGLIB --
'     Copyright 2005 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function RMatrixLUDet(ByRef A() As Double, _
         ByRef Pivots() As Long, _
         ByVal N As Long) As Double
    Dim Result As Double
    Dim i As Long
    Dim S As Long
    Result = 1#
    S = 1#
    For i = 0# To N - 1# Step 1
        Result = Result * A(i, i)
        If Pivots(i) <> i Then
            S = -S
        End If
    Next i
    Result = Result * S
    RMatrixLUDet = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Calculation of the determinant of a general matrix
'
'Input parameters:
'    A       -   matrix, array[0..N-1, 0..N-1]
'    N       -   size of matrix A.
'
'Result: determinant of matrix A.
'
'  -- ALGLIB --
'     Copyright 2005 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function RMatrixDet(ByRef A_() As Double, ByVal N As Long) As Double
    Dim Result As Double
    Dim A() As Double
    Dim Pivots() As Long
    A = A_
    Call RMatrixLU(A, N, N, Pivots)
    Result = RMatrixLUDet(A, Pivots, N)
    RMatrixDet = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Determinant calculation of the matrix given by its LU decomposition.
'
'Input parameters:
'    A       -   LU decomposition of the matrix (output of
'                RMatrixLU subroutine).
'    Pivots  -   table of permutations which were made during
'                the LU decomposition.
'                Output of RMatrixLU subroutine.
'    N       -   size of matrix A.
'
'Result: matrix determinant.
'
'  -- ALGLIB --
'     Copyright 2005 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function CMatrixLUDet(ByRef A() As Complex, _
         ByRef Pivots() As Long, _
         ByVal N As Long) As Complex
    Dim Result As Complex
    Dim i As Long
    Dim S As Long
    Result = C_Complex(1#)
    S = 1#
    For i = 0# To N - 1# Step 1
        Result = C_Mul(Result, A(i, i))
        If Pivots(i) <> i Then
            S = -S
        End If
    Next i
    Result = C_MulR(Result, S)
    CMatrixLUDet = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Calculation of the determinant of a general matrix
'
'Input parameters:
'    A       -   matrix, array[0..N-1, 0..N-1]
'    N       -   size of matrix A.
'
'Result: determinant of matrix A.
'
'  -- ALGLIB --
'     Copyright 2005 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function CMatrixDet(ByRef A_() As Complex, ByVal N As Long) As Complex
    Dim Result As Complex
    Dim A() As Complex
    Dim Pivots() As Long
    A = A_
    Call CMatrixLU(A, N, N, Pivots)
    Result = CMatrixLUDet(A, Pivots, N)
    CMatrixDet = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Determinant calculation of the matrix given by the Cholesky decomposition.
'
'Input parameters:
'    A   -   Cholesky decomposition,
'            output of SMatrixCholesky subroutine.
'    N   -   size of matrix A.
'
'As the determinant is equal to the product of squares of diagonal elements,
'its not necessary to specify which triangle - lower or upper - the matrix
'is stored in.
'
'Result:
'    matrix determinant.
'
'  -- ALGLIB --
'     Copyright 2005-2008 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function SPDMatrixCholeskyDet(ByRef A() As Double, _
         ByVal N As Long) As Double
    Dim Result As Double
    Dim i As Long
    Result = 1#
    For i = 0# To N - 1# Step 1
        Result = Result * Square(A(i, i))
    Next i
    SPDMatrixCholeskyDet = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Determinant calculation of the symmetric positive definite matrix.
'
'Input parameters:
'    A       -   matrix. Array with elements [0..N-1, 0..N-1].
'    N       -   size of matrix A.
'    IsUpper -   if IsUpper = True, then the symmetric matrix A is given by
'                its upper triangle, and the lower triangle isnt used by
'                subroutine. Similarly, if IsUpper = False, then A is given
'                by its lower triangle.
'
'Result:
'    determinant of matrix A.
'    If matrix A is not positive definite, then subroutine returns -1.
'
'  -- ALGLIB --
'     Copyright 2005-2008 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function SPDMatrixDet(ByRef A_() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean) As Double
    Dim Result As Double
    Dim A() As Double
    A = A_
    If Not SPDMatrixCholesky(A, N, IsUpper) Then
        Result = -1#
    Else
        Result = SPDMatrixCholeskyDet(A, N)
    End If
    SPDMatrixDet = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 1992-2007 The University of Tennessee.  All rights reserved.
'
'Contributors:
'    * Sergey Bochkanov (ALGLIB project). Translation from FORTRAN to
'      pseudocode.
'
'See subroutines comments for additional copyrights.
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'LDLTDecomposition of a symmetric matrix
'
'The algorithm represents a symmetric matrix (which is not necessarily
'positive definite) as A=L*D*L' or A = U*D*U', where D is a block-diagonal
'matrix with blocks 1x1 or 2x2, matrix L (matrix U) is a product of lower
'(upper) triangular matrices with unit diagonal and permutation matrices.
'
'Input parameters:
'    A       -   factorized matrix, array with elements [0..N-1, 0..N-1].
'                If IsUpper  True, then the upper triangle contains
'                elements of symmetric matrix A, and the lower triangle is
'                not used.
'                The same applies if IsUpper = False.
'    N       -   size of factorized matrix.
'    IsUpper -   parameter which shows a method of matrix definition (lower
'                or upper triangle).
'
'Output parameters:
'    A       -   matrices D and U, if IsUpper = True, or L, if IsUpper = False,
'                in compact form, replacing the upper (lower) triangle of
'                matrix A. In that case, the elements under (over) the main
'                diagonal are not used nor modified.
'    Pivots  -   tables of performed permutations (see below).
'
'If IsUpper = True, then A = U*D*U', U = P(n)*U(n)*...*P(k)*U(k), where
'P(k) is the permutation matrix, U(k) - upper triangular matrix with its
'unit main diagonal and k decreases from n with step s which is equal to
'1 or 2 (according to the size of the blocks of matrix D).
'
'        (   I    v    0   )   k-s+1
'U(k) =  (   0    I    0   )   s
'        (   0    0    I   )   n-k-1
'           k-s+1 s   n-k-1
'
'If Pivots[k]>=0, then s=1, P(k) - permutation of rows k and Pivots[k], the
'vectorv forming matrix U(k) is stored in elements A(0:k-1,k), D(k) replaces
'A(k,k). If Pivots[k]=Pivots[k-1]<0 then s=2, P(k) - permutation of rows k-1
'and N+Pivots[k-1], the vector v forming matrix U(k) is stored in elements
'A(0:k-1,k:k+1), the upper triangle of block D(k) is stored in A(k,k),
'A(k,k+1) and A(k+1,k+1).
'
'If IsUpper = False, then A = L*D*L', L=P(0)*L(0)*...*P(k)*L(k), where P(k)
'is the permutation matrix, L(k)  lower triangular matrix with unit main
'diagonal and k decreases from 1 with step s which is equal to 1 or 2
'(according to the size of the blocks of matrix D).
'
'        (   I    0     0   )  k-1
'L(k) =  (   0    I     0   )  s
'        (   0    v     I   )  n-k-s+1
'           k-1   s  n-k-s+1
'
'If Pivots[k]>=0 then s=1, P(k)  permutation of rows k and Pivots[k], the
'vector v forming matrix L(k) is stored in elements A(k+1:n-1,k), D(k)
'replaces A(k,k). If Pivots[k]=Pivots[k+1]<0 then s=2, P(k) - permutation
'of rows k+1 and N+Pivots[k+1], the vector v forming matrix L(k) is stored
'in elements A(k+2:n-1,k:k+1), the lower triangle of block D(k) is stored in
'A(k,k), A(k+1,k) and A(k+1,k+1).
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     June 30, 1999
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub SMatrixLDLT(ByRef A() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef Pivots() As Long)
    Dim i As Long
    Dim IMAX As Long
    Dim j As Long
    Dim JMax As Long
    Dim K As Long
    Dim KK As Long
    Dim KP As Long
    Dim KSTEP As Long
    Dim ABSAKK As Double
    Dim Alpha As Double
    Dim COLMAX As Double
    Dim D11 As Double
    Dim D12 As Double
    Dim D21 As Double
    Dim D22 As Double
    Dim R1 As Double
    Dim ROWMAX As Double
    Dim T As Double
    Dim WK As Double
    Dim WKM1 As Double
    Dim WKP1 As Double
    Dim II As Long
    Dim I1 As Long
    Dim I2 As Long
    Dim VV As Double
    Dim temp() As Double
    Dim i_ As Long
    ReDim Pivots(0# To N - 1#)
    ReDim temp(0# To N - 1#)
    '
    ' Initialize ALPHA for use in choosing pivot block size.
    '
    Alpha = (1# + Sqr(17#)) / 8#
    If IsUpper Then
        '
        ' Factorize A as U*D*U' using the upper triangle of A
        '
        '
        ' K is the main loop index, decreasing from N to 1 in steps of
        ' 1 or 2
        '
        K = N - 1#
        Do While K >= 0#
            KSTEP = 1#
            '
            ' Determine rows and columns to be interchanged and whether
            ' a 1-by-1 or 2-by-2 pivot block will be used
            '
            ABSAKK = Abs(A(K, K))
            '
            ' IMAX is the row-index of the largest off-diagonal element in
            ' column K+1, and COLMAX is its absolute value
            '
            If K > 0# Then
                IMAX = 1#
                For II = 2# To K Step 1
                    If Abs(A(II - 1#, K)) > Abs(A(IMAX - 1#, K)) Then
                        IMAX = II
                    End If
                Next II
                COLMAX = Abs(A(IMAX - 1#, K))
            Else
                COLMAX = 0#
            End If
            If MaxReal(ABSAKK, COLMAX) = 0# Then
                '
                ' Column K is zero
                '
                KP = K
            Else
                If ABSAKK >= Alpha * COLMAX Then
                    '
                    ' no interchange, use 1-by-1 pivot block
                    '
                    KP = K
                Else
                    '
                    ' JMAX is the column-index of the largest off-diagonal
                    ' element in row IMAX, and ROWMAX is its absolute value
                    '
                    JMax = IMAX + 1#
                    For II = IMAX + 2# To K + 1# Step 1
                        If Abs(A(IMAX - 1#, II - 1#)) > Abs(A(IMAX - 1#, JMax - 1#)) Then
                            JMax = II
                        End If
                    Next II
                    ROWMAX = Abs(A(IMAX - 1#, JMax - 1#))
                    If IMAX > 1# Then
                        JMax = 1#
                        For II = 2# To IMAX - 1# Step 1
                            If Abs(A(II - 1#, IMAX - 1#)) > Abs(A(JMax - 1#, IMAX - 1#)) Then
                                JMax = II
                            End If
                        Next II
                        ROWMAX = MaxReal(ROWMAX, Abs(A(JMax - 1#, IMAX - 1#)))
                    End If
                    VV = COLMAX / ROWMAX
                    If ABSAKK >= Alpha * COLMAX * VV Then
                        '
                        ' no interchange, use 1-by-1 pivot block
                        '
                        KP = K
                    Else
                        If Abs(A(IMAX - 1#, IMAX - 1#)) >= Alpha * ROWMAX Then
                            '
                            ' interchange rows and columns K and IMAX, use 1-by-1
                            ' pivot block
                            '
                            KP = IMAX - 1#
                        Else
                            '
                            ' interchange rows and columns K-1 and IMAX, use 2-by-2
                            ' pivot block
                            '
                            KP = IMAX - 1#
                            KSTEP = 2#
                        End If
                    End If
                End If
                KK = K + 1# - KSTEP
                If KP + 1# <> KK + 1# Then
                    '
                    ' Interchange rows and columns KK and KP+1 in the leading
                    ' submatrix A(0:K,0:K)
                    '
                    For i_ = 0# To KP - 1# Step 1
                        temp(i_) = A(i_, KK)
                    Next i_
                    For i_ = 0# To KP - 1# Step 1
                        A(i_, KK) = A(i_, KP)
                    Next i_
                    For i_ = 0# To KP - 1# Step 1
                        A(i_, KP) = temp(i_)
                    Next i_
                    For i_ = KP + 1# To KK - 1# Step 1
                        temp(i_) = A(i_, KK)
                    Next i_
                    For i_ = KP + 1# To KK - 1# Step 1
                        A(i_, KK) = A(KP, i_)
                    Next i_
                    For i_ = KP + 1# To KK - 1# Step 1
                        A(KP, i_) = temp(i_)
                    Next i_
                    T = A(KK, KK)
                    A(KK, KK) = A(KP, KP)
                    A(KP, KP) = T
                    If KSTEP = 2# Then
                        T = A(K - 1#, K)
                        A(K - 1#, K) = A(KP, K)
                        A(KP, K) = T
                    End If
                End If
                '
                ' Update the leading submatrix
                '
                If KSTEP = 1# Then
                    '
                    ' 1-by-1 pivot block D(k): column k now holds
                    '
                    ' W(k) = U(k)*D(k)
                    '
                    ' where U(k) is the k-th column of U
                    '
                    ' Perform a rank-1 update of A(1:k-1,1:k-1) as
                    '
                    ' A := A - U(k)*D(k)*U(k)' = A - W(k)*1/D(k)*W(k)'
                    '
                    R1 = 1# / A(K, K)
                    For i = 0# To K - 1# Step 1
                        VV = -(R1 * A(i, K))
                        For i_ = i To K - 1# Step 1
                            A(i, i_) = A(i, i_) + VV * A(i_, K)
                        Next i_
                    Next i
                    '
                    ' Store U(K+1) in column K+1
                    '
                    For i_ = 0# To K - 1# Step 1
                        A(i_, K) = R1 * A(i_, K)
                    Next i_
                Else
                    '
                    ' 2-by-2 pivot block D(k): columns k and k-1 now hold
                    '
                    ' ( W(k-1) W(k) ) = ( U(k-1) U(k) )*D(k)
                    '
                    ' where U(k) and U(k-1) are the k-th and (k-1)-th columns
                    ' of U
                    '
                    ' Perform a rank-2 update of A(1:k-2,1:k-2) as
                    '
                    ' A := A - ( U(k-1) U(k) )*D(k)*( U(k-1) U(k) )'
                    '    = A - ( W(k-1) W(k) )*inv(D(k))*( W(k-1) W(k) )'
                    '
                    If K > 1# Then
                        D12 = A(K - 1#, K)
                        D22 = A(K - 1#, K - 1#) / D12
                        D11 = A(K, K) / D12
                        T = 1# / (D11 * D22 - 1#)
                        D12 = T / D12
                        For j = K - 2# To 0# Step -1
                            WKM1 = D12 * (D11 * A(j, K - 1#) - A(j, K))
                            WK = D12 * (D22 * A(j, K) - A(j, K - 1#))
                            For i_ = 0# To j Step 1
                                A(i_, j) = A(i_, j) - WK * A(i_, K)
                            Next i_
                            For i_ = 0# To j Step 1
                                A(i_, j) = A(i_, j) - WKM1 * A(i_, K - 1#)
                            Next i_
                            A(j, K) = WK
                            A(j, K - 1#) = WKM1
                        Next j
                    End If
                End If
            End If
            '
            ' Store details of the interchanges in IPIV
            '
            If KSTEP = 1# Then
                Pivots(K) = KP
            Else
                Pivots(K) = KP - N
                Pivots(K - 1#) = KP - N
            End If
            '
            ' Decrease K+1 and return to the start of the main loop
            '
            K = K - KSTEP
        Loop
    Else
        '
        ' Factorize A as L*D*L' using the lower triangle of A
        '
        ' K+1 is the main loop index, increasing from 1 to N in steps of
        ' 1 or 2
        '
        K = 0#
        Do While K <= N - 1#
            KSTEP = 1#
            '
            ' Determine rows and columns to be interchanged and whether
            ' a 1-by-1 or 2-by-2 pivot block will be used
            '
            ABSAKK = Abs(A(K, K))
            '
            ' IMAX is the row-index of the largest off-diagonal element in
            ' column K+1, and COLMAX is its absolute value
            '
            If K < N - 1# Then
                IMAX = K + 1# + 1#
                For II = K + 1# + 2# To N Step 1
                    If Abs(A(II - 1#, K)) > Abs(A(IMAX - 1#, K)) Then
                        IMAX = II
                    End If
                Next II
                COLMAX = Abs(A(IMAX - 1#, K))
            Else
                COLMAX = 0#
            End If
            If MaxReal(ABSAKK, COLMAX) = 0# Then
                '
                ' Column K+1 is zero
                '
                KP = K
            Else
                If ABSAKK >= Alpha * COLMAX Then
                    '
                    ' no interchange, use 1-by-1 pivot block
                    '
                    KP = K
                Else
                    '
                    ' JMAX is the column-index of the largest off-diagonal
                    ' element in row IMAX, and ROWMAX is its absolute value
                    '
                    JMax = K + 1#
                    For II = K + 1# + 1# To IMAX - 1# Step 1
                        If Abs(A(IMAX - 1#, II - 1#)) > Abs(A(IMAX - 1#, JMax - 1#)) Then
                            JMax = II
                        End If
                    Next II
                    ROWMAX = Abs(A(IMAX - 1#, JMax - 1#))
                    If IMAX < N Then
                        JMax = IMAX + 1#
                        For II = IMAX + 2# To N Step 1
                            If Abs(A(II - 1#, IMAX - 1#)) > Abs(A(JMax - 1#, IMAX - 1#)) Then
                                JMax = II
                            End If
                        Next II
                        ROWMAX = MaxReal(ROWMAX, Abs(A(JMax - 1#, IMAX - 1#)))
                    End If
                    VV = COLMAX / ROWMAX
                    If ABSAKK >= Alpha * COLMAX * VV Then
                        '
                        ' no interchange, use 1-by-1 pivot block
                        '
                        KP = K
                    Else
                        If Abs(A(IMAX - 1#, IMAX - 1#)) >= Alpha * ROWMAX Then
                            '
                            ' interchange rows and columns K+1 and IMAX, use 1-by-1
                            ' pivot block
                            '
                            KP = IMAX - 1#
                        Else
                            '
                            ' interchange rows and columns K+1+1 and IMAX, use 2-by-2
                            ' pivot block
                            '
                            KP = IMAX - 1#
                            KSTEP = 2#
                        End If
                    End If
                End If
                KK = K + KSTEP - 1#
                If KP <> KK Then
                    '
                    '              Interchange rows and columns KK+1 and KP+1 in the trailing
                    '              submatrix A(K+1:n,K+1:n)
                    '
                    If KP + 1# < N Then
                        For i_ = KP + 1# To N - 1# Step 1
                            temp(i_) = A(i_, KK)
                        Next i_
                        For i_ = KP + 1# To N - 1# Step 1
                            A(i_, KK) = A(i_, KP)
                        Next i_
                        For i_ = KP + 1# To N - 1# Step 1
                            A(i_, KP) = temp(i_)
                        Next i_
                    End If
                    For i_ = KK + 1# To KP - 1# Step 1
                        temp(i_) = A(i_, KK)
                    Next i_
                    For i_ = KK + 1# To KP - 1# Step 1
                        A(i_, KK) = A(KP, i_)
                    Next i_
                    For i_ = KK + 1# To KP - 1# Step 1
                        A(KP, i_) = temp(i_)
                    Next i_
                    T = A(KK, KK)
                    A(KK, KK) = A(KP, KP)
                    A(KP, KP) = T
                    If KSTEP = 2# Then
                        T = A(K + 1#, K)
                        A(K + 1#, K) = A(KP, K)
                        A(KP, K) = T
                    End If
                End If
                '
                ' Update the trailing submatrix
                '
                If KSTEP = 1# Then
                    '
                    ' 1-by-1 pivot block D(K+1): column K+1 now holds
                    '
                    ' W(K+1) = L(K+1)*D(K+1)
                    '
                    ' where L(K+1) is the K+1-th column of L
                    '
                    If K + 1# < N Then
                        '
                        ' Perform a rank-1 update of A(K+1+1:n,K+1+1:n) as
                        '
                        ' A := A - L(K+1)*D(K+1)*L(K+1)' = A - W(K+1)*(1/D(K+1))*W(K+1)'
                        '
                        D11 = 1# / A(K + 1# - 1#, K + 1# - 1#)
                        For II = K + 1# To N - 1# Step 1
                            VV = -(D11 * A(II, K))
                            For i_ = K + 1# To II Step 1
                                A(II, i_) = A(II, i_) + VV * A(i_, K)
                            Next i_
                        Next II
                        '
                        ' Store L(K+1) in column K+1
                        '
                        For i_ = K + 1# To N - 1# Step 1
                            A(i_, K) = D11 * A(i_, K)
                        Next i_
                    End If
                Else
                    '
                    ' 2-by-2 pivot block D(K+1)
                    '
                    If K < N - 2# Then
                        '
                        ' Perform a rank-2 update of A(K+1+2:n,K+1+2:n) as
                        '
                        ' A := A - ( (A(K+1) A(K+1+1))*D(K+1)**(-1) ) * (A(K+1) A(K+1+1))'
                        '
                        ' where L(K+1) and L(K+1+1) are the K+1-th and (K+1+1)-th
                        ' columns of L
                        '
                        D21 = A(K + 1#, K)
                        D11 = A(K + 1#, K + 1#) / D21
                        D22 = A(K, K) / D21
                        T = 1# / (D11 * D22 - 1#)
                        D21 = T / D21
                        For j = K + 2# To N - 1# Step 1
                            WK = D21 * (D11 * A(j, K) - A(j, K + 1#))
                            WKP1 = D21 * (D22 * A(j, K + 1#) - A(j, K))
                            For i_ = j To N - 1# Step 1
                                A(i_, j) = A(i_, j) - WK * A(i_, K)
                            Next i_
                            For i_ = j To N - 1# Step 1
                                A(i_, j) = A(i_, j) - WKP1 * A(i_, K + 1#)
                            Next i_
                            A(j, K) = WK
                            A(j, K + 1#) = WKP1
                        Next j
                    End If
                End If
            End If
            '
            ' Store details of the interchanges in IPIV
            '
            If KSTEP = 1# Then
                Pivots(K + 1# - 1#) = KP + 1# - 1#
            Else
                Pivots(K + 1# - 1#) = KP + 1# - 1# - N
                Pivots(K + 1# + 1# - 1#) = KP + 1# - 1# - N
            End If
            '
            ' Increase K+1 and return to the start of the main loop
            '
            K = K + KSTEP
        Loop
    End If
End Sub
Public Sub LDLTDecomposition(ByRef A() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef Pivots() As Long)
    Dim i As Long
    Dim IMAX As Long
    Dim j As Long
    Dim JMax As Long
    Dim K As Long
    Dim KK As Long
    Dim KP As Long
    Dim KSTEP As Long
    Dim ABSAKK As Double
    Dim Alpha As Double
    Dim COLMAX As Double
    Dim D11 As Double
    Dim D12 As Double
    Dim D21 As Double
    Dim D22 As Double
    Dim R1 As Double
    Dim ROWMAX As Double
    Dim T As Double
    Dim WK As Double
    Dim WKM1 As Double
    Dim WKP1 As Double
    Dim II As Long
    Dim I1 As Long
    Dim I2 As Long
    Dim VV As Double
    Dim temp() As Double
    Dim i_ As Long
    ReDim Pivots(1# To N)
    ReDim temp(1# To N)
    '
    ' Initialize ALPHA for use in choosing pivot block size.
    '
    Alpha = (1# + Sqr(17#)) / 8#
    If IsUpper Then
        '
        ' Factorize A as U*D*U' using the upper triangle of A
        '
        '
        ' K is the main loop index, decreasing from N to 1 in steps of
        ' 1 or 2
        '
        K = N
        Do While K >= 1#
            KSTEP = 1#
            '
            ' Determine rows and columns to be interchanged and whether
            ' a 1-by-1 or 2-by-2 pivot block will be used
            '
            ABSAKK = Abs(A(K, K))
            '
            ' IMAX is the row-index of the largest off-diagonal element in
            ' column K, and COLMAX is its absolute value
            '
            If K > 1# Then
                IMAX = 1#
                For II = 2# To K - 1# Step 1
                    If Abs(A(II, K)) > Abs(A(IMAX, K)) Then
                        IMAX = II
                    End If
                Next II
                COLMAX = Abs(A(IMAX, K))
            Else
                COLMAX = 0#
            End If
            If MaxReal(ABSAKK, COLMAX) = 0# Then
                '
                ' Column K is zero
                '
                KP = K
            Else
                If ABSAKK >= Alpha * COLMAX Then
                    '
                    ' no interchange, use 1-by-1 pivot block
                    '
                    KP = K
                Else
                    '
                    ' JMAX is the column-index of the largest off-diagonal
                    ' element in row IMAX, and ROWMAX is its absolute value
                    '
                    JMax = IMAX + 1#
                    For II = IMAX + 2# To K Step 1
                        If Abs(A(IMAX, II)) > Abs(A(IMAX, JMax)) Then
                            JMax = II
                        End If
                    Next II
                    ROWMAX = Abs(A(IMAX, JMax))
                    If IMAX > 1# Then
                        JMax = 1#
                        For II = 2# To IMAX - 1# Step 1
                            If Abs(A(II, IMAX)) > Abs(A(JMax, IMAX)) Then
                                JMax = II
                            End If
                        Next II
                        ROWMAX = MaxReal(ROWMAX, Abs(A(JMax, IMAX)))
                    End If
                    VV = COLMAX / ROWMAX
                    If ABSAKK >= Alpha * COLMAX * VV Then
                        '
                        ' no interchange, use 1-by-1 pivot block
                        '
                        KP = K
                    Else
                        If Abs(A(IMAX, IMAX)) >= Alpha * ROWMAX Then
                            '
                            ' interchange rows and columns K and IMAX, use 1-by-1
                            ' pivot block
                            '
                            KP = IMAX
                        Else
                            '
                            ' interchange rows and columns K-1 and IMAX, use 2-by-2
                            ' pivot block
                            '
                            KP = IMAX
                            KSTEP = 2#
                        End If
                    End If
                End If
                KK = K - KSTEP + 1#
                If KP <> KK Then
                    '
                    ' Interchange rows and columns KK and KP in the leading
                    ' submatrix A(1:k,1:k)
                    '
                    I1 = KP - 1#
                    For i_ = 1# To I1 Step 1
                        temp(i_) = A(i_, KK)
                    Next i_
                    For i_ = 1# To I1 Step 1
                        A(i_, KK) = A(i_, KP)
                    Next i_
                    For i_ = 1# To I1 Step 1
                        A(i_, KP) = temp(i_)
                    Next i_
                    I1 = KP + 1#
                    I2 = KK - 1#
                    For i_ = I1 To I2 Step 1
                        temp(i_) = A(i_, KK)
                    Next i_
                    For i_ = I1 To I2 Step 1
                        A(i_, KK) = A(KP, i_)
                    Next i_
                    For i_ = I1 To I2 Step 1
                        A(KP, i_) = temp(i_)
                    Next i_
                    T = A(KK, KK)
                    A(KK, KK) = A(KP, KP)
                    A(KP, KP) = T
                    If KSTEP = 2# Then
                        T = A(K - 1#, K)
                        A(K - 1#, K) = A(KP, K)
                        A(KP, K) = T
                    End If
                End If
                '
                ' Update the leading submatrix
                '
                If KSTEP = 1# Then
                    '
                    ' 1-by-1 pivot block D(k): column k now holds
                    '
                    ' W(k) = U(k)*D(k)
                    '
                    ' where U(k) is the k-th column of U
                    '
                    ' Perform a rank-1 update of A(1:k-1,1:k-1) as
                    '
                    ' A := A - U(k)*D(k)*U(k)' = A - W(k)*1/D(k)*W(k)'
                    '
                    R1 = 1# / A(K, K)
                    For i = 1# To K - 1# Step 1
                        I2 = K - 1#
                        VV = -(R1 * A(i, K))
                        For i_ = i To I2 Step 1
                            A(i, i_) = A(i, i_) + VV * A(i_, K)
                        Next i_
                    Next i
                    '
                    ' Store U(k) in column k
                    '
                    I2 = K - 1#
                    For i_ = 1# To I2 Step 1
                        A(i_, K) = R1 * A(i_, K)
                    Next i_
                Else
                    '
                    ' 2-by-2 pivot block D(k): columns k and k-1 now hold
                    '
                    ' ( W(k-1) W(k) ) = ( U(k-1) U(k) )*D(k)
                    '
                    ' where U(k) and U(k-1) are the k-th and (k-1)-th columns
                    ' of U
                    '
                    ' Perform a rank-2 update of A(1:k-2,1:k-2) as
                    '
                    ' A := A - ( U(k-1) U(k) )*D(k)*( U(k-1) U(k) )'
                    '    = A - ( W(k-1) W(k) )*inv(D(k))*( W(k-1) W(k) )'
                    '
                    If K > 2# Then
                        D12 = A(K - 1#, K)
                        D22 = A(K - 1#, K - 1#) / D12
                        D11 = A(K, K) / D12
                        T = 1# / (D11 * D22 - 1#)
                        D12 = T / D12
                        For j = K - 2# To 1# Step -1
                            WKM1 = D12 * (D11 * A(j, K - 1#) - A(j, K))
                            WK = D12 * (D22 * A(j, K) - A(j, K - 1#))
                            For i_ = 1# To j Step 1
                                A(i_, j) = A(i_, j) - WK * A(i_, K)
                            Next i_
                            I1 = K - 1#
                            For i_ = 1# To j Step 1
                                A(i_, j) = A(i_, j) - WKM1 * A(i_, I1)
                            Next i_
                            A(j, K) = WK
                            A(j, K - 1#) = WKM1
                        Next j
                    End If
                End If
            End If
            '
            ' Store details of the interchanges in IPIV
            '
            If KSTEP = 1# Then
                Pivots(K) = KP
            Else
                Pivots(K) = -KP
                Pivots(K - 1#) = -KP
            End If
            '
            ' Decrease K and return to the start of the main loop
            '
            K = K - KSTEP
        Loop
    Else
        '
        ' Factorize A as L*D*L' using the lower triangle of A
        '
        ' K is the main loop index, increasing from 1 to N in steps of
        ' 1 or 2
        '
        K = 1#
        Do While K <= N
            KSTEP = 1#
            '
            ' Determine rows and columns to be interchanged and whether
            ' a 1-by-1 or 2-by-2 pivot block will be used
            '
            ABSAKK = Abs(A(K, K))
            '
            ' IMAX is the row-index of the largest off-diagonal element in
            ' column K, and COLMAX is its absolute value
            '
            If K < N Then
                IMAX = K + 1#
                For II = K + 2# To N Step 1
                    If Abs(A(II, K)) > Abs(A(IMAX, K)) Then
                        IMAX = II
                    End If
                Next II
                COLMAX = Abs(A(IMAX, K))
            Else
                COLMAX = 0#
            End If
            If MaxReal(ABSAKK, COLMAX) = 0# Then
                '
                ' Column K is zero
                '
                KP = K
            Else
                If ABSAKK >= Alpha * COLMAX Then
                    '
                    ' no interchange, use 1-by-1 pivot block
                    '
                    KP = K
                Else
                    '
                    ' JMAX is the column-index of the largest off-diagonal
                    ' element in row IMAX, and ROWMAX is its absolute value
                    '
                    JMax = K
                    For II = K + 1# To IMAX - 1# Step 1
                        If Abs(A(IMAX, II)) > Abs(A(IMAX, JMax)) Then
                            JMax = II
                        End If
                    Next II
                    ROWMAX = Abs(A(IMAX, JMax))
                    If IMAX < N Then
                        JMax = IMAX + 1#
                        For II = IMAX + 2# To N Step 1
                            If Abs(A(II, IMAX)) > Abs(A(JMax, IMAX)) Then
                                JMax = II
                            End If
                        Next II
                        ROWMAX = MaxReal(ROWMAX, Abs(A(JMax, IMAX)))
                    End If
                    VV = COLMAX / ROWMAX
                    If ABSAKK >= Alpha * COLMAX * VV Then
                        '
                        ' no interchange, use 1-by-1 pivot block
                        '
                        KP = K
                    Else
                        If Abs(A(IMAX, IMAX)) >= Alpha * ROWMAX Then
                            '
                            ' interchange rows and columns K and IMAX, use 1-by-1
                            ' pivot block
                            '
                            KP = IMAX
                        Else
                            '
                            ' interchange rows and columns K+1 and IMAX, use 2-by-2
                            ' pivot block
                            '
                            KP = IMAX
                            KSTEP = 2#
                        End If
                    End If
                End If
                KK = K + KSTEP - 1#
                If KP <> KK Then
                    '
                    '              Interchange rows and columns KK and KP in the trailing
                    '              submatrix A(k:n,k:n)
                    '
                    If KP < N Then
                        I1 = KP + 1#
                        For i_ = I1 To N Step 1
                            temp(i_) = A(i_, KK)
                        Next i_
                        For i_ = I1 To N Step 1
                            A(i_, KK) = A(i_, KP)
                        Next i_
                        For i_ = I1 To N Step 1
                            A(i_, KP) = temp(i_)
                        Next i_
                    End If
                    I1 = KK + 1#
                    I2 = KP - 1#
                    For i_ = I1 To I2 Step 1
                        temp(i_) = A(i_, KK)
                    Next i_
                    For i_ = I1 To I2 Step 1
                        A(i_, KK) = A(KP, i_)
                    Next i_
                    For i_ = I1 To I2 Step 1
                        A(KP, i_) = temp(i_)
                    Next i_
                    T = A(KK, KK)
                    A(KK, KK) = A(KP, KP)
                    A(KP, KP) = T
                    If KSTEP = 2# Then
                        T = A(K + 1#, K)
                        A(K + 1#, K) = A(KP, K)
                        A(KP, K) = T
                    End If
                End If
                '
                ' Update the trailing submatrix
                '
                If KSTEP = 1# Then
                    '
                    ' 1-by-1 pivot block D(k): column k now holds
                    '
                    ' W(k) = L(k)*D(k)
                    '
                    ' where L(k) is the k-th column of L
                    '
                    If K < N Then
                        '
                        ' Perform a rank-1 update of A(k+1:n,k+1:n) as
                        '
                        ' A := A - L(k)*D(k)*L(k)' = A - W(k)*(1/D(k))*W(k)'
                        '
                        D11 = 1# / A(K, K)
                        For II = K + 1# To N Step 1
                            I1 = K + 1#
                            I2 = II
                            VV = -(D11 * A(II, K))
                            For i_ = I1 To I2 Step 1
                                A(II, i_) = A(II, i_) + VV * A(i_, K)
                            Next i_
                        Next II
                        '
                        ' Store L(k) in column K
                        '
                        I1 = K + 1#
                        For i_ = I1 To N Step 1
                            A(i_, K) = D11 * A(i_, K)
                        Next i_
                    End If
                Else
                    '
                    ' 2-by-2 pivot block D(k)
                    '
                    If K < N - 1# Then
                        '
                        ' Perform a rank-2 update of A(k+2:n,k+2:n) as
                        '
                        ' A := A - ( (A(k) A(k+1))*D(k)**(-1) ) * (A(k) A(k+1))'
                        '
                        ' where L(k) and L(k+1) are the k-th and (k+1)-th
                        ' columns of L
                        '
                        D21 = A(K + 1#, K)
                        D11 = A(K + 1#, K + 1#) / D21
                        D22 = A(K, K) / D21
                        T = 1# / (D11 * D22 - 1#)
                        D21 = T / D21
                        For j = K + 2# To N Step 1
                            WK = D21 * (D11 * A(j, K) - A(j, K + 1#))
                            WKP1 = D21 * (D22 * A(j, K + 1#) - A(j, K))
                            II = K + 1#
                            For i_ = j To N Step 1
                                A(i_, j) = A(i_, j) - WK * A(i_, K)
                            Next i_
                            For i_ = j To N Step 1
                                A(i_, j) = A(i_, j) - WKP1 * A(i_, II)
                            Next i_
                            A(j, K) = WK
                            A(j, K + 1#) = WKP1
                        Next j
                    End If
                End If
            End If
            '
            ' Store details of the interchanges in IPIV
            '
            If KSTEP = 1# Then
                Pivots(K) = KP
            Else
                Pivots(K) = -KP
                Pivots(K + 1#) = -KP
            End If
            '
            ' Increase K and return to the start of the main loop
            '
            K = K + KSTEP
        Loop
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2005-2007, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Inverse matrix update by the Sherman-Morrison formula
'
'The algorithm updates matrix A^-1 when adding a number to an element
'of matrix A.
'
'Input parameters:
'    InvA    -   inverse of matrix A.
'                Array whose indexes range within [0..N-1, 0..N-1].
'    N       -   size of matrix A.
'    UpdRow  -   row where the element to be updated is stored.
'    UpdColumn - column where the element to be updated is stored.
'    UpdVal  -   a number to be added to the element.
'
'
'Output parameters:
'    InvA    -   inverse of modified matrix A.
'
'  -- ALGLIB --
'     Copyright 2005 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixInvUpdateSimple(ByRef InvA() As Double, _
         ByVal N As Long, _
         ByVal UpdRow As Long, _
         ByVal UpdColumn As Long, _
         ByVal UpdVal As Double)
    Dim T1() As Double
    Dim T2() As Double
    Dim i As Long
    Dim Lambda As Double
    Dim VT As Double
    Dim i_ As Long
    ReDim T1(0# To N - 1#)
    ReDim T2(0# To N - 1#)
    
    '
    ' T1 = InvA * U
    '
    For i_ = 0# To N - 1# Step 1
        T1(i_) = InvA(i_, UpdRow)
    Next i_
    
    '
    ' T2 = v*InvA
    '
    For i_ = 0# To N - 1# Step 1
        T2(i_) = InvA(UpdColumn, i_)
    Next i_
    
    '
    ' Lambda = v * InvA * U
    '
    Lambda = UpdVal * InvA(UpdColumn, UpdRow)
    
    '
    ' InvA = InvA - correction
    '
    For i = 0# To N - 1# Step 1
        VT = UpdVal * T1(i)
        VT = VT / (1# + Lambda)
        For i_ = 0# To N - 1# Step 1
            InvA(i, i_) = InvA(i, i_) - VT * T2(i_)
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Inverse matrix update by the Sherman-Morrison formula
'
'The algorithm updates matrix A^-1 when adding a vector to a row
'of matrix A.
'
'Input parameters:
'    InvA    -   inverse of matrix A.
'                Array whose indexes range within [0..N-1, 0..N-1].
'    N       -   size of matrix A.
'    UpdRow  -   the row of A whose vector V was added.
'                0 <= Row <= N-1
'    V       -   the vector to be added to a row.
'                Array whose index ranges within [0..N-1].
'
'Output parameters:
'    InvA    -   inverse of modified matrix A.
'
'  -- ALGLIB --
'     Copyright 2005 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixInvUpdateRow(ByRef InvA() As Double, _
         ByVal N As Long, _
         ByVal UpdRow As Long, _
         ByRef V() As Double)
    Dim T1() As Double
    Dim T2() As Double
    Dim i As Long
    Dim j As Long
    Dim Lambda As Double
    Dim VT As Double
    Dim i_ As Long
    ReDim T1(0# To N - 1#)
    ReDim T2(0# To N - 1#)
    
    '
    ' T1 = InvA * U
    '
    For i_ = 0# To N - 1# Step 1
        T1(i_) = InvA(i_, UpdRow)
    Next i_
    
    '
    ' T2 = v*InvA
    ' Lambda = v * InvA * U
    '
    For j = 0# To N - 1# Step 1
        VT = 0#
        For i_ = 0# To N - 1# Step 1
            VT = VT + V(i_) * InvA(i_, j)
        Next i_
        T2(j) = VT
    Next j
    Lambda = T2(UpdRow)
    
    '
    ' InvA = InvA - correction
    '
    For i = 0# To N - 1# Step 1
        VT = T1(i) / (1# + Lambda)
        For i_ = 0# To N - 1# Step 1
            InvA(i, i_) = InvA(i, i_) - VT * T2(i_)
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Inverse matrix update by the Sherman-Morrison formula
'
'The algorithm updates matrix A^-1 when adding a vector to a column
'of matrix A.
'
'Input parameters:
'    InvA        -   inverse of matrix A.
'                    Array whose indexes range within [0..N-1, 0..N-1].
'    N           -   size of matrix A.
'    UpdColumn   -   the column of A whose vector U was added.
'                    0 <= UpdColumn <= N-1
'    U           -   the vector to be added to a column.
'                    Array whose index ranges within [0..N-1].
'
'Output parameters:
'    InvA        -   inverse of modified matrix A.
'
'  -- ALGLIB --
'     Copyright 2005 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixInvUpdateColumn(ByRef InvA() As Double, _
         ByVal N As Long, _
         ByVal UpdColumn As Long, _
         ByRef U() As Double)
    Dim T1() As Double
    Dim T2() As Double
    Dim i As Long
    Dim Lambda As Double
    Dim VT As Double
    Dim i_ As Long
    ReDim T1(0# To N - 1#)
    ReDim T2(0# To N - 1#)
    
    '
    ' T1 = InvA * U
    ' Lambda = v * InvA * U
    '
    For i = 0# To N - 1# Step 1
        VT = 0#
        For i_ = 0# To N - 1# Step 1
            VT = VT + InvA(i, i_) * U(i_)
        Next i_
        T1(i) = VT
    Next i
    Lambda = T1(UpdColumn)
    
    '
    ' T2 = v*InvA
    '
    For i_ = 0# To N - 1# Step 1
        T2(i_) = InvA(UpdColumn, i_)
    Next i_
    
    '
    ' InvA = InvA - correction
    '
    For i = 0# To N - 1# Step 1
        VT = T1(i) / (1# + Lambda)
        For i_ = 0# To N - 1# Step 1
            InvA(i, i_) = InvA(i, i_) - VT * T2(i_)
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Inverse matrix update by the Sherman-Morrison formula
'
'The algorithm computes the inverse of matrix A+u*v by using the given matrix
'A^-1 and the vectors u and v.
'
'Input parameters:
'    InvA    -   inverse of matrix A.
'                Array whose indexes range within [0..N-1, 0..N-1].
'    N       -   size of matrix A.
'    U       -   the vector modifying the matrix.
'                Array whose index ranges within [0..N-1].
'    V       -   the vector modifying the matrix.
'                Array whose index ranges within [0..N-1].
'
'Output parameters:
'    InvA - inverse of matrix A + u*v'.
'
'  -- ALGLIB --
'     Copyright 2005 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixInvUpdateUV(ByRef InvA() As Double, _
         ByVal N As Long, _
         ByRef U() As Double, _
         ByRef V() As Double)
    Dim T1() As Double
    Dim T2() As Double
    Dim i As Long
    Dim j As Long
    Dim Lambda As Double
    Dim VT As Double
    Dim i_ As Long
    ReDim T1(0# To N - 1#)
    ReDim T2(0# To N - 1#)
    
    '
    ' T1 = InvA * U
    ' Lambda = v * T1
    '
    For i = 0# To N - 1# Step 1
        VT = 0#
        For i_ = 0# To N - 1# Step 1
            VT = VT + InvA(i, i_) * U(i_)
        Next i_
        T1(i) = VT
    Next i
    Lambda = 0#
    For i_ = 0# To N - 1# Step 1
        Lambda = Lambda + V(i_) * T1(i_)
    Next i_
    
    '
    ' T2 = v*InvA
    '
    For j = 0# To N - 1# Step 1
        VT = 0#
        For i_ = 0# To N - 1# Step 1
            VT = VT + V(i_) * InvA(i_, j)
        Next i_
        T2(j) = VT
    Next j
    
    '
    ' InvA = InvA - correction
    '
    For i = 0# To N - 1# Step 1
        VT = T1(i) / (1# + Lambda)
        For i_ = 0# To N - 1# Step 1
            InvA(i, i_) = InvA(i, i_) - VT * T2(i_)
        Next i_
    Next i
End Sub
Public Sub ShermanMorrisonSimpleUpdate(ByRef InvA() As Double, _
         ByVal N As Long, _
         ByVal UpdRow As Long, _
         ByVal UpdColumn As Long, _
         ByVal UpdVal As Double)
    Dim T1() As Double
    Dim T2() As Double
    Dim i As Long
    Dim Lambda As Double
    Dim VT As Double
    Dim i_ As Long
    ReDim T1(1# To N)
    ReDim T2(1# To N)
    
    '
    ' T1 = InvA * U
    '
    For i_ = 1# To N Step 1
        T1(i_) = InvA(i_, UpdRow)
    Next i_
    
    '
    ' T2 = v*InvA
    '
    For i_ = 1# To N Step 1
        T2(i_) = InvA(UpdColumn, i_)
    Next i_
    
    '
    ' Lambda = v * InvA * U
    '
    Lambda = UpdVal * InvA(UpdColumn, UpdRow)
    
    '
    ' InvA = InvA - correction
    '
    For i = 1# To N Step 1
        VT = UpdVal * T1(i)
        VT = VT / (1# + Lambda)
        For i_ = 1# To N Step 1
            InvA(i, i_) = InvA(i, i_) - VT * T2(i_)
        Next i_
    Next i
End Sub
Public Sub ShermanMorrisonUpdateRow(ByRef InvA() As Double, _
         ByVal N As Long, _
         ByVal UpdRow As Long, _
         ByRef V() As Double)
    Dim T1() As Double
    Dim T2() As Double
    Dim i As Long
    Dim j As Long
    Dim Lambda As Double
    Dim VT As Double
    Dim i_ As Long
    ReDim T1(1# To N)
    ReDim T2(1# To N)
    
    '
    ' T1 = InvA * U
    '
    For i_ = 1# To N Step 1
        T1(i_) = InvA(i_, UpdRow)
    Next i_
    
    '
    ' T2 = v*InvA
    ' Lambda = v * InvA * U
    '
    For j = 1# To N Step 1
        VT = 0#
        For i_ = 1# To N Step 1
            VT = VT + V(i_) * InvA(i_, j)
        Next i_
        T2(j) = VT
    Next j
    Lambda = T2(UpdRow)
    
    '
    ' InvA = InvA - correction
    '
    For i = 1# To N Step 1
        VT = T1(i) / (1# + Lambda)
        For i_ = 1# To N Step 1
            InvA(i, i_) = InvA(i, i_) - VT * T2(i_)
        Next i_
    Next i
End Sub
Public Sub ShermanMorrisonUpdateColumn(ByRef InvA() As Double, _
         ByVal N As Long, _
         ByVal UpdColumn As Long, _
         ByRef U() As Double)
    Dim T1() As Double
    Dim T2() As Double
    Dim i As Long
    Dim Lambda As Double
    Dim VT As Double
    Dim i_ As Long
    ReDim T1(1# To N)
    ReDim T2(1# To N)
    
    '
    ' T1 = InvA * U
    ' Lambda = v * InvA * U
    '
    For i = 1# To N Step 1
        VT = 0#
        For i_ = 1# To N Step 1
            VT = VT + InvA(i, i_) * U(i_)
        Next i_
        T1(i) = VT
    Next i
    Lambda = T1(UpdColumn)
    
    '
    ' T2 = v*InvA
    '
    For i_ = 1# To N Step 1
        T2(i_) = InvA(UpdColumn, i_)
    Next i_
    
    '
    ' InvA = InvA - correction
    '
    For i = 1# To N Step 1
        VT = T1(i) / (1# + Lambda)
        For i_ = 1# To N Step 1
            InvA(i, i_) = InvA(i, i_) - VT * T2(i_)
        Next i_
    Next i
End Sub
Public Sub ShermanMorrisonUpdateUV(ByRef InvA() As Double, _
         ByVal N As Long, _
         ByRef U() As Double, _
         ByRef V() As Double)
    Dim T1() As Double
    Dim T2() As Double
    Dim i As Long
    Dim j As Long
    Dim Lambda As Double
    Dim VT As Double
    Dim i_ As Long
    ReDim T1(1# To N)
    ReDim T2(1# To N)
    
    '
    ' T1 = InvA * U
    ' Lambda = v * T1
    '
    For i = 1# To N Step 1
        VT = 0#
        For i_ = 1# To N Step 1
            VT = VT + InvA(i, i_) * U(i_)
        Next i_
        T1(i) = VT
    Next i
    Lambda = 0#
    For i_ = 1# To N Step 1
        Lambda = Lambda + V(i_) * T1(i_)
    Next i_
    
    '
    ' T2 = v*InvA
    '
    For j = 1# To N Step 1
        VT = 0#
        For i_ = 1# To N Step 1
            VT = VT + V(i_) * InvA(i_, j)
        Next i_
        T2(j) = VT
    Next j
    
    '
    ' InvA = InvA - correction
    '
    For i = 1# To N Step 1
        VT = T1(i) / (1# + Lambda)
        For i_ = 1# To N Step 1
            InvA(i, i_) = InvA(i, i_) - VT * T2(i_)
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 1992-2007 The University of Tennessee.  All rights reserved.
'
'Contributors:
'    * Sergey Bochkanov (ALGLIB project). Translation from FORTRAN to
'      pseudocode.
'
'See subroutines comments for additional copyrights.
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Matrix norm estimation
'
'The algorithm estimates the 1-norm of square matrix A  on  the  assumption
'that the multiplication of matrix  A  by  the  vector  is  available  (the
'iterative method is used). It is recommended to use this algorithm  if  it
'is hard  to  calculate  matrix  elements  explicitly  (for  example,  when
'estimating the inverse matrix norm).
'
'The algorithm uses back communication for multiplying the  vector  by  the
'matrix.  If  KASE=0  after  returning from a subroutine, its execution was
'completed successfully, otherwise it is required to multiply the  returned
'vector by matrix A and call the subroutine again.
'
'The DemoIterativeEstimateNorm subroutine shows a simple example.
'
'Parameters:
'    N       -   size of matrix A.
'    V       -   vector.   It is initialized by the subroutine on the first
'                call. It is then passed into it on repeated calls.
'    X       -   if KASE<>0, it contains the vector to be replaced by:
'                    A * X,      if KASE=1
'                    A^T * X,    if KASE=2
'                Array whose index ranges within [1..N].
'    ISGN    -   vector. It is initialized by the subroutine on  the  first
'                call. It is then passed into it on repeated calls.
'    EST     -   if KASE=0, it contains the lower boundary of the matrix
'                norm estimate.
'    KASE    -   on the first call, it should be equal to 0. After the last
'                return, it is equal to 0 (EST contains the  matrix  norm),
'                on intermediate returns it can be equal to 1 or 2 depending
'                on the operation to be performed on vector X.
'
'  -- LAPACK auxiliary routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     February 29, 1992
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub IterativeEstimate1Norm(ByVal N As Long, _
         ByRef V() As Double, _
         ByRef X() As Double, _
         ByRef ISGN() As Long, _
         ByRef EST As Double, _
         ByRef KASE As Long)
    Dim ITMAX As Long
    Dim i As Long
    Dim T As Double
    Dim Flg As Boolean
    Dim PosITER As Long
    Dim PosJ As Long
    Dim PosJLAST As Long
    Dim PosJUMP As Long
    Dim PosALTSGN As Long
    Dim PosESTOLD As Long
    Dim PosTEMP As Long
    Dim i_ As Long
    ITMAX = 5#
    PosALTSGN = N + 1#
    PosESTOLD = N + 2#
    PosTEMP = N + 3#
    PosITER = N + 1#
    PosJ = N + 2#
    PosJLAST = N + 3#
    PosJUMP = N + 4#
    If KASE = 0# Then
        ReDim V(1# To N + 3#)
        ReDim X(1# To N)
        ReDim ISGN(1# To N + 4#)
        T = 1# / N
        For i = 1# To N Step 1
            X(i) = T
        Next i
        KASE = 1#
        ISGN(PosJUMP) = 1#
        Exit Sub
    End If
    '
    '     ................ ENTRY   (JUMP = 1)
    '     FIRST ITERATION.  X HAS BEEN OVERWRITTEN BY A*X.
    '
    If ISGN(PosJUMP) = 1# Then
        If N = 1# Then
            V(1#) = X(1#)
            EST = Abs(V(1#))
            KASE = 0#
            Exit Sub
        End If
        EST = 0#
        For i = 1# To N Step 1
            EST = EST + Abs(X(i))
        Next i
        For i = 1# To N Step 1
            If X(i) >= 0# Then
                X(i) = 1#
            Else
                X(i) = -1#
            End If
            ISGN(i) = Sgn(X(i))
        Next i
        KASE = 2#
        ISGN(PosJUMP) = 2#
        Exit Sub
    End If
    '
    '     ................ ENTRY   (JUMP = 2)
    '     FIRST ITERATION.  X HAS BEEN OVERWRITTEN BY TRANDPOSE(A)*X.
    '
    If ISGN(PosJUMP) = 2# Then
        ISGN(PosJ) = 1#
        For i = 2# To N Step 1
            If Abs(X(i)) > Abs(X(ISGN(PosJ))) Then
                ISGN(PosJ) = i
            End If
        Next i
        ISGN(PosITER) = 2#
        '
        ' MAIN LOOP - ITERATIONS 2,3,...,ITMAX.
        '
        For i = 1# To N Step 1
            X(i) = 0#
        Next i
        X(ISGN(PosJ)) = 1#
        KASE = 1#
        ISGN(PosJUMP) = 3#
        Exit Sub
    End If
    '
    '     ................ ENTRY   (JUMP = 3)
    '     X HAS BEEN OVERWRITTEN BY A*X.
    '
    If ISGN(PosJUMP) = 3# Then
        For i_ = 1# To N Step 1
            V(i_) = X(i_)
        Next i_
        V(PosESTOLD) = EST
        EST = 0#
        For i = 1# To N Step 1
            EST = EST + Abs(V(i))
        Next i
        Flg = False
        For i = 1# To N Step 1
            If X(i) >= 0# And ISGN(i) < 0# Or X(i) < 0# And ISGN(i) >= 0# Then
                Flg = True
            End If
        Next i
        '
        ' REPEATED SIGN VECTOR DETECTED, HENCE ALGORITHM HAS CONVERGED.
        ' OR MAY BE CYCLING.
        '
        If Not Flg Or EST <= V(PosESTOLD) Then
            V(PosALTSGN) = 1#
            For i = 1# To N Step 1
                X(i) = V(PosALTSGN) * (1# + (i - 1#) / (N - 1#))
                V(PosALTSGN) = -V(PosALTSGN)
            Next i
            KASE = 1#
            ISGN(PosJUMP) = 5#
            Exit Sub
        End If
        For i = 1# To N Step 1
            If X(i) >= 0# Then
                X(i) = 1#
                ISGN(i) = 1#
            Else
                X(i) = -1#
                ISGN(i) = -1#
            End If
        Next i
        KASE = 2#
        ISGN(PosJUMP) = 4#
        Exit Sub
    End If
    '
    '     ................ ENTRY   (JUMP = 4)
    '     X HAS BEEN OVERWRITTEN BY TRANDPOSE(A)*X.
    '
    If ISGN(PosJUMP) = 4# Then
        ISGN(PosJLAST) = ISGN(PosJ)
        ISGN(PosJ) = 1#
        For i = 2# To N Step 1
            If Abs(X(i)) > Abs(X(ISGN(PosJ))) Then
                ISGN(PosJ) = i
            End If
        Next i
        If X(ISGN(PosJLAST)) <> Abs(X(ISGN(PosJ))) And ISGN(PosITER) < ITMAX Then
            ISGN(PosITER) = ISGN(PosITER) + 1#
            For i = 1# To N Step 1
                X(i) = 0#
            Next i
            X(ISGN(PosJ)) = 1#
            KASE = 1#
            ISGN(PosJUMP) = 3#
            Exit Sub
        End If
        '
        ' ITERATION COMPLETE.  FINAL STAGE.
        '
        V(PosALTSGN) = 1#
        For i = 1# To N Step 1
            X(i) = V(PosALTSGN) * (1# + (i - 1#) / (N - 1#))
            V(PosALTSGN) = -V(PosALTSGN)
        Next i
        KASE = 1#
        ISGN(PosJUMP) = 5#
        Exit Sub
    End If
    '
    '     ................ ENTRY   (JUMP = 5)
    '     X HAS BEEN OVERWRITTEN BY A*X.
    '
    If ISGN(PosJUMP) = 5# Then
        V(PosTEMP) = 0#
        For i = 1# To N Step 1
            V(PosTEMP) = V(PosTEMP) + Abs(X(i))
        Next i
        V(PosTEMP) = 2# * V(PosTEMP) / (3# * N)
        If V(PosTEMP) > EST Then
            For i_ = 1# To N Step 1
                V(i_) = X(i_)
            Next i_
            EST = V(PosTEMP)
        End If
        KASE = 0#
        Exit Sub
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Example of usage of an IterativeEstimateNorm subroutine
'
'Input parameters:
'    A   -   matrix.
'            Array whose indexes range within [1..N, 1..N].
'
'Return:
'    Matrix norm estimated by the subroutine.
'
'  -- ALGLIB --
'     Copyright 2005 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function DemoIterativeEstimate1Norm(ByRef A() As Double, _
         ByVal N As Long) As Double
    Dim Result As Double
    Dim i As Long
    Dim S As Double
    Dim X() As Double
    Dim T() As Double
    Dim V() As Double
    Dim IV() As Long
    Dim KASE As Long
    Dim i_ As Long
    KASE = 0#
    ReDim T(1# To N)
    Call IterativeEstimate1Norm(N, V, X, IV, Result, KASE)
    Do While KASE <> 0#
        If KASE = 1# Then
            For i = 1# To N Step 1
                S = 0#
                For i_ = 1# To N Step 1
                    S = S + A(i, i_) * X(i_)
                Next i_
                T(i) = S
            Next i
        Else
            For i = 1# To N Step 1
                S = 0#
                For i_ = 1# To N Step 1
                    S = S + A(i_, i) * X(i_)
                Next i_
                T(i) = S
            Next i
        End If
        For i_ = 1# To N Step 1
            X(i_) = T(i_)
        Next i_
        Call IterativeEstimate1Norm(N, V, X, IV, Result, KASE)
    Loop
    DemoIterativeEstimate1Norm = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 1992-2007 The University of Tennessee.  All rights reserved.
'
'Contributors:
'    * Sergey Bochkanov (ALGLIB project). Translation from FORTRAN to
'      pseudocode.
'
'See subroutines comments for additional copyrights.
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
Public Sub HermitianMatrixVectorMultiply(ByRef A() As Complex, _
         ByVal IsUpper As Boolean, _
         ByVal I1 As Long, _
         ByVal I2 As Long, _
         ByRef X() As Complex, _
         ByRef Alpha_ As Complex, _
         ByRef y() As Complex)
    Dim Alpha As Complex
    Dim i As Long
    Dim BA1 As Long
    Dim BA2 As Long
    Dim BY1 As Long
    Dim BY2 As Long
    Dim BX1 As Long
    Dim BX2 As Long
    Dim N As Long
    Dim V As Complex
    Dim i_ As Long
    Dim i1_ As Long
    Alpha = Alpha_
    N = I2 - I1 + 1#
    If N <= 0# Then
        Exit Sub
    End If
    
    '
    ' Let A = L + D + U, where
    '  L is strictly lower triangular (main diagonal is zero)
    '  D is diagonal
    '  U is strictly upper triangular (main diagonal is zero)
    '
    ' A*x = L*x + D*x + U*x
    '
    ' Calculate D*x first
    '
    For i = I1 To I2 Step 1
        y(i - I1 + 1#) = C_Mul(A(i, i), X(i - I1 + 1#))
    Next i
    
    '
    ' Add L*x + U*x
    '
    If IsUpper Then
        For i = I1 To I2 - 1# Step 1
            
            '
            ' Add L*x to the result
            '
            V = X(i - I1 + 1#)
            BY1 = i - I1 + 2#
            BY2 = N
            BA1 = i + 1#
            BA2 = I2
            i1_ = (BA1) - (BY1)
            For i_ = BY1 To BY2 Step 1
                y(i_) = C_Add(y(i_), C_Mul(V, Conj(A(i, i_ + i1_))))
            Next i_
            
            '
            ' Add U*x to the result
            '
            BX1 = i - I1 + 2#
            BX2 = N
            BA1 = i + 1#
            BA2 = I2
            i1_ = (BA1) - (BX1)
            V = C_Complex(0#)
            For i_ = BX1 To BX2 Step 1
                V = C_Add(V, C_Mul(X(i_), A(i, i_ + i1_)))
            Next i_
            y(i - I1 + 1#) = C_Add(y(i - I1 + 1#), V)
        Next i
    Else
        For i = I1 + 1# To I2 Step 1
            
            '
            ' Add L*x to the result
            '
            BX1 = 1#
            BX2 = i - I1
            BA1 = I1
            BA2 = i - 1#
            i1_ = (BA1) - (BX1)
            V = C_Complex(0#)
            For i_ = BX1 To BX2 Step 1
                V = C_Add(V, C_Mul(X(i_), A(i, i_ + i1_)))
            Next i_
            y(i - I1 + 1#) = C_Add(y(i - I1 + 1#), V)
            
            '
            ' Add U*x to the result
            '
            V = X(i - I1 + 1#)
            BY1 = 1#
            BY2 = i - I1
            BA1 = I1
            BA2 = i - 1#
            i1_ = (BA1) - (BY1)
            For i_ = BY1 To BY2 Step 1
                y(i_) = C_Add(y(i_), C_Mul(V, Conj(A(i, i_ + i1_))))
            Next i_
        Next i
    End If
    For i_ = 1# To N Step 1
        y(i_) = C_Mul(Alpha, y(i_))
    Next i_
End Sub
Public Sub HermitianRank2Update(ByRef A() As Complex, _
         ByVal IsUpper As Boolean, _
         ByVal I1 As Long, _
         ByVal I2 As Long, _
         ByRef X() As Complex, _
         ByRef y() As Complex, _
         ByRef T() As Complex, _
         ByRef Alpha_ As Complex)
    Dim Alpha As Complex
    Dim i As Long
    Dim TP1 As Long
    Dim TP2 As Long
    Dim V As Complex
    Dim i_ As Long
    Dim i1_ As Long
    Alpha = Alpha_
    If IsUpper Then
        For i = I1 To I2 Step 1
            TP1 = i + 1# - I1
            TP2 = I2 - I1 + 1#
            V = C_Mul(Alpha, X(i + 1# - I1))
            For i_ = TP1 To TP2 Step 1
                T(i_) = C_Mul(V, Conj(y(i_)))
            Next i_
            V = C_Mul(Conj(Alpha), y(i + 1# - I1))
            For i_ = TP1 To TP2 Step 1
                T(i_) = C_Add(T(i_), C_Mul(V, Conj(X(i_))))
            Next i_
            i1_ = (TP1) - (i)
            For i_ = i To I2 Step 1
                A(i, i_) = C_Add(A(i, i_), T(i_ + i1_))
            Next i_
        Next i
    Else
        For i = I1 To I2 Step 1
            TP1 = 1#
            TP2 = i + 1# - I1
            V = C_Mul(Alpha, X(i + 1# - I1))
            For i_ = TP1 To TP2 Step 1
                T(i_) = C_Mul(V, Conj(y(i_)))
            Next i_
            V = C_Mul(Conj(Alpha), y(i + 1# - I1))
            For i_ = TP1 To TP2 Step 1
                T(i_) = C_Add(T(i_), C_Mul(V, Conj(X(i_))))
            Next i_
            i1_ = (TP1) - (I1)
            For i_ = I1 To i Step 1
                A(i, i_) = C_Add(A(i, i_), T(i_ + i1_))
            Next i_
        Next i
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2007-2008, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Dense solver.
'
'This  subroutine  solves  a  system  A*x=b,  where A is NxN non-denegerate
'real matrix, x and b are vectors.
'
'Algorithm features:
'* automatic detection of degenerate cases
'* condition number estimation
'* iterative refinement
'* O(N^3) complexity
'
'INPUT PARAMETERS
'    A       -   array[0..N-1,0..N-1], system matrix
'    N       -   size of A
'    B       -   array[0..N-1], right part
'
'OUTPUT PARAMETERS
'    Info    -   return code:
'                * -3    A is singular, or VERY close to singular.
'                        X is filled by zeros in such cases.
'                * -1    N<=0 was passed
'                *  1    task is solved (but matrix A may be ill-conditioned,
'                        check R1/RInf parameters for condition numbers).
'    Rep     -   solver report, see below for more info
'    X       -   array[0..N-1], it contains:
'                * solution of A*x=b if A is non-singular (well-conditioned
'                  or ill-conditioned, but not very close to singular)
'                * zeros,  if  A  is  singular  or  VERY  close to singular
'                  (in this case Info=-3).
'
'SOLVER REPORT
'
'Subroutine sets following fields of the Rep structure:
'* R1        reciprocal of condition number: 1/cond(A), 1-norm.
'* RInf      reciprocal of condition number: 1/cond(A), inf-norm.
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixSolve(ByRef A() As Double, _
         ByVal N As Long, _
         ByRef B() As Double, _
         ByRef Info As Long, _
         ByRef Rep As DenseSolverReport, _
         ByRef X() As Double)
    Dim BM() As Double
    Dim XM() As Double
    Dim i_ As Long
    If N <= 0# Then
        Info = -1#
        Exit Sub
    End If
    ReDim BM(0 To N - 1, 0 To 1# - 1)
    For i_ = 0# To N - 1# Step 1
        BM(i_, 0#) = B(i_)
    Next i_
    Call RMatrixSolveM(A, N, BM, 1#, True, Info, Rep, XM)
    ReDim X(0 To N - 1)
    For i_ = 0# To N - 1# Step 1
        X(i_) = XM(i_, 0#)
    Next i_
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Dense solver.
'
'Similar to RMatrixSolve() but solves task with multiple right parts (where
'b and x are NxM matrices).
'
'Algorithm features:
'* automatic detection of degenerate cases
'* condition number estimation
'* optional iterative refinement
'* O(N^3+M*N^2) complexity
'
'INPUT PARAMETERS
'    A       -   array[0..N-1,0..N-1], system matrix
'    N       -   size of A
'    B       -   array[0..N-1,0..M-1], right part
'    M       -   right part size
'    RFS     -   iterative refinement switch:
'                * True - refinement is used.
'                  Less performance, more precision.
'                * False - refinement is not used.
'                  More performance, less precision.
'
'OUTPUT PARAMETERS
'    Info    -   same as in RMatrixSolve
'    Rep     -   same as in RMatrixSolve
'    X       -   same as in RMatrixSolve
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixSolveM(ByRef A() As Double, _
         ByVal N As Long, _
         ByRef B() As Double, _
         ByVal M As Long, _
         ByVal RFS As Boolean, _
         ByRef Info As Long, _
         ByRef Rep As DenseSolverReport, _
         ByRef X() As Double)
    Dim DA() As Double
    Dim EmptyA() As Double
    Dim p() As Long
    Dim ScaleA As Double
    Dim i As Long
    Dim j As Long
    Dim i_ As Long
    
    '
    ' prepare: check inputs, allocate space...
    '
    If N <= 0# Or M <= 0# Then
        Info = -1#
        Exit Sub
    End If
    ReDim DA(0 To N - 1, 0 To N - 1)
    
    '
    ' 1. scale matrix, max(|A[i,j]|)
    ' 2. factorize scaled matrix
    ' 3. solve
    '
    ScaleA = 0#
    For i = 0# To N - 1# Step 1
        For j = 0# To N - 1# Step 1
            ScaleA = MaxReal(ScaleA, Abs(A(i, j)))
        Next j
    Next i
    If ScaleA = 0# Then
        ScaleA = 1#
    End If
    ScaleA = 1# / ScaleA
    For i = 0# To N - 1# Step 1
        For i_ = 0# To N - 1# Step 1
            DA(i, i_) = A(i, i_)
        Next i_
    Next i
    Call RMatrixLU(DA, N, N, p)
    If RFS Then
        Call RMatrixLUSolveInternal(DA, p, ScaleA, N, A, True, B, M, Info, Rep, X)
    Else
        Call RMatrixLUSolveInternal(DA, p, ScaleA, N, EmptyA, False, B, M, Info, Rep, X)
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Dense solver.
'
'This  subroutine  solves  a  system  A*X=B,  where A is NxN non-denegerate
'real matrix given by its LU decomposition, X and B are NxM real matrices.
'
'Algorithm features:
'* automatic detection of degenerate cases
'* O(N^2) complexity
'* condition number estimation
'
'No iterative refinement  is provided because exact form of original matrix
'is not known to subroutine. Use RMatrixSolve or RMatrixMixedSolve  if  you
'need iterative refinement.
'
'INPUT PARAMETERS
'    LUA     -   array[0..N-1,0..N-1], LU decomposition, RMatrixLU result
'    P       -   array[0..N-1], pivots array, RMatrixLU result
'    N       -   size of A
'    B       -   array[0..N-1], right part
'
'OUTPUT PARAMETERS
'    Info    -   same as in RMatrixSolve
'    Rep     -   same as in RMatrixSolve
'    X       -   same as in RMatrixSolve
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixLUSolve(ByRef LUA() As Double, _
         ByRef p() As Long, _
         ByVal N As Long, _
         ByRef B() As Double, _
         ByRef Info As Long, _
         ByRef Rep As DenseSolverReport, _
         ByRef X() As Double)
    Dim BM() As Double
    Dim XM() As Double
    Dim i_ As Long
    If N <= 0# Then
        Info = -1#
        Exit Sub
    End If
    ReDim BM(0 To N - 1, 0 To 1# - 1)
    For i_ = 0# To N - 1# Step 1
        BM(i_, 0#) = B(i_)
    Next i_
    Call RMatrixLUSolveM(LUA, p, N, BM, 1#, Info, Rep, XM)
    ReDim X(0 To N - 1)
    For i_ = 0# To N - 1# Step 1
        X(i_) = XM(i_, 0#)
    Next i_
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Dense solver.
'
'Similar to RMatrixLUSolve() but solves task with multiple right parts
'(where b and x are NxM matrices).
'
'Algorithm features:
'* automatic detection of degenerate cases
'* O(M*N^2) complexity
'* condition number estimation
'
'No iterative refinement  is provided because exact form of original matrix
'is not known to subroutine. Use RMatrixSolve or RMatrixMixedSolve  if  you
'need iterative refinement.
'
'INPUT PARAMETERS
'    LUA     -   array[0..N-1,0..N-1], LU decomposition, RMatrixLU result
'    P       -   array[0..N-1], pivots array, RMatrixLU result
'    N       -   size of A
'    B       -   array[0..N-1,0..M-1], right part
'    M       -   right part size
'
'OUTPUT PARAMETERS
'    Info    -   same as in RMatrixSolve
'    Rep     -   same as in RMatrixSolve
'    X       -   same as in RMatrixSolve
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixLUSolveM(ByRef LUA() As Double, _
         ByRef p() As Long, _
         ByVal N As Long, _
         ByRef B() As Double, _
         ByVal M As Long, _
         ByRef Info As Long, _
         ByRef Rep As DenseSolverReport, _
         ByRef X() As Double)
    Dim EmptyA() As Double
    Dim i As Long
    Dim j As Long
    Dim ScaleA As Double
    
    '
    ' prepare: check inputs, allocate space...
    '
    If N <= 0# Or M <= 0# Then
        Info = -1#
        Exit Sub
    End If
    
    '
    ' 1. scale matrix, max(|U[i,j]|)
    '    we assume that LU is in its normal form, i.e. |L[i,j]|<=1
    ' 2. solve
    '
    ScaleA = 0#
    For i = 0# To N - 1# Step 1
        For j = i To N - 1# Step 1
            ScaleA = MaxReal(ScaleA, Abs(LUA(i, j)))
        Next j
    Next i
    If ScaleA = 0# Then
        ScaleA = 1#
    End If
    ScaleA = 1# / ScaleA
    Call RMatrixLUSolveInternal(LUA, p, ScaleA, N, EmptyA, False, B, M, Info, Rep, X)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Dense solver.
'
'This  subroutine  solves  a  system  A*x=b,  where BOTH ORIGINAL A AND ITS
'LU DECOMPOSITION ARE KNOWN. You can use it if for some  reasons  you  have
'both A and its LU decomposition.
'
'Algorithm features:
'* automatic detection of degenerate cases
'* condition number estimation
'* iterative refinement
'* O(N^2) complexity
'
'INPUT PARAMETERS
'    A       -   array[0..N-1,0..N-1], system matrix
'    LUA     -   array[0..N-1,0..N-1], LU decomposition, RMatrixLU result
'    P       -   array[0..N-1], pivots array, RMatrixLU result
'    N       -   size of A
'    B       -   array[0..N-1], right part
'
'OUTPUT PARAMETERS
'    Info    -   same as in RMatrixSolveM
'    Rep     -   same as in RMatrixSolveM
'    X       -   same as in RMatrixSolveM
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixMixedSolve(ByRef A() As Double, _
         ByRef LUA() As Double, _
         ByRef p() As Long, _
         ByVal N As Long, _
         ByRef B() As Double, _
         ByRef Info As Long, _
         ByRef Rep As DenseSolverReport, _
         ByRef X() As Double)
    Dim BM() As Double
    Dim XM() As Double
    Dim i_ As Long
    If N <= 0# Then
        Info = -1#
        Exit Sub
    End If
    ReDim BM(0 To N - 1, 0 To 1# - 1)
    For i_ = 0# To N - 1# Step 1
        BM(i_, 0#) = B(i_)
    Next i_
    Call RMatrixMixedSolveM(A, LUA, p, N, BM, 1#, Info, Rep, XM)
    ReDim X(0 To N - 1)
    For i_ = 0# To N - 1# Step 1
        X(i_) = XM(i_, 0#)
    Next i_
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Dense solver.
'
'Similar to RMatrixMixedSolve() but  solves task with multiple right  parts
'(where b and x are NxM matrices).
'
'Algorithm features:
'* automatic detection of degenerate cases
'* condition number estimation
'* iterative refinement
'* O(M*N^2) complexity
'
'INPUT PARAMETERS
'    A       -   array[0..N-1,0..N-1], system matrix
'    LUA     -   array[0..N-1,0..N-1], LU decomposition, RMatrixLU result
'    P       -   array[0..N-1], pivots array, RMatrixLU result
'    N       -   size of A
'    B       -   array[0..N-1,0..M-1], right part
'    M       -   right part size
'
'OUTPUT PARAMETERS
'    Info    -   same as in RMatrixSolveM
'    Rep     -   same as in RMatrixSolveM
'    X       -   same as in RMatrixSolveM
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixMixedSolveM(ByRef A() As Double, _
         ByRef LUA() As Double, _
         ByRef p() As Long, _
         ByVal N As Long, _
         ByRef B() As Double, _
         ByVal M As Long, _
         ByRef Info As Long, _
         ByRef Rep As DenseSolverReport, _
         ByRef X() As Double)
    Dim ScaleA As Double
    Dim i As Long
    Dim j As Long
    
    '
    ' prepare: check inputs, allocate space...
    '
    If N <= 0# Or M <= 0# Then
        Info = -1#
        Exit Sub
    End If
    
    '
    ' 1. scale matrix, max(|A[i,j]|)
    ' 2. factorize scaled matrix
    ' 3. solve
    '
    ScaleA = 0#
    For i = 0# To N - 1# Step 1
        For j = 0# To N - 1# Step 1
            ScaleA = MaxReal(ScaleA, Abs(A(i, j)))
        Next j
    Next i
    If ScaleA = 0# Then
        ScaleA = 1#
    End If
    ScaleA = 1# / ScaleA
    Call RMatrixLUSolveInternal(LUA, p, ScaleA, N, A, True, B, M, Info, Rep, X)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Dense solver. Same as RMatrixSolveM(), but for complex matrices.
'
'Algorithm features:
'* automatic detection of degenerate cases
'* condition number estimation
'* iterative refinement
'* O(N^3+M*N^2) complexity
'
'INPUT PARAMETERS
'    A       -   array[0..N-1,0..N-1], system matrix
'    N       -   size of A
'    B       -   array[0..N-1,0..M-1], right part
'    M       -   right part size
'    RFS     -   iterative refinement switch:
'                * True - refinement is used.
'                  Less performance, more precision.
'                * False - refinement is not used.
'                  More performance, less precision.
'
'OUTPUT PARAMETERS
'    Info    -   same as in RMatrixSolve
'    Rep     -   same as in RMatrixSolve
'    X       -   same as in RMatrixSolve
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixSolveM(ByRef A() As Complex, _
         ByVal N As Long, _
         ByRef B() As Complex, _
         ByVal M As Long, _
         ByVal RFS As Boolean, _
         ByRef Info As Long, _
         ByRef Rep As DenseSolverReport, _
         ByRef X() As Complex)
    Dim DA() As Complex
    Dim EmptyA() As Complex
    Dim p() As Long
    Dim ScaleA As Double
    Dim i As Long
    Dim j As Long
    Dim i_ As Long
    
    '
    ' prepare: check inputs, allocate space...
    '
    If N <= 0# Or M <= 0# Then
        Info = -1#
        Exit Sub
    End If
    ReDim DA(0 To N - 1, 0 To N - 1)
    
    '
    ' 1. scale matrix, max(|A[i,j]|)
    ' 2. factorize scaled matrix
    ' 3. solve
    '
    ScaleA = 0#
    For i = 0# To N - 1# Step 1
        For j = 0# To N - 1# Step 1
            ScaleA = MaxReal(ScaleA, AbsComplex(A(i, j)))
        Next j
    Next i
    If ScaleA = 0# Then
        ScaleA = 1#
    End If
    ScaleA = 1# / ScaleA
    For i = 0# To N - 1# Step 1
        For i_ = 0# To N - 1# Step 1
            DA(i, i_) = A(i, i_)
        Next i_
    Next i
    Call CMatrixLU(DA, N, N, p)
    If RFS Then
        Call CMatrixLUSolveInternal(DA, p, ScaleA, N, A, True, B, M, Info, Rep, X)
    Else
        Call CMatrixLUSolveInternal(DA, p, ScaleA, N, EmptyA, False, B, M, Info, Rep, X)
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Dense solver. Same as RMatrixSolve(), but for complex matrices.
'
'Algorithm features:
'* automatic detection of degenerate cases
'* condition number estimation
'* iterative refinement
'* O(N^3) complexity
'
'INPUT PARAMETERS
'    A       -   array[0..N-1,0..N-1], system matrix
'    N       -   size of A
'    B       -   array[0..N-1], right part
'
'OUTPUT PARAMETERS
'    Info    -   same as in RMatrixSolve
'    Rep     -   same as in RMatrixSolve
'    X       -   same as in RMatrixSolve
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixSolve(ByRef A() As Complex, _
         ByVal N As Long, _
         ByRef B() As Complex, _
         ByRef Info As Long, _
         ByRef Rep As DenseSolverReport, _
         ByRef X() As Complex)
    Dim BM() As Complex
    Dim XM() As Complex
    Dim i_ As Long
    If N <= 0# Then
        Info = -1#
        Exit Sub
    End If
    ReDim BM(0 To N - 1, 0 To 1# - 1)
    For i_ = 0# To N - 1# Step 1
        BM(i_, 0#) = B(i_)
    Next i_
    Call CMatrixSolveM(A, N, BM, 1#, True, Info, Rep, XM)
    ReDim X(0 To N - 1)
    For i_ = 0# To N - 1# Step 1
        X(i_) = XM(i_, 0#)
    Next i_
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Dense solver. Same as RMatrixLUSolveM(), but for complex matrices.
'
'Algorithm features:
'* automatic detection of degenerate cases
'* O(M*N^2) complexity
'* condition number estimation
'
'No iterative refinement  is provided because exact form of original matrix
'is not known to subroutine. Use CMatrixSolve or CMatrixMixedSolve  if  you
'need iterative refinement.
'
'INPUT PARAMETERS
'    LUA     -   array[0..N-1,0..N-1], LU decomposition, RMatrixLU result
'    P       -   array[0..N-1], pivots array, RMatrixLU result
'    N       -   size of A
'    B       -   array[0..N-1,0..M-1], right part
'    M       -   right part size
'
'OUTPUT PARAMETERS
'    Info    -   same as in RMatrixSolve
'    Rep     -   same as in RMatrixSolve
'    X       -   same as in RMatrixSolve
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixLUSolveM(ByRef LUA() As Complex, _
         ByRef p() As Long, _
         ByVal N As Long, _
         ByRef B() As Complex, _
         ByVal M As Long, _
         ByRef Info As Long, _
         ByRef Rep As DenseSolverReport, _
         ByRef X() As Complex)
    Dim EmptyA() As Complex
    Dim i As Long
    Dim j As Long
    Dim ScaleA As Double
    
    '
    ' prepare: check inputs, allocate space...
    '
    If N <= 0# Or M <= 0# Then
        Info = -1#
        Exit Sub
    End If
    
    '
    ' 1. scale matrix, max(|U[i,j]|)
    '    we assume that LU is in its normal form, i.e. |L[i,j]|<=1
    ' 2. solve
    '
    ScaleA = 0#
    For i = 0# To N - 1# Step 1
        For j = i To N - 1# Step 1
            ScaleA = MaxReal(ScaleA, AbsComplex(LUA(i, j)))
        Next j
    Next i
    If ScaleA = 0# Then
        ScaleA = 1#
    End If
    ScaleA = 1# / ScaleA
    Call CMatrixLUSolveInternal(LUA, p, ScaleA, N, EmptyA, False, B, M, Info, Rep, X)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Dense solver. Same as RMatrixLUSolve(), but for complex matrices.
'
'Algorithm features:
'* automatic detection of degenerate cases
'* O(N^2) complexity
'* condition number estimation
'
'No iterative refinement is provided because exact form of original matrix
'is not known to subroutine. Use CMatrixSolve or CMatrixMixedSolve  if  you
'need iterative refinement.
'
'INPUT PARAMETERS
'    LUA     -   array[0..N-1,0..N-1], LU decomposition, CMatrixLU result
'    P       -   array[0..N-1], pivots array, CMatrixLU result
'    N       -   size of A
'    B       -   array[0..N-1], right part
'
'OUTPUT PARAMETERS
'    Info    -   same as in RMatrixSolve
'    Rep     -   same as in RMatrixSolve
'    X       -   same as in RMatrixSolve
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixLUSolve(ByRef LUA() As Complex, _
         ByRef p() As Long, _
         ByVal N As Long, _
         ByRef B() As Complex, _
         ByRef Info As Long, _
         ByRef Rep As DenseSolverReport, _
         ByRef X() As Complex)
    Dim BM() As Complex
    Dim XM() As Complex
    Dim i_ As Long
    If N <= 0# Then
        Info = -1#
        Exit Sub
    End If
    ReDim BM(0 To N - 1, 0 To 1# - 1)
    For i_ = 0# To N - 1# Step 1
        BM(i_, 0#) = B(i_)
    Next i_
    Call CMatrixLUSolveM(LUA, p, N, BM, 1#, Info, Rep, XM)
    ReDim X(0 To N - 1)
    For i_ = 0# To N - 1# Step 1
        X(i_) = XM(i_, 0#)
    Next i_
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Dense solver. Same as RMatrixMixedSolveM(), but for complex matrices.
'
'Algorithm features:
'* automatic detection of degenerate cases
'* condition number estimation
'* iterative refinement
'* O(M*N^2) complexity
'
'INPUT PARAMETERS
'    A       -   array[0..N-1,0..N-1], system matrix
'    LUA     -   array[0..N-1,0..N-1], LU decomposition, CMatrixLU result
'    P       -   array[0..N-1], pivots array, CMatrixLU result
'    N       -   size of A
'    B       -   array[0..N-1,0..M-1], right part
'    M       -   right part size
'
'OUTPUT PARAMETERS
'    Info    -   same as in RMatrixSolveM
'    Rep     -   same as in RMatrixSolveM
'    X       -   same as in RMatrixSolveM
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixMixedSolveM(ByRef A() As Complex, _
         ByRef LUA() As Complex, _
         ByRef p() As Long, _
         ByVal N As Long, _
         ByRef B() As Complex, _
         ByVal M As Long, _
         ByRef Info As Long, _
         ByRef Rep As DenseSolverReport, _
         ByRef X() As Complex)
    Dim ScaleA As Double
    Dim i As Long
    Dim j As Long
    
    '
    ' prepare: check inputs, allocate space...
    '
    If N <= 0# Or M <= 0# Then
        Info = -1#
        Exit Sub
    End If
    
    '
    ' 1. scale matrix, max(|A[i,j]|)
    ' 2. factorize scaled matrix
    ' 3. solve
    '
    ScaleA = 0#
    For i = 0# To N - 1# Step 1
        For j = 0# To N - 1# Step 1
            ScaleA = MaxReal(ScaleA, AbsComplex(A(i, j)))
        Next j
    Next i
    If ScaleA = 0# Then
        ScaleA = 1#
    End If
    ScaleA = 1# / ScaleA
    Call CMatrixLUSolveInternal(LUA, p, ScaleA, N, A, True, B, M, Info, Rep, X)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Dense solver. Same as RMatrixMixedSolve(), but for complex matrices.
'
'Algorithm features:
'* automatic detection of degenerate cases
'* condition number estimation
'* iterative refinement
'* O(N^2) complexity
'
'INPUT PARAMETERS
'    A       -   array[0..N-1,0..N-1], system matrix
'    LUA     -   array[0..N-1,0..N-1], LU decomposition, CMatrixLU result
'    P       -   array[0..N-1], pivots array, CMatrixLU result
'    N       -   size of A
'    B       -   array[0..N-1], right part
'
'OUTPUT PARAMETERS
'    Info    -   same as in RMatrixSolveM
'    Rep     -   same as in RMatrixSolveM
'    X       -   same as in RMatrixSolveM
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixMixedSolve(ByRef A() As Complex, _
         ByRef LUA() As Complex, _
         ByRef p() As Long, _
         ByVal N As Long, _
         ByRef B() As Complex, _
         ByRef Info As Long, _
         ByRef Rep As DenseSolverReport, _
         ByRef X() As Complex)
    Dim BM() As Complex
    Dim XM() As Complex
    Dim i_ As Long
    If N <= 0# Then
        Info = -1#
        Exit Sub
    End If
    ReDim BM(0 To N - 1, 0 To 1# - 1)
    For i_ = 0# To N - 1# Step 1
        BM(i_, 0#) = B(i_)
    Next i_
    Call CMatrixMixedSolveM(A, LUA, p, N, BM, 1#, Info, Rep, XM)
    ReDim X(0 To N - 1)
    For i_ = 0# To N - 1# Step 1
        X(i_) = XM(i_, 0#)
    Next i_
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Dense solver. Same as RMatrixSolveM(), but for symmetric positive definite
'matrices.
'
'Algorithm features:
'* automatic detection of degenerate cases
'* condition number estimation
'* O(N^3+M*N^2) complexity
'* matrix is represented by its upper or lower triangle
'
'No iterative refinement is provided because such partial representation of
'matrix does not allow efficient calculation of extra-precise  matrix-vector
'products for large matrices. Use RMatrixSolve or RMatrixMixedSolve  if  you
'need iterative refinement.
'
'INPUT PARAMETERS
'    A       -   array[0..N-1,0..N-1], system matrix
'    N       -   size of A
'    IsUpper -   what half of A is provided
'    B       -   array[0..N-1,0..M-1], right part
'    M       -   right part size
'
'OUTPUT PARAMETERS
'    Info    -   same as in RMatrixSolve.
'                Returns -3 for non-SPD matrices.
'    Rep     -   same as in RMatrixSolve
'    X       -   same as in RMatrixSolve
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub SPDMatrixSolveM(ByRef A() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef B() As Double, _
         ByVal M As Long, _
         ByRef Info As Long, _
         ByRef Rep As DenseSolverReport, _
         ByRef X() As Double)
    Dim DA() As Double
    Dim SqrtScaleA As Double
    Dim i As Long
    Dim j As Long
    Dim J1 As Long
    Dim J2 As Long
    Dim i_ As Long
    
    '
    ' prepare: check inputs, allocate space...
    '
    If N <= 0# Or M <= 0# Then
        Info = -1#
        Exit Sub
    End If
    ReDim DA(0 To N - 1, 0 To N - 1)
    
    '
    ' 1. scale matrix, max(|A[i,j]|)
    ' 2. factorize scaled matrix
    ' 3. solve
    '
    SqrtScaleA = 0#
    For i = 0# To N - 1# Step 1
        If IsUpper Then
            J1 = i
            J2 = N - 1#
        Else
            J1 = 0#
            J2 = i
        End If
        For j = J1 To J2 Step 1
            SqrtScaleA = MaxReal(SqrtScaleA, Abs(A(i, j)))
        Next j
    Next i
    If SqrtScaleA = 0# Then
        SqrtScaleA = 1#
    End If
    SqrtScaleA = 1# / SqrtScaleA
    SqrtScaleA = Sqr(SqrtScaleA)
    For i = 0# To N - 1# Step 1
        If IsUpper Then
            J1 = i
            J2 = N - 1#
        Else
            J1 = 0#
            J2 = i
        End If
        For i_ = J1 To J2 Step 1
            DA(i, i_) = A(i, i_)
        Next i_
    Next i
    If Not SPDMatrixCholesky(DA, N, IsUpper) Then
        ReDim X(0 To N - 1, 0 To M - 1)
        For i = 0# To N - 1# Step 1
            For j = 0# To M - 1# Step 1
                X(i, j) = 0#
            Next j
        Next i
        Rep.R1 = 0#
        Rep.RInf = 0#
        Info = -3#
        Exit Sub
    End If
    Info = 1#
    Call SPDMatrixCholeskySolveInternal(DA, SqrtScaleA, N, IsUpper, A, True, B, M, Info, Rep, X)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Dense solver. Same as RMatrixSolve(), but for SPD matrices.
'
'Algorithm features:
'* automatic detection of degenerate cases
'* condition number estimation
'* O(N^3) complexity
'* matrix is represented by its upper or lower triangle
'
'No iterative refinement is provided because such partial representation of
'matrix does not allow efficient calculation of extra-precise  matrix-vector
'products for large matrices. Use RMatrixSolve or RMatrixMixedSolve  if  you
'need iterative refinement.
'
'INPUT PARAMETERS
'    A       -   array[0..N-1,0..N-1], system matrix
'    N       -   size of A
'    IsUpper -   what half of A is provided
'    B       -   array[0..N-1], right part
'
'OUTPUT PARAMETERS
'    Info    -   same as in RMatrixSolve
'                Returns -3 for non-SPD matrices.
'    Rep     -   same as in RMatrixSolve
'    X       -   same as in RMatrixSolve
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub SPDMatrixSolve(ByRef A() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef B() As Double, _
         ByRef Info As Long, _
         ByRef Rep As DenseSolverReport, _
         ByRef X() As Double)
    Dim BM() As Double
    Dim XM() As Double
    Dim i_ As Long
    If N <= 0# Then
        Info = -1#
        Exit Sub
    End If
    ReDim BM(0 To N - 1, 0 To 1# - 1)
    For i_ = 0# To N - 1# Step 1
        BM(i_, 0#) = B(i_)
    Next i_
    Call SPDMatrixSolveM(A, N, IsUpper, BM, 1#, Info, Rep, XM)
    ReDim X(0 To N - 1)
    For i_ = 0# To N - 1# Step 1
        X(i_) = XM(i_, 0#)
    Next i_
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Dense solver. Same as RMatrixLUSolveM(), but for SPD matrices  represented
'by their Cholesky decomposition.
'
'Algorithm features:
'* automatic detection of degenerate cases
'* O(M*N^2) complexity
'* condition number estimation
'* matrix is represented by its upper or lower triangle
'
'No iterative refinement is provided because such partial representation of
'matrix does not allow efficient calculation of extra-precise  matrix-vector
'products for large matrices. Use RMatrixSolve or RMatrixMixedSolve  if  you
'need iterative refinement.
'
'INPUT PARAMETERS
'    CHA     -   array[0..N-1,0..N-1], Cholesky decomposition,
'                SPDMatrixCholesky result
'    N       -   size of CHA
'    IsUpper -   what half of CHA is provided
'    B       -   array[0..N-1,0..M-1], right part
'    M       -   right part size
'
'OUTPUT PARAMETERS
'    Info    -   same as in RMatrixSolve
'    Rep     -   same as in RMatrixSolve
'    X       -   same as in RMatrixSolve
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub SPDMatrixCholeskySolveM(ByRef CHA() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef B() As Double, _
         ByVal M As Long, _
         ByRef Info As Long, _
         ByRef Rep As DenseSolverReport, _
         ByRef X() As Double)
    Dim EmptyA() As Double
    Dim SqrtScaleA As Double
    Dim i As Long
    Dim j As Long
    Dim J1 As Long
    Dim J2 As Long
    
    '
    ' prepare: check inputs, allocate space...
    '
    If N <= 0# Or M <= 0# Then
        Info = -1#
        Exit Sub
    End If
    
    '
    ' 1. scale matrix, max(|U[i,j]|)
    ' 2. factorize scaled matrix
    ' 3. solve
    '
    SqrtScaleA = 0#
    For i = 0# To N - 1# Step 1
        If IsUpper Then
            J1 = i
            J2 = N - 1#
        Else
            J1 = 0#
            J2 = i
        End If
        For j = J1 To J2 Step 1
            SqrtScaleA = MaxReal(SqrtScaleA, Abs(CHA(i, j)))
        Next j
    Next i
    If SqrtScaleA = 0# Then
        SqrtScaleA = 1#
    End If
    SqrtScaleA = 1# / SqrtScaleA
    Call SPDMatrixCholeskySolveInternal(CHA, SqrtScaleA, N, IsUpper, EmptyA, False, B, M, Info, Rep, X)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Dense solver. Same as RMatrixLUSolve(), but for  SPD matrices  represented
'by their Cholesky decomposition.
'
'Algorithm features:
'* automatic detection of degenerate cases
'* O(N^2) complexity
'* condition number estimation
'* matrix is represented by its upper or lower triangle
'
'No iterative refinement is provided because such partial representation of
'matrix does not allow efficient calculation of extra-precise  matrix-vector
'products for large matrices. Use RMatrixSolve or RMatrixMixedSolve  if  you
'need iterative refinement.
'
'INPUT PARAMETERS
'    CHA     -   array[0..N-1,0..N-1], Cholesky decomposition,
'                SPDMatrixCholesky result
'    N       -   size of A
'    IsUpper -   what half of CHA is provided
'    B       -   array[0..N-1], right part
'
'OUTPUT PARAMETERS
'    Info    -   same as in RMatrixSolve
'    Rep     -   same as in RMatrixSolve
'    X       -   same as in RMatrixSolve
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub SPDMatrixCholeskySolve(ByRef CHA() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef B() As Double, _
         ByRef Info As Long, _
         ByRef Rep As DenseSolverReport, _
         ByRef X() As Double)
    Dim BM() As Double
    Dim XM() As Double
    Dim i_ As Long
    If N <= 0# Then
        Info = -1#
        Exit Sub
    End If
    ReDim BM(0 To N - 1, 0 To 1# - 1)
    For i_ = 0# To N - 1# Step 1
        BM(i_, 0#) = B(i_)
    Next i_
    Call SPDMatrixCholeskySolveM(CHA, N, IsUpper, BM, 1#, Info, Rep, XM)
    ReDim X(0 To N - 1)
    For i_ = 0# To N - 1# Step 1
        X(i_) = XM(i_, 0#)
    Next i_
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Dense solver. Same as RMatrixSolveM(), but for Hermitian positive definite
'matrices.
'
'Algorithm features:
'* automatic detection of degenerate cases
'* condition number estimation
'* O(N^3+M*N^2) complexity
'* matrix is represented by its upper or lower triangle
'
'No iterative refinement is provided because such partial representation of
'matrix does not allow efficient calculation of extra-precise  matrix-vector
'products for large matrices. Use RMatrixSolve or RMatrixMixedSolve  if  you
'need iterative refinement.
'
'INPUT PARAMETERS
'    A       -   array[0..N-1,0..N-1], system matrix
'    N       -   size of A
'    IsUpper -   what half of A is provided
'    B       -   array[0..N-1,0..M-1], right part
'    M       -   right part size
'
'OUTPUT PARAMETERS
'    Info    -   same as in RMatrixSolve.
'                Returns -3 for non-HPD matrices.
'    Rep     -   same as in RMatrixSolve
'    X       -   same as in RMatrixSolve
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub HPDMatrixSolveM(ByRef A() As Complex, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef B() As Complex, _
         ByVal M As Long, _
         ByRef Info As Long, _
         ByRef Rep As DenseSolverReport, _
         ByRef X() As Complex)
    Dim DA() As Complex
    Dim SqrtScaleA As Double
    Dim i As Long
    Dim j As Long
    Dim J1 As Long
    Dim J2 As Long
    Dim i_ As Long
    
    '
    ' prepare: check inputs, allocate space...
    '
    If N <= 0# Or M <= 0# Then
        Info = -1#
        Exit Sub
    End If
    ReDim DA(0 To N - 1, 0 To N - 1)
    
    '
    ' 1. scale matrix, max(|A[i,j]|)
    ' 2. factorize scaled matrix
    ' 3. solve
    '
    SqrtScaleA = 0#
    For i = 0# To N - 1# Step 1
        If IsUpper Then
            J1 = i
            J2 = N - 1#
        Else
            J1 = 0#
            J2 = i
        End If
        For j = J1 To J2 Step 1
            SqrtScaleA = MaxReal(SqrtScaleA, AbsComplex(A(i, j)))
        Next j
    Next i
    If SqrtScaleA = 0# Then
        SqrtScaleA = 1#
    End If
    SqrtScaleA = 1# / SqrtScaleA
    SqrtScaleA = Sqr(SqrtScaleA)
    For i = 0# To N - 1# Step 1
        If IsUpper Then
            J1 = i
            J2 = N - 1#
        Else
            J1 = 0#
            J2 = i
        End If
        For i_ = J1 To J2 Step 1
            DA(i, i_) = A(i, i_)
        Next i_
    Next i
    If Not HPDMatrixCholesky(DA, N, IsUpper) Then
        ReDim X(0 To N - 1, 0 To M - 1)
        For i = 0# To N - 1# Step 1
            For j = 0# To M - 1# Step 1
                X(i, j) = C_Complex(0#)
            Next j
        Next i
        Rep.R1 = 0#
        Rep.RInf = 0#
        Info = -3#
        Exit Sub
    End If
    Info = 1#
    Call HPDMatrixCholeskySolveInternal(DA, SqrtScaleA, N, IsUpper, A, True, B, M, Info, Rep, X)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Dense solver. Same as RMatrixSolve(),  but for Hermitian positive definite
'matrices.
'
'Algorithm features:
'* automatic detection of degenerate cases
'* condition number estimation
'* O(N^3) complexity
'* matrix is represented by its upper or lower triangle
'
'No iterative refinement is provided because such partial representation of
'matrix does not allow efficient calculation of extra-precise  matrix-vector
'products for large matrices. Use RMatrixSolve or RMatrixMixedSolve  if  you
'need iterative refinement.
'
'INPUT PARAMETERS
'    A       -   array[0..N-1,0..N-1], system matrix
'    N       -   size of A
'    IsUpper -   what half of A is provided
'    B       -   array[0..N-1], right part
'
'OUTPUT PARAMETERS
'    Info    -   same as in RMatrixSolve
'                Returns -3 for non-HPD matrices.
'    Rep     -   same as in RMatrixSolve
'    X       -   same as in RMatrixSolve
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub HPDMatrixSolve(ByRef A() As Complex, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef B() As Complex, _
         ByRef Info As Long, _
         ByRef Rep As DenseSolverReport, _
         ByRef X() As Complex)
    Dim BM() As Complex
    Dim XM() As Complex
    Dim i_ As Long
    If N <= 0# Then
        Info = -1#
        Exit Sub
    End If
    ReDim BM(0 To N - 1, 0 To 1# - 1)
    For i_ = 0# To N - 1# Step 1
        BM(i_, 0#) = B(i_)
    Next i_
    Call HPDMatrixSolveM(A, N, IsUpper, BM, 1#, Info, Rep, XM)
    ReDim X(0 To N - 1)
    For i_ = 0# To N - 1# Step 1
        X(i_) = XM(i_, 0#)
    Next i_
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Dense solver. Same as RMatrixLUSolveM(), but for HPD matrices  represented
'by their Cholesky decomposition.
'
'Algorithm features:
'* automatic detection of degenerate cases
'* O(M*N^2) complexity
'* condition number estimation
'* matrix is represented by its upper or lower triangle
'
'No iterative refinement is provided because such partial representation of
'matrix does not allow efficient calculation of extra-precise  matrix-vector
'products for large matrices. Use RMatrixSolve or RMatrixMixedSolve  if  you
'need iterative refinement.
'
'INPUT PARAMETERS
'    CHA     -   array[0..N-1,0..N-1], Cholesky decomposition,
'                HPDMatrixCholesky result
'    N       -   size of CHA
'    IsUpper -   what half of CHA is provided
'    B       -   array[0..N-1,0..M-1], right part
'    M       -   right part size
'
'OUTPUT PARAMETERS
'    Info    -   same as in RMatrixSolve
'    Rep     -   same as in RMatrixSolve
'    X       -   same as in RMatrixSolve
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub HPDMatrixCholeskySolveM(ByRef CHA() As Complex, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef B() As Complex, _
         ByVal M As Long, _
         ByRef Info As Long, _
         ByRef Rep As DenseSolverReport, _
         ByRef X() As Complex)
    Dim EmptyA() As Complex
    Dim SqrtScaleA As Double
    Dim i As Long
    Dim j As Long
    Dim J1 As Long
    Dim J2 As Long
    
    '
    ' prepare: check inputs, allocate space...
    '
    If N <= 0# Or M <= 0# Then
        Info = -1#
        Exit Sub
    End If
    
    '
    ' 1. scale matrix, max(|U[i,j]|)
    ' 2. factorize scaled matrix
    ' 3. solve
    '
    SqrtScaleA = 0#
    For i = 0# To N - 1# Step 1
        If IsUpper Then
            J1 = i
            J2 = N - 1#
        Else
            J1 = 0#
            J2 = i
        End If
        For j = J1 To J2 Step 1
            SqrtScaleA = MaxReal(SqrtScaleA, AbsComplex(CHA(i, j)))
        Next j
    Next i
    If SqrtScaleA = 0# Then
        SqrtScaleA = 1#
    End If
    SqrtScaleA = 1# / SqrtScaleA
    Call HPDMatrixCholeskySolveInternal(CHA, SqrtScaleA, N, IsUpper, EmptyA, False, B, M, Info, Rep, X)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Dense solver. Same as RMatrixLUSolve(), but for  HPD matrices  represented
'by their Cholesky decomposition.
'
'Algorithm features:
'* automatic detection of degenerate cases
'* O(N^2) complexity
'* condition number estimation
'* matrix is represented by its upper or lower triangle
'
'No iterative refinement is provided because such partial representation of
'matrix does not allow efficient calculation of extra-precise  matrix-vector
'products for large matrices. Use RMatrixSolve or RMatrixMixedSolve  if  you
'need iterative refinement.
'
'INPUT PARAMETERS
'    CHA     -   array[0..N-1,0..N-1], Cholesky decomposition,
'                SPDMatrixCholesky result
'    N       -   size of A
'    IsUpper -   what half of CHA is provided
'    B       -   array[0..N-1], right part
'
'OUTPUT PARAMETERS
'    Info    -   same as in RMatrixSolve
'    Rep     -   same as in RMatrixSolve
'    X       -   same as in RMatrixSolve
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub HPDMatrixCholeskySolve(ByRef CHA() As Complex, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef B() As Complex, _
         ByRef Info As Long, _
         ByRef Rep As DenseSolverReport, _
         ByRef X() As Complex)
    Dim BM() As Complex
    Dim XM() As Complex
    Dim i_ As Long
    If N <= 0# Then
        Info = -1#
        Exit Sub
    End If
    ReDim BM(0 To N - 1, 0 To 1# - 1)
    For i_ = 0# To N - 1# Step 1
        BM(i_, 0#) = B(i_)
    Next i_
    Call HPDMatrixCholeskySolveM(CHA, N, IsUpper, BM, 1#, Info, Rep, XM)
    ReDim X(0 To N - 1)
    For i_ = 0# To N - 1# Step 1
        X(i_) = XM(i_, 0#)
    Next i_
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Dense solver.
'
'This subroutine finds solution of the linear system A*X=B with non-square,
'possibly degenerate A.  System  is  solved in the least squares sense, and
'general least squares solution  X = X0 + CX*y  which  minimizes |A*X-B| is
'returned. If A is non-degenerate, solution in the  usual sense is returned
'
'Algorithm features:
'* automatic detection of degenerate cases
'* iterative refinement
'* O(N^3) complexity
'
'INPUT PARAMETERS
'    A       -   array[0..NRows-1,0..NCols-1], system matrix
'    NRows   -   vertical size of A
'    NCols   -   horizontal size of A
'    B       -   array[0..NCols-1], right part
'    Threshold-  a number in [0,1]. Singular values  beyond  Threshold  are
'                considered  zero.  Set  it to 0.0, if you don't understand
'                what it means, so the solver will choose good value on its
'                own.
'
'OUTPUT PARAMETERS
'    Info    -   return code:
'                * -4    SVD subroutine failed
'                * -1    if NRows<=0 or NCols<=0 or Threshold<0 was passed
'                *  1    if task is solved
'    Rep     -   solver report, see below for more info
'    X       -   array[0..N-1,0..M-1], it contains:
'                * solution of A*X=B if A is non-singular (well-conditioned
'                  or ill-conditioned, but not very close to singular)
'                * zeros,  if  A  is  singular  or  VERY  close to singular
'                  (in this case Info=-3).
'
'SOLVER REPORT
'
'Subroutine sets following fields of the Rep structure:
'* R2        reciprocal of condition number: 1/cond(A), 2-norm.
'* N         = NCols
'* K         dim(Null(A))
'* CX        array[0..N-1,0..K-1], kernel of A.
'            Columns of CX store such vectors that A*CX[i]=0.
'
'  -- ALGLIB --
'     Copyright 24.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixSolveLS(ByRef A() As Double, _
         ByVal NRows As Long, _
         ByVal NCols As Long, _
         ByRef B() As Double, _
         ByVal Threshold As Double, _
         ByRef Info As Long, _
         ByRef Rep As DenseSolverLSReport, _
         ByRef X() As Double)
    Dim SV() As Double
    Dim U() As Double
    Dim VT() As Double
    Dim RP() As Double
    Dim UTB() As Double
    Dim SUTB() As Double
    Dim Tmp() As Double
    Dim TA() As Double
    Dim TX() As Double
    Dim Buf() As Double
    Dim w() As Double
    Dim i As Long
    Dim j As Long
    Dim NSV As Long
    Dim KernelIdx As Long
    Dim V As Double
    Dim VErr As Double
    Dim SVDFailed As Boolean
    Dim ZeroA As Boolean
    Dim RFS As Long
    Dim NRFS As Long
    Dim TerminateNextTime As Boolean
    Dim SmallErr As Boolean
    Dim i_ As Long
    If NRows <= 0# Or NCols <= 0# Or Threshold < 0# Then
        Info = -1#
        Exit Sub
    End If
    If Threshold = 0# Then
        Threshold = 1000# * MachineEpsilon
    End If
    
    '
    ' Factorize A first
    '
    SVDFailed = Not RMatrixSVD(A, NRows, NCols, 1#, 2#, 2#, SV, U, VT)
    ZeroA = SV(0#) = 0#
    If SVDFailed Or ZeroA Then
        If SVDFailed Then
            Info = -4#
        Else
            Info = 1#
        End If
        ReDim X(0 To NCols - 1)
        For i = 0# To NCols - 1# Step 1
            X(i) = 0#
        Next i
        Rep.N = NCols
        Rep.K = NCols
        ReDim Rep.CX(0 To NCols - 1, 0 To NCols - 1)
        For i = 0# To NCols - 1# Step 1
            For j = 0# To NCols - 1# Step 1
                If i = j Then
                    Rep.CX(i, j) = 1#
                Else
                    Rep.CX(i, j) = 0#
                End If
            Next j
        Next i
        Rep.R2 = 0#
        Exit Sub
    End If
    NSV = MinInt(NCols, NRows)
    If NSV = NCols Then
        Rep.R2 = SV(NSV - 1#) / SV(0#)
    Else
        Rep.R2 = 0#
    End If
    Rep.N = NCols
    Info = 1#
    
    '
    ' Iterative refinement of xc combined with solution:
    ' 1. xc = 0
    ' 2. calculate r = bc-A*xc using extra-precise dot product
    ' 3. solve A*y = r
    ' 4. update x:=x+r
    ' 5. goto 2
    '
    ' This cycle is executed until one of two things happens:
    ' 1. maximum number of iterations reached
    ' 2. last iteration decreased error to the lower limit
    '
    ReDim UTB(0 To NSV - 1)
    ReDim SUTB(0 To NSV - 1)
    ReDim X(0 To NCols - 1)
    ReDim Tmp(0 To NCols - 1)
    ReDim TA(0 To NCols + 1# - 1)
    ReDim TX(0 To NCols + 1# - 1)
    ReDim Buf(0 To NCols + 1# - 1)
    For i = 0# To NCols - 1# Step 1
        X(i) = 0#
    Next i
    KernelIdx = NSV
    For i = 0# To NSV - 1# Step 1
        If SV(i) <= Threshold * SV(0#) Then
            KernelIdx = i
            Exit For
        End If
    Next i
    Rep.K = NCols - KernelIdx
    NRFS = DenseSolverRFSMaxV2(NCols, Rep.R2)
    TerminateNextTime = False
    ReDim RP(0 To NRows - 1)
    For RFS = 0# To NRFS Step 1
        If TerminateNextTime Then
            Exit For
        End If
        
        '
        ' calculate right part
        '
        If RFS = 0# Then
            For i_ = 0# To NRows - 1# Step 1
                RP(i_) = B(i_)
            Next i_
        Else
            SmallErr = True
            For i = 0# To NRows - 1# Step 1
                For i_ = 0# To NCols - 1# Step 1
                    TA(i_) = A(i, i_)
                Next i_
                TA(NCols) = -1#
                For i_ = 0# To NCols - 1# Step 1
                    TX(i_) = X(i_)
                Next i_
                TX(NCols) = B(i)
                Call XDot(TA, TX, NCols + 1#, Buf, V, VErr)
                RP(i) = -V
                SmallErr = SmallErr And Abs(V) < 4# * VErr
            Next i
            If SmallErr Then
                TerminateNextTime = True
            End If
        End If
        
        '
        ' solve A*dx = rp
        '
        For i = 0# To NCols - 1# Step 1
            Tmp(i) = 0#
        Next i
        For i = 0# To NSV - 1# Step 1
            UTB(i) = 0#
        Next i
        For i = 0# To NRows - 1# Step 1
            V = RP(i)
            For i_ = 0# To NSV - 1# Step 1
                UTB(i_) = UTB(i_) + V * U(i, i_)
            Next i_
        Next i
        For i = 0# To NSV - 1# Step 1
            If i < KernelIdx Then
                SUTB(i) = UTB(i) / SV(i)
            Else
                SUTB(i) = 0#
            End If
        Next i
        For i = 0# To NSV - 1# Step 1
            V = SUTB(i)
            For i_ = 0# To NCols - 1# Step 1
                Tmp(i_) = Tmp(i_) + V * VT(i, i_)
            Next i_
        Next i
        
        '
        ' update x:  x:=x+dx
        '
        For i_ = 0# To NCols - 1# Step 1
            X(i_) = X(i_) + Tmp(i_)
        Next i_
    Next RFS
    
    '
    ' fill CX
    '
    If Rep.K > 0# Then
        ReDim Rep.CX(0 To NCols - 1, 0 To Rep.K - 1)
        For i = 0# To Rep.K - 1# Step 1
            For i_ = 0# To NCols - 1# Step 1
                Rep.CX(i_, i) = VT(KernelIdx + i, i_)
            Next i_
        Next i
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal LU solver
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub RMatrixLUSolveInternal(ByRef LUA() As Double, _
         ByRef p() As Long, _
         ByRef ScaleA As Double, _
         ByVal N As Long, _
         ByRef A() As Double, _
         ByVal HaveA As Boolean, _
         ByRef B() As Double, _
         ByVal M As Long, _
         ByRef Info As Long, _
         ByRef Rep As DenseSolverReport, _
         ByRef X() As Double)
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim RFS As Long
    Dim NRFS As Long
    Dim XC() As Double
    Dim y() As Double
    Dim BC() As Double
    Dim XA() As Double
    Dim XB() As Double
    Dim TX() As Double
    Dim V As Double
    Dim VErr As Double
    Dim MXB As Double
    Dim ScaleRight As Double
    Dim SmallErr As Boolean
    Dim TerminateNextTime As Boolean
    Dim i_ As Long
    
    '
    ' prepare: check inputs, allocate space...
    '
    If N <= 0# Or M <= 0# Then
        Info = -1#
        Exit Sub
    End If
    For i = 0# To N - 1# Step 1
        If p(i) > N - 1# Or p(i) < i Then
            Info = -1#
            Exit Sub
        End If
    Next i
    ReDim X(0 To N - 1, 0 To M - 1)
    ReDim y(0 To N - 1)
    ReDim XC(0 To N - 1)
    ReDim BC(0 To N - 1)
    ReDim TX(0 To N + 1# - 1)
    ReDim XA(0 To N + 1# - 1)
    ReDim XB(0 To N + 1# - 1)
    
    '
    ' estimate condition number, test for near singularity
    '
    Rep.R1 = RMatrixLURCond1(LUA, N)
    Rep.RInf = RMatrixLURCondInf(LUA, N)
    If Rep.R1 < RCondThreshold() Or Rep.RInf < RCondThreshold() Then
        For i = 0# To N - 1# Step 1
            For j = 0# To M - 1# Step 1
                X(i, j) = 0#
            Next j
        Next i
        Rep.R1 = 0#
        Rep.RInf = 0#
        Info = -3#
        Exit Sub
    End If
    Info = 1#
    
    '
    ' solve
    '
    For K = 0# To M - 1# Step 1
        
        '
        ' copy B to contiguous storage
        '
        For i_ = 0# To N - 1# Step 1
            BC(i_) = B(i_, K)
        Next i_
        
        '
        ' Scale right part:
        ' * MX stores max(|Bi|)
        ' * ScaleRight stores actual scaling applied to B when solving systems
        '   it is chosen to make |scaleRight*b| close to 1.
        '
        MXB = 0#
        For i = 0# To N - 1# Step 1
            MXB = MaxReal(MXB, Abs(BC(i)))
        Next i
        If MXB = 0# Then
            MXB = 1#
        End If
        ScaleRight = 1# / MXB
        
        '
        ' First, non-iterative part of solution process.
        ' We use separate code for this task because
        ' XDot is quite slow and we want to save time.
        '
        For i_ = 0# To N - 1# Step 1
            XC(i_) = ScaleRight * BC(i_)
        Next i_
        Call RBasicLUSolve(LUA, p, ScaleA, N, XC, TX)
        
        '
        ' Iterative refinement of xc:
        ' * calculate r = bc-A*xc using extra-precise dot product
        ' * solve A*y = r
        ' * update x:=x+r
        '
        ' This cycle is executed until one of two things happens:
        ' 1. maximum number of iterations reached
        ' 2. last iteration decreased error to the lower limit
        '
        If HaveA Then
            NRFS = DenseSolverRFSMax(N, Rep.R1, Rep.RInf)
            TerminateNextTime = False
            For RFS = 0# To NRFS - 1# Step 1
                If TerminateNextTime Then
                    Exit For
                End If
                
                '
                ' generate right part
                '
                SmallErr = True
                For i_ = 0# To N - 1# Step 1
                    XB(i_) = XC(i_)
                Next i_
                For i = 0# To N - 1# Step 1
                    For i_ = 0# To N - 1# Step 1
                        XA(i_) = ScaleA * A(i, i_)
                    Next i_
                    XA(N) = -1#
                    XB(N) = ScaleRight * BC(i)
                    Call XDot(XA, XB, N + 1#, TX, V, VErr)
                    y(i) = -V
                    SmallErr = SmallErr And Abs(V) < 4# * VErr
                Next i
                If SmallErr Then
                    TerminateNextTime = True
                End If
                
                '
                ' solve and update
                '
                Call RBasicLUSolve(LUA, p, ScaleA, N, y, TX)
                For i_ = 0# To N - 1# Step 1
                    XC(i_) = XC(i_) + y(i_)
                Next i_
            Next RFS
        End If
        
        '
        ' Store xc.
        ' Post-scale result.
        '
        V = ScaleA * MXB
        For i_ = 0# To N - 1# Step 1
            X(i_, K) = V * XC(i_)
        Next i_
    Next K
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal Cholesky solver
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub SPDMatrixCholeskySolveInternal(ByRef CHA() As Double, _
         ByRef SqrtScaleA As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef A() As Double, _
         ByVal HaveA As Boolean, _
         ByRef B() As Double, _
         ByVal M As Long, _
         ByRef Info As Long, _
         ByRef Rep As DenseSolverReport, _
         ByRef X() As Double)
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim RFS As Long
    Dim NRFS As Long
    Dim XC() As Double
    Dim y() As Double
    Dim BC() As Double
    Dim XA() As Double
    Dim XB() As Double
    Dim TX() As Double
    Dim V As Double
    Dim VErr As Double
    Dim MXB As Double
    Dim ScaleRight As Double
    Dim SmallErr As Boolean
    Dim TerminateNextTime As Boolean
    Dim i_ As Long
    
    '
    ' prepare: check inputs, allocate space...
    '
    If N <= 0# Or M <= 0# Then
        Info = -1#
        Exit Sub
    End If
    ReDim X(0 To N - 1, 0 To M - 1)
    ReDim y(0 To N - 1)
    ReDim XC(0 To N - 1)
    ReDim BC(0 To N - 1)
    ReDim TX(0 To N + 1# - 1)
    ReDim XA(0 To N + 1# - 1)
    ReDim XB(0 To N + 1# - 1)
    
    '
    ' estimate condition number, test for near singularity
    '
    Rep.R1 = SPDMatrixCholeskyRCond(CHA, N, IsUpper)
    Rep.RInf = Rep.R1
    If Rep.R1 < RCondThreshold() Then
        For i = 0# To N - 1# Step 1
            For j = 0# To M - 1# Step 1
                X(i, j) = 0#
            Next j
        Next i
        Rep.R1 = 0#
        Rep.RInf = 0#
        Info = -3#
        Exit Sub
    End If
    Info = 1#
    
    '
    ' solve
    '
    For K = 0# To M - 1# Step 1
        
        '
        ' copy B to contiguous storage
        '
        For i_ = 0# To N - 1# Step 1
            BC(i_) = B(i_, K)
        Next i_
        
        '
        ' Scale right part:
        ' * MX stores max(|Bi|)
        ' * ScaleRight stores actual scaling applied to B when solving systems
        '   it is chosen to make |scaleRight*b| close to 1.
        '
        MXB = 0#
        For i = 0# To N - 1# Step 1
            MXB = MaxReal(MXB, Abs(BC(i)))
        Next i
        If MXB = 0# Then
            MXB = 1#
        End If
        ScaleRight = 1# / MXB
        
        '
        ' First, non-iterative part of solution process.
        ' We use separate code for this task because
        ' XDot is quite slow and we want to save time.
        '
        For i_ = 0# To N - 1# Step 1
            XC(i_) = ScaleRight * BC(i_)
        Next i_
        Call SPDBasicCholeskySolve(CHA, SqrtScaleA, N, IsUpper, XC, TX)
        
        '
        ' Store xc.
        ' Post-scale result.
        '
        V = Square(SqrtScaleA) * MXB
        For i_ = 0# To N - 1# Step 1
            X(i_, K) = V * XC(i_)
        Next i_
    Next K
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal LU solver
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub CMatrixLUSolveInternal(ByRef LUA() As Complex, _
         ByRef p() As Long, _
         ByRef ScaleA As Double, _
         ByVal N As Long, _
         ByRef A() As Complex, _
         ByVal HaveA As Boolean, _
         ByRef B() As Complex, _
         ByVal M As Long, _
         ByRef Info As Long, _
         ByRef Rep As DenseSolverReport, _
         ByRef X() As Complex)
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim RFS As Long
    Dim NRFS As Long
    Dim XC() As Complex
    Dim y() As Complex
    Dim BC() As Complex
    Dim XA() As Complex
    Dim XB() As Complex
    Dim TX() As Complex
    Dim TmpBuf() As Double
    Dim V As Complex
    Dim VErr As Double
    Dim MXB As Double
    Dim ScaleRight As Double
    Dim SmallErr As Boolean
    Dim TerminateNextTime As Boolean
    Dim i_ As Long
    
    '
    ' prepare: check inputs, allocate space...
    '
    If N <= 0# Or M <= 0# Then
        Info = -1#
        Exit Sub
    End If
    For i = 0# To N - 1# Step 1
        If p(i) > N - 1# Or p(i) < i Then
            Info = -1#
            Exit Sub
        End If
    Next i
    ReDim X(0 To N - 1, 0 To M - 1)
    ReDim y(0 To N - 1)
    ReDim XC(0 To N - 1)
    ReDim BC(0 To N - 1)
    ReDim TX(0 To N - 1)
    ReDim XA(0 To N + 1# - 1)
    ReDim XB(0 To N + 1# - 1)
    ReDim TmpBuf(0 To 2# * N + 2# - 1)
    
    '
    ' estimate condition number, test for near singularity
    '
    Rep.R1 = CMatrixLURCond1(LUA, N)
    Rep.RInf = CMatrixLURCondInf(LUA, N)
    If Rep.R1 < RCondThreshold() Or Rep.RInf < RCondThreshold() Then
        For i = 0# To N - 1# Step 1
            For j = 0# To M - 1# Step 1
                X(i, j) = C_Complex(0#)
            Next j
        Next i
        Rep.R1 = 0#
        Rep.RInf = 0#
        Info = -3#
        Exit Sub
    End If
    Info = 1#
    
    '
    ' solve
    '
    For K = 0# To M - 1# Step 1
        
        '
        ' copy B to contiguous storage
        '
        For i_ = 0# To N - 1# Step 1
            BC(i_) = B(i_, K)
        Next i_
        
        '
        ' Scale right part:
        ' * MX stores max(|Bi|)
        ' * ScaleRight stores actual scaling applied to B when solving systems
        '   it is chosen to make |scaleRight*b| close to 1.
        '
        MXB = 0#
        For i = 0# To N - 1# Step 1
            MXB = MaxReal(MXB, AbsComplex(BC(i)))
        Next i
        If MXB = 0# Then
            MXB = 1#
        End If
        ScaleRight = 1# / MXB
        
        '
        ' First, non-iterative part of solution process.
        ' We use separate code for this task because
        ' XDot is quite slow and we want to save time.
        '
        For i_ = 0# To N - 1# Step 1
            XC(i_) = C_MulR(BC(i_), ScaleRight)
        Next i_
        Call CBasicLUSolve(LUA, p, ScaleA, N, XC, TX)
        
        '
        ' Iterative refinement of xc:
        ' * calculate r = bc-A*xc using extra-precise dot product
        ' * solve A*y = r
        ' * update x:=x+r
        '
        ' This cycle is executed until one of two things happens:
        ' 1. maximum number of iterations reached
        ' 2. last iteration decreased error to the lower limit
        '
        If HaveA Then
            NRFS = DenseSolverRFSMax(N, Rep.R1, Rep.RInf)
            TerminateNextTime = False
            For RFS = 0# To NRFS - 1# Step 1
                If TerminateNextTime Then
                    Exit For
                End If
                
                '
                ' generate right part
                '
                SmallErr = True
                For i_ = 0# To N - 1# Step 1
                    XB(i_) = XC(i_)
                Next i_
                For i = 0# To N - 1# Step 1
                    For i_ = 0# To N - 1# Step 1
                        XA(i_) = C_MulR(A(i, i_), ScaleA)
                    Next i_
                    XA(N) = C_Complex(-1#)
                    XB(N) = C_MulR(BC(i), ScaleRight)
                    Call XCDot(XA, XB, N + 1#, TmpBuf, V, VErr)
                    y(i) = C_Opposite(V)
                    SmallErr = SmallErr And AbsComplex(V) < 4# * VErr
                Next i
                If SmallErr Then
                    TerminateNextTime = True
                End If
                
                '
                ' solve and update
                '
                Call CBasicLUSolve(LUA, p, ScaleA, N, y, TX)
                For i_ = 0# To N - 1# Step 1
                    XC(i_) = C_Add(XC(i_), y(i_))
                Next i_
            Next RFS
        End If
        
        '
        ' Store xc.
        ' Post-scale result.
        '
        V = C_Complex(ScaleA * MXB)
        For i_ = 0# To N - 1# Step 1
            X(i_, K) = C_Mul(V, XC(i_))
        Next i_
    Next K
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal Cholesky solver
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub HPDMatrixCholeskySolveInternal(ByRef CHA() As Complex, _
         ByRef SqrtScaleA As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef A() As Complex, _
         ByVal HaveA As Boolean, _
         ByRef B() As Complex, _
         ByVal M As Long, _
         ByRef Info As Long, _
         ByRef Rep As DenseSolverReport, _
         ByRef X() As Complex)
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim RFS As Long
    Dim NRFS As Long
    Dim XC() As Complex
    Dim y() As Complex
    Dim BC() As Complex
    Dim XA() As Complex
    Dim XB() As Complex
    Dim TX() As Complex
    Dim V As Double
    Dim VErr As Double
    Dim MXB As Double
    Dim ScaleRight As Double
    Dim SmallErr As Boolean
    Dim TerminateNextTime As Boolean
    Dim i_ As Long
    
    '
    ' prepare: check inputs, allocate space...
    '
    If N <= 0# Or M <= 0# Then
        Info = -1#
        Exit Sub
    End If
    ReDim X(0 To N - 1, 0 To M - 1)
    ReDim y(0 To N - 1)
    ReDim XC(0 To N - 1)
    ReDim BC(0 To N - 1)
    ReDim TX(0 To N + 1# - 1)
    ReDim XA(0 To N + 1# - 1)
    ReDim XB(0 To N + 1# - 1)
    
    '
    ' estimate condition number, test for near singularity
    '
    Rep.R1 = HPDMatrixCholeskyRCond(CHA, N, IsUpper)
    Rep.RInf = Rep.R1
    If Rep.R1 < RCondThreshold() Then
        For i = 0# To N - 1# Step 1
            For j = 0# To M - 1# Step 1
                X(i, j) = C_Complex(0#)
            Next j
        Next i
        Rep.R1 = 0#
        Rep.RInf = 0#
        Info = -3#
        Exit Sub
    End If
    Info = 1#
    
    '
    ' solve
    '
    For K = 0# To M - 1# Step 1
        
        '
        ' copy B to contiguous storage
        '
        For i_ = 0# To N - 1# Step 1
            BC(i_) = B(i_, K)
        Next i_
        
        '
        ' Scale right part:
        ' * MX stores max(|Bi|)
        ' * ScaleRight stores actual scaling applied to B when solving systems
        '   it is chosen to make |scaleRight*b| close to 1.
        '
        MXB = 0#
        For i = 0# To N - 1# Step 1
            MXB = MaxReal(MXB, AbsComplex(BC(i)))
        Next i
        If MXB = 0# Then
            MXB = 1#
        End If
        ScaleRight = 1# / MXB
        
        '
        ' First, non-iterative part of solution process.
        ' We use separate code for this task because
        ' XDot is quite slow and we want to save time.
        '
        For i_ = 0# To N - 1# Step 1
            XC(i_) = C_MulR(BC(i_), ScaleRight)
        Next i_
        Call HPDBasicCholeskySolve(CHA, SqrtScaleA, N, IsUpper, XC, TX)
        
        '
        ' Store xc.
        ' Post-scale result.
        '
        V = Square(SqrtScaleA) * MXB
        For i_ = 0# To N - 1# Step 1
            X(i_, K) = C_MulR(XC(i_), V)
        Next i_
    Next K
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal subroutine.
'Returns maximum count of RFS iterations as function of:
'1. machine epsilon
'2. task size.
'3. condition number
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Function DenseSolverRFSMax(ByVal N As Long, _
         ByVal R1 As Double, _
         ByVal RInf As Double) As Long
    Dim Result As Long
    Result = 5#
    DenseSolverRFSMax = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal subroutine.
'Returns maximum count of RFS iterations as function of:
'1. machine epsilon
'2. task size.
'3. norm-2 condition number
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Function DenseSolverRFSMaxV2(ByVal N As Long, _
         ByVal R2 As Double) As Long
    Dim Result As Long
    Result = DenseSolverRFSMax(N, 0#, 0#)
    DenseSolverRFSMaxV2 = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Basic LU solver for ScaleA*PLU*x = y.
'
'This subroutine assumes that:
'* L is well-scaled, and it is U which needs scaling by ScaleA.
'* A=PLU is well-conditioned, so no zero divisions or overflow may occur
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub RBasicLUSolve(ByRef LUA() As Double, _
         ByRef p() As Long, _
         ByVal ScaleA As Double, _
         ByVal N As Long, _
         ByRef XB() As Double, _
         ByRef Tmp() As Double)
    Dim i As Long
    Dim V As Double
    Dim i_ As Long
    For i = 0# To N - 1# Step 1
        If p(i) <> i Then
            V = XB(i)
            XB(i) = XB(p(i))
            XB(p(i)) = V
        End If
    Next i
    For i = 1# To N - 1# Step 1
        V = 0#
        For i_ = 0# To i - 1# Step 1
            V = V + LUA(i, i_) * XB(i_)
        Next i_
        XB(i) = XB(i) - V
    Next i
    XB(N - 1#) = XB(N - 1#) / (ScaleA * LUA(N - 1#, N - 1#))
    For i = N - 2# To 0# Step -1
        For i_ = i + 1# To N - 1# Step 1
            Tmp(i_) = ScaleA * LUA(i, i_)
        Next i_
        V = 0#
        For i_ = i + 1# To N - 1# Step 1
            V = V + Tmp(i_) * XB(i_)
        Next i_
        XB(i) = (XB(i) - V) / (ScaleA * LUA(i, i))
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Basic Cholesky solver for ScaleA*Cholesky(A)'*x = y.
'
'This subroutine assumes that:
'* A*ScaleA is well scaled
'* A is well-conditioned, so no zero divisions or overflow may occur
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub SPDBasicCholeskySolve(ByRef CHA() As Double, _
         ByVal SqrtScaleA As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef XB() As Double, _
         ByRef Tmp() As Double)
    Dim i As Long
    Dim V As Double
    Dim i_ As Long
    
    '
    ' A = L*L' or A=U'*U
    '
    If IsUpper Then
        
        '
        ' Solve U'*y=b first.
        '
        For i = 0# To N - 1# Step 1
            XB(i) = XB(i) / (SqrtScaleA * CHA(i, i))
            If i < N - 1# Then
                V = XB(i)
                For i_ = i + 1# To N - 1# Step 1
                    Tmp(i_) = SqrtScaleA * CHA(i, i_)
                Next i_
                For i_ = i + 1# To N - 1# Step 1
                    XB(i_) = XB(i_) - V * Tmp(i_)
                Next i_
            End If
        Next i
        
        '
        ' Solve U*x=y then.
        '
        For i = N - 1# To 0# Step -1
            If i < N - 1# Then
                For i_ = i + 1# To N - 1# Step 1
                    Tmp(i_) = SqrtScaleA * CHA(i, i_)
                Next i_
                V = 0#
                For i_ = i + 1# To N - 1# Step 1
                    V = V + Tmp(i_) * XB(i_)
                Next i_
                XB(i) = XB(i) - V
            End If
            XB(i) = XB(i) / (SqrtScaleA * CHA(i, i))
        Next i
    Else
        
        '
        ' Solve L*y=b first
        '
        For i = 0# To N - 1# Step 1
            If i > 0# Then
                For i_ = 0# To i - 1# Step 1
                    Tmp(i_) = SqrtScaleA * CHA(i, i_)
                Next i_
                V = 0#
                For i_ = 0# To i - 1# Step 1
                    V = V + Tmp(i_) * XB(i_)
                Next i_
                XB(i) = XB(i) - V
            End If
            XB(i) = XB(i) / (SqrtScaleA * CHA(i, i))
        Next i
        
        '
        ' Solve L'*x=y then.
        '
        For i = N - 1# To 0# Step -1
            XB(i) = XB(i) / (SqrtScaleA * CHA(i, i))
            If i > 0# Then
                V = XB(i)
                For i_ = 0# To i - 1# Step 1
                    Tmp(i_) = SqrtScaleA * CHA(i, i_)
                Next i_
                For i_ = 0# To i - 1# Step 1
                    XB(i_) = XB(i_) - V * Tmp(i_)
                Next i_
            End If
        Next i
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Basic LU solver for ScaleA*PLU*x = y.
'
'This subroutine assumes that:
'* L is well-scaled, and it is U which needs scaling by ScaleA.
'* A=PLU is well-conditioned, so no zero divisions or overflow may occur
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub CBasicLUSolve(ByRef LUA() As Complex, _
         ByRef p() As Long, _
         ByVal ScaleA As Double, _
         ByVal N As Long, _
         ByRef XB() As Complex, _
         ByRef Tmp() As Complex)
    Dim i As Long
    Dim V As Complex
    Dim i_ As Long
    For i = 0# To N - 1# Step 1
        If p(i) <> i Then
            V = XB(i)
            XB(i) = XB(p(i))
            XB(p(i)) = V
        End If
    Next i
    For i = 1# To N - 1# Step 1
        V = C_Complex(0#)
        For i_ = 0# To i - 1# Step 1
            V = C_Add(V, C_Mul(LUA(i, i_), XB(i_)))
        Next i_
        XB(i) = C_Sub(XB(i), V)
    Next i
    XB(N - 1#) = C_Div(XB(N - 1#), C_MulR(LUA(N - 1#, N - 1#), ScaleA))
    For i = N - 2# To 0# Step -1
        For i_ = i + 1# To N - 1# Step 1
            Tmp(i_) = C_MulR(LUA(i, i_), ScaleA)
        Next i_
        V = C_Complex(0#)
        For i_ = i + 1# To N - 1# Step 1
            V = C_Add(V, C_Mul(Tmp(i_), XB(i_)))
        Next i_
        XB(i) = C_Div(C_Sub(XB(i), V), C_MulR(LUA(i, i), ScaleA))
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Basic Cholesky solver for ScaleA*Cholesky(A)'*x = y.
'
'This subroutine assumes that:
'* A*ScaleA is well scaled
'* A is well-conditioned, so no zero divisions or overflow may occur
'
'  -- ALGLIB --
'     Copyright 27.01.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub HPDBasicCholeskySolve(ByRef CHA() As Complex, _
         ByVal SqrtScaleA As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef XB() As Complex, _
         ByRef Tmp() As Complex)
    Dim i As Long
    Dim V As Complex
    Dim i_ As Long
    
    '
    ' A = L*L' or A=U'*U
    '
    If IsUpper Then
        
        '
        ' Solve U'*y=b first.
        '
        For i = 0# To N - 1# Step 1
            XB(i) = C_Div(XB(i), C_MulR(Conj(CHA(i, i)), SqrtScaleA))
            If i < N - 1# Then
                V = XB(i)
                For i_ = i + 1# To N - 1# Step 1
                    Tmp(i_) = C_MulR(Conj(CHA(i, i_)), SqrtScaleA)
                Next i_
                For i_ = i + 1# To N - 1# Step 1
                    XB(i_) = C_Sub(XB(i_), C_Mul(V, Tmp(i_)))
                Next i_
            End If
        Next i
        
        '
        ' Solve U*x=y then.
        '
        For i = N - 1# To 0# Step -1
            If i < N - 1# Then
                For i_ = i + 1# To N - 1# Step 1
                    Tmp(i_) = C_MulR(CHA(i, i_), SqrtScaleA)
                Next i_
                V = C_Complex(0#)
                For i_ = i + 1# To N - 1# Step 1
                    V = C_Add(V, C_Mul(Tmp(i_), XB(i_)))
                Next i_
                XB(i) = C_Sub(XB(i), V)
            End If
            XB(i) = C_Div(XB(i), C_MulR(CHA(i, i), SqrtScaleA))
        Next i
    Else
        
        '
        ' Solve L*y=b first
        '
        For i = 0# To N - 1# Step 1
            If i > 0# Then
                For i_ = 0# To i - 1# Step 1
                    Tmp(i_) = C_MulR(CHA(i, i_), SqrtScaleA)
                Next i_
                V = C_Complex(0#)
                For i_ = 0# To i - 1# Step 1
                    V = C_Add(V, C_Mul(Tmp(i_), XB(i_)))
                Next i_
                XB(i) = C_Sub(XB(i), V)
            End If
            XB(i) = C_Div(XB(i), C_MulR(CHA(i, i), SqrtScaleA))
        Next i
        
        '
        ' Solve L'*x=y then.
        '
        For i = N - 1# To 0# Step -1
            XB(i) = C_Div(XB(i), C_MulR(Conj(CHA(i, i)), SqrtScaleA))
            If i > 0# Then
                V = XB(i)
                For i_ = 0# To i - 1# Step 1
                    Tmp(i_) = C_MulR(Conj(CHA(i, i_)), SqrtScaleA)
                Next i_
                For i_ = 0# To i - 1# Step 1
                    XB(i_) = C_Sub(XB(i_), C_Mul(V, Tmp(i_)))
                Next i_
            End If
        Next i
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2005-2007, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Finding the eigenvalues and eigenvectors of a symmetric matrix
'
'The algorithm finds eigen pairs of a symmetric matrix by reducing it to
'tridiagonal form and using the QL/QR algorithm.
'
'Input parameters:
'    A       -   symmetric matrix which is given by its upper or lower
'                triangular part.
'                Array whose indexes range within [0..N-1, 0..N-1].
'    N       -   size of matrix A.
'    IsUpper -   storage format.
'    ZNeeded -   flag controlling whether the eigenvectors are needed or not.
'                If ZNeeded is equal to:
'                 * 0, the eigenvectors are not returned;
'                 * 1, the eigenvectors are returned.
'
'Output parameters:
'    D       -   eigenvalues in ascending order.
'                Array whose index ranges within [0..N-1].
'    Z       -   if ZNeeded is equal to:
'                 * 0, Z hasnt changed;
'                 * 1, Z contains the eigenvectors.
'                Array whose indexes range within [0..N-1, 0..N-1].
'                The eigenvectors are stored in the matrix columns.
'
'Result:
'    True, if the algorithm has converged.
'    False, if the algorithm hasn't converged (rare case).
'
'  -- ALGLIB --
'     Copyright 2005-2008 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function SMatrixEVD(ByRef A_() As Double, _
         ByVal N As Long, _
         ByVal ZNeeded As Long, _
         ByVal IsUpper As Boolean, _
         ByRef D() As Double, _
         ByRef z() As Double) As Boolean
    Dim Result As Boolean
    Dim A() As Double
    Dim Tau() As Double
    Dim E() As Double
    A = A_
    Call SMatrixTD(A, N, IsUpper, Tau, D, E)
    If ZNeeded = 1# Then
        Call SMatrixTDUnpackQ(A, N, IsUpper, Tau, z)
    End If
    Result = SMatrixTDEVD(D, E, N, ZNeeded, z)
    SMatrixEVD = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Subroutine for finding the eigenvalues (and eigenvectors) of  a  symmetric
'matrix  in  a  given half open interval (A, B] by using  a  bisection  and
'inverse iteration
'
'Input parameters:
'    A       -   symmetric matrix which is given by its upper or lower
'                triangular part. Array [0..N-1, 0..N-1].
'    N       -   size of matrix A.
'    ZNeeded -   flag controlling whether the eigenvectors are needed or not.
'                If ZNeeded is equal to:
'                 * 0, the eigenvectors are not returned;
'                 * 1, the eigenvectors are returned.
'    IsUpperA -  storage format of matrix A.
'    B1, B2 -    half open interval (B1, B2] to search eigenvalues in.
'
'Output parameters:
'    M       -   number of eigenvalues found in a given half-interval (M>=0).
'    W       -   array of the eigenvalues found.
'                Array whose index ranges within [0..M-1].
'    Z       -   if ZNeeded is equal to:
'                 * 0, Z hasnt changed;
'                 * 1, Z contains eigenvectors.
'                Array whose indexes range within [0..N-1, 0..M-1].
'                The eigenvectors are stored in the matrix columns.
'
'Result:
'    True, if successful. M contains the number of eigenvalues in the given
'    half-interval (could be equal to 0), W contains the eigenvalues,
'    Z contains the eigenvectors (if needed).
'
'    False, if the bisection method subroutine wasn't able to find the
'    eigenvalues in the given interval or if the inverse iteration subroutine
'    wasn't able to find all the corresponding eigenvectors.
'    In that case, the eigenvalues and eigenvectors are not returned,
'    M is equal to 0.
'
'  -- ALGLIB --
'     Copyright 07.01.2006 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function SMatrixEVDR(ByRef A_() As Double, _
         ByVal N As Long, _
         ByVal ZNeeded As Long, _
         ByVal IsUpper As Boolean, _
         ByVal b1 As Double, _
         ByVal b2 As Double, _
         ByRef M As Long, _
         ByRef w() As Double, _
         ByRef z() As Double) As Boolean
    Dim Result As Boolean
    Dim A() As Double
    Dim Tau() As Double
    Dim E() As Double
    A = A_
    Call SMatrixTD(A, N, IsUpper, Tau, w, E)
    If ZNeeded = 1# Then
        Call SMatrixTDUnpackQ(A, N, IsUpper, Tau, z)
    End If
    Result = SMatrixTDEVDR(w, E, N, ZNeeded, b1, b2, M, z)
    SMatrixEVDR = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Subroutine for finding the eigenvalues and  eigenvectors  of  a  symmetric
'matrix with given indexes by using bisection and inverse iteration methods.
'
'Input parameters:
'    A       -   symmetric matrix which is given by its upper or lower
'                triangular part. Array whose indexes range within [0..N-1, 0..N-1].
'    N       -   size of matrix A.
'    ZNeeded -   flag controlling whether the eigenvectors are needed or not.
'                If ZNeeded is equal to:
'                 * 0, the eigenvectors are not returned;
'                 * 1, the eigenvectors are returned.
'    IsUpperA -  storage format of matrix A.
'    I1, I2 -    index interval for searching (from I1 to I2).
'                0 <= I1 <= I2 <= N-1.
'
'Output parameters:
'    W       -   array of the eigenvalues found.
'                Array whose index ranges within [0..I2-I1].
'    Z       -   if ZNeeded is equal to:
'                 * 0, Z hasnt changed;
'                 * 1, Z contains eigenvectors.
'                Array whose indexes range within [0..N-1, 0..I2-I1].
'                In that case, the eigenvectors are stored in the matrix columns.
'
'Result:
'    True, if successful. W contains the eigenvalues, Z contains the
'    eigenvectors (if needed).
'
'    False, if the bisection method subroutine wasn't able to find the
'    eigenvalues in the given interval or if the inverse iteration subroutine
'    wasn't able to find all the corresponding eigenvectors.
'    In that case, the eigenvalues and eigenvectors are not returned.
'
'  -- ALGLIB --
'     Copyright 07.01.2006 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function SMatrixEVDI(ByRef A_() As Double, _
         ByVal N As Long, _
         ByVal ZNeeded As Long, _
         ByVal IsUpper As Boolean, _
         ByVal I1 As Long, _
         ByVal I2 As Long, _
         ByRef w() As Double, _
         ByRef z() As Double) As Boolean
    Dim Result As Boolean
    Dim A() As Double
    Dim Tau() As Double
    Dim E() As Double
    A = A_
    Call SMatrixTD(A, N, IsUpper, Tau, w, E)
    If ZNeeded = 1# Then
        Call SMatrixTDUnpackQ(A, N, IsUpper, Tau, z)
    End If
    Result = SMatrixTDEVDI(w, E, N, ZNeeded, I1, I2, z)
    SMatrixEVDI = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Finding the eigenvalues and eigenvectors of a Hermitian matrix
'
'The algorithm finds eigen pairs of a Hermitian matrix by  reducing  it  to
'real tridiagonal form and using the QL/QR algorithm.
'
'Input parameters:
'    A       -   Hermitian matrix which is given  by  its  upper  or  lower
'                triangular part.
'                Array whose indexes range within [0..N-1, 0..N-1].
'    N       -   size of matrix A.
'    IsUpper -   storage format.
'    ZNeeded -   flag controlling whether the eigenvectors  are  needed  or
'                not. If ZNeeded is equal to:
'                 * 0, the eigenvectors are not returned;
'                 * 1, the eigenvectors are returned.
'
'Output parameters:
'    D       -   eigenvalues in ascending order.
'                Array whose index ranges within [0..N-1].
'    Z       -   if ZNeeded is equal to:
'                 * 0, Z hasnt changed;
'                 * 1, Z contains the eigenvectors.
'                Array whose indexes range within [0..N-1, 0..N-1].
'                The eigenvectors are stored in the matrix columns.
'
'Result:
'    True, if the algorithm has converged.
'    False, if the algorithm hasn't converged (rare case).
'
'Note:
'    eigenvectors of Hermitian matrix are defined up to  multiplication  by
'    a complex number L, such that |L|=1.
'
'  -- ALGLIB --
'     Copyright 2005, 23 March 2007 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function HMatrixEVD(ByRef A_() As Complex, _
         ByVal N As Long, _
         ByVal ZNeeded As Long, _
         ByVal IsUpper As Boolean, _
         ByRef D() As Double, _
         ByRef z() As Complex) As Boolean
    Dim Result As Boolean
    Dim A() As Complex
    Dim Tau() As Complex
    Dim E() As Double
    Dim WORK() As Double
    Dim T() As Double
    Dim q() As Complex
    Dim i As Long
    Dim K As Long
    Dim V As Double
    Dim i_ As Long
    A = A_
    
    '
    ' Reduce to tridiagonal form
    '
    Call HMatrixTD(A, N, IsUpper, Tau, D, E)
    If ZNeeded = 1# Then
        Call HMatrixTDUnpackQ(A, N, IsUpper, Tau, q)
        ZNeeded = 2#
    End If
    
    '
    ' TDEVD
    '
    Result = SMatrixTDEVD(D, E, N, ZNeeded, T)
    
    '
    ' Eigenvectors are needed
    ' Calculate Z = Q*T = Re(Q)*T + i*Im(Q)*T
    '
    If Result And ZNeeded <> 0# Then
        ReDim WORK(0# To N - 1#)
        ReDim z(0# To N - 1#, 0# To N - 1#)
        For i = 0# To N - 1# Step 1
            
            '
            ' Calculate real part
            '
            For K = 0# To N - 1# Step 1
                WORK(K) = 0#
            Next K
            For K = 0# To N - 1# Step 1
                V = q(i, K).X
                For i_ = 0# To N - 1# Step 1
                    WORK(i_) = WORK(i_) + V * T(K, i_)
                Next i_
            Next K
            For K = 0# To N - 1# Step 1
                z(i, K).X = WORK(K)
            Next K
            
            '
            ' Calculate imaginary part
            '
            For K = 0# To N - 1# Step 1
                WORK(K) = 0#
            Next K
            For K = 0# To N - 1# Step 1
                V = q(i, K).y
                For i_ = 0# To N - 1# Step 1
                    WORK(i_) = WORK(i_) + V * T(K, i_)
                Next i_
            Next K
            For K = 0# To N - 1# Step 1
                z(i, K).y = WORK(K)
            Next K
        Next i
    End If
    HMatrixEVD = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Subroutine for finding the eigenvalues (and eigenvectors) of  a  Hermitian
'matrix  in  a  given half-interval (A, B] by using a bisection and inverse
'iteration
'
'Input parameters:
'    A       -   Hermitian matrix which is given  by  its  upper  or  lower
'                triangular  part.  Array  whose   indexes   range   within
'                [0..N-1, 0..N-1].
'    N       -   size of matrix A.
'    ZNeeded -   flag controlling whether the eigenvectors  are  needed  or
'                not. If ZNeeded is equal to:
'                 * 0, the eigenvectors are not returned;
'                 * 1, the eigenvectors are returned.
'    IsUpperA -  storage format of matrix A.
'    B1, B2 -    half-interval (B1, B2] to search eigenvalues in.
'
'Output parameters:
'    M       -   number of eigenvalues found in a given half-interval, M>=0
'    W       -   array of the eigenvalues found.
'                Array whose index ranges within [0..M-1].
'    Z       -   if ZNeeded is equal to:
'                 * 0, Z hasnt changed;
'                 * 1, Z contains eigenvectors.
'                Array whose indexes range within [0..N-1, 0..M-1].
'                The eigenvectors are stored in the matrix columns.
'
'Result:
'    True, if successful. M contains the number of eigenvalues in the given
'    half-interval (could be equal to 0), W contains the eigenvalues,
'    Z contains the eigenvectors (if needed).
'
'    False, if the bisection method subroutine  wasn't  able  to  find  the
'    eigenvalues  in  the  given  interval  or  if  the  inverse  iteration
'    subroutine  wasn't  able  to  find all the corresponding eigenvectors.
'    In that case, the eigenvalues and eigenvectors are not returned, M  is
'    equal to 0.
'
'Note:
'    eigen vectors of Hermitian matrix are defined up to multiplication  by
'    a complex number L, such as |L|=1.
'
'  -- ALGLIB --
'     Copyright 07.01.2006, 24.03.2007 by Bochkanov Sergey.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function HMatrixEVDR(ByRef A_() As Complex, _
         ByVal N As Long, _
         ByVal ZNeeded As Long, _
         ByVal IsUpper As Boolean, _
         ByVal b1 As Double, _
         ByVal b2 As Double, _
         ByRef M As Long, _
         ByRef w() As Double, _
         ByRef z() As Complex) As Boolean
    Dim Result As Boolean
    Dim A() As Complex
    Dim q() As Complex
    Dim T() As Double
    Dim Tau() As Complex
    Dim E() As Double
    Dim WORK() As Double
    Dim i As Long
    Dim K As Long
    Dim V As Double
    Dim i_ As Long
    A = A_
    
    '
    ' Reduce to tridiagonal form
    '
    Call HMatrixTD(A, N, IsUpper, Tau, w, E)
    If ZNeeded = 1# Then
        Call HMatrixTDUnpackQ(A, N, IsUpper, Tau, q)
        ZNeeded = 2#
    End If
    
    '
    ' Bisection and inverse iteration
    '
    Result = SMatrixTDEVDR(w, E, N, ZNeeded, b1, b2, M, T)
    
    '
    ' Eigenvectors are needed
    ' Calculate Z = Q*T = Re(Q)*T + i*Im(Q)*T
    '
    If Result And ZNeeded <> 0# And M <> 0# Then
        ReDim WORK(0# To M - 1#)
        ReDim z(0# To N - 1#, 0# To M - 1#)
        For i = 0# To N - 1# Step 1
            
            '
            ' Calculate real part
            '
            For K = 0# To M - 1# Step 1
                WORK(K) = 0#
            Next K
            For K = 0# To N - 1# Step 1
                V = q(i, K).X
                For i_ = 0# To M - 1# Step 1
                    WORK(i_) = WORK(i_) + V * T(K, i_)
                Next i_
            Next K
            For K = 0# To M - 1# Step 1
                z(i, K).X = WORK(K)
            Next K
            
            '
            ' Calculate imaginary part
            '
            For K = 0# To M - 1# Step 1
                WORK(K) = 0#
            Next K
            For K = 0# To N - 1# Step 1
                V = q(i, K).y
                For i_ = 0# To M - 1# Step 1
                    WORK(i_) = WORK(i_) + V * T(K, i_)
                Next i_
            Next K
            For K = 0# To M - 1# Step 1
                z(i, K).y = WORK(K)
            Next K
        Next i
    End If
    HMatrixEVDR = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Subroutine for finding the eigenvalues and  eigenvectors  of  a  Hermitian
'matrix with given indexes by using bisection and inverse iteration methods
'
'Input parameters:
'    A       -   Hermitian matrix which is given  by  its  upper  or  lower
'                triangular part.
'                Array whose indexes range within [0..N-1, 0..N-1].
'    N       -   size of matrix A.
'    ZNeeded -   flag controlling whether the eigenvectors  are  needed  or
'                not. If ZNeeded is equal to:
'                 * 0, the eigenvectors are not returned;
'                 * 1, the eigenvectors are returned.
'    IsUpperA -  storage format of matrix A.
'    I1, I2 -    index interval for searching (from I1 to I2).
'                0 <= I1 <= I2 <= N-1.
'
'Output parameters:
'    W       -   array of the eigenvalues found.
'                Array whose index ranges within [0..I2-I1].
'    Z       -   if ZNeeded is equal to:
'                 * 0, Z hasnt changed;
'                 * 1, Z contains eigenvectors.
'                Array whose indexes range within [0..N-1, 0..I2-I1].
'                In  that  case,  the eigenvectors are stored in the matrix
'                columns.
'
'Result:
'    True, if successful. W contains the eigenvalues, Z contains the
'    eigenvectors (if needed).
'
'    False, if the bisection method subroutine  wasn't  able  to  find  the
'    eigenvalues  in  the  given  interval  or  if  the  inverse  iteration
'    subroutine wasn't able to find  all  the  corresponding  eigenvectors.
'    In that case, the eigenvalues and eigenvectors are not returned.
'
'Note:
'    eigen vectors of Hermitian matrix are defined up to multiplication  by
'    a complex number L, such as |L|=1.
'
'  -- ALGLIB --
'     Copyright 07.01.2006, 24.03.2007 by Bochkanov Sergey.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function HMatrixEVDI(ByRef A_() As Complex, _
         ByVal N As Long, _
         ByVal ZNeeded As Long, _
         ByVal IsUpper As Boolean, _
         ByVal I1 As Long, _
         ByVal I2 As Long, _
         ByRef w() As Double, _
         ByRef z() As Complex) As Boolean
    Dim Result As Boolean
    Dim A() As Complex
    Dim q() As Complex
    Dim T() As Double
    Dim Tau() As Complex
    Dim E() As Double
    Dim WORK() As Double
    Dim i As Long
    Dim K As Long
    Dim V As Double
    Dim M As Long
    Dim i_ As Long
    A = A_
    
    '
    ' Reduce to tridiagonal form
    '
    Call HMatrixTD(A, N, IsUpper, Tau, w, E)
    If ZNeeded = 1# Then
        Call HMatrixTDUnpackQ(A, N, IsUpper, Tau, q)
        ZNeeded = 2#
    End If
    
    '
    ' Bisection and inverse iteration
    '
    Result = SMatrixTDEVDI(w, E, N, ZNeeded, I1, I2, T)
    
    '
    ' Eigenvectors are needed
    ' Calculate Z = Q*T = Re(Q)*T + i*Im(Q)*T
    '
    M = I2 - I1 + 1#
    If Result And ZNeeded <> 0# Then
        ReDim WORK(0# To M - 1#)
        ReDim z(0# To N - 1#, 0# To M - 1#)
        For i = 0# To N - 1# Step 1
            
            '
            ' Calculate real part
            '
            For K = 0# To M - 1# Step 1
                WORK(K) = 0#
            Next K
            For K = 0# To N - 1# Step 1
                V = q(i, K).X
                For i_ = 0# To M - 1# Step 1
                    WORK(i_) = WORK(i_) + V * T(K, i_)
                Next i_
            Next K
            For K = 0# To M - 1# Step 1
                z(i, K).X = WORK(K)
            Next K
            
            '
            ' Calculate imaginary part
            '
            For K = 0# To M - 1# Step 1
                WORK(K) = 0#
            Next K
            For K = 0# To N - 1# Step 1
                V = q(i, K).y
                For i_ = 0# To M - 1# Step 1
                    WORK(i_) = WORK(i_) + V * T(K, i_)
                Next i_
            Next K
            For K = 0# To M - 1# Step 1
                z(i, K).y = WORK(K)
            Next K
        Next i
    End If
    HMatrixEVDI = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Finding the eigenvalues and eigenvectors of a tridiagonal symmetric matrix
'
'The algorithm finds the eigen pairs of a tridiagonal symmetric matrix by
'using an QL/QR algorithm with implicit shifts.
'
'Input parameters:
'    D       -   the main diagonal of a tridiagonal matrix.
'                Array whose index ranges within [0..N-1].
'    E       -   the secondary diagonal of a tridiagonal matrix.
'                Array whose index ranges within [0..N-2].
'    N       -   size of matrix A.
'    ZNeeded -   flag controlling whether the eigenvectors are needed or not.
'                If ZNeeded is equal to:
'                 * 0, the eigenvectors are not needed;
'                 * 1, the eigenvectors of a tridiagonal matrix
'                   are multiplied by the square matrix Z. It is used if the
'                   tridiagonal matrix is obtained by the similarity
'                   transformation of a symmetric matrix;
'                 * 2, the eigenvectors of a tridiagonal matrix replace the
'                   square matrix Z;
'                 * 3, matrix Z contains the first row of the eigenvectors
'                   matrix.
'    Z       -   if ZNeeded=1, Z contains the square matrix by which the
'                eigenvectors are multiplied.
'                Array whose indexes range within [0..N-1, 0..N-1].
'
'Output parameters:
'    D       -   eigenvalues in ascending order.
'                Array whose index ranges within [0..N-1].
'    Z       -   if ZNeeded is equal to:
'                 * 0, Z hasnt changed;
'                 * 1, Z contains the product of a given matrix (from the left)
'                   and the eigenvectors matrix (from the right);
'                 * 2, Z contains the eigenvectors.
'                 * 3, Z contains the first row of the eigenvectors matrix.
'                If ZNeeded<3, Z is the array whose indexes range within [0..N-1, 0..N-1].
'                In that case, the eigenvectors are stored in the matrix columns.
'                If ZNeeded=3, Z is the array whose indexes range within [0..0, 0..N-1].
'
'Result:
'    True, if the algorithm has converged.
'    False, if the algorithm hasn't converged.
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     September 30, 1994
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function SMatrixTDEVD(ByRef D() As Double, _
         ByRef E_() As Double, _
         ByVal N As Long, _
         ByVal ZNeeded As Long, _
         ByRef z() As Double) As Boolean
    Dim Result As Boolean
    Dim E() As Double
    Dim D1() As Double
    Dim E1() As Double
    Dim Z1() As Double
    Dim i As Long
    Dim i_ As Long
    Dim i1_ As Long
    E = E_
    
    '
    ' Prepare 1-based task
    '
    ReDim D1(1# To N)
    ReDim E1(1# To N)
    i1_ = (0#) - (1#)
    For i_ = 1# To N Step 1
        D1(i_) = D(i_ + i1_)
    Next i_
    If N > 1# Then
        i1_ = (0#) - (1#)
        For i_ = 1# To N - 1# Step 1
            E1(i_) = E(i_ + i1_)
        Next i_
    End If
    If ZNeeded = 1# Then
        ReDim Z1(1# To N, 1# To N)
        For i = 1# To N Step 1
            i1_ = (0#) - (1#)
            For i_ = 1# To N Step 1
                Z1(i, i_) = z(i - 1#, i_ + i1_)
            Next i_
        Next i
    End If
    
    '
    ' Solve 1-based task
    '
    Result = TridiagonalEVD(D1, E1, N, ZNeeded, Z1)
    If Not Result Then
        SMatrixTDEVD = Result
        Exit Function
    End If
    
    '
    ' Convert back to 0-based result
    '
    i1_ = (1#) - (0#)
    For i_ = 0# To N - 1# Step 1
        D(i_) = D1(i_ + i1_)
    Next i_
    If ZNeeded <> 0# Then
        If ZNeeded = 1# Then
            For i = 1# To N Step 1
                i1_ = (1#) - (0#)
                For i_ = 0# To N - 1# Step 1
                    z(i - 1#, i_) = Z1(i, i_ + i1_)
                Next i_
            Next i
            SMatrixTDEVD = Result
            Exit Function
        End If
        If ZNeeded = 2# Then
            ReDim z(0# To N - 1#, 0# To N - 1#)
            For i = 1# To N Step 1
                i1_ = (1#) - (0#)
                For i_ = 0# To N - 1# Step 1
                    z(i - 1#, i_) = Z1(i, i_ + i1_)
                Next i_
            Next i
            SMatrixTDEVD = Result
            Exit Function
        End If
        If ZNeeded = 3# Then
            ReDim z(0# To 0#, 0# To N - 1#)
            i1_ = (1#) - (0#)
            For i_ = 0# To N - 1# Step 1
                z(0#, i_) = Z1(1#, i_ + i1_)
            Next i_
            SMatrixTDEVD = Result
            Exit Function
        End If
    End If
    SMatrixTDEVD = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Subroutine for finding the tridiagonal matrix eigenvalues/vectors in a
'given half-interval (A, B] by using bisection and inverse iteration.
'
'Input parameters:
'    D       -   the main diagonal of a tridiagonal matrix.
'                Array whose index ranges within [0..N-1].
'    E       -   the secondary diagonal of a tridiagonal matrix.
'                Array whose index ranges within [0..N-2].
'    N       -   size of matrix, N>=0.
'    ZNeeded -   flag controlling whether the eigenvectors are needed or not.
'                If ZNeeded is equal to:
'                 * 0, the eigenvectors are not needed;
'                 * 1, the eigenvectors of a tridiagonal matrix are multiplied
'                   by the square matrix Z. It is used if the tridiagonal
'                   matrix is obtained by the similarity transformation
'                   of a symmetric matrix.
'                 * 2, the eigenvectors of a tridiagonal matrix replace matrix Z.
'    A, B    -   half-interval (A, B] to search eigenvalues in.
'    Z       -   if ZNeeded is equal to:
'                 * 0, Z isn't used and remains unchanged;
'                 * 1, Z contains the square matrix (array whose indexes range
'                   within [0..N-1, 0..N-1]) which reduces the given symmetric
'                   matrix to tridiagonal form;
'                 * 2, Z isn't used (but changed on the exit).
'
'Output parameters:
'    D       -   array of the eigenvalues found.
'                Array whose index ranges within [0..M-1].
'    M       -   number of eigenvalues found in the given half-interval (M>=0).
'    Z       -   if ZNeeded is equal to:
'                 * 0, doesn't contain any information;
'                 * 1, contains the product of a given NxN matrix Z (from the
'                   left) and NxM matrix of the eigenvectors found (from the
'                   right). Array whose indexes range within [0..N-1, 0..M-1].
'                 * 2, contains the matrix of the eigenvectors found.
'                   Array whose indexes range within [0..N-1, 0..M-1].
'
'Result:
'
'    True, if successful. In that case, M contains the number of eigenvalues
'    in the given half-interval (could be equal to 0), D contains the eigenvalues,
'    Z contains the eigenvectors (if needed).
'    It should be noted that the subroutine changes the size of arrays D and Z.
'
'    False, if the bisection method subroutine wasn't able to find the
'    eigenvalues in the given interval or if the inverse iteration subroutine
'    wasn't able to find all the corresponding eigenvectors. In that case,
'    the eigenvalues and eigenvectors are not returned, M is equal to 0.
'
'  -- ALGLIB --
'     Copyright 31.03.2008 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function SMatrixTDEVDR(ByRef D() As Double, _
         ByRef E() As Double, _
         ByVal N As Long, _
         ByVal ZNeeded As Long, _
         ByVal A As Double, _
         ByVal B As Double, _
         ByRef M As Long, _
         ByRef z() As Double) As Boolean
    Dim Result As Boolean
    Dim ErrorCode As Long
    Dim NSPLIT As Long
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim CR As Long
    Dim IBLOCK() As Long
    Dim ISPLIT() As Long
    Dim IFAIL() As Long
    Dim D1() As Double
    Dim E1() As Double
    Dim w() As Double
    Dim Z2() As Double
    Dim Z3() As Double
    Dim V As Double
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' Special cases
    '
    If B <= A Then
        M = 0#
        Result = True
        SMatrixTDEVDR = Result
        Exit Function
    End If
    If N <= 0# Then
        M = 0#
        Result = True
        SMatrixTDEVDR = Result
        Exit Function
    End If
    
    '
    ' Copy D,E to D1, E1
    '
    ReDim D1(1# To N)
    i1_ = (0#) - (1#)
    For i_ = 1# To N Step 1
        D1(i_) = D(i_ + i1_)
    Next i_
    If N > 1# Then
        ReDim E1(1# To N - 1#)
        i1_ = (0#) - (1#)
        For i_ = 1# To N - 1# Step 1
            E1(i_) = E(i_ + i1_)
        Next i_
    End If
    
    '
    ' No eigen vectors
    '
    If ZNeeded = 0# Then
        Result = InternalBisectionEigenValues(D1, E1, N, 2#, 1#, A, B, 0#, 0#, -1#, w, M, NSPLIT, IBLOCK, ISPLIT, ErrorCode)
        If Not Result Or M = 0# Then
            M = 0#
            SMatrixTDEVDR = Result
            Exit Function
        End If
        ReDim D(0# To M - 1#)
        i1_ = (1#) - (0#)
        For i_ = 0# To M - 1# Step 1
            D(i_) = w(i_ + i1_)
        Next i_
        SMatrixTDEVDR = Result
        Exit Function
    End If
    
    '
    ' Eigen vectors are multiplied by Z
    '
    If ZNeeded = 1# Then
        
        '
        ' Find eigen pairs
        '
        Result = InternalBisectionEigenValues(D1, E1, N, 2#, 2#, A, B, 0#, 0#, -1#, w, M, NSPLIT, IBLOCK, ISPLIT, ErrorCode)
        If Not Result Or M = 0# Then
            M = 0#
            SMatrixTDEVDR = Result
            Exit Function
        End If
        Call InternalDSTEIN(N, D1, E1, M, w, IBLOCK, ISPLIT, Z2, IFAIL, CR)
        If CR <> 0# Then
            M = 0#
            Result = False
            SMatrixTDEVDR = Result
            Exit Function
        End If
        
        '
        ' Sort eigen values and vectors
        '
        For i = 1# To M Step 1
            K = i
            For j = i To M Step 1
                If w(j) < w(K) Then
                    K = j
                End If
            Next j
            V = w(i)
            w(i) = w(K)
            w(K) = V
            For j = 1# To N Step 1
                V = Z2(j, i)
                Z2(j, i) = Z2(j, K)
                Z2(j, K) = V
            Next j
        Next i
        
        '
        ' Transform Z2 and overwrite Z
        '
        ReDim Z3(1# To M, 1# To N)
        For i = 1# To M Step 1
            For i_ = 1# To N Step 1
                Z3(i, i_) = Z2(i_, i)
            Next i_
        Next i
        For i = 1# To N Step 1
            For j = 1# To M Step 1
                i1_ = (1#) - (0#)
                V = 0#
                For i_ = 0# To N - 1# Step 1
                    V = V + z(i - 1#, i_) * Z3(j, i_ + i1_)
                Next i_
                Z2(i, j) = V
            Next j
        Next i
        ReDim z(0# To N - 1#, 0# To M - 1#)
        For i = 1# To M Step 1
            i1_ = (1#) - (0#)
            For i_ = 0# To N - 1# Step 1
                z(i_, i - 1#) = Z2(i_ + i1_, i)
            Next i_
        Next i
        
        '
        ' Store W
        '
        ReDim D(0# To M - 1#)
        For i = 1# To M Step 1
            D(i - 1#) = w(i)
        Next i
        SMatrixTDEVDR = Result
        Exit Function
    End If
    
    '
    ' Eigen vectors are stored in Z
    '
    If ZNeeded = 2# Then
        
        '
        ' Find eigen pairs
        '
        Result = InternalBisectionEigenValues(D1, E1, N, 2#, 2#, A, B, 0#, 0#, -1#, w, M, NSPLIT, IBLOCK, ISPLIT, ErrorCode)
        If Not Result Or M = 0# Then
            M = 0#
            SMatrixTDEVDR = Result
            Exit Function
        End If
        Call InternalDSTEIN(N, D1, E1, M, w, IBLOCK, ISPLIT, Z2, IFAIL, CR)
        If CR <> 0# Then
            M = 0#
            Result = False
            SMatrixTDEVDR = Result
            Exit Function
        End If
        
        '
        ' Sort eigen values and vectors
        '
        For i = 1# To M Step 1
            K = i
            For j = i To M Step 1
                If w(j) < w(K) Then
                    K = j
                End If
            Next j
            V = w(i)
            w(i) = w(K)
            w(K) = V
            For j = 1# To N Step 1
                V = Z2(j, i)
                Z2(j, i) = Z2(j, K)
                Z2(j, K) = V
            Next j
        Next i
        
        '
        ' Store W
        '
        ReDim D(0# To M - 1#)
        For i = 1# To M Step 1
            D(i - 1#) = w(i)
        Next i
        ReDim z(0# To N - 1#, 0# To M - 1#)
        For i = 1# To M Step 1
            i1_ = (1#) - (0#)
            For i_ = 0# To N - 1# Step 1
                z(i_, i - 1#) = Z2(i_ + i1_, i)
            Next i_
        Next i
        SMatrixTDEVDR = Result
        Exit Function
    End If
    Result = False
    SMatrixTDEVDR = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Subroutine for finding tridiagonal matrix eigenvalues/vectors with given
'indexes (in ascending order) by using the bisection and inverse iteraion.
'
'Input parameters:
'    D       -   the main diagonal of a tridiagonal matrix.
'                Array whose index ranges within [0..N-1].
'    E       -   the secondary diagonal of a tridiagonal matrix.
'                Array whose index ranges within [0..N-2].
'    N       -   size of matrix. N>=0.
'    ZNeeded -   flag controlling whether the eigenvectors are needed or not.
'                If ZNeeded is equal to:
'                 * 0, the eigenvectors are not needed;
'                 * 1, the eigenvectors of a tridiagonal matrix are multiplied
'                   by the square matrix Z. It is used if the
'                   tridiagonal matrix is obtained by the similarity transformation
'                   of a symmetric matrix.
'                 * 2, the eigenvectors of a tridiagonal matrix replace
'                   matrix Z.
'    I1, I2  -   index interval for searching (from I1 to I2).
'                0 <= I1 <= I2 <= N-1.
'    Z       -   if ZNeeded is equal to:
'                 * 0, Z isn't used and remains unchanged;
'                 * 1, Z contains the square matrix (array whose indexes range within [0..N-1, 0..N-1])
'                   which reduces the given symmetric matrix to  tridiagonal form;
'                 * 2, Z isn't used (but changed on the exit).
'
'Output parameters:
'    D       -   array of the eigenvalues found.
'                Array whose index ranges within [0..I2-I1].
'    Z       -   if ZNeeded is equal to:
'                 * 0, doesn't contain any information;
'                 * 1, contains the product of a given NxN matrix Z (from the left) and
'                   Nx(I2-I1) matrix of the eigenvectors found (from the right).
'                   Array whose indexes range within [0..N-1, 0..I2-I1].
'                 * 2, contains the matrix of the eigenvalues found.
'                   Array whose indexes range within [0..N-1, 0..I2-I1].
'
'
'Result:
'
'    True, if successful. In that case, D contains the eigenvalues,
'    Z contains the eigenvectors (if needed).
'    It should be noted that the subroutine changes the size of arrays D and Z.
'
'    False, if the bisection method subroutine wasn't able to find the eigenvalues
'    in the given interval or if the inverse iteration subroutine wasn't able
'    to find all the corresponding eigenvectors. In that case, the eigenvalues
'    and eigenvectors are not returned.
'
'  -- ALGLIB --
'     Copyright 25.12.2005 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function SMatrixTDEVDI(ByRef D() As Double, _
         ByRef E() As Double, _
         ByVal N As Long, _
         ByVal ZNeeded As Long, _
         ByVal I1 As Long, _
         ByVal I2 As Long, _
         ByRef z() As Double) As Boolean
    Dim Result As Boolean
    Dim ErrorCode As Long
    Dim NSPLIT As Long
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim M As Long
    Dim CR As Long
    Dim IBLOCK() As Long
    Dim ISPLIT() As Long
    Dim IFAIL() As Long
    Dim w() As Double
    Dim D1() As Double
    Dim E1() As Double
    Dim Z2() As Double
    Dim Z3() As Double
    Dim V As Double
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' Copy D,E to D1, E1
    '
    ReDim D1(1# To N)
    i1_ = (0#) - (1#)
    For i_ = 1# To N Step 1
        D1(i_) = D(i_ + i1_)
    Next i_
    If N > 1# Then
        ReDim E1(1# To N - 1#)
        i1_ = (0#) - (1#)
        For i_ = 1# To N - 1# Step 1
            E1(i_) = E(i_ + i1_)
        Next i_
    End If
    
    '
    ' No eigen vectors
    '
    If ZNeeded = 0# Then
        Result = InternalBisectionEigenValues(D1, E1, N, 3#, 1#, 0#, 0#, I1 + 1#, I2 + 1#, -1#, w, M, NSPLIT, IBLOCK, ISPLIT, ErrorCode)
        If Not Result Then
            SMatrixTDEVDI = Result
            Exit Function
        End If
        If M <> I2 - I1 + 1# Then
            Result = False
            SMatrixTDEVDI = Result
            Exit Function
        End If
        ReDim D(0# To M - 1#)
        For i = 1# To M Step 1
            D(i - 1#) = w(i)
        Next i
        SMatrixTDEVDI = Result
        Exit Function
    End If
    
    '
    ' Eigen vectors are multiplied by Z
    '
    If ZNeeded = 1# Then
        
        '
        ' Find eigen pairs
        '
        Result = InternalBisectionEigenValues(D1, E1, N, 3#, 2#, 0#, 0#, I1 + 1#, I2 + 1#, -1#, w, M, NSPLIT, IBLOCK, ISPLIT, ErrorCode)
        If Not Result Then
            SMatrixTDEVDI = Result
            Exit Function
        End If
        If M <> I2 - I1 + 1# Then
            Result = False
            SMatrixTDEVDI = Result
            Exit Function
        End If
        Call InternalDSTEIN(N, D1, E1, M, w, IBLOCK, ISPLIT, Z2, IFAIL, CR)
        If CR <> 0# Then
            Result = False
            SMatrixTDEVDI = Result
            Exit Function
        End If
        
        '
        ' Sort eigen values and vectors
        '
        For i = 1# To M Step 1
            K = i
            For j = i To M Step 1
                If w(j) < w(K) Then
                    K = j
                End If
            Next j
            V = w(i)
            w(i) = w(K)
            w(K) = V
            For j = 1# To N Step 1
                V = Z2(j, i)
                Z2(j, i) = Z2(j, K)
                Z2(j, K) = V
            Next j
        Next i
        
        '
        ' Transform Z2 and overwrite Z
        '
        ReDim Z3(1# To M, 1# To N)
        For i = 1# To M Step 1
            For i_ = 1# To N Step 1
                Z3(i, i_) = Z2(i_, i)
            Next i_
        Next i
        For i = 1# To N Step 1
            For j = 1# To M Step 1
                i1_ = (1#) - (0#)
                V = 0#
                For i_ = 0# To N - 1# Step 1
                    V = V + z(i - 1#, i_) * Z3(j, i_ + i1_)
                Next i_
                Z2(i, j) = V
            Next j
        Next i
        ReDim z(0# To N - 1#, 0# To M - 1#)
        For i = 1# To M Step 1
            i1_ = (1#) - (0#)
            For i_ = 0# To N - 1# Step 1
                z(i_, i - 1#) = Z2(i_ + i1_, i)
            Next i_
        Next i
        
        '
        ' Store W
        '
        ReDim D(0# To M - 1#)
        For i = 1# To M Step 1
            D(i - 1#) = w(i)
        Next i
        SMatrixTDEVDI = Result
        Exit Function
    End If
    
    '
    ' Eigen vectors are stored in Z
    '
    If ZNeeded = 2# Then
        
        '
        ' Find eigen pairs
        '
        Result = InternalBisectionEigenValues(D1, E1, N, 3#, 2#, 0#, 0#, I1 + 1#, I2 + 1#, -1#, w, M, NSPLIT, IBLOCK, ISPLIT, ErrorCode)
        If Not Result Then
            SMatrixTDEVDI = Result
            Exit Function
        End If
        If M <> I2 - I1 + 1# Then
            Result = False
            SMatrixTDEVDI = Result
            Exit Function
        End If
        Call InternalDSTEIN(N, D1, E1, M, w, IBLOCK, ISPLIT, Z2, IFAIL, CR)
        If CR <> 0# Then
            Result = False
            SMatrixTDEVDI = Result
            Exit Function
        End If
        
        '
        ' Sort eigen values and vectors
        '
        For i = 1# To M Step 1
            K = i
            For j = i To M Step 1
                If w(j) < w(K) Then
                    K = j
                End If
            Next j
            V = w(i)
            w(i) = w(K)
            w(K) = V
            For j = 1# To N Step 1
                V = Z2(j, i)
                Z2(j, i) = Z2(j, K)
                Z2(j, K) = V
            Next j
        Next i
        
        '
        ' Store Z
        '
        ReDim z(0# To N - 1#, 0# To M - 1#)
        For i = 1# To M Step 1
            i1_ = (1#) - (0#)
            For i_ = 0# To N - 1# Step 1
                z(i_, i - 1#) = Z2(i_ + i1_, i)
            Next i_
        Next i
        
        '
        ' Store W
        '
        ReDim D(0# To M - 1#)
        For i = 1# To M Step 1
            D(i - 1#) = w(i)
        Next i
        SMatrixTDEVDI = Result
        Exit Function
    End If
    Result = False
    SMatrixTDEVDI = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Finding eigenvalues and eigenvectors of a general matrix
'
'The algorithm finds eigenvalues and eigenvectors of a general matrix by
'using the QR algorithm with multiple shifts. The algorithm can find
'eigenvalues and both left and right eigenvectors.
'
'The right eigenvector is a vector x such that A*x = w*x, and the left
'eigenvector is a vector y such that y'*A = w*y' (here y' implies a complex
'conjugate transposition of vector y).
'
'Input parameters:
'    A       -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
'    N       -   size of matrix A.
'    VNeeded -   flag controlling whether eigenvectors are needed or not.
'                If VNeeded is equal to:
'                 * 0, eigenvectors are not returned;
'                 * 1, right eigenvectors are returned;
'                 * 2, left eigenvectors are returned;
'                 * 3, both left and right eigenvectors are returned.
'
'Output parameters:
'    WR      -   real parts of eigenvalues.
'                Array whose index ranges within [0..N-1].
'    WR      -   imaginary parts of eigenvalues.
'                Array whose index ranges within [0..N-1].
'    VL, VR  -   arrays of left and right eigenvectors (if they are needed).
'                If WI[i]=0, the respective eigenvalue is a real number,
'                and it corresponds to the column number I of matrices VL/VR.
'                If WI[i]>0, we have a pair of complex conjugate numbers with
'                positive and negative imaginary parts:
'                    the first eigenvalue WR[i] + sqrt(-1)*WI[i];
'                    the second eigenvalue WR[i+1] + sqrt(-1)*WI[i+1];
'                    WI[i]>0
'                    WI[i+1] = -WI[i] < 0
'                In that case, the eigenvector  corresponding to the first
'                eigenvalue is located in i and i+1 columns of matrices
'                VL/VR (the column number i contains the real part, and the
'                column number i+1 contains the imaginary part), and the vector
'                corresponding to the second eigenvalue is a complex conjugate to
'                the first vector.
'                Arrays whose indexes range within [0..N-1, 0..N-1].
'
'Result:
'    True, if the algorithm has converged.
'    False, if the algorithm has not converged.
'
'Note 1:
'    Some users may ask the following question: what if WI[N-1]>0?
'    WI[N] must contain an eigenvalue which is complex conjugate to the
'    N-th eigenvalue, but the array has only size N?
'    The answer is as follows: such a situation cannot occur because the
'    algorithm finds a pairs of eigenvalues, therefore, if WI[i]>0, I is
'    strictly less than N-1.
'
'Note 2:
'    The algorithm performance depends on the value of the internal parameter
'    NS of the InternalSchurDecomposition subroutine which defines the number
'    of shifts in the QR algorithm (similarly to the block width in block-matrix
'    algorithms of linear algebra). If you require maximum performance
'    on your machine, it is recommended to adjust this parameter manually.
'
'
'See also the InternalTREVC subroutine.
'
'The algorithm is based on the LAPACK 3.0 library.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function RMatrixEVD(ByRef A_() As Double, _
         ByVal N As Long, _
         ByVal VNeeded As Long, _
         ByRef WR() As Double, _
         ByRef WI() As Double, _
         ByRef VL() As Double, _
         ByRef VR() As Double) As Boolean
    Dim Result As Boolean
    Dim A() As Double
    Dim A1() As Double
    Dim VL1() As Double
    Dim VR1() As Double
    Dim WR1() As Double
    Dim WI1() As Double
    Dim i As Long
    Dim i_ As Long
    Dim i1_ As Long
    A = A_
    ReDim A1(1# To N, 1# To N)
    For i = 1# To N Step 1
        i1_ = (0#) - (1#)
        For i_ = 1# To N Step 1
            A1(i, i_) = A(i - 1#, i_ + i1_)
        Next i_
    Next i
    Result = NonSymmetricEVD(A1, N, VNeeded, WR1, WI1, VL1, VR1)
    If Result Then
        ReDim WR(0# To N - 1#)
        ReDim WI(0# To N - 1#)
        i1_ = (1#) - (0#)
        For i_ = 0# To N - 1# Step 1
            WR(i_) = WR1(i_ + i1_)
        Next i_
        i1_ = (1#) - (0#)
        For i_ = 0# To N - 1# Step 1
            WI(i_) = WI1(i_ + i1_)
        Next i_
        If VNeeded = 2# Or VNeeded = 3# Then
            ReDim VL(0# To N - 1#, 0# To N - 1#)
            For i = 0# To N - 1# Step 1
                i1_ = (1#) - (0#)
                For i_ = 0# To N - 1# Step 1
                    VL(i, i_) = VL1(i + 1#, i_ + i1_)
                Next i_
            Next i
        End If
        If VNeeded = 1# Or VNeeded = 3# Then
            ReDim VR(0# To N - 1#, 0# To N - 1#)
            For i = 0# To N - 1# Step 1
                i1_ = (1#) - (0#)
                For i_ = 0# To N - 1# Step 1
                    VR(i, i_) = VR1(i + 1#, i_ + i1_)
                Next i_
            Next i
        End If
    End If
    RMatrixEVD = Result
End Function
Public Function InternalBisectionEigenValues(ByRef D_() As Double, _
         ByRef E_() As Double, _
         ByVal N As Long, _
         ByVal IRANGE As Long, _
         ByVal IORDER As Long, _
         ByVal VL As Double, _
         ByVal VU As Double, _
         ByVal IL As Long, _
         ByVal IU As Long, _
         ByVal ABSTOL As Double, _
         ByRef w() As Double, _
         ByRef M As Long, _
         ByRef NSPLIT As Long, _
         ByRef IBLOCK() As Long, _
         ByRef ISPLIT() As Long, _
         ByRef ErrorCode As Long) As Boolean
    Dim Result As Boolean
    Dim D() As Double
    Dim E() As Double
    Dim FUDGE As Double
    Dim RELFAC As Double
    Dim NCNVRG As Boolean
    Dim TOOFEW As Boolean
    Dim IB As Long
    Dim IBEGIN As Long
    Dim IDISCL As Long
    Dim IDISCU As Long
    Dim IE As Long
    Dim IEND As Long
    Dim IINFO As Long
    Dim IM As Long
    Dim IIN As Long
    Dim IOFF As Long
    Dim IOUT As Long
    Dim ITMAX As Long
    Dim IW As Long
    Dim IWOFF As Long
    Dim j As Long
    Dim ITMP1 As Long
    Dim JB As Long
    Dim JDISC As Long
    Dim JE As Long
    Dim NWL As Long
    Dim NWU As Long
    Dim ATOLI As Double
    Dim BNorm As Double
    Dim GL As Double
    Dim GU As Double
    Dim PIVMIN As Double
    Dim RTOLI As Double
    Dim SAFEMN As Double
    Dim TMP1 As Double
    Dim Tmp2 As Double
    Dim TNORM As Double
    Dim Ulp As Double
    Dim WKILL As Double
    Dim WL As Double
    Dim WLU As Double
    Dim WU As Double
    Dim WUL As Double
    Dim ScaleFactor As Double
    Dim T As Double
    Dim IDUMMA() As Long
    Dim WORK() As Double
    Dim IWORK() As Long
    Dim IA1S2() As Long
    Dim RA1S2() As Double
    Dim RA1S2X2() As Double
    Dim IA1S2X2() As Long
    Dim RA1SIIN() As Double
    Dim RA2SIIN() As Double
    Dim RA3SIIN() As Double
    Dim RA4SIIN() As Double
    Dim RA1SIINX2() As Double
    Dim IA1SIINX2() As Long
    Dim IWORKSPACE() As Long
    Dim RWORKSPACE() As Double
    Dim TmpI As Long
    D = D_
    E = E_
    
    '
    ' Quick return if possible
    '
    M = 0#
    If N = 0# Then
        Result = True
        InternalBisectionEigenValues = Result
        Exit Function
    End If
    
    '
    ' Get machine constants
    ' NB is the minimum vector length for vector bisection, or 0
    ' if only scalar is to be done.
    '
    FUDGE = 2#
    RELFAC = 2#
    SAFEMN = MinRealNumber
    Ulp = 2# * MachineEpsilon
    RTOLI = Ulp * RELFAC
    ReDim IDUMMA(1# To 1#)
    ReDim WORK(1# To 4# * N)
    ReDim IWORK(1# To 3# * N)
    ReDim w(1# To N)
    ReDim IBLOCK(1# To N)
    ReDim ISPLIT(1# To N)
    ReDim IA1S2(1# To 2#)
    ReDim RA1S2(1# To 2#)
    ReDim RA1S2X2(1# To 2#, 1# To 2#)
    ReDim IA1S2X2(1# To 2#, 1# To 2#)
    ReDim RA1SIIN(1# To N)
    ReDim RA2SIIN(1# To N)
    ReDim RA3SIIN(1# To N)
    ReDim RA4SIIN(1# To N)
    ReDim RA1SIINX2(1# To N, 1# To 2#)
    ReDim IA1SIINX2(1# To N, 1# To 2#)
    ReDim IWORKSPACE(1# To N)
    ReDim RWORKSPACE(1# To N)
    
    '
    ' Check for Errors
    '
    Result = False
    ErrorCode = 0#
    If IRANGE <= 0# Or IRANGE >= 4# Then
        ErrorCode = -4#
    End If
    If IORDER <= 0# Or IORDER >= 3# Then
        ErrorCode = -5#
    End If
    If N < 0# Then
        ErrorCode = -3#
    End If
    If IRANGE = 2# And VL >= VU Then
        ErrorCode = -6#
    End If
    If IRANGE = 3# And (IL < 1# Or IL > MaxInt(1#, N)) Then
        ErrorCode = -8#
    End If
    If IRANGE = 3# And (IU < MinInt(N, IL) Or IU > N) Then
        ErrorCode = -9#
    End If
    If ErrorCode <> 0# Then
        InternalBisectionEigenValues = Result
        Exit Function
    End If
    
    '
    ' Initialize error flags
    '
    NCNVRG = False
    TOOFEW = False
    
    '
    ' Simplifications:
    '
    If IRANGE = 3# And IL = 1# And IU = N Then
        IRANGE = 1#
    End If
    
    '
    ' Special Case when N=1
    '
    If N = 1# Then
        NSPLIT = 1#
        ISPLIT(1#) = 1#
        If IRANGE = 2# And (VL >= D(1#) Or VU < D(1#)) Then
            M = 0#
        Else
            w(1#) = D(1#)
            IBLOCK(1#) = 1#
            M = 1#
        End If
        Result = True
        InternalBisectionEigenValues = Result
        Exit Function
    End If
    
    '
    ' Scaling
    '
    T = Abs(D(N))
    For j = 1# To N - 1# Step 1
        T = MaxReal(T, Abs(D(j)))
        T = MaxReal(T, Abs(E(j)))
    Next j
    ScaleFactor = 1#
    If T <> 0# Then
        If T > Sqr(Sqr(MinRealNumber)) * Sqr(MaxRealNumber) Then
            ScaleFactor = T
        End If
        If T < Sqr(Sqr(MaxRealNumber)) * Sqr(MinRealNumber) Then
            ScaleFactor = T
        End If
        For j = 1# To N - 1# Step 1
            D(j) = D(j) / ScaleFactor
            E(j) = E(j) / ScaleFactor
        Next j
        D(N) = D(N) / ScaleFactor
    End If
    
    '
    ' Compute Splitting Points
    '
    NSPLIT = 1#
    WORK(N) = 0#
    PIVMIN = 1#
    For j = 2# To N Step 1
        TMP1 = Square(E(j - 1#))
        If Abs(D(j) * D(j - 1#)) * Square(Ulp) + SAFEMN > TMP1 Then
            ISPLIT(NSPLIT) = j - 1#
            NSPLIT = NSPLIT + 1#
            WORK(j - 1#) = 0#
        Else
            WORK(j - 1#) = TMP1
            PIVMIN = MaxReal(PIVMIN, TMP1)
        End If
    Next j
    ISPLIT(NSPLIT) = N
    PIVMIN = PIVMIN * SAFEMN
    
    '
    ' Compute Interval and ATOLI
    '
    If IRANGE = 3# Then
        
        '
        ' RANGE='I': Compute the interval containing eigenvalues
        '     IL through IU.
        '
        ' Compute Gershgorin interval for entire (split) matrix
        ' and use it as the initial interval
        '
        GU = D(1#)
        GL = D(1#)
        TMP1 = 0#
        For j = 1# To N - 1# Step 1
            Tmp2 = Sqr(WORK(j))
            GU = MaxReal(GU, D(j) + TMP1 + Tmp2)
            GL = MinReal(GL, D(j) - TMP1 - Tmp2)
            TMP1 = Tmp2
        Next j
        GU = MaxReal(GU, D(N) + TMP1)
        GL = MinReal(GL, D(N) - TMP1)
        TNORM = MaxReal(Abs(GL), Abs(GU))
        GL = GL - FUDGE * TNORM * Ulp * N - FUDGE * 2# * PIVMIN
        GU = GU + FUDGE * TNORM * Ulp * N + FUDGE * PIVMIN
        
        '
        ' Compute Iteration parameters
        '
        ITMAX = Ceil((log(TNORM + PIVMIN) - log(PIVMIN)) / log(2#)) + 2#
        If ABSTOL <= 0# Then
            ATOLI = Ulp * TNORM
        Else
            ATOLI = ABSTOL
        End If
        WORK(N + 1#) = GL
        WORK(N + 2#) = GL
        WORK(N + 3#) = GU
        WORK(N + 4#) = GU
        WORK(N + 5#) = GL
        WORK(N + 6#) = GU
        IWORK(1#) = -1#
        IWORK(2#) = -1#
        IWORK(3#) = N + 1#
        IWORK(4#) = N + 1#
        IWORK(5#) = IL - 1#
        IWORK(6#) = IU
        
        '
        ' Calling DLAEBZ
        '
        ' DLAEBZ( 3, ITMAX, N, 2, 2, NB, ATOLI, RTOLI, PIVMIN, D, E,
        '    WORK, IWORK( 5 ), WORK( N+1 ), WORK( N+5 ), IOUT,
        '    IWORK, W, IBLOCK, IINFO )
        '
        IA1S2(1#) = IWORK(5#)
        IA1S2(2#) = IWORK(6#)
        RA1S2(1#) = WORK(N + 5#)
        RA1S2(2#) = WORK(N + 6#)
        RA1S2X2(1#, 1#) = WORK(N + 1#)
        RA1S2X2(2#, 1#) = WORK(N + 2#)
        RA1S2X2(1#, 2#) = WORK(N + 3#)
        RA1S2X2(2#, 2#) = WORK(N + 4#)
        IA1S2X2(1#, 1#) = IWORK(1#)
        IA1S2X2(2#, 1#) = IWORK(2#)
        IA1S2X2(1#, 2#) = IWORK(3#)
        IA1S2X2(2#, 2#) = IWORK(4#)
        Call InternalDLAEBZ(3#, ITMAX, N, 2#, 2#, ATOLI, RTOLI, PIVMIN, D, E, WORK, IA1S2, RA1S2X2, RA1S2, IOUT, IA1S2X2, w, IBLOCK, IINFO)
        IWORK(5#) = IA1S2(1#)
        IWORK(6#) = IA1S2(2#)
        WORK(N + 5#) = RA1S2(1#)
        WORK(N + 6#) = RA1S2(2#)
        WORK(N + 1#) = RA1S2X2(1#, 1#)
        WORK(N + 2#) = RA1S2X2(2#, 1#)
        WORK(N + 3#) = RA1S2X2(1#, 2#)
        WORK(N + 4#) = RA1S2X2(2#, 2#)
        IWORK(1#) = IA1S2X2(1#, 1#)
        IWORK(2#) = IA1S2X2(2#, 1#)
        IWORK(3#) = IA1S2X2(1#, 2#)
        IWORK(4#) = IA1S2X2(2#, 2#)
        If IWORK(6#) = IU Then
            WL = WORK(N + 1#)
            WLU = WORK(N + 3#)
            NWL = IWORK(1#)
            WU = WORK(N + 4#)
            WUL = WORK(N + 2#)
            NWU = IWORK(4#)
        Else
            WL = WORK(N + 2#)
            WLU = WORK(N + 4#)
            NWL = IWORK(2#)
            WU = WORK(N + 3#)
            WUL = WORK(N + 1#)
            NWU = IWORK(3#)
        End If
        If NWL < 0# Or NWL >= N Or NWU < 1# Or NWU > N Then
            ErrorCode = 4#
            Result = False
            InternalBisectionEigenValues = Result
            Exit Function
        End If
    Else
        
        '
        ' RANGE='A' or 'V' -- Set ATOLI
        '
        TNORM = MaxReal(Abs(D(1#)) + Abs(E(1#)), Abs(D(N)) + Abs(E(N - 1#)))
        For j = 2# To N - 1# Step 1
            TNORM = MaxReal(TNORM, Abs(D(j)) + Abs(E(j - 1#)) + Abs(E(j)))
        Next j
        If ABSTOL <= 0# Then
            ATOLI = Ulp * TNORM
        Else
            ATOLI = ABSTOL
        End If
        If IRANGE = 2# Then
            WL = VL
            WU = VU
        Else
            WL = 0#
            WU = 0#
        End If
    End If
    
    '
    ' Find Eigenvalues -- Loop Over Blocks and recompute NWL and NWU.
    ' NWL accumulates the number of eigenvalues .le. WL,
    ' NWU accumulates the number of eigenvalues .le. WU
    '
    M = 0#
    IEND = 0#
    ErrorCode = 0#
    NWL = 0#
    NWU = 0#
    For JB = 1# To NSPLIT Step 1
        IOFF = IEND
        IBEGIN = IOFF + 1#
        IEND = ISPLIT(JB)
        IIN = IEND - IOFF
        If IIN = 1# Then
            
            '
            ' Special Case -- IIN=1
            '
            If IRANGE = 1# Or WL >= D(IBEGIN) - PIVMIN Then
                NWL = NWL + 1#
            End If
            If IRANGE = 1# Or WU >= D(IBEGIN) - PIVMIN Then
                NWU = NWU + 1#
            End If
            If IRANGE = 1# Or WL < D(IBEGIN) - PIVMIN And WU >= D(IBEGIN) - PIVMIN Then
                M = M + 1#
                w(M) = D(IBEGIN)
                IBLOCK(M) = JB
            End If
        Else
            
            '
            ' General Case -- IIN > 1
            '
            ' Compute Gershgorin Interval
            ' and use it as the initial interval
            '
            GU = D(IBEGIN)
            GL = D(IBEGIN)
            TMP1 = 0#
            For j = IBEGIN To IEND - 1# Step 1
                Tmp2 = Abs(E(j))
                GU = MaxReal(GU, D(j) + TMP1 + Tmp2)
                GL = MinReal(GL, D(j) - TMP1 - Tmp2)
                TMP1 = Tmp2
            Next j
            GU = MaxReal(GU, D(IEND) + TMP1)
            GL = MinReal(GL, D(IEND) - TMP1)
            BNorm = MaxReal(Abs(GL), Abs(GU))
            GL = GL - FUDGE * BNorm * Ulp * IIN - FUDGE * PIVMIN
            GU = GU + FUDGE * BNorm * Ulp * IIN + FUDGE * PIVMIN
            
            '
            ' Compute ATOLI for the current submatrix
            '
            If ABSTOL <= 0# Then
                ATOLI = Ulp * MaxReal(Abs(GL), Abs(GU))
            Else
                ATOLI = ABSTOL
            End If
            If IRANGE > 1# Then
                If GU < WL Then
                    NWL = NWL + IIN
                    NWU = NWU + IIN
                    GoTo Cont_6
                End If
                GL = MaxReal(GL, WL)
                GU = MinReal(GU, WU)
                If GL >= GU Then
                    GoTo Cont_6
                End If
            End If
            
            '
            ' Set Up Initial Interval
            '
            WORK(N + 1#) = GL
            WORK(N + IIN + 1#) = GU
            
            '
            ' Calling DLAEBZ
            '
            ' CALL DLAEBZ( 1, 0, IN, IN, 1, NB, ATOLI, RTOLI, PIVMIN,
            '    D( IBEGIN ), E( IBEGIN ), WORK( IBEGIN ),
            '    IDUMMA, WORK( N+1 ), WORK( N+2*IN+1 ), IM,
            '    IWORK, W( M+1 ), IBLOCK( M+1 ), IINFO )
            '
            For TmpI = 1# To IIN Step 1
                RA1SIIN(TmpI) = D(IBEGIN - 1# + TmpI)
                If IBEGIN - 1# + TmpI < N Then
                    RA2SIIN(TmpI) = E(IBEGIN - 1# + TmpI)
                End If
                RA3SIIN(TmpI) = WORK(IBEGIN - 1# + TmpI)
                RA1SIINX2(TmpI, 1#) = WORK(N + TmpI)
                RA1SIINX2(TmpI, 2#) = WORK(N + TmpI + IIN)
                RA4SIIN(TmpI) = WORK(N + 2# * IIN + TmpI)
                RWORKSPACE(TmpI) = w(M + TmpI)
                IWORKSPACE(TmpI) = IBLOCK(M + TmpI)
                IA1SIINX2(TmpI, 1#) = IWORK(TmpI)
                IA1SIINX2(TmpI, 2#) = IWORK(TmpI + IIN)
            Next TmpI
            Call InternalDLAEBZ(1#, 0#, IIN, IIN, 1#, ATOLI, RTOLI, PIVMIN, RA1SIIN, RA2SIIN, RA3SIIN, IDUMMA, RA1SIINX2, RA4SIIN, IM, IA1SIINX2, RWORKSPACE, IWORKSPACE, IINFO)
            For TmpI = 1# To IIN Step 1
                WORK(N + TmpI) = RA1SIINX2(TmpI, 1#)
                WORK(N + TmpI + IIN) = RA1SIINX2(TmpI, 2#)
                WORK(N + 2# * IIN + TmpI) = RA4SIIN(TmpI)
                w(M + TmpI) = RWORKSPACE(TmpI)
                IBLOCK(M + TmpI) = IWORKSPACE(TmpI)
                IWORK(TmpI) = IA1SIINX2(TmpI, 1#)
                IWORK(TmpI + IIN) = IA1SIINX2(TmpI, 2#)
            Next TmpI
            NWL = NWL + IWORK(1#)
            NWU = NWU + IWORK(IIN + 1#)
            IWOFF = M - IWORK(1#)
            
            '
            ' Compute Eigenvalues
            '
            ITMAX = Ceil((log(GU - GL + PIVMIN) - log(PIVMIN)) / log(2#)) + 2#
            
            '
            ' Calling DLAEBZ
            '
            'CALL DLAEBZ( 2, ITMAX, IN, IN, 1, NB, ATOLI, RTOLI, PIVMIN,
            '    D( IBEGIN ), E( IBEGIN ), WORK( IBEGIN ),
            '    IDUMMA, WORK( N+1 ), WORK( N+2*IN+1 ), IOUT,
            '    IWORK, W( M+1 ), IBLOCK( M+1 ), IINFO )
            '
            For TmpI = 1# To IIN Step 1
                RA1SIIN(TmpI) = D(IBEGIN - 1# + TmpI)
                If IBEGIN - 1# + TmpI < N Then
                    RA2SIIN(TmpI) = E(IBEGIN - 1# + TmpI)
                End If
                RA3SIIN(TmpI) = WORK(IBEGIN - 1# + TmpI)
                RA1SIINX2(TmpI, 1#) = WORK(N + TmpI)
                RA1SIINX2(TmpI, 2#) = WORK(N + TmpI + IIN)
                RA4SIIN(TmpI) = WORK(N + 2# * IIN + TmpI)
                RWORKSPACE(TmpI) = w(M + TmpI)
                IWORKSPACE(TmpI) = IBLOCK(M + TmpI)
                IA1SIINX2(TmpI, 1#) = IWORK(TmpI)
                IA1SIINX2(TmpI, 2#) = IWORK(TmpI + IIN)
            Next TmpI
            Call InternalDLAEBZ(2#, ITMAX, IIN, IIN, 1#, ATOLI, RTOLI, PIVMIN, RA1SIIN, RA2SIIN, RA3SIIN, IDUMMA, RA1SIINX2, RA4SIIN, IOUT, IA1SIINX2, RWORKSPACE, IWORKSPACE, IINFO)
            For TmpI = 1# To IIN Step 1
                WORK(N + TmpI) = RA1SIINX2(TmpI, 1#)
                WORK(N + TmpI + IIN) = RA1SIINX2(TmpI, 2#)
                WORK(N + 2# * IIN + TmpI) = RA4SIIN(TmpI)
                w(M + TmpI) = RWORKSPACE(TmpI)
                IBLOCK(M + TmpI) = IWORKSPACE(TmpI)
                IWORK(TmpI) = IA1SIINX2(TmpI, 1#)
                IWORK(TmpI + IIN) = IA1SIINX2(TmpI, 2#)
            Next TmpI
            
            '
            ' Copy Eigenvalues Into W and IBLOCK
            ' Use -JB for block number for unconverged eigenvalues.
            '
            For j = 1# To IOUT Step 1
                TMP1 = 0.5 * (WORK(j + N) + WORK(j + IIN + N))
                
                '
                ' Flag non-convergence.
                '
                If j > IOUT - IINFO Then
                    NCNVRG = True
                    IB = -JB
                Else
                    IB = JB
                End If
                For JE = IWORK(j) + 1# + IWOFF To IWORK(j + IIN) + IWOFF Step 1
                    w(JE) = TMP1
                    IBLOCK(JE) = IB
                Next JE
            Next j
            M = M + IM
        End If
Cont_6:
    Next JB
    
    '
    ' If RANGE='I', then (WL,WU) contains eigenvalues NWL+1,...,NWU
    ' If NWL+1 < IL or NWU > IU, discard extra eigenvalues.
    '
    If IRANGE = 3# Then
        IM = 0#
        IDISCL = IL - 1# - NWL
        IDISCU = NWU - IU
        If IDISCL > 0# Or IDISCU > 0# Then
            For JE = 1# To M Step 1
                If w(JE) <= WLU And IDISCL > 0# Then
                    IDISCL = IDISCL - 1#
                Else
                    If w(JE) >= WUL And IDISCU > 0# Then
                        IDISCU = IDISCU - 1#
                    Else
                        IM = IM + 1#
                        w(IM) = w(JE)
                        IBLOCK(IM) = IBLOCK(JE)
                    End If
                End If
            Next JE
            M = IM
        End If
        If IDISCL > 0# Or IDISCU > 0# Then
            
            '
            ' Code to deal with effects of bad arithmetic:
            ' Some low eigenvalues to be discarded are not in (WL,WLU],
            ' or high eigenvalues to be discarded are not in (WUL,WU]
            ' so just kill off the smallest IDISCL/largest IDISCU
            ' eigenvalues, by simply finding the smallest/largest
            ' eigenvalue(s).
            '
            ' (If N(w) is monotone non-decreasing, this should never
            '  happen.)
            '
            If IDISCL > 0# Then
                WKILL = WU
                For JDISC = 1# To IDISCL Step 1
                    IW = 0#
                    For JE = 1# To M Step 1
                        If IBLOCK(JE) <> 0# And (w(JE) < WKILL Or IW = 0#) Then
                            IW = JE
                            WKILL = w(JE)
                        End If
                    Next JE
                    IBLOCK(IW) = 0#
                Next JDISC
            End If
            If IDISCU > 0# Then
                WKILL = WL
                For JDISC = 1# To IDISCU Step 1
                    IW = 0#
                    For JE = 1# To M Step 1
                        If IBLOCK(JE) <> 0# And (w(JE) > WKILL Or IW = 0#) Then
                            IW = JE
                            WKILL = w(JE)
                        End If
                    Next JE
                    IBLOCK(IW) = 0#
                Next JDISC
            End If
            IM = 0#
            For JE = 1# To M Step 1
                If IBLOCK(JE) <> 0# Then
                    IM = IM + 1#
                    w(IM) = w(JE)
                    IBLOCK(IM) = IBLOCK(JE)
                End If
            Next JE
            M = IM
        End If
        If IDISCL < 0# Or IDISCU < 0# Then
            TOOFEW = True
        End If
    End If
    
    '
    ' If ORDER='B', do nothing -- the eigenvalues are already sorted
    '    by block.
    ' If ORDER='E', sort the eigenvalues from smallest to largest
    '
    If IORDER = 1# And NSPLIT > 1# Then
        For JE = 1# To M - 1# Step 1
            IE = 0#
            TMP1 = w(JE)
            For j = JE + 1# To M Step 1
                If w(j) < TMP1 Then
                    IE = j
                    TMP1 = w(j)
                End If
            Next j
            If IE <> 0# Then
                ITMP1 = IBLOCK(IE)
                w(IE) = w(JE)
                IBLOCK(IE) = IBLOCK(JE)
                w(JE) = TMP1
                IBLOCK(JE) = ITMP1
            End If
        Next JE
    End If
    For j = 1# To M Step 1
        w(j) = w(j) * ScaleFactor
    Next j
    ErrorCode = 0#
    If NCNVRG Then
        ErrorCode = ErrorCode + 1#
    End If
    If TOOFEW Then
        ErrorCode = ErrorCode + 2#
    End If
    Result = ErrorCode = 0#
    InternalBisectionEigenValues = Result
End Function
Public Sub InternalDSTEIN(ByRef N As Long, _
         ByRef D() As Double, _
         ByRef E_() As Double, _
         ByRef M As Long, _
         ByRef W_() As Double, _
         ByRef IBLOCK() As Long, _
         ByRef ISPLIT() As Long, _
         ByRef z() As Double, _
         ByRef IFAIL() As Long, _
         ByRef Info As Long)
    Dim E() As Double
    Dim w() As Double
    Dim MaxIts As Long
    Dim EXTRA As Long
    Dim b1 As Long
    Dim BLKSIZ As Long
    Dim BN As Long
    Dim GPIND As Long
    Dim i As Long
    Dim IINFO As Long
    Dim ITS As Long
    Dim j As Long
    Dim J1 As Long
    Dim JBLK As Long
    Dim JMax As Long
    Dim NBLK As Long
    Dim NRMCHK As Long
    Dim DTPCRT As Double
    Dim Eps As Double
    Dim EPS1 As Double
    Dim Nrm As Double
    Dim ONENRM As Double
    Dim ORTOL As Double
    Dim PERTOL As Double
    Dim SCL As Double
    Dim SEP As Double
    Dim TOL As Double
    Dim XJ As Double
    Dim XJM As Double
    Dim ZTR As Double
    Dim WORK1() As Double
    Dim WORK2() As Double
    Dim WORK3() As Double
    Dim WORK4() As Double
    Dim WORK5() As Double
    Dim IWORK() As Long
    Dim TmpCriterion As Boolean
    Dim TI As Long
    Dim I1 As Long
    Dim I2 As Long
    Dim V As Double
    Dim i_ As Long
    Dim i1_ As Long
    E = E_
    w = W_
    MaxIts = 5#
    EXTRA = 2#
    ReDim WORK1(1# To MaxInt(N, 1#))
    ReDim WORK2(1# To MaxInt(N - 1#, 1#))
    ReDim WORK3(1# To MaxInt(N, 1#))
    ReDim WORK4(1# To MaxInt(N, 1#))
    ReDim WORK5(1# To MaxInt(N, 1#))
    ReDim IWORK(1# To MaxInt(N, 1#))
    ReDim IFAIL(1# To MaxInt(M, 1#))
    ReDim z(1# To MaxInt(N, 1#), 1# To MaxInt(M, 1#))
    
    '
    ' Test the input parameters.
    '
    Info = 0#
    For i = 1# To M Step 1
        IFAIL(i) = 0#
    Next i
    If N < 0# Then
        Info = -1#
        Exit Sub
    End If
    If M < 0# Or M > N Then
        Info = -4#
        Exit Sub
    End If
    For j = 2# To M Step 1
        If IBLOCK(j) < IBLOCK(j - 1#) Then
            Info = -6#
            Exit For
        End If
        If IBLOCK(j) = IBLOCK(j - 1#) And w(j) < w(j - 1#) Then
            Info = -5#
            Exit For
        End If
    Next j
    If Info <> 0# Then
        Exit Sub
    End If
    
    '
    ' Quick return if possible
    '
    If N = 0# Or M = 0# Then
        Exit Sub
    End If
    If N = 1# Then
        z(1#, 1#) = 1#
        Exit Sub
    End If
    
    '
    ' Some preparations
    '
    TI = N - 1#
    For i_ = 1# To TI Step 1
        WORK1(i_) = E(i_)
    Next i_
    ReDim E(1# To N)
    For i_ = 1# To TI Step 1
        E(i_) = WORK1(i_)
    Next i_
    For i_ = 1# To M Step 1
        WORK1(i_) = w(i_)
    Next i_
    ReDim w(1# To N)
    For i_ = 1# To M Step 1
        w(i_) = WORK1(i_)
    Next i_
    
    '
    ' Get machine constants.
    '
    Eps = MachineEpsilon
    
    '
    ' Compute eigenvectors of matrix blocks.
    '
    J1 = 1#
    For NBLK = 1# To IBLOCK(M) Step 1
        
        '
        ' Find starting and ending indices of block nblk.
        '
        If NBLK = 1# Then
            b1 = 1#
        Else
            b1 = ISPLIT(NBLK - 1#) + 1#
        End If
        BN = ISPLIT(NBLK)
        BLKSIZ = BN - b1 + 1#
        If BLKSIZ <> 1# Then
            
            '
            ' Compute reorthogonalization criterion and stopping criterion.
            '
            GPIND = b1
            ONENRM = Abs(D(b1)) + Abs(E(b1))
            ONENRM = MaxReal(ONENRM, Abs(D(BN)) + Abs(E(BN - 1#)))
            For i = b1 + 1# To BN - 1# Step 1
                ONENRM = MaxReal(ONENRM, Abs(D(i)) + Abs(E(i - 1#)) + Abs(E(i)))
            Next i
            ORTOL = 0.001 * ONENRM
            DTPCRT = Sqr(0.1 / BLKSIZ)
        End If
        
        '
        ' Loop through eigenvalues of block nblk.
        '
        JBLK = 0#
        For j = J1 To M Step 1
            If IBLOCK(j) <> NBLK Then
                J1 = j
                Exit For
            End If
            JBLK = JBLK + 1#
            XJ = w(j)
            If BLKSIZ = 1# Then
                
                '
                ' Skip all the work if the block size is one.
                '
                WORK1(1#) = 1#
            Else
                
                '
                ' If eigenvalues j and j-1 are too close, add a relatively
                ' small perturbation.
                '
                If JBLK > 1# Then
                    EPS1 = Abs(Eps * XJ)
                    PERTOL = 10# * EPS1
                    SEP = XJ - XJM
                    If SEP < PERTOL Then
                        XJ = XJM + PERTOL
                    End If
                End If
                ITS = 0#
                NRMCHK = 0#
                
                '
                ' Get random starting vector.
                '
                For TI = 1# To BLKSIZ Step 1
                    WORK1(TI) = 2# * Rnd() - 1#
                Next TI
                
                '
                ' Copy the matrix T so it won't be destroyed in factorization.
                '
                For TI = 1# To BLKSIZ - 1# Step 1
                    WORK2(TI) = E(b1 + TI - 1#)
                    WORK3(TI) = E(b1 + TI - 1#)
                    WORK4(TI) = D(b1 + TI - 1#)
                Next TI
                WORK4(BLKSIZ) = D(b1 + BLKSIZ - 1#)
                
                '
                ' Compute LU factors with partial pivoting  ( PT = LU )
                '
                TOL = 0#
                Call TDINInternalDLAGTF(BLKSIZ, WORK4, XJ, WORK2, WORK3, TOL, WORK5, IWORK, IINFO)
                
                '
                ' Update iteration count.
                '
                Do
                    ITS = ITS + 1#
                    If ITS > MaxIts Then
                        
                        '
                        ' If stopping criterion was not satisfied, update info and
                        ' store eigenvector number in array ifail.
                        '
                        Info = Info + 1#
                        IFAIL(Info) = j
                        Exit Do
                    End If
                    
                    '
                    ' Normalize and scale the righthand side vector Pb.
                    '
                    V = 0#
                    For TI = 1# To BLKSIZ Step 1
                        V = V + Abs(WORK1(TI))
                    Next TI
                    SCL = BLKSIZ * ONENRM * MaxReal(Eps, Abs(WORK4(BLKSIZ))) / V
                    For i_ = 1# To BLKSIZ Step 1
                        WORK1(i_) = SCL * WORK1(i_)
                    Next i_
                    
                    '
                    ' Solve the system LU = Pb.
                    '
                    Call TDINInternalDLAGTS(BLKSIZ, WORK4, WORK2, WORK3, WORK5, IWORK, WORK1, TOL, IINFO)
                    
                    '
                    ' Reorthogonalize by modified Gram-Schmidt if eigenvalues are
                    ' close enough.
                    '
                    If JBLK <> 1# Then
                        If Abs(XJ - XJM) > ORTOL Then
                            GPIND = j
                        End If
                        If GPIND <> j Then
                            For i = GPIND To j - 1# Step 1
                                I1 = b1
                                I2 = b1 + BLKSIZ - 1#
                                i1_ = (I1) - (1#)
                                ZTR = 0#
                                For i_ = 1# To BLKSIZ Step 1
                                    ZTR = ZTR + WORK1(i_) * z(i_ + i1_, i)
                                Next i_
                                i1_ = (I1) - (1#)
                                For i_ = 1# To BLKSIZ Step 1
                                    WORK1(i_) = WORK1(i_) - ZTR * z(i_ + i1_, i)
                                Next i_
                            Next i
                        End If
                    End If
                    
                    '
                    ' Check the infinity norm of the iterate.
                    '
                    JMax = VectorIdxAbsMax(WORK1, 1#, BLKSIZ)
                    Nrm = Abs(WORK1(JMax))
                    
                    '
                    ' Continue for additional iterations after norm reaches
                    ' stopping criterion.
                    '
                    TmpCriterion = False
                    If Nrm < DTPCRT Then
                        TmpCriterion = True
                    Else
                        NRMCHK = NRMCHK + 1#
                        If NRMCHK < EXTRA + 1# Then
                            TmpCriterion = True
                        End If
                    End If
                Loop Until Not TmpCriterion
                
                '
                ' Accept iterate as jth eigenvector.
                '
                SCL = 1# / VectorNorm2(WORK1, 1#, BLKSIZ)
                JMax = VectorIdxAbsMax(WORK1, 1#, BLKSIZ)
                If WORK1(JMax) < 0# Then
                    SCL = -SCL
                End If
                For i_ = 1# To BLKSIZ Step 1
                    WORK1(i_) = SCL * WORK1(i_)
                Next i_
            End If
            For i = 1# To N Step 1
                z(i, j) = 0#
            Next i
            For i = 1# To BLKSIZ Step 1
                z(b1 + i - 1#, j) = WORK1(i)
            Next i
            
            '
            ' Save the shift to check eigenvalue spacing at next
            ' iteration.
            '
            XJM = XJ
        Next j
    Next NBLK
End Sub
Private Function TridiagonalEVD(ByRef D() As Double, _
         ByRef E_() As Double, _
         ByVal N As Long, _
         ByVal ZNeeded As Long, _
         ByRef z() As Double) As Boolean
    Dim Result As Boolean
    Dim E() As Double
    Dim MAXIT As Long
    Dim i As Long
    Dim II As Long
    Dim ISCALE As Long
    Dim j As Long
    Dim JTOT As Long
    Dim K As Long
    Dim T As Long
    Dim L As Long
    Dim L1 As Long
    Dim LEND As Long
    Dim LENDM1 As Long
    Dim LENDP1 As Long
    Dim LENDSV As Long
    Dim LM1 As Long
    Dim LSV As Long
    Dim M As Long
    Dim MM As Long
    Dim MM1 As Long
    Dim NM1 As Long
    Dim NMAXIT As Long
    Dim TmpInt As Long
    Dim ANORM As Double
    Dim B As Double
    Dim C As Double
    Dim Eps As Double
    Dim EPS2 As Double
    Dim F As Double
    Dim G As Double
    Dim p As Double
    Dim R As Double
    Dim RT1 As Double
    Dim RT2 As Double
    Dim S As Double
    Dim SAFMAX As Double
    Dim SAFMIN As Double
    Dim SSFMAX As Double
    Dim SSFMIN As Double
    Dim TST As Double
    Dim Tmp As Double
    Dim WORK1() As Double
    Dim WORK2() As Double
    Dim WORKC() As Double
    Dim WORKS() As Double
    Dim WTemp() As Double
    Dim GotoFlag As Boolean
    Dim ZRows As Long
    Dim WasTranspose As Boolean
    Dim i_ As Long
    E = E_
    
    '
    ' Quick return if possible
    '
    If ZNeeded < 0# Or ZNeeded > 3# Then
        Result = False
        TridiagonalEVD = Result
        Exit Function
    End If
    Result = True
    If N = 0# Then
        TridiagonalEVD = Result
        Exit Function
    End If
    If N = 1# Then
        If ZNeeded = 2# Or ZNeeded = 3# Then
            ReDim z(1# To 1#, 1# To 1#)
            z(1#, 1#) = 1#
        End If
        TridiagonalEVD = Result
        Exit Function
    End If
    MAXIT = 30#
    
    '
    ' Initialize arrays
    '
    ReDim WTemp(1# To N)
    ReDim WORK1(1# To N - 1#)
    ReDim WORK2(1# To N - 1#)
    ReDim WORKC(1# To N)
    ReDim WORKS(1# To N)
    
    '
    ' Determine the unit roundoff and over/underflow thresholds.
    '
    Eps = MachineEpsilon
    EPS2 = Square(Eps)
    SAFMIN = MinRealNumber
    SAFMAX = MaxRealNumber
    SSFMAX = Sqr(SAFMAX) / 3#
    SSFMIN = Sqr(SAFMIN) / EPS2
    
    '
    ' Prepare Z
    '
    ' Here we are using transposition to get rid of column operations
    '
    '
    WasTranspose = False
    If ZNeeded = 0# Then
        ZRows = 0#
    End If
    If ZNeeded = 1# Then
        ZRows = N
    End If
    If ZNeeded = 2# Then
        ZRows = N
    End If
    If ZNeeded = 3# Then
        ZRows = 1#
    End If
    If ZNeeded = 1# Then
        WasTranspose = True
        Call InplaceTranspose(z, 1#, N, 1#, N, WTemp)
    End If
    If ZNeeded = 2# Then
        WasTranspose = True
        ReDim z(1# To N, 1# To N)
        For i = 1# To N Step 1
            For j = 1# To N Step 1
                If i = j Then
                    z(i, j) = 1#
                Else
                    z(i, j) = 0#
                End If
            Next j
        Next i
    End If
    If ZNeeded = 3# Then
        WasTranspose = False
        ReDim z(1# To 1#, 1# To N)
        For j = 1# To N Step 1
            If j = 1# Then
                z(1#, j) = 1#
            Else
                z(1#, j) = 0#
            End If
        Next j
    End If
    NMAXIT = N * MAXIT
    JTOT = 0#
    
    '
    ' Determine where the matrix splits and choose QL or QR iteration
    ' for each block, according to whether top or bottom diagonal
    ' element is smaller.
    '
    L1 = 1#
    NM1 = N - 1#
    Do While True
        If L1 > N Then
            Exit Do
        End If
        If L1 > 1# Then
            E(L1 - 1#) = 0#
        End If
        GotoFlag = False
        If L1 <= NM1 Then
            For M = L1 To NM1 Step 1
                TST = Abs(E(M))
                If TST = 0# Then
                    GotoFlag = True
                    Exit For
                End If
                If TST <= Sqr(Abs(D(M))) * Sqr(Abs(D(M + 1#))) * Eps Then
                    E(M) = 0#
                    GotoFlag = True
                    Exit For
                End If
            Next M
        End If
        If Not GotoFlag Then
            M = N
        End If
        
        '
        ' label 30:
        '
        L = L1
        LSV = L
        LEND = M
        LENDSV = LEND
        L1 = M + 1#
        If LEND = L Then
            GoTo Cont_4
        End If
        
        '
        ' Scale submatrix in rows and columns L to LEND
        '
        If L = LEND Then
            ANORM = Abs(D(L))
        Else
            ANORM = MaxReal(Abs(D(L)) + Abs(E(L)), Abs(E(LEND - 1#)) + Abs(D(LEND)))
            For i = L + 1# To LEND - 1# Step 1
                ANORM = MaxReal(ANORM, Abs(D(i)) + Abs(E(i)) + Abs(E(i - 1#)))
            Next i
        End If
        ISCALE = 0#
        If ANORM = 0# Then
            GoTo Cont_4
        End If
        If ANORM > SSFMAX Then
            ISCALE = 1#
            Tmp = SSFMAX / ANORM
            TmpInt = LEND - 1#
            For i_ = L To LEND Step 1
                D(i_) = Tmp * D(i_)
            Next i_
            For i_ = L To TmpInt Step 1
                E(i_) = Tmp * E(i_)
            Next i_
        End If
        If ANORM < SSFMIN Then
            ISCALE = 2#
            Tmp = SSFMIN / ANORM
            TmpInt = LEND - 1#
            For i_ = L To LEND Step 1
                D(i_) = Tmp * D(i_)
            Next i_
            For i_ = L To TmpInt Step 1
                E(i_) = Tmp * E(i_)
            Next i_
        End If
        
        '
        ' Choose between QL and QR iteration
        '
        If Abs(D(LEND)) < Abs(D(L)) Then
            LEND = LSV
            L = LENDSV
        End If
        If LEND > L Then
            
            '
            ' QL Iteration
            '
            ' Look for small subdiagonal element.
            '
            Do While True
                GotoFlag = False
                If L <> LEND Then
                    LENDM1 = LEND - 1#
                    For M = L To LENDM1 Step 1
                        TST = Square(Abs(E(M)))
                        If TST <= EPS2 * Abs(D(M)) * Abs(D(M + 1#)) + SAFMIN Then
                            GotoFlag = True
                            Exit For
                        End If
                    Next M
                End If
                If Not GotoFlag Then
                    M = LEND
                End If
                If M < LEND Then
                    E(M) = 0#
                End If
                p = D(L)
                If M <> L Then
                    
                    '
                    ' If remaining matrix is 2-by-2, use DLAE2 or SLAEV2
                    ' to compute its eigensystem.
                    '
                    If M = L + 1# Then
                        If ZNeeded > 0# Then
                            Call TdEVDEV2(D(L), E(L), D(L + 1#), RT1, RT2, C, S)
                            WORK1(L) = C
                            WORK2(L) = S
                            WORKC(1#) = WORK1(L)
                            WORKS(1#) = WORK2(L)
                            If Not WasTranspose Then
                                Call ApplyRotationsFromTheRight(False, 1#, ZRows, L, L + 1#, WORKC, WORKS, z, WTemp)
                            Else
                                Call ApplyRotationsFromTheLeft(False, L, L + 1#, 1#, ZRows, WORKC, WORKS, z, WTemp)
                            End If
                        Else
                            Call TdEVDE2(D(L), E(L), D(L + 1#), RT1, RT2)
                        End If
                        D(L) = RT1
                        D(L + 1#) = RT2
                        E(L) = 0#
                        L = L + 2#
                        If L <= LEND Then
                            GoTo Cont_7
                        End If
                        
                        '
                        ' GOTO 140
                        '
                        Exit Do
                    End If
                    If JTOT = NMAXIT Then
                        
                        '
                        ' GOTO 140
                        '
                        Exit Do
                    End If
                    JTOT = JTOT + 1#
                    
                    '
                    ' Form shift.
                    '
                    G = (D(L + 1#) - p) / (2# * E(L))
                    R = TdEVDPythag(G, 1#)
                    G = D(M) - p + E(L) / (G + TdEVDExtSign(R, G))
                    S = 1#
                    C = 1#
                    p = 0#
                    
                    '
                    ' Inner loop
                    '
                    MM1 = M - 1#
                    For i = MM1 To L Step -1
                        F = S * E(i)
                        B = C * E(i)
                        Call GenerateRotation(G, F, C, S, R)
                        If i <> M - 1# Then
                            E(i + 1#) = R
                        End If
                        G = D(i + 1#) - p
                        R = (D(i) - G) * S + 2# * C * B
                        p = S * R
                        D(i + 1#) = G + p
                        G = C * R - B
                        
                        '
                        ' If eigenvectors are desired, then save rotations.
                        '
                        If ZNeeded > 0# Then
                            WORK1(i) = C
                            WORK2(i) = -S
                        End If
                    Next i
                    
                    '
                    ' If eigenvectors are desired, then apply saved rotations.
                    '
                    If ZNeeded > 0# Then
                        For i = L To M - 1# Step 1
                            WORKC(i - L + 1#) = WORK1(i)
                            WORKS(i - L + 1#) = WORK2(i)
                        Next i
                        If Not WasTranspose Then
                            Call ApplyRotationsFromTheRight(False, 1#, ZRows, L, M, WORKC, WORKS, z, WTemp)
                        Else
                            Call ApplyRotationsFromTheLeft(False, L, M, 1#, ZRows, WORKC, WORKS, z, WTemp)
                        End If
                    End If
                    D(L) = D(L) - p
                    E(L) = G
                    GoTo Cont_7
                End If
                
                '
                ' Eigenvalue found.
                '
                D(L) = p
                L = L + 1#
                If L <= LEND Then
                    GoTo Cont_7
                End If
                Exit Do
Cont_7:
            Loop
        Else
            
            '
            ' QR Iteration
            '
            ' Look for small superdiagonal element.
            '
            Do While True
                GotoFlag = False
                If L <> LEND Then
                    LENDP1 = LEND + 1#
                    For M = L To LENDP1 Step -1
                        TST = Square(Abs(E(M - 1#)))
                        If TST <= EPS2 * Abs(D(M)) * Abs(D(M - 1#)) + SAFMIN Then
                            GotoFlag = True
                            Exit For
                        End If
                    Next M
                End If
                If Not GotoFlag Then
                    M = LEND
                End If
                If M > LEND Then
                    E(M - 1#) = 0#
                End If
                p = D(L)
                If M <> L Then
                    
                    '
                    ' If remaining matrix is 2-by-2, use DLAE2 or SLAEV2
                    ' to compute its eigensystem.
                    '
                    If M = L - 1# Then
                        If ZNeeded > 0# Then
                            Call TdEVDEV2(D(L - 1#), E(L - 1#), D(L), RT1, RT2, C, S)
                            WORK1(M) = C
                            WORK2(M) = S
                            WORKC(1#) = C
                            WORKS(1#) = S
                            If Not WasTranspose Then
                                Call ApplyRotationsFromTheRight(True, 1#, ZRows, L - 1#, L, WORKC, WORKS, z, WTemp)
                            Else
                                Call ApplyRotationsFromTheLeft(True, L - 1#, L, 1#, ZRows, WORKC, WORKS, z, WTemp)
                            End If
                        Else
                            Call TdEVDE2(D(L - 1#), E(L - 1#), D(L), RT1, RT2)
                        End If
                        D(L - 1#) = RT1
                        D(L) = RT2
                        E(L - 1#) = 0#
                        L = L - 2#
                        If L >= LEND Then
                            GoTo Cont_11
                        End If
                        Exit Do
                    End If
                    If JTOT = NMAXIT Then
                        Exit Do
                    End If
                    JTOT = JTOT + 1#
                    
                    '
                    ' Form shift.
                    '
                    G = (D(L - 1#) - p) / (2# * E(L - 1#))
                    R = TdEVDPythag(G, 1#)
                    G = D(M) - p + E(L - 1#) / (G + TdEVDExtSign(R, G))
                    S = 1#
                    C = 1#
                    p = 0#
                    
                    '
                    ' Inner loop
                    '
                    LM1 = L - 1#
                    For i = M To LM1 Step 1
                        F = S * E(i)
                        B = C * E(i)
                        Call GenerateRotation(G, F, C, S, R)
                        If i <> M Then
                            E(i - 1#) = R
                        End If
                        G = D(i) - p
                        R = (D(i + 1#) - G) * S + 2# * C * B
                        p = S * R
                        D(i) = G + p
                        G = C * R - B
                        
                        '
                        ' If eigenvectors are desired, then save rotations.
                        '
                        If ZNeeded > 0# Then
                            WORK1(i) = C
                            WORK2(i) = S
                        End If
                    Next i
                    
                    '
                    ' If eigenvectors are desired, then apply saved rotations.
                    '
                    If ZNeeded > 0# Then
                        MM = L - M + 1#
                        For i = M To L - 1# Step 1
                            WORKC(i - M + 1#) = WORK1(i)
                            WORKS(i - M + 1#) = WORK2(i)
                        Next i
                        If Not WasTranspose Then
                            Call ApplyRotationsFromTheRight(True, 1#, ZRows, M, L, WORKC, WORKS, z, WTemp)
                        Else
                            Call ApplyRotationsFromTheLeft(True, M, L, 1#, ZRows, WORKC, WORKS, z, WTemp)
                        End If
                    End If
                    D(L) = D(L) - p
                    E(LM1) = G
                    GoTo Cont_11
                End If
                
                '
                ' Eigenvalue found.
                '
                D(L) = p
                L = L - 1#
                If L >= LEND Then
                    GoTo Cont_11
                End If
                Exit Do
Cont_11:
            Loop
        End If
        
        '
        ' Undo scaling if necessary
        '
        If ISCALE = 1# Then
            Tmp = ANORM / SSFMAX
            TmpInt = LENDSV - 1#
            For i_ = LSV To LENDSV Step 1
                D(i_) = Tmp * D(i_)
            Next i_
            For i_ = LSV To TmpInt Step 1
                E(i_) = Tmp * E(i_)
            Next i_
        End If
        If ISCALE = 2# Then
            Tmp = ANORM / SSFMIN
            TmpInt = LENDSV - 1#
            For i_ = LSV To LENDSV Step 1
                D(i_) = Tmp * D(i_)
            Next i_
            For i_ = LSV To TmpInt Step 1
                E(i_) = Tmp * E(i_)
            Next i_
        End If
        
        '
        ' Check for no convergence to an eigenvalue after a total
        ' of N*MAXIT iterations.
        '
        If JTOT >= NMAXIT Then
            Result = False
            If WasTranspose Then
                Call InplaceTranspose(z, 1#, N, 1#, N, WTemp)
            End If
            TridiagonalEVD = Result
            Exit Function
        End If
Cont_4:
    Loop
    
    '
    ' Order eigenvalues and eigenvectors.
    '
    If ZNeeded = 0# Then
        
        '
        ' Sort
        '
        If N = 1# Then
            TridiagonalEVD = Result
            Exit Function
        End If
        If N = 2# Then
            If D(1#) > D(2#) Then
                Tmp = D(1#)
                D(1#) = D(2#)
                D(2#) = Tmp
            End If
            TridiagonalEVD = Result
            Exit Function
        End If
        i = 2#
        Do
            T = i
            Do While T <> 1#
                K = T \ 2#
                If D(K) >= D(T) Then
                    T = 1#
                Else
                    Tmp = D(K)
                    D(K) = D(T)
                    D(T) = Tmp
                    T = K
                End If
            Loop
            i = i + 1#
        Loop Until Not i <= N
        i = N - 1#
        Do
            Tmp = D(i + 1#)
            D(i + 1#) = D(1#)
            D(1#) = Tmp
            T = 1#
            Do While T <> 0#
                K = 2# * T
                If K > i Then
                    T = 0#
                Else
                    If K < i Then
                        If D(K + 1#) > D(K) Then
                            K = K + 1#
                        End If
                    End If
                    If D(T) >= D(K) Then
                        T = 0#
                    Else
                        Tmp = D(K)
                        D(K) = D(T)
                        D(T) = Tmp
                        T = K
                    End If
                End If
            Loop
            i = i - 1#
        Loop Until Not i >= 1#
    Else
        
        '
        ' Use Selection Sort to minimize swaps of eigenvectors
        '
        For II = 2# To N Step 1
            i = II - 1#
            K = i
            p = D(i)
            For j = II To N Step 1
                If D(j) < p Then
                    K = j
                    p = D(j)
                End If
            Next j
            If K <> i Then
                D(K) = D(i)
                D(i) = p
                If WasTranspose Then
                    For i_ = 1# To N Step 1
                        WTemp(i_) = z(i, i_)
                    Next i_
                    For i_ = 1# To N Step 1
                        z(i, i_) = z(K, i_)
                    Next i_
                    For i_ = 1# To N Step 1
                        z(K, i_) = WTemp(i_)
                    Next i_
                Else
                    For i_ = 1# To ZRows Step 1
                        WTemp(i_) = z(i_, i)
                    Next i_
                    For i_ = 1# To ZRows Step 1
                        z(i_, i) = z(i_, K)
                    Next i_
                    For i_ = 1# To ZRows Step 1
                        z(i_, K) = WTemp(i_)
                    Next i_
                End If
            End If
        Next II
        If WasTranspose Then
            Call InplaceTranspose(z, 1#, N, 1#, N, WTemp)
        End If
    End If
    TridiagonalEVD = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'DLAE2  computes the eigenvalues of a 2-by-2 symmetric matrix
'   [  A   B  ]
'   [  B   C  ].
'On return, RT1 is the eigenvalue of larger absolute value, and RT2
'is the eigenvalue of smaller absolute value.
'
'  -- LAPACK auxiliary routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     October 31, 1992
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub TdEVDE2(ByRef A As Double, _
         ByRef B As Double, _
         ByRef C As Double, _
         ByRef RT1 As Double, _
         ByRef RT2 As Double)
    Dim AB As Double
    Dim ACMN As Double
    Dim ACMX As Double
    Dim ADF As Double
    Dim DF As Double
    Dim RT As Double
    Dim SM As Double
    Dim TB As Double
    SM = A + C
    DF = A - C
    ADF = Abs(DF)
    TB = B + B
    AB = Abs(TB)
    If Abs(A) > Abs(C) Then
        ACMX = A
        ACMN = C
    Else
        ACMX = C
        ACMN = A
    End If
    If ADF > AB Then
        RT = ADF * Sqr(1# + Square(AB / ADF))
    Else
        If ADF < AB Then
            RT = AB * Sqr(1# + Square(ADF / AB))
        Else
            
            '
            ' Includes case AB=ADF=0
            '
            RT = AB * Sqr(2#)
        End If
    End If
    If SM < 0# Then
        RT1 = 0.5 * (SM - RT)
        
        '
        ' Order of execution important.
        ' To get fully accurate smaller eigenvalue,
        ' next line needs to be executed in higher precision.
        '
        RT2 = ACMX / RT1 * ACMN - B / RT1 * B
    Else
        If SM > 0# Then
            RT1 = 0.5 * (SM + RT)
            
            '
            ' Order of execution important.
            ' To get fully accurate smaller eigenvalue,
            ' next line needs to be executed in higher precision.
            '
            RT2 = ACMX / RT1 * ACMN - B / RT1 * B
        Else
            
            '
            ' Includes case RT1 = RT2 = 0
            '
            RT1 = 0.5 * RT
            RT2 = -(0.5 * RT)
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'DLAEV2 computes the eigendecomposition of a 2-by-2 symmetric matrix
'
'   [  A   B  ]
'   [  B   C  ].
'
'On return, RT1 is the eigenvalue of larger absolute value, RT2 is the
'eigenvalue of smaller absolute value, and (CS1,SN1) is the unit right
'eigenvector for RT1, giving the decomposition
'
'   [ CS1  SN1 ] [  A   B  ] [ CS1 -SN1 ]  =  [ RT1  0  ]
'   [-SN1  CS1 ] [  B   C  ] [ SN1  CS1 ]     [  0  RT2 ].
'
'
'  -- LAPACK auxiliary routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     October 31, 1992
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub TdEVDEV2(ByRef A As Double, _
         ByRef B As Double, _
         ByRef C As Double, _
         ByRef RT1 As Double, _
         ByRef RT2 As Double, _
         ByRef CS1 As Double, _
         ByRef SN1 As Double)
    Dim SGN1 As Long
    Dim SGN2 As Long
    Dim AB As Double
    Dim ACMN As Double
    Dim ACMX As Double
    Dim ACS As Double
    Dim ADF As Double
    Dim CS As Double
    Dim CT As Double
    Dim DF As Double
    Dim RT As Double
    Dim SM As Double
    Dim TB As Double
    Dim TN As Double
    
    '
    ' Compute the eigenvalues
    '
    SM = A + C
    DF = A - C
    ADF = Abs(DF)
    TB = B + B
    AB = Abs(TB)
    If Abs(A) > Abs(C) Then
        ACMX = A
        ACMN = C
    Else
        ACMX = C
        ACMN = A
    End If
    If ADF > AB Then
        RT = ADF * Sqr(1# + Square(AB / ADF))
    Else
        If ADF < AB Then
            RT = AB * Sqr(1# + Square(ADF / AB))
        Else
            
            '
            ' Includes case AB=ADF=0
            '
            RT = AB * Sqr(2#)
        End If
    End If
    If SM < 0# Then
        RT1 = 0.5 * (SM - RT)
        SGN1 = -1#
        
        '
        ' Order of execution important.
        ' To get fully accurate smaller eigenvalue,
        ' next line needs to be executed in higher precision.
        '
        RT2 = ACMX / RT1 * ACMN - B / RT1 * B
    Else
        If SM > 0# Then
            RT1 = 0.5 * (SM + RT)
            SGN1 = 1#
            
            '
            ' Order of execution important.
            ' To get fully accurate smaller eigenvalue,
            ' next line needs to be executed in higher precision.
            '
            RT2 = ACMX / RT1 * ACMN - B / RT1 * B
        Else
            
            '
            ' Includes case RT1 = RT2 = 0
            '
            RT1 = 0.5 * RT
            RT2 = -(0.5 * RT)
            SGN1 = 1#
        End If
    End If
    
    '
    ' Compute the eigenvector
    '
    If DF >= 0# Then
        CS = DF + RT
        SGN2 = 1#
    Else
        CS = DF - RT
        SGN2 = -1#
    End If
    ACS = Abs(CS)
    If ACS > AB Then
        CT = -(TB / CS)
        SN1 = 1# / Sqr(1# + CT * CT)
        CS1 = CT * SN1
    Else
        If AB = 0# Then
            CS1 = 1#
            SN1 = 0#
        Else
            TN = -(CS / TB)
            CS1 = 1# / Sqr(1# + TN * TN)
            SN1 = TN * CS1
        End If
    End If
    If SGN1 = SGN2 Then
        TN = CS1
        CS1 = -SN1
        SN1 = TN
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal routine
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Function TdEVDPythag(ByVal A As Double, ByVal B As Double) As Double
    Dim Result As Double
    If Abs(A) < Abs(B) Then
        Result = Abs(B) * Sqr(1# + Square(A / B))
    Else
        Result = Abs(A) * Sqr(1# + Square(B / A))
    End If
    TdEVDPythag = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal routine
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Function TdEVDExtSign(ByVal A As Double, ByVal B As Double) As Double
    Dim Result As Double
    If B >= 0# Then
        Result = Abs(A)
    Else
        Result = -Abs(A)
    End If
    TdEVDExtSign = Result
End Function
Private Sub TDINInternalDLAGTF(ByRef N As Long, _
         ByRef A() As Double, _
         ByRef Lambda As Double, _
         ByRef B() As Double, _
         ByRef C() As Double, _
         ByRef TOL As Double, _
         ByRef D() As Double, _
         ByRef IIN() As Long, _
         ByRef Info As Long)
    Dim K As Long
    Dim Eps As Double
    Dim MULT As Double
    Dim PIV1 As Double
    Dim PIV2 As Double
    Dim SCALE1 As Double
    Dim SCALE2 As Double
    Dim temp As Double
    Dim TL As Double
    Info = 0#
    If N < 0# Then
        Info = -1#
        Exit Sub
    End If
    If N = 0# Then
        Exit Sub
    End If
    A(1#) = A(1#) - Lambda
    IIN(N) = 0#
    If N = 1# Then
        If A(1#) = 0# Then
            IIN(1#) = 1#
        End If
        Exit Sub
    End If
    Eps = MachineEpsilon
    TL = MaxReal(TOL, Eps)
    SCALE1 = Abs(A(1#)) + Abs(B(1#))
    For K = 1# To N - 1# Step 1
        A(K + 1#) = A(K + 1#) - Lambda
        SCALE2 = Abs(C(K)) + Abs(A(K + 1#))
        If K < N - 1# Then
            SCALE2 = SCALE2 + Abs(B(K + 1#))
        End If
        If A(K) = 0# Then
            PIV1 = 0#
        Else
            PIV1 = Abs(A(K)) / SCALE1
        End If
        If C(K) = 0# Then
            IIN(K) = 0#
            PIV2 = 0#
            SCALE1 = SCALE2
            If K < N - 1# Then
                D(K) = 0#
            End If
        Else
            PIV2 = Abs(C(K)) / SCALE2
            If PIV2 <= PIV1 Then
                IIN(K) = 0#
                SCALE1 = SCALE2
                C(K) = C(K) / A(K)
                A(K + 1#) = A(K + 1#) - C(K) * B(K)
                If K < N - 1# Then
                    D(K) = 0#
                End If
            Else
                IIN(K) = 1#
                MULT = A(K) / C(K)
                A(K) = C(K)
                temp = A(K + 1#)
                A(K + 1#) = B(K) - MULT * temp
                If K < N - 1# Then
                    D(K) = B(K + 1#)
                    B(K + 1#) = -(MULT * D(K))
                End If
                B(K) = temp
                C(K) = MULT
            End If
        End If
        If MaxReal(PIV1, PIV2) <= TL And IIN(N) = 0# Then
            IIN(N) = K
        End If
    Next K
    If Abs(A(N)) <= SCALE1 * TL And IIN(N) = 0# Then
        IIN(N) = N
    End If
End Sub
Private Sub TDINInternalDLAGTS(ByRef N As Long, _
         ByRef A() As Double, _
         ByRef B() As Double, _
         ByRef C() As Double, _
         ByRef D() As Double, _
         ByRef IIN() As Long, _
         ByRef y() As Double, _
         ByRef TOL As Double, _
         ByRef Info As Long)
    Dim K As Long
    Dim ABSAK As Double
    Dim AK As Double
    Dim BIGNUM As Double
    Dim Eps As Double
    Dim PERT As Double
    Dim SFMIN As Double
    Dim temp As Double
    Info = 0#
    If N < 0# Then
        Info = -1#
        Exit Sub
    End If
    If N = 0# Then
        Exit Sub
    End If
    Eps = MachineEpsilon
    SFMIN = MinRealNumber
    BIGNUM = 1# / SFMIN
    If TOL <= 0# Then
        TOL = Abs(A(1#))
        If N > 1# Then
            TOL = MaxReal(TOL, MaxReal(Abs(A(2#)), Abs(B(1#))))
        End If
        For K = 3# To N Step 1
            TOL = MaxReal(TOL, MaxReal(Abs(A(K)), MaxReal(Abs(B(K - 1#)), Abs(D(K - 2#)))))
        Next K
        TOL = TOL * Eps
        If TOL = 0# Then
            TOL = Eps
        End If
    End If
    For K = 2# To N Step 1
        If IIN(K - 1#) = 0# Then
            y(K) = y(K) - C(K - 1#) * y(K - 1#)
        Else
            temp = y(K - 1#)
            y(K - 1#) = y(K)
            y(K) = temp - C(K - 1#) * y(K)
        End If
    Next K
    For K = N To 1# Step -1
        If K <= N - 2# Then
            temp = y(K) - B(K) * y(K + 1#) - D(K) * y(K + 2#)
        Else
            If K = N - 1# Then
                temp = y(K) - B(K) * y(K + 1#)
            Else
                temp = y(K)
            End If
        End If
        AK = A(K)
        PERT = Abs(TOL)
        If AK < 0# Then
            PERT = -PERT
        End If
        Do While True
            ABSAK = Abs(AK)
            If ABSAK < 1# Then
                If ABSAK < SFMIN Then
                    If ABSAK = 0# Or Abs(temp) * SFMIN > ABSAK Then
                        AK = AK + PERT
                        PERT = 2# * PERT
                        GoTo Cont_4
                    Else
                        temp = temp * BIGNUM
                        AK = AK * BIGNUM
                    End If
                Else
                    If Abs(temp) > ABSAK * BIGNUM Then
                        AK = AK + PERT
                        PERT = 2# * PERT
                        GoTo Cont_4
                    End If
                End If
            End If
            Exit Do
Cont_4:
        Loop
        y(K) = temp / AK
    Next K
End Sub
Private Sub InternalDLAEBZ(ByRef IJOB As Long, _
         ByRef NITMAX As Long, _
         ByRef N As Long, _
         ByRef MMAX As Long, _
         ByRef MINP As Long, _
         ByRef ABSTOL As Double, _
         ByRef RELTOL As Double, _
         ByRef PIVMIN As Double, _
         ByRef D() As Double, _
         ByRef E() As Double, _
         ByRef E2() As Double, _
         ByRef NVAL() As Long, _
         ByRef AB() As Double, _
         ByRef C() As Double, _
         ByRef MOUT As Long, _
         ByRef NAB() As Long, _
         ByRef WORK() As Double, _
         ByRef IWORK() As Long, _
         ByRef Info As Long)
    Dim ITMP1 As Long
    Dim ITMP2 As Long
    Dim j As Long
    Dim JI As Long
    Dim JIT As Long
    Dim JP As Long
    Dim KF As Long
    Dim KFNEW As Long
    Dim KL As Long
    Dim KLNEW As Long
    Dim TMP1 As Double
    Dim Tmp2 As Double
    Info = 0#
    If IJOB < 1# Or IJOB > 3# Then
        Info = -1#
        Exit Sub
    End If
    
    '
    ' Initialize NAB
    '
    If IJOB = 1# Then
        
        '
        ' Compute the number of eigenvalues in the initial intervals.
        '
        MOUT = 0#
        
        '
        'DIR$ NOVECTOR
        '
        For JI = 1# To MINP Step 1
            For JP = 1# To 2# Step 1
                TMP1 = D(1#) - AB(JI, JP)
                If Abs(TMP1) < PIVMIN Then
                    TMP1 = -PIVMIN
                End If
                NAB(JI, JP) = 0#
                If TMP1 <= 0# Then
                    NAB(JI, JP) = 1#
                End If
                For j = 2# To N Step 1
                    TMP1 = D(j) - E2(j - 1#) / TMP1 - AB(JI, JP)
                    If Abs(TMP1) < PIVMIN Then
                        TMP1 = -PIVMIN
                    End If
                    If TMP1 <= 0# Then
                        NAB(JI, JP) = NAB(JI, JP) + 1#
                    End If
                Next j
            Next JP
            MOUT = MOUT + NAB(JI, 2#) - NAB(JI, 1#)
        Next JI
        Exit Sub
    End If
    
    '
    ' Initialize for loop
    '
    ' KF and KL have the following meaning:
    '   Intervals 1,...,KF-1 have converged.
    '   Intervals KF,...,KL  still need to be refined.
    '
    KF = 1#
    KL = MINP
    
    '
    ' If IJOB=2, initialize C.
    ' If IJOB=3, use the user-supplied starting point.
    '
    If IJOB = 2# Then
        For JI = 1# To MINP Step 1
            C(JI) = 0.5 * (AB(JI, 1#) + AB(JI, 2#))
        Next JI
    End If
    
    '
    ' Iteration loop
    '
    For JIT = 1# To NITMAX Step 1
        
        '
        ' Loop over intervals
        '
        '
        ' Serial Version of the loop
        '
        KLNEW = KL
        For JI = KF To KL Step 1
            
            '
            ' Compute N(w), the number of eigenvalues less than w
            '
            TMP1 = C(JI)
            Tmp2 = D(1#) - TMP1
            ITMP1 = 0#
            If Tmp2 <= PIVMIN Then
                ITMP1 = 1#
                Tmp2 = MinReal(Tmp2, -PIVMIN)
            End If
            
            '
            ' A series of compiler directives to defeat vectorization
            ' for the next loop
            '
            '*$PL$ CMCHAR=' '
            'CDIR$          NEXTSCALAR
            'C$DIR          SCALAR
            'CDIR$          NEXT SCALAR
            'CVD$L          NOVECTOR
            'CDEC$          NOVECTOR
            'CVD$           NOVECTOR
            '*VDIR          NOVECTOR
            '*VOCL          LOOP,SCALAR
            'CIBM           PREFER SCALAR
            '*$PL$ CMCHAR='*'
            '
            For j = 2# To N Step 1
                Tmp2 = D(j) - E2(j - 1#) / Tmp2 - TMP1
                If Tmp2 <= PIVMIN Then
                    ITMP1 = ITMP1 + 1#
                    Tmp2 = MinReal(Tmp2, -PIVMIN)
                End If
            Next j
            If IJOB <= 2# Then
                
                '
                ' IJOB=2: Choose all intervals containing eigenvalues.
                '
                ' Insure that N(w) is monotone
                '
                ITMP1 = MinInt(NAB(JI, 2#), MaxInt(NAB(JI, 1#), ITMP1))
                
                '
                ' Update the Queue -- add intervals if both halves
                ' contain eigenvalues.
                '
                If ITMP1 = NAB(JI, 2#) Then
                    
                    '
                    ' No eigenvalue in the upper interval:
                    ' just use the lower interval.
                    '
                    AB(JI, 2#) = TMP1
                Else
                    If ITMP1 = NAB(JI, 1#) Then
                        
                        '
                        ' No eigenvalue in the lower interval:
                        ' just use the upper interval.
                        '
                        AB(JI, 1#) = TMP1
                    Else
                        If KLNEW < MMAX Then
                            
                            '
                            ' Eigenvalue in both intervals -- add upper to queue.
                            '
                            KLNEW = KLNEW + 1#
                            AB(KLNEW, 2#) = AB(JI, 2#)
                            NAB(KLNEW, 2#) = NAB(JI, 2#)
                            AB(KLNEW, 1#) = TMP1
                            NAB(KLNEW, 1#) = ITMP1
                            AB(JI, 2#) = TMP1
                            NAB(JI, 2#) = ITMP1
                        Else
                            Info = MMAX + 1#
                            Exit Sub
                        End If
                    End If
                End If
            Else
                
                '
                ' IJOB=3: Binary search.  Keep only the interval
                ' containing  w  s.t. N(w) = NVAL
                '
                If ITMP1 <= NVAL(JI) Then
                    AB(JI, 1#) = TMP1
                    NAB(JI, 1#) = ITMP1
                End If
                If ITMP1 >= NVAL(JI) Then
                    AB(JI, 2#) = TMP1
                    NAB(JI, 2#) = ITMP1
                End If
            End If
        Next JI
        KL = KLNEW
        
        '
        ' Check for convergence
        '
        KFNEW = KF
        For JI = KF To KL Step 1
            TMP1 = Abs(AB(JI, 2#) - AB(JI, 1#))
            Tmp2 = MaxReal(Abs(AB(JI, 2#)), Abs(AB(JI, 1#)))
            If TMP1 < MaxReal(ABSTOL, MaxReal(PIVMIN, RELTOL * Tmp2)) Or NAB(JI, 1#) >= NAB(JI, 2#) Then
                
                '
                ' Converged -- Swap with position KFNEW,
                ' then increment KFNEW
                '
                If JI > KFNEW Then
                    TMP1 = AB(JI, 1#)
                    Tmp2 = AB(JI, 2#)
                    ITMP1 = NAB(JI, 1#)
                    ITMP2 = NAB(JI, 2#)
                    AB(JI, 1#) = AB(KFNEW, 1#)
                    AB(JI, 2#) = AB(KFNEW, 2#)
                    NAB(JI, 1#) = NAB(KFNEW, 1#)
                    NAB(JI, 2#) = NAB(KFNEW, 2#)
                    AB(KFNEW, 1#) = TMP1
                    AB(KFNEW, 2#) = Tmp2
                    NAB(KFNEW, 1#) = ITMP1
                    NAB(KFNEW, 2#) = ITMP2
                    If IJOB = 3# Then
                        ITMP1 = NVAL(JI)
                        NVAL(JI) = NVAL(KFNEW)
                        NVAL(KFNEW) = ITMP1
                    End If
                End If
                KFNEW = KFNEW + 1#
            End If
        Next JI
        KF = KFNEW
        
        '
        ' Choose Midpoints
        '
        For JI = KF To KL Step 1
            C(JI) = 0.5 * (AB(JI, 1#) + AB(JI, 2#))
        Next JI
        
        '
        ' If no more intervals to refine, quit.
        '
        If KF > KL Then
            Exit For
        End If
    Next JIT
    
    '
    ' Converged
    '
    Info = MaxInt(KL + 1# - KF, 0#)
    MOUT = KL
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal subroutine
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     June 30, 1999
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub InternalTREVC(ByRef T() As Double, _
         ByVal N As Long, _
         ByVal SIDE As Long, _
         ByVal HOWMNY As Long, _
         ByRef VSELECT_() As Boolean, _
         ByRef VL() As Double, _
         ByRef VR() As Double, _
         ByRef M As Long, _
         ByRef Info As Long)
    Dim VSELECT() As Boolean
    Dim ALLV As Boolean
    Dim BOTHV As Boolean
    Dim LEFTV As Boolean
    Dim OVER As Boolean
    Dim PAIR As Boolean
    Dim RIGHTV As Boolean
    Dim SOMEV As Boolean
    Dim i As Long
    Dim IERR As Long
    Dim II As Long
    Dim IP As Long
    Dim IIS As Long
    Dim j As Long
    Dim J1 As Long
    Dim J2 As Long
    Dim JNXT As Long
    Dim K As Long
    Dim KI As Long
    Dim N2 As Long
    Dim Beta As Double
    Dim BIGNUM As Double
    Dim EMAX As Double
    Dim OVFL As Double
    Dim REC As Double
    Dim REMAX As Double
    Dim SCL As Double
    Dim SMIN As Double
    Dim SMLNUM As Double
    Dim Ulp As Double
    Dim UNFL As Double
    Dim VCRIT As Double
    Dim VMax As Double
    Dim WI As Double
    Dim WR As Double
    Dim XNorm As Double
    Dim X() As Double
    Dim WORK() As Double
    Dim temp() As Double
    Dim TEMP11() As Double
    Dim TEMP22() As Double
    Dim TEMP11B() As Double
    Dim TEMP21B() As Double
    Dim TEMP12B() As Double
    Dim TEMP22B() As Double
    Dim SkipFlag As Boolean
    Dim K1 As Long
    Dim K2 As Long
    Dim k3 As Long
    Dim k4 As Long
    Dim VT As Double
    Dim RSWAP4() As Boolean
    Dim ZSWAP4() As Boolean
    Dim IPIVOT44() As Long
    Dim CIV4() As Double
    Dim CRV4() As Double
    Dim i_ As Long
    Dim i1_ As Long
    VSELECT = VSELECT_
    ReDim X(1# To 2#, 1# To 2#)
    ReDim TEMP11(1# To 1#, 1# To 1#)
    ReDim TEMP11B(1# To 1#, 1# To 1#)
    ReDim TEMP21B(1# To 2#, 1# To 1#)
    ReDim TEMP12B(1# To 1#, 1# To 2#)
    ReDim TEMP22B(1# To 2#, 1# To 2#)
    ReDim TEMP22(1# To 2#, 1# To 2#)
    ReDim WORK(1# To 3# * N)
    ReDim temp(1# To N)
    ReDim RSWAP4(1# To 4#)
    ReDim ZSWAP4(1# To 4#)
    ReDim IPIVOT44(1# To 4#, 1# To 4#)
    ReDim CIV4(1# To 4#)
    ReDim CRV4(1# To 4#)
    If HOWMNY <> 1# Then
        If SIDE = 1# Or SIDE = 3# Then
            ReDim VR(1# To N, 1# To N)
        End If
        If SIDE = 2# Or SIDE = 3# Then
            ReDim VL(1# To N, 1# To N)
        End If
    End If
    
    '
    ' Decode and test the input parameters
    '
    BOTHV = SIDE = 3#
    RIGHTV = SIDE = 1# Or BOTHV
    LEFTV = SIDE = 2# Or BOTHV
    ALLV = HOWMNY = 2#
    OVER = HOWMNY = 1#
    SOMEV = HOWMNY = 3#
    Info = 0#
    If N < 0# Then
        Info = -2#
        Exit Sub
    End If
    If Not RIGHTV And Not LEFTV Then
        Info = -3#
        Exit Sub
    End If
    If Not ALLV And Not OVER And Not SOMEV Then
        Info = -4#
        Exit Sub
    End If
    
    '
    ' Set M to the number of columns required to store the selected
    ' eigenvectors, standardize the array SELECT if necessary, and
    ' test MM.
    '
    If SOMEV Then
        M = 0#
        PAIR = False
        For j = 1# To N Step 1
            If PAIR Then
                PAIR = False
                VSELECT(j) = False
            Else
                If j < N Then
                    If T(j + 1#, j) = 0# Then
                        If VSELECT(j) Then
                            M = M + 1#
                        End If
                    Else
                        PAIR = True
                        If VSELECT(j) Or VSELECT(j + 1#) Then
                            VSELECT(j) = True
                            M = M + 2#
                        End If
                    End If
                Else
                    If VSELECT(N) Then
                        M = M + 1#
                    End If
                End If
            End If
        Next j
    Else
        M = N
    End If
    
    '
    ' Quick return if possible.
    '
    If N = 0# Then
        Exit Sub
    End If
    
    '
    ' Set the constants to control overflow.
    '
    UNFL = MinRealNumber
    OVFL = 1# / UNFL
    Ulp = MachineEpsilon
    SMLNUM = UNFL * (N / Ulp)
    BIGNUM = (1# - Ulp) / SMLNUM
    
    '
    ' Compute 1-norm of each column of strictly upper triangular
    ' part of T to control overflow in triangular solver.
    '
    WORK(1#) = 0#
    For j = 2# To N Step 1
        WORK(j) = 0#
        For i = 1# To j - 1# Step 1
            WORK(j) = WORK(j) + Abs(T(i, j))
        Next i
    Next j
    
    '
    ' Index IP is used to specify the real or complex eigenvalue:
    ' IP = 0, real eigenvalue,
    '      1, first of conjugate complex pair: (wr,wi)
    '     -1, second of conjugate complex pair: (wr,wi)
    '
    N2 = 2# * N
    If RIGHTV Then
        
        '
        ' Compute right eigenvectors.
        '
        IP = 0#
        IIS = M
        For KI = N To 1# Step -1
            SkipFlag = False
            If IP = 1# Then
                SkipFlag = True
            Else
                If KI <> 1# Then
                    If T(KI, KI - 1#) <> 0# Then
                        IP = -1#
                    End If
                End If
                If SOMEV Then
                    If IP = 0# Then
                        If Not VSELECT(KI) Then
                            SkipFlag = True
                        End If
                    Else
                        If Not VSELECT(KI - 1#) Then
                            SkipFlag = True
                        End If
                    End If
                End If
            End If
            If Not SkipFlag Then
                
                '
                ' Compute the KI-th eigenvalue (WR,WI).
                '
                WR = T(KI, KI)
                WI = 0#
                If IP <> 0# Then
                    WI = Sqr(Abs(T(KI, KI - 1#))) * Sqr(Abs(T(KI - 1#, KI)))
                End If
                SMIN = MaxReal(Ulp * (Abs(WR) + Abs(WI)), SMLNUM)
                If IP = 0# Then
                    
                    '
                    ' Real right eigenvector
                    '
                    WORK(KI + N) = 1#
                    
                    '
                    ' Form right-hand side
                    '
                    For K = 1# To KI - 1# Step 1
                        WORK(K + N) = -T(K, KI)
                    Next K
                    
                    '
                    ' Solve the upper quasi-triangular system:
                    '   (T(1:KI-1,1:KI-1) - WR)*X = SCALE*WORK.
                    '
                    JNXT = KI - 1#
                    For j = KI - 1# To 1# Step -1
                        If j > JNXT Then
                            GoTo Cont_6
                        End If
                        J1 = j
                        J2 = j
                        JNXT = j - 1#
                        If j > 1# Then
                            If T(j, j - 1#) <> 0# Then
                                J1 = j - 1#
                                JNXT = j - 2#
                            End If
                        End If
                        If J1 = J2 Then
                            
                            '
                            ' 1-by-1 diagonal block
                            '
                            TEMP11(1#, 1#) = T(j, j)
                            TEMP11B(1#, 1#) = WORK(j + N)
                            Call InternalHSEVDLALN2(False, 1#, 1#, SMIN, 1#, TEMP11, 1#, 1#, TEMP11B, WR, 0#, RSWAP4, ZSWAP4, IPIVOT44, CIV4, CRV4, X, SCL, XNorm, IERR)
                            
                            '
                            ' Scale X(1,1) to avoid overflow when updating
                            ' the right-hand side.
                            '
                            If XNorm > 1# Then
                                If WORK(j) > BIGNUM / XNorm Then
                                    X(1#, 1#) = X(1#, 1#) / XNorm
                                    SCL = SCL / XNorm
                                End If
                            End If
                            
                            '
                            ' Scale if necessary
                            '
                            If SCL <> 1# Then
                                K1 = N + 1#
                                K2 = N + KI
                                For i_ = K1 To K2 Step 1
                                    WORK(i_) = SCL * WORK(i_)
                                Next i_
                            End If
                            WORK(j + N) = X(1#, 1#)
                            
                            '
                            ' Update right-hand side
                            '
                            K1 = 1# + N
                            K2 = j - 1# + N
                            k3 = j - 1#
                            VT = -X(1#, 1#)
                            i1_ = (1#) - (K1)
                            For i_ = K1 To K2 Step 1
                                WORK(i_) = WORK(i_) + VT * T(i_ + i1_, j)
                            Next i_
                        Else
                            
                            '
                            ' 2-by-2 diagonal block
                            '
                            TEMP22(1#, 1#) = T(j - 1#, j - 1#)
                            TEMP22(1#, 2#) = T(j - 1#, j)
                            TEMP22(2#, 1#) = T(j, j - 1#)
                            TEMP22(2#, 2#) = T(j, j)
                            TEMP21B(1#, 1#) = WORK(j - 1# + N)
                            TEMP21B(2#, 1#) = WORK(j + N)
                            Call InternalHSEVDLALN2(False, 2#, 1#, SMIN, 1#, TEMP22, 1#, 1#, TEMP21B, WR, 0#, RSWAP4, ZSWAP4, IPIVOT44, CIV4, CRV4, X, SCL, XNorm, IERR)
                            
                            '
                            ' Scale X(1,1) and X(2,1) to avoid overflow when
                            ' updating the right-hand side.
                            '
                            If XNorm > 1# Then
                                Beta = MaxReal(WORK(j - 1#), WORK(j))
                                If Beta > BIGNUM / XNorm Then
                                    X(1#, 1#) = X(1#, 1#) / XNorm
                                    X(2#, 1#) = X(2#, 1#) / XNorm
                                    SCL = SCL / XNorm
                                End If
                            End If
                            
                            '
                            ' Scale if necessary
                            '
                            If SCL <> 1# Then
                                K1 = 1# + N
                                K2 = KI + N
                                For i_ = K1 To K2 Step 1
                                    WORK(i_) = SCL * WORK(i_)
                                Next i_
                            End If
                            WORK(j - 1# + N) = X(1#, 1#)
                            WORK(j + N) = X(2#, 1#)
                            
                            '
                            ' Update right-hand side
                            '
                            K1 = 1# + N
                            K2 = j - 2# + N
                            k3 = j - 2#
                            k4 = j - 1#
                            VT = -X(1#, 1#)
                            i1_ = (1#) - (K1)
                            For i_ = K1 To K2 Step 1
                                WORK(i_) = WORK(i_) + VT * T(i_ + i1_, k4)
                            Next i_
                            VT = -X(2#, 1#)
                            i1_ = (1#) - (K1)
                            For i_ = K1 To K2 Step 1
                                WORK(i_) = WORK(i_) + VT * T(i_ + i1_, j)
                            Next i_
                        End If
Cont_6:
                    Next j
                    
                    '
                    ' Copy the vector x or Q*x to VR and normalize.
                    '
                    If Not OVER Then
                        K1 = 1# + N
                        K2 = KI + N
                        i1_ = (K1) - (1#)
                        For i_ = 1# To KI Step 1
                            VR(i_, IIS) = WORK(i_ + i1_)
                        Next i_
                        II = ColumnIdxAbsMax(VR, 1#, KI, IIS)
                        REMAX = 1# / Abs(VR(II, IIS))
                        For i_ = 1# To KI Step 1
                            VR(i_, IIS) = REMAX * VR(i_, IIS)
                        Next i_
                        For K = KI + 1# To N Step 1
                            VR(K, IIS) = 0#
                        Next K
                    Else
                        If KI > 1# Then
                            For i_ = 1# To N Step 1
                                temp(i_) = VR(i_, KI)
                            Next i_
                            Call MatrixVectorMultiply(VR, 1#, N, 1#, KI - 1#, False, WORK, 1# + N, KI - 1# + N, 1#, temp, 1#, N, WORK(KI + N))
                            For i_ = 1# To N Step 1
                                VR(i_, KI) = temp(i_)
                            Next i_
                        End If
                        II = ColumnIdxAbsMax(VR, 1#, N, KI)
                        REMAX = 1# / Abs(VR(II, KI))
                        For i_ = 1# To N Step 1
                            VR(i_, KI) = REMAX * VR(i_, KI)
                        Next i_
                    End If
                Else
                    
                    '
                    ' Complex right eigenvector.
                    '
                    ' Initial solve
                    '     [ (T(KI-1,KI-1) T(KI-1,KI) ) - (WR + I* WI)]*X = 0.
                    '     [ (T(KI,KI-1)   T(KI,KI)   )               ]
                    '
                    If Abs(T(KI - 1#, KI)) >= Abs(T(KI, KI - 1#)) Then
                        WORK(KI - 1# + N) = 1#
                        WORK(KI + N2) = WI / T(KI - 1#, KI)
                    Else
                        WORK(KI - 1# + N) = -(WI / T(KI, KI - 1#))
                        WORK(KI + N2) = 1#
                    End If
                    WORK(KI + N) = 0#
                    WORK(KI - 1# + N2) = 0#
                    
                    '
                    ' Form right-hand side
                    '
                    For K = 1# To KI - 2# Step 1
                        WORK(K + N) = -(WORK(KI - 1# + N) * T(K, KI - 1#))
                        WORK(K + N2) = -(WORK(KI + N2) * T(K, KI))
                    Next K
                    
                    '
                    ' Solve upper quasi-triangular system:
                    ' (T(1:KI-2,1:KI-2) - (WR+i*WI))*X = SCALE*(WORK+i*WORK2)
                    '
                    JNXT = KI - 2#
                    For j = KI - 2# To 1# Step -1
                        If j > JNXT Then
                            GoTo Cont_9
                        End If
                        J1 = j
                        J2 = j
                        JNXT = j - 1#
                        If j > 1# Then
                            If T(j, j - 1#) <> 0# Then
                                J1 = j - 1#
                                JNXT = j - 2#
                            End If
                        End If
                        If J1 = J2 Then
                            
                            '
                            ' 1-by-1 diagonal block
                            '
                            TEMP11(1#, 1#) = T(j, j)
                            TEMP12B(1#, 1#) = WORK(j + N)
                            TEMP12B(1#, 2#) = WORK(j + N + N)
                            Call InternalHSEVDLALN2(False, 1#, 2#, SMIN, 1#, TEMP11, 1#, 1#, TEMP12B, WR, WI, RSWAP4, ZSWAP4, IPIVOT44, CIV4, CRV4, X, SCL, XNorm, IERR)
                            
                            '
                            ' Scale X(1,1) and X(1,2) to avoid overflow when
                            ' updating the right-hand side.
                            '
                            If XNorm > 1# Then
                                If WORK(j) > BIGNUM / XNorm Then
                                    X(1#, 1#) = X(1#, 1#) / XNorm
                                    X(1#, 2#) = X(1#, 2#) / XNorm
                                    SCL = SCL / XNorm
                                End If
                            End If
                            
                            '
                            ' Scale if necessary
                            '
                            If SCL <> 1# Then
                                K1 = 1# + N
                                K2 = KI + N
                                For i_ = K1 To K2 Step 1
                                    WORK(i_) = SCL * WORK(i_)
                                Next i_
                                K1 = 1# + N2
                                K2 = KI + N2
                                For i_ = K1 To K2 Step 1
                                    WORK(i_) = SCL * WORK(i_)
                                Next i_
                            End If
                            WORK(j + N) = X(1#, 1#)
                            WORK(j + N2) = X(1#, 2#)
                            
                            '
                            ' Update the right-hand side
                            '
                            K1 = 1# + N
                            K2 = j - 1# + N
                            k3 = 1#
                            k4 = j - 1#
                            VT = -X(1#, 1#)
                            i1_ = (k3) - (K1)
                            For i_ = K1 To K2 Step 1
                                WORK(i_) = WORK(i_) + VT * T(i_ + i1_, j)
                            Next i_
                            K1 = 1# + N2
                            K2 = j - 1# + N2
                            k3 = 1#
                            k4 = j - 1#
                            VT = -X(1#, 2#)
                            i1_ = (k3) - (K1)
                            For i_ = K1 To K2 Step 1
                                WORK(i_) = WORK(i_) + VT * T(i_ + i1_, j)
                            Next i_
                        Else
                            
                            '
                            ' 2-by-2 diagonal block
                            '
                            TEMP22(1#, 1#) = T(j - 1#, j - 1#)
                            TEMP22(1#, 2#) = T(j - 1#, j)
                            TEMP22(2#, 1#) = T(j, j - 1#)
                            TEMP22(2#, 2#) = T(j, j)
                            TEMP22B(1#, 1#) = WORK(j - 1# + N)
                            TEMP22B(1#, 2#) = WORK(j - 1# + N + N)
                            TEMP22B(2#, 1#) = WORK(j + N)
                            TEMP22B(2#, 2#) = WORK(j + N + N)
                            Call InternalHSEVDLALN2(False, 2#, 2#, SMIN, 1#, TEMP22, 1#, 1#, TEMP22B, WR, WI, RSWAP4, ZSWAP4, IPIVOT44, CIV4, CRV4, X, SCL, XNorm, IERR)
                            
                            '
                            ' Scale X to avoid overflow when updating
                            ' the right-hand side.
                            '
                            If XNorm > 1# Then
                                Beta = MaxReal(WORK(j - 1#), WORK(j))
                                If Beta > BIGNUM / XNorm Then
                                    REC = 1# / XNorm
                                    X(1#, 1#) = X(1#, 1#) * REC
                                    X(1#, 2#) = X(1#, 2#) * REC
                                    X(2#, 1#) = X(2#, 1#) * REC
                                    X(2#, 2#) = X(2#, 2#) * REC
                                    SCL = SCL * REC
                                End If
                            End If
                            
                            '
                            ' Scale if necessary
                            '
                            If SCL <> 1# Then
                                For i_ = 1# + N To KI + N Step 1
                                    WORK(i_) = SCL * WORK(i_)
                                Next i_
                                For i_ = 1# + N2 To KI + N2 Step 1
                                    WORK(i_) = SCL * WORK(i_)
                                Next i_
                            End If
                            WORK(j - 1# + N) = X(1#, 1#)
                            WORK(j + N) = X(2#, 1#)
                            WORK(j - 1# + N2) = X(1#, 2#)
                            WORK(j + N2) = X(2#, 2#)
                            
                            '
                            ' Update the right-hand side
                            '
                            VT = -X(1#, 1#)
                            i1_ = (1#) - (N + 1#)
                            For i_ = N + 1# To N + j - 2# Step 1
                                WORK(i_) = WORK(i_) + VT * T(i_ + i1_, j - 1#)
                            Next i_
                            VT = -X(2#, 1#)
                            i1_ = (1#) - (N + 1#)
                            For i_ = N + 1# To N + j - 2# Step 1
                                WORK(i_) = WORK(i_) + VT * T(i_ + i1_, j)
                            Next i_
                            VT = -X(1#, 2#)
                            i1_ = (1#) - (N2 + 1#)
                            For i_ = N2 + 1# To N2 + j - 2# Step 1
                                WORK(i_) = WORK(i_) + VT * T(i_ + i1_, j - 1#)
                            Next i_
                            VT = -X(2#, 2#)
                            i1_ = (1#) - (N2 + 1#)
                            For i_ = N2 + 1# To N2 + j - 2# Step 1
                                WORK(i_) = WORK(i_) + VT * T(i_ + i1_, j)
                            Next i_
                        End If
Cont_9:
                    Next j
                    
                    '
                    ' Copy the vector x or Q*x to VR and normalize.
                    '
                    If Not OVER Then
                        i1_ = (N + 1#) - (1#)
                        For i_ = 1# To KI Step 1
                            VR(i_, IIS - 1#) = WORK(i_ + i1_)
                        Next i_
                        i1_ = (N2 + 1#) - (1#)
                        For i_ = 1# To KI Step 1
                            VR(i_, IIS) = WORK(i_ + i1_)
                        Next i_
                        EMAX = 0#
                        For K = 1# To KI Step 1
                            EMAX = MaxReal(EMAX, Abs(VR(K, IIS - 1#)) + Abs(VR(K, IIS)))
                        Next K
                        REMAX = 1# / EMAX
                        For i_ = 1# To KI Step 1
                            VR(i_, IIS - 1#) = REMAX * VR(i_, IIS - 1#)
                        Next i_
                        For i_ = 1# To KI Step 1
                            VR(i_, IIS) = REMAX * VR(i_, IIS)
                        Next i_
                        For K = KI + 1# To N Step 1
                            VR(K, IIS - 1#) = 0#
                            VR(K, IIS) = 0#
                        Next K
                    Else
                        If KI > 2# Then
                            For i_ = 1# To N Step 1
                                temp(i_) = VR(i_, KI - 1#)
                            Next i_
                            Call MatrixVectorMultiply(VR, 1#, N, 1#, KI - 2#, False, WORK, 1# + N, KI - 2# + N, 1#, temp, 1#, N, WORK(KI - 1# + N))
                            For i_ = 1# To N Step 1
                                VR(i_, KI - 1#) = temp(i_)
                            Next i_
                            For i_ = 1# To N Step 1
                                temp(i_) = VR(i_, KI)
                            Next i_
                            Call MatrixVectorMultiply(VR, 1#, N, 1#, KI - 2#, False, WORK, 1# + N2, KI - 2# + N2, 1#, temp, 1#, N, WORK(KI + N2))
                            For i_ = 1# To N Step 1
                                VR(i_, KI) = temp(i_)
                            Next i_
                        Else
                            VT = WORK(KI - 1# + N)
                            For i_ = 1# To N Step 1
                                VR(i_, KI - 1#) = VT * VR(i_, KI - 1#)
                            Next i_
                            VT = WORK(KI + N2)
                            For i_ = 1# To N Step 1
                                VR(i_, KI) = VT * VR(i_, KI)
                            Next i_
                        End If
                        EMAX = 0#
                        For K = 1# To N Step 1
                            EMAX = MaxReal(EMAX, Abs(VR(K, KI - 1#)) + Abs(VR(K, KI)))
                        Next K
                        REMAX = 1# / EMAX
                        For i_ = 1# To N Step 1
                            VR(i_, KI - 1#) = REMAX * VR(i_, KI - 1#)
                        Next i_
                        For i_ = 1# To N Step 1
                            VR(i_, KI) = REMAX * VR(i_, KI)
                        Next i_
                    End If
                End If
                IIS = IIS - 1#
                If IP <> 0# Then
                    IIS = IIS - 1#
                End If
            End If
            If IP = 1# Then
                IP = 0#
            End If
            If IP = -1# Then
                IP = 1#
            End If
        Next KI
    End If
    If LEFTV Then
        
        '
        ' Compute left eigenvectors.
        '
        IP = 0#
        IIS = 1#
        For KI = 1# To N Step 1
            SkipFlag = False
            If IP = -1# Then
                SkipFlag = True
            Else
                If KI <> N Then
                    If T(KI + 1#, KI) <> 0# Then
                        IP = 1#
                    End If
                End If
                If SOMEV Then
                    If Not VSELECT(KI) Then
                        SkipFlag = True
                    End If
                End If
            End If
            If Not SkipFlag Then
                
                '
                ' Compute the KI-th eigenvalue (WR,WI).
                '
                WR = T(KI, KI)
                WI = 0#
                If IP <> 0# Then
                    WI = Sqr(Abs(T(KI, KI + 1#))) * Sqr(Abs(T(KI + 1#, KI)))
                End If
                SMIN = MaxReal(Ulp * (Abs(WR) + Abs(WI)), SMLNUM)
                If IP = 0# Then
                    
                    '
                    ' Real left eigenvector.
                    '
                    WORK(KI + N) = 1#
                    
                    '
                    ' Form right-hand side
                    '
                    For K = KI + 1# To N Step 1
                        WORK(K + N) = -T(KI, K)
                    Next K
                    
                    '
                    ' Solve the quasi-triangular system:
                    ' (T(KI+1:N,KI+1:N) - WR)'*X = SCALE*WORK
                    '
                    VMax = 1#
                    VCRIT = BIGNUM
                    JNXT = KI + 1#
                    For j = KI + 1# To N Step 1
                        If j < JNXT Then
                            GoTo Cont_15
                        End If
                        J1 = j
                        J2 = j
                        JNXT = j + 1#
                        If j < N Then
                            If T(j + 1#, j) <> 0# Then
                                J2 = j + 1#
                                JNXT = j + 2#
                            End If
                        End If
                        If J1 = J2 Then
                            
                            '
                            ' 1-by-1 diagonal block
                            '
                            ' Scale if necessary to avoid overflow when forming
                            ' the right-hand side.
                            '
                            If WORK(j) > VCRIT Then
                                REC = 1# / VMax
                                For i_ = KI + N To N + N Step 1
                                    WORK(i_) = REC * WORK(i_)
                                Next i_
                                VMax = 1#
                                VCRIT = BIGNUM
                            End If
                            i1_ = (KI + 1# + N) - (KI + 1#)
                            VT = 0#
                            For i_ = KI + 1# To j - 1# Step 1
                                VT = VT + T(i_, j) * WORK(i_ + i1_)
                            Next i_
                            WORK(j + N) = WORK(j + N) - VT
                            
                            '
                            ' Solve (T(J,J)-WR)'*X = WORK
                            '
                            TEMP11(1#, 1#) = T(j, j)
                            TEMP11B(1#, 1#) = WORK(j + N)
                            Call InternalHSEVDLALN2(False, 1#, 1#, SMIN, 1#, TEMP11, 1#, 1#, TEMP11B, WR, 0#, RSWAP4, ZSWAP4, IPIVOT44, CIV4, CRV4, X, SCL, XNorm, IERR)
                            
                            '
                            ' Scale if necessary
                            '
                            If SCL <> 1# Then
                                For i_ = KI + N To N + N Step 1
                                    WORK(i_) = SCL * WORK(i_)
                                Next i_
                            End If
                            WORK(j + N) = X(1#, 1#)
                            VMax = MaxReal(Abs(WORK(j + N)), VMax)
                            VCRIT = BIGNUM / VMax
                        Else
                            
                            '
                            ' 2-by-2 diagonal block
                            '
                            ' Scale if necessary to avoid overflow when forming
                            ' the right-hand side.
                            '
                            Beta = MaxReal(WORK(j), WORK(j + 1#))
                            If Beta > VCRIT Then
                                REC = 1# / VMax
                                For i_ = KI + N To N + N Step 1
                                    WORK(i_) = REC * WORK(i_)
                                Next i_
                                VMax = 1#
                                VCRIT = BIGNUM
                            End If
                            i1_ = (KI + 1# + N) - (KI + 1#)
                            VT = 0#
                            For i_ = KI + 1# To j - 1# Step 1
                                VT = VT + T(i_, j) * WORK(i_ + i1_)
                            Next i_
                            WORK(j + N) = WORK(j + N) - VT
                            i1_ = (KI + 1# + N) - (KI + 1#)
                            VT = 0#
                            For i_ = KI + 1# To j - 1# Step 1
                                VT = VT + T(i_, j + 1#) * WORK(i_ + i1_)
                            Next i_
                            WORK(j + 1# + N) = WORK(j + 1# + N) - VT
                            
                            '
                            ' Solve
                            '    [T(J,J)-WR   T(J,J+1)     ]'* X = SCALE*( WORK1 )
                            '    [T(J+1,J)    T(J+1,J+1)-WR]             ( WORK2 )
                            '
                            TEMP22(1#, 1#) = T(j, j)
                            TEMP22(1#, 2#) = T(j, j + 1#)
                            TEMP22(2#, 1#) = T(j + 1#, j)
                            TEMP22(2#, 2#) = T(j + 1#, j + 1#)
                            TEMP21B(1#, 1#) = WORK(j + N)
                            TEMP21B(2#, 1#) = WORK(j + 1# + N)
                            Call InternalHSEVDLALN2(True, 2#, 1#, SMIN, 1#, TEMP22, 1#, 1#, TEMP21B, WR, 0#, RSWAP4, ZSWAP4, IPIVOT44, CIV4, CRV4, X, SCL, XNorm, IERR)
                            
                            '
                            ' Scale if necessary
                            '
                            If SCL <> 1# Then
                                For i_ = KI + N To N + N Step 1
                                    WORK(i_) = SCL * WORK(i_)
                                Next i_
                            End If
                            WORK(j + N) = X(1#, 1#)
                            WORK(j + 1# + N) = X(2#, 1#)
                            VMax = MaxReal(Abs(WORK(j + N)), MaxReal(Abs(WORK(j + 1# + N)), VMax))
                            VCRIT = BIGNUM / VMax
                        End If
Cont_15:
                    Next j
                    
                    '
                    ' Copy the vector x or Q*x to VL and normalize.
                    '
                    If Not OVER Then
                        i1_ = (KI + N) - (KI)
                        For i_ = KI To N Step 1
                            VL(i_, IIS) = WORK(i_ + i1_)
                        Next i_
                        II = ColumnIdxAbsMax(VL, KI, N, IIS)
                        REMAX = 1# / Abs(VL(II, IIS))
                        For i_ = KI To N Step 1
                            VL(i_, IIS) = REMAX * VL(i_, IIS)
                        Next i_
                        For K = 1# To KI - 1# Step 1
                            VL(K, IIS) = 0#
                        Next K
                    Else
                        If KI < N Then
                            For i_ = 1# To N Step 1
                                temp(i_) = VL(i_, KI)
                            Next i_
                            Call MatrixVectorMultiply(VL, 1#, N, KI + 1#, N, False, WORK, KI + 1# + N, N + N, 1#, temp, 1#, N, WORK(KI + N))
                            For i_ = 1# To N Step 1
                                VL(i_, KI) = temp(i_)
                            Next i_
                        End If
                        II = ColumnIdxAbsMax(VL, 1#, N, KI)
                        REMAX = 1# / Abs(VL(II, KI))
                        For i_ = 1# To N Step 1
                            VL(i_, KI) = REMAX * VL(i_, KI)
                        Next i_
                    End If
                Else
                    
                    '
                    ' Complex left eigenvector.
                    '
                    ' Initial solve:
                    '   ((T(KI,KI)    T(KI,KI+1) )' - (WR - I* WI))*X = 0.
                    '   ((T(KI+1,KI) T(KI+1,KI+1))                )
                    '
                    If Abs(T(KI, KI + 1#)) >= Abs(T(KI + 1#, KI)) Then
                        WORK(KI + N) = WI / T(KI, KI + 1#)
                        WORK(KI + 1# + N2) = 1#
                    Else
                        WORK(KI + N) = 1#
                        WORK(KI + 1# + N2) = -(WI / T(KI + 1#, KI))
                    End If
                    WORK(KI + 1# + N) = 0#
                    WORK(KI + N2) = 0#
                    
                    '
                    ' Form right-hand side
                    '
                    For K = KI + 2# To N Step 1
                        WORK(K + N) = -(WORK(KI + N) * T(KI, K))
                        WORK(K + N2) = -(WORK(KI + 1# + N2) * T(KI + 1#, K))
                    Next K
                    
                    '
                    ' Solve complex quasi-triangular system:
                    ' ( T(KI+2,N:KI+2,N) - (WR-i*WI) )*X = WORK1+i*WORK2
                    '
                    VMax = 1#
                    VCRIT = BIGNUM
                    JNXT = KI + 2#
                    For j = KI + 2# To N Step 1
                        If j < JNXT Then
                            GoTo Cont_18
                        End If
                        J1 = j
                        J2 = j
                        JNXT = j + 1#
                        If j < N Then
                            If T(j + 1#, j) <> 0# Then
                                J2 = j + 1#
                                JNXT = j + 2#
                            End If
                        End If
                        If J1 = J2 Then
                            
                            '
                            ' 1-by-1 diagonal block
                            '
                            ' Scale if necessary to avoid overflow when
                            ' forming the right-hand side elements.
                            '
                            If WORK(j) > VCRIT Then
                                REC = 1# / VMax
                                For i_ = KI + N To N + N Step 1
                                    WORK(i_) = REC * WORK(i_)
                                Next i_
                                For i_ = KI + N2 To N + N2 Step 1
                                    WORK(i_) = REC * WORK(i_)
                                Next i_
                                VMax = 1#
                                VCRIT = BIGNUM
                            End If
                            i1_ = (KI + 2# + N) - (KI + 2#)
                            VT = 0#
                            For i_ = KI + 2# To j - 1# Step 1
                                VT = VT + T(i_, j) * WORK(i_ + i1_)
                            Next i_
                            WORK(j + N) = WORK(j + N) - VT
                            i1_ = (KI + 2# + N2) - (KI + 2#)
                            VT = 0#
                            For i_ = KI + 2# To j - 1# Step 1
                                VT = VT + T(i_, j) * WORK(i_ + i1_)
                            Next i_
                            WORK(j + N2) = WORK(j + N2) - VT
                            
                            '
                            ' Solve (T(J,J)-(WR-i*WI))*(X11+i*X12)= WK+I*WK2
                            '
                            TEMP11(1#, 1#) = T(j, j)
                            TEMP12B(1#, 1#) = WORK(j + N)
                            TEMP12B(1#, 2#) = WORK(j + N + N)
                            Call InternalHSEVDLALN2(False, 1#, 2#, SMIN, 1#, TEMP11, 1#, 1#, TEMP12B, WR, -WI, RSWAP4, ZSWAP4, IPIVOT44, CIV4, CRV4, X, SCL, XNorm, IERR)
                            
                            '
                            ' Scale if necessary
                            '
                            If SCL <> 1# Then
                                For i_ = KI + N To N + N Step 1
                                    WORK(i_) = SCL * WORK(i_)
                                Next i_
                                For i_ = KI + N2 To N + N2 Step 1
                                    WORK(i_) = SCL * WORK(i_)
                                Next i_
                            End If
                            WORK(j + N) = X(1#, 1#)
                            WORK(j + N2) = X(1#, 2#)
                            VMax = MaxReal(Abs(WORK(j + N)), MaxReal(Abs(WORK(j + N2)), VMax))
                            VCRIT = BIGNUM / VMax
                        Else
                            
                            '
                            ' 2-by-2 diagonal block
                            '
                            ' Scale if necessary to avoid overflow when forming
                            ' the right-hand side elements.
                            '
                            Beta = MaxReal(WORK(j), WORK(j + 1#))
                            If Beta > VCRIT Then
                                REC = 1# / VMax
                                For i_ = KI + N To N + N Step 1
                                    WORK(i_) = REC * WORK(i_)
                                Next i_
                                For i_ = KI + N2 To N + N2 Step 1
                                    WORK(i_) = REC * WORK(i_)
                                Next i_
                                VMax = 1#
                                VCRIT = BIGNUM
                            End If
                            i1_ = (KI + 2# + N) - (KI + 2#)
                            VT = 0#
                            For i_ = KI + 2# To j - 1# Step 1
                                VT = VT + T(i_, j) * WORK(i_ + i1_)
                            Next i_
                            WORK(j + N) = WORK(j + N) - VT
                            i1_ = (KI + 2# + N2) - (KI + 2#)
                            VT = 0#
                            For i_ = KI + 2# To j - 1# Step 1
                                VT = VT + T(i_, j) * WORK(i_ + i1_)
                            Next i_
                            WORK(j + N2) = WORK(j + N2) - VT
                            i1_ = (KI + 2# + N) - (KI + 2#)
                            VT = 0#
                            For i_ = KI + 2# To j - 1# Step 1
                                VT = VT + T(i_, j + 1#) * WORK(i_ + i1_)
                            Next i_
                            WORK(j + 1# + N) = WORK(j + 1# + N) - VT
                            i1_ = (KI + 2# + N2) - (KI + 2#)
                            VT = 0#
                            For i_ = KI + 2# To j - 1# Step 1
                                VT = VT + T(i_, j + 1#) * WORK(i_ + i1_)
                            Next i_
                            WORK(j + 1# + N2) = WORK(j + 1# + N2) - VT
                            
                            '
                            ' Solve 2-by-2 complex linear equation
                            '   ([T(j,j)   T(j,j+1)  ]'-(wr-i*wi)*I)*X = SCALE*B
                            '   ([T(j+1,j) T(j+1,j+1)]             )
                            '
                            TEMP22(1#, 1#) = T(j, j)
                            TEMP22(1#, 2#) = T(j, j + 1#)
                            TEMP22(2#, 1#) = T(j + 1#, j)
                            TEMP22(2#, 2#) = T(j + 1#, j + 1#)
                            TEMP22B(1#, 1#) = WORK(j + N)
                            TEMP22B(1#, 2#) = WORK(j + N + N)
                            TEMP22B(2#, 1#) = WORK(j + 1# + N)
                            TEMP22B(2#, 2#) = WORK(j + 1# + N + N)
                            Call InternalHSEVDLALN2(True, 2#, 2#, SMIN, 1#, TEMP22, 1#, 1#, TEMP22B, WR, -WI, RSWAP4, ZSWAP4, IPIVOT44, CIV4, CRV4, X, SCL, XNorm, IERR)
                            
                            '
                            ' Scale if necessary
                            '
                            If SCL <> 1# Then
                                For i_ = KI + N To N + N Step 1
                                    WORK(i_) = SCL * WORK(i_)
                                Next i_
                                For i_ = KI + N2 To N + N2 Step 1
                                    WORK(i_) = SCL * WORK(i_)
                                Next i_
                            End If
                            WORK(j + N) = X(1#, 1#)
                            WORK(j + N2) = X(1#, 2#)
                            WORK(j + 1# + N) = X(2#, 1#)
                            WORK(j + 1# + N2) = X(2#, 2#)
                            VMax = MaxReal(Abs(X(1#, 1#)), VMax)
                            VMax = MaxReal(Abs(X(1#, 2#)), VMax)
                            VMax = MaxReal(Abs(X(2#, 1#)), VMax)
                            VMax = MaxReal(Abs(X(2#, 2#)), VMax)
                            VCRIT = BIGNUM / VMax
                        End If
Cont_18:
                    Next j
                    
                    '
                    ' Copy the vector x or Q*x to VL and normalize.
                    '
                    If Not OVER Then
                        i1_ = (KI + N) - (KI)
                        For i_ = KI To N Step 1
                            VL(i_, IIS) = WORK(i_ + i1_)
                        Next i_
                        i1_ = (KI + N2) - (KI)
                        For i_ = KI To N Step 1
                            VL(i_, IIS + 1#) = WORK(i_ + i1_)
                        Next i_
                        EMAX = 0#
                        For K = KI To N Step 1
                            EMAX = MaxReal(EMAX, Abs(VL(K, IIS)) + Abs(VL(K, IIS + 1#)))
                        Next K
                        REMAX = 1# / EMAX
                        For i_ = KI To N Step 1
                            VL(i_, IIS) = REMAX * VL(i_, IIS)
                        Next i_
                        For i_ = KI To N Step 1
                            VL(i_, IIS + 1#) = REMAX * VL(i_, IIS + 1#)
                        Next i_
                        For K = 1# To KI - 1# Step 1
                            VL(K, IIS) = 0#
                            VL(K, IIS + 1#) = 0#
                        Next K
                    Else
                        If KI < N - 1# Then
                            For i_ = 1# To N Step 1
                                temp(i_) = VL(i_, KI)
                            Next i_
                            Call MatrixVectorMultiply(VL, 1#, N, KI + 2#, N, False, WORK, KI + 2# + N, N + N, 1#, temp, 1#, N, WORK(KI + N))
                            For i_ = 1# To N Step 1
                                VL(i_, KI) = temp(i_)
                            Next i_
                            For i_ = 1# To N Step 1
                                temp(i_) = VL(i_, KI + 1#)
                            Next i_
                            Call MatrixVectorMultiply(VL, 1#, N, KI + 2#, N, False, WORK, KI + 2# + N2, N + N2, 1#, temp, 1#, N, WORK(KI + 1# + N2))
                            For i_ = 1# To N Step 1
                                VL(i_, KI + 1#) = temp(i_)
                            Next i_
                        Else
                            VT = WORK(KI + N)
                            For i_ = 1# To N Step 1
                                VL(i_, KI) = VT * VL(i_, KI)
                            Next i_
                            VT = WORK(KI + 1# + N2)
                            For i_ = 1# To N Step 1
                                VL(i_, KI + 1#) = VT * VL(i_, KI + 1#)
                            Next i_
                        End If
                        EMAX = 0#
                        For K = 1# To N Step 1
                            EMAX = MaxReal(EMAX, Abs(VL(K, KI)) + Abs(VL(K, KI + 1#)))
                        Next K
                        REMAX = 1# / EMAX
                        For i_ = 1# To N Step 1
                            VL(i_, KI) = REMAX * VL(i_, KI)
                        Next i_
                        For i_ = 1# To N Step 1
                            VL(i_, KI + 1#) = REMAX * VL(i_, KI + 1#)
                        Next i_
                    End If
                End If
                IIS = IIS + 1#
                If IP <> 0# Then
                    IIS = IIS + 1#
                End If
            End If
            If IP = -1# Then
                IP = 0#
            End If
            If IP = 1# Then
                IP = -1#
            End If
        Next KI
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'DLALN2 solves a system of the form  (ca A - w D ) X = s B
'or (ca A' - w D) X = s B   with possible scaling ("s") and
'perturbation of A.  (A' means A-transpose.)
'
'A is an NA x NA real matrix, ca is a real scalar, D is an NA x NA
'real diagonal matrix, w is a real or complex value, and X and B are
'NA x 1 matrices -- real if w is real, complex if w is complex.  NA
'may be 1 or 2.
'
'If w is complex, X and B are represented as NA x 2 matrices,
'the first column of each being the real part and the second
'being the imaginary part.
'
'"s" is a scaling factor (.LE. 1), computed by DLALN2, which is
'so chosen that X can be computed without overflow.  X is further
'scaled if necessary to assure that norm(ca A - w D)*norm(X) is less
'than overflow.
'
'If both singular values of (ca A - w D) are less than SMIN,
'SMIN*identity will be used instead of (ca A - w D).  If only one
'singular value is less than SMIN, one element of (ca A - w D) will be
'perturbed enough to make the smallest singular value roughly SMIN.
'If both singular values are at least SMIN, (ca A - w D) will not be
'perturbed.  In any case, the perturbation will be at most some small
'multiple of max( SMIN, ulp*norm(ca A - w D) ).  The singular values
'are computed by infinity-norm approximations, and thus will only be
'correct to a factor of 2 or so.
'
'Note: all input quantities are assumed to be smaller than overflow
'by a reasonable factor.  (See BIGNUM.)
'
'  -- LAPACK auxiliary routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     October 31, 1992
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub InternalHSEVDLALN2(ByRef LTRANS As Boolean, _
         ByRef NA As Long, _
         ByRef NW As Long, _
         ByRef SMIN As Double, _
         ByRef CA As Double, _
         ByRef A() As Double, _
         ByRef D1 As Double, _
         ByRef D2 As Double, _
         ByRef B() As Double, _
         ByRef WR As Double, _
         ByRef WI As Double, _
         ByRef RSWAP4() As Boolean, _
         ByRef ZSWAP4() As Boolean, _
         ByRef IPIVOT44() As Long, _
         ByRef CIV4() As Double, _
         ByRef CRV4() As Double, _
         ByRef X() As Double, _
         ByRef SCL As Double, _
         ByRef XNorm As Double, _
         ByRef Info As Long)
    Dim ICMAX As Long
    Dim j As Long
    Dim BBND As Double
    Dim BI1 As Double
    Dim BI2 As Double
    Dim BIGNUM As Double
    Dim BNorm As Double
    Dim BR1 As Double
    Dim BR2 As Double
    Dim CI21 As Double
    Dim CI22 As Double
    Dim CMAX As Double
    Dim CNORM As Double
    Dim CR21 As Double
    Dim CR22 As Double
    Dim CSI As Double
    Dim CSR As Double
    Dim LI21 As Double
    Dim LR21 As Double
    Dim SMINI As Double
    Dim SMLNUM As Double
    Dim temp As Double
    Dim U22ABS As Double
    Dim UI11 As Double
    Dim UI11R As Double
    Dim UI12 As Double
    Dim UI12S As Double
    Dim UI22 As Double
    Dim UR11 As Double
    Dim UR11R As Double
    Dim UR12 As Double
    Dim UR12S As Double
    Dim UR22 As Double
    Dim XI1 As Double
    Dim XI2 As Double
    Dim XR1 As Double
    Dim XR2 As Double
    Dim TMP1 As Double
    Dim Tmp2 As Double
    ZSWAP4(1#) = False
    ZSWAP4(2#) = False
    ZSWAP4(3#) = True
    ZSWAP4(4#) = True
    RSWAP4(1#) = False
    RSWAP4(2#) = True
    RSWAP4(3#) = False
    RSWAP4(4#) = True
    IPIVOT44(1#, 1#) = 1#
    IPIVOT44(2#, 1#) = 2#
    IPIVOT44(3#, 1#) = 3#
    IPIVOT44(4#, 1#) = 4#
    IPIVOT44(1#, 2#) = 2#
    IPIVOT44(2#, 2#) = 1#
    IPIVOT44(3#, 2#) = 4#
    IPIVOT44(4#, 2#) = 3#
    IPIVOT44(1#, 3#) = 3#
    IPIVOT44(2#, 3#) = 4#
    IPIVOT44(3#, 3#) = 1#
    IPIVOT44(4#, 3#) = 2#
    IPIVOT44(1#, 4#) = 4#
    IPIVOT44(2#, 4#) = 3#
    IPIVOT44(3#, 4#) = 2#
    IPIVOT44(4#, 4#) = 1#
    SMLNUM = 2# * MinRealNumber
    BIGNUM = 1# / SMLNUM
    SMINI = MaxReal(SMIN, SMLNUM)
    
    '
    ' Don't check for input errors
    '
    Info = 0#
    
    '
    ' Standard Initializations
    '
    SCL = 1#
    If NA = 1# Then
        
        '
        ' 1 x 1  (i.e., scalar) system   C X = B
        '
        If NW = 1# Then
            
            '
            ' Real 1x1 system.
            '
            ' C = ca A - w D
            '
            CSR = CA * A(1#, 1#) - WR * D1
            CNORM = Abs(CSR)
            
            '
            ' If | C | < SMINI, use C = SMINI
            '
            If CNORM < SMINI Then
                CSR = SMINI
                CNORM = SMINI
                Info = 1#
            End If
            
            '
            ' Check scaling for  X = B / C
            '
            BNorm = Abs(B(1#, 1#))
            If CNORM < 1# And BNorm > 1# Then
                If BNorm > BIGNUM * CNORM Then
                    SCL = 1# / BNorm
                End If
            End If
            
            '
            ' Compute X
            '
            X(1#, 1#) = B(1#, 1#) * SCL / CSR
            XNorm = Abs(X(1#, 1#))
        Else
            
            '
            ' Complex 1x1 system (w is complex)
            '
            ' C = ca A - w D
            '
            CSR = CA * A(1#, 1#) - WR * D1
            CSI = -(WI * D1)
            CNORM = Abs(CSR) + Abs(CSI)
            
            '
            ' If | C | < SMINI, use C = SMINI
            '
            If CNORM < SMINI Then
                CSR = SMINI
                CSI = 0#
                CNORM = SMINI
                Info = 1#
            End If
            
            '
            ' Check scaling for  X = B / C
            '
            BNorm = Abs(B(1#, 1#)) + Abs(B(1#, 2#))
            If CNORM < 1# And BNorm > 1# Then
                If BNorm > BIGNUM * CNORM Then
                    SCL = 1# / BNorm
                End If
            End If
            
            '
            ' Compute X
            '
            Call InternalHSEVDLADIV(SCL * B(1#, 1#), SCL * B(1#, 2#), CSR, CSI, TMP1, Tmp2)
            X(1#, 1#) = TMP1
            X(1#, 2#) = Tmp2
            XNorm = Abs(X(1#, 1#)) + Abs(X(1#, 2#))
        End If
    Else
        
        '
        ' 2x2 System
        '
        ' Compute the real part of  C = ca A - w D  (or  ca A' - w D )
        '
        CRV4(1# + 0#) = CA * A(1#, 1#) - WR * D1
        CRV4(2# + 2#) = CA * A(2#, 2#) - WR * D2
        If LTRANS Then
            CRV4(1# + 2#) = CA * A(2#, 1#)
            CRV4(2# + 0#) = CA * A(1#, 2#)
        Else
            CRV4(2# + 0#) = CA * A(2#, 1#)
            CRV4(1# + 2#) = CA * A(1#, 2#)
        End If
        If NW = 1# Then
            
            '
            ' Real 2x2 system  (w is real)
            '
            ' Find the largest element in C
            '
            CMAX = 0#
            ICMAX = 0#
            For j = 1# To 4# Step 1
                If Abs(CRV4(j)) > CMAX Then
                    CMAX = Abs(CRV4(j))
                    ICMAX = j
                End If
            Next j
            
            '
            ' If norm(C) < SMINI, use SMINI*identity.
            '
            If CMAX < SMINI Then
                BNorm = MaxReal(Abs(B(1#, 1#)), Abs(B(2#, 1#)))
                If SMINI < 1# And BNorm > 1# Then
                    If BNorm > BIGNUM * SMINI Then
                        SCL = 1# / BNorm
                    End If
                End If
                temp = SCL / SMINI
                X(1#, 1#) = temp * B(1#, 1#)
                X(2#, 1#) = temp * B(2#, 1#)
                XNorm = temp * BNorm
                Info = 1#
                Exit Sub
            End If
            
            '
            ' Gaussian elimination with complete pivoting.
            '
            UR11 = CRV4(ICMAX)
            CR21 = CRV4(IPIVOT44(2#, ICMAX))
            UR12 = CRV4(IPIVOT44(3#, ICMAX))
            CR22 = CRV4(IPIVOT44(4#, ICMAX))
            UR11R = 1# / UR11
            LR21 = UR11R * CR21
            UR22 = CR22 - UR12 * LR21
            
            '
            ' If smaller pivot < SMINI, use SMINI
            '
            If Abs(UR22) < SMINI Then
                UR22 = SMINI
                Info = 1#
            End If
            If RSWAP4(ICMAX) Then
                BR1 = B(2#, 1#)
                BR2 = B(1#, 1#)
            Else
                BR1 = B(1#, 1#)
                BR2 = B(2#, 1#)
            End If
            BR2 = BR2 - LR21 * BR1
            BBND = MaxReal(Abs(BR1 * (UR22 * UR11R)), Abs(BR2))
            If BBND > 1# And Abs(UR22) < 1# Then
                If BBND >= BIGNUM * Abs(UR22) Then
                    SCL = 1# / BBND
                End If
            End If
            XR2 = BR2 * SCL / UR22
            XR1 = SCL * BR1 * UR11R - XR2 * (UR11R * UR12)
            If ZSWAP4(ICMAX) Then
                X(1#, 1#) = XR2
                X(2#, 1#) = XR1
            Else
                X(1#, 1#) = XR1
                X(2#, 1#) = XR2
            End If
            XNorm = MaxReal(Abs(XR1), Abs(XR2))
            
            '
            ' Further scaling if  norm(A) norm(X) > overflow
            '
            If XNorm > 1# And CMAX > 1# Then
                If XNorm > BIGNUM / CMAX Then
                    temp = CMAX / BIGNUM
                    X(1#, 1#) = temp * X(1#, 1#)
                    X(2#, 1#) = temp * X(2#, 1#)
                    XNorm = temp * XNorm
                    SCL = temp * SCL
                End If
            End If
        Else
            
            '
            ' Complex 2x2 system  (w is complex)
            '
            ' Find the largest element in C
            '
            CIV4(1# + 0#) = -(WI * D1)
            CIV4(2# + 0#) = 0#
            CIV4(1# + 2#) = 0#
            CIV4(2# + 2#) = -(WI * D2)
            CMAX = 0#
            ICMAX = 0#
            For j = 1# To 4# Step 1
                If Abs(CRV4(j)) + Abs(CIV4(j)) > CMAX Then
                    CMAX = Abs(CRV4(j)) + Abs(CIV4(j))
                    ICMAX = j
                End If
            Next j
            
            '
            ' If norm(C) < SMINI, use SMINI*identity.
            '
            If CMAX < SMINI Then
                BNorm = MaxReal(Abs(B(1#, 1#)) + Abs(B(1#, 2#)), Abs(B(2#, 1#)) + Abs(B(2#, 2#)))
                If SMINI < 1# And BNorm > 1# Then
                    If BNorm > BIGNUM * SMINI Then
                        SCL = 1# / BNorm
                    End If
                End If
                temp = SCL / SMINI
                X(1#, 1#) = temp * B(1#, 1#)
                X(2#, 1#) = temp * B(2#, 1#)
                X(1#, 2#) = temp * B(1#, 2#)
                X(2#, 2#) = temp * B(2#, 2#)
                XNorm = temp * BNorm
                Info = 1#
                Exit Sub
            End If
            
            '
            ' Gaussian elimination with complete pivoting.
            '
            UR11 = CRV4(ICMAX)
            UI11 = CIV4(ICMAX)
            CR21 = CRV4(IPIVOT44(2#, ICMAX))
            CI21 = CIV4(IPIVOT44(2#, ICMAX))
            UR12 = CRV4(IPIVOT44(3#, ICMAX))
            UI12 = CIV4(IPIVOT44(3#, ICMAX))
            CR22 = CRV4(IPIVOT44(4#, ICMAX))
            CI22 = CIV4(IPIVOT44(4#, ICMAX))
            If ICMAX = 1# Or ICMAX = 4# Then
                
                '
                ' Code when off-diagonals of pivoted C are real
                '
                If Abs(UR11) > Abs(UI11) Then
                    temp = UI11 / UR11
                    UR11R = 1# / (UR11 * (1# + Square(temp)))
                    UI11R = -(temp * UR11R)
                Else
                    temp = UR11 / UI11
                    UI11R = -(1# / (UI11 * (1# + Square(temp))))
                    UR11R = -(temp * UI11R)
                End If
                LR21 = CR21 * UR11R
                LI21 = CR21 * UI11R
                UR12S = UR12 * UR11R
                UI12S = UR12 * UI11R
                UR22 = CR22 - UR12 * LR21
                UI22 = CI22 - UR12 * LI21
            Else
                
                '
                ' Code when diagonals of pivoted C are real
                '
                UR11R = 1# / UR11
                UI11R = 0#
                LR21 = CR21 * UR11R
                LI21 = CI21 * UR11R
                UR12S = UR12 * UR11R
                UI12S = UI12 * UR11R
                UR22 = CR22 - UR12 * LR21 + UI12 * LI21
                UI22 = -(UR12 * LI21) - UI12 * LR21
            End If
            U22ABS = Abs(UR22) + Abs(UI22)
            
            '
            ' If smaller pivot < SMINI, use SMINI
            '
            If U22ABS < SMINI Then
                UR22 = SMINI
                UI22 = 0#
                Info = 1#
            End If
            If RSWAP4(ICMAX) Then
                BR2 = B(1#, 1#)
                BR1 = B(2#, 1#)
                BI2 = B(1#, 2#)
                BI1 = B(2#, 2#)
            Else
                BR1 = B(1#, 1#)
                BR2 = B(2#, 1#)
                BI1 = B(1#, 2#)
                BI2 = B(2#, 2#)
            End If
            BR2 = BR2 - LR21 * BR1 + LI21 * BI1
            BI2 = BI2 - LI21 * BR1 - LR21 * BI1
            BBND = MaxReal((Abs(BR1) + Abs(BI1)) * (U22ABS * (Abs(UR11R) + Abs(UI11R))), Abs(BR2) + Abs(BI2))
            If BBND > 1# And U22ABS < 1# Then
                If BBND >= BIGNUM * U22ABS Then
                    SCL = 1# / BBND
                    BR1 = SCL * BR1
                    BI1 = SCL * BI1
                    BR2 = SCL * BR2
                    BI2 = SCL * BI2
                End If
            End If
            Call InternalHSEVDLADIV(BR2, BI2, UR22, UI22, XR2, XI2)
            XR1 = UR11R * BR1 - UI11R * BI1 - UR12S * XR2 + UI12S * XI2
            XI1 = UI11R * BR1 + UR11R * BI1 - UI12S * XR2 - UR12S * XI2
            If ZSWAP4(ICMAX) Then
                X(1#, 1#) = XR2
                X(2#, 1#) = XR1
                X(1#, 2#) = XI2
                X(2#, 2#) = XI1
            Else
                X(1#, 1#) = XR1
                X(2#, 1#) = XR2
                X(1#, 2#) = XI1
                X(2#, 2#) = XI2
            End If
            XNorm = MaxReal(Abs(XR1) + Abs(XI1), Abs(XR2) + Abs(XI2))
            
            '
            ' Further scaling if  norm(A) norm(X) > overflow
            '
            If XNorm > 1# And CMAX > 1# Then
                If XNorm > BIGNUM / CMAX Then
                    temp = CMAX / BIGNUM
                    X(1#, 1#) = temp * X(1#, 1#)
                    X(2#, 1#) = temp * X(2#, 1#)
                    X(1#, 2#) = temp * X(1#, 2#)
                    X(2#, 2#) = temp * X(2#, 2#)
                    XNorm = temp * XNorm
                    SCL = temp * SCL
                End If
            End If
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'performs complex division in  real arithmetic
'
'                        a + i*b
'             p + i*q = ---------
'                        c + i*d
'
'The algorithm is due to Robert L. Smith and can be found
'in D. Knuth, The art of Computer Programming, Vol.2, p.195
'
'  -- LAPACK auxiliary routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     October 31, 1992
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub InternalHSEVDLADIV(ByRef A As Double, _
         ByRef B As Double, _
         ByRef C As Double, _
         ByRef D As Double, _
         ByRef p As Double, _
         ByRef q As Double)
    Dim E As Double
    Dim F As Double
    If Abs(D) < Abs(C) Then
        E = D / C
        F = C + D * E
        p = (A + B * E) / F
        q = (B - A * E) / F
    Else
        E = C / D
        F = D + C * E
        p = (B + A * E) / F
        q = (-A + B * E) / F
    End If
End Sub
Private Function NonSymmetricEVD(ByRef A_() As Double, _
         ByVal N As Long, _
         ByVal VNeeded As Long, _
         ByRef WR() As Double, _
         ByRef WI() As Double, _
         ByRef VL() As Double, _
         ByRef VR() As Double) As Boolean
    Dim Result As Boolean
    Dim A() As Double
    Dim S() As Double
    Dim Tau() As Double
    Dim SEL() As Boolean
    Dim i As Long
    Dim Info As Long
    Dim M As Long
    Dim i_ As Long
    A = A_
    If VNeeded = 0# Then
        
        '
        ' Eigen values only
        '
        Call ToUpperHessenberg(A, N, Tau)
        Call InternalSchurDecomposition(A, N, 0#, 0#, WR, WI, S, Info)
        Result = Info = 0#
        NonSymmetricEVD = Result
        Exit Function
    End If
    
    '
    ' Eigen values and vectors
    '
    Call ToUpperHessenberg(A, N, Tau)
    Call UnpackQFromUpperHessenberg(A, N, Tau, S)
    Call InternalSchurDecomposition(A, N, 1#, 1#, WR, WI, S, Info)
    Result = Info = 0#
    If Not Result Then
        NonSymmetricEVD = Result
        Exit Function
    End If
    If VNeeded = 1# Or VNeeded = 3# Then
        ReDim VR(1# To N, 1# To N)
        For i = 1# To N Step 1
            For i_ = 1# To N Step 1
                VR(i, i_) = S(i, i_)
            Next i_
        Next i
    End If
    If VNeeded = 2# Or VNeeded = 3# Then
        ReDim VL(1# To N, 1# To N)
        For i = 1# To N Step 1
            For i_ = 1# To N Step 1
                VL(i, i_) = S(i, i_)
            Next i_
        Next i
    End If
    Call InternalTREVC(A, N, VNeeded, 1#, SEL, VL, VR, M, Info)
    Result = Info = 0#
    NonSymmetricEVD = Result
End Function
Private Sub ToUpperHessenberg(ByRef A() As Double, _
         ByVal N As Long, _
         ByRef Tau() As Double)
    Dim i As Long
    Dim IP1 As Long
    Dim NMI As Long
    Dim V As Double
    Dim T() As Double
    Dim WORK() As Double
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' Quick return if possible
    '
    If N <= 1# Then
        Exit Sub
    End If
    ReDim Tau(1# To N - 1#)
    ReDim T(1# To N)
    ReDim WORK(1# To N)
    For i = 1# To N - 1# Step 1
        
        '
        ' Compute elementary reflector H(i) to annihilate A(i+2:ihi,i)
        '
        IP1 = i + 1#
        NMI = N - i
        i1_ = (IP1) - (1#)
        For i_ = 1# To NMI Step 1
            T(i_) = A(i_ + i1_, i)
        Next i_
        Call GenerateReflection(T, NMI, V)
        i1_ = (1#) - (IP1)
        For i_ = IP1 To N Step 1
            A(i_, i) = T(i_ + i1_)
        Next i_
        Tau(i) = V
        T(1#) = 1#
        
        '
        ' Apply H(i) to A(1:ihi,i+1:ihi) from the right
        '
        Call ApplyReflectionFromTheRight(A, V, T, 1#, N, i + 1#, N, WORK)
        
        '
        ' Apply H(i) to A(i+1:ihi,i+1:n) from the left
        '
        Call ApplyReflectionFromTheLeft(A, V, T, i + 1#, N, i + 1#, N, WORK)
    Next i
End Sub
Private Sub UnpackQFromUpperHessenberg(ByRef A() As Double, _
         ByVal N As Long, _
         ByRef Tau() As Double, _
         ByRef q() As Double)
    Dim i As Long
    Dim j As Long
    Dim V() As Double
    Dim WORK() As Double
    Dim IP1 As Long
    Dim NMI As Long
    Dim i_ As Long
    Dim i1_ As Long
    If N = 0# Then
        Exit Sub
    End If
    
    '
    ' init
    '
    ReDim q(1# To N, 1# To N)
    ReDim V(1# To N)
    ReDim WORK(1# To N)
    For i = 1# To N Step 1
        For j = 1# To N Step 1
            If i = j Then
                q(i, j) = 1#
            Else
                q(i, j) = 0#
            End If
        Next j
    Next i
    
    '
    ' unpack Q
    '
    For i = 1# To N - 1# Step 1
        
        '
        ' Apply H(i)
        '
        IP1 = i + 1#
        NMI = N - i
        i1_ = (IP1) - (1#)
        For i_ = 1# To NMI Step 1
            V(i_) = A(i_ + i1_, i)
        Next i_
        V(1#) = 1#
        Call ApplyReflectionFromTheRight(q, Tau(i), V, 1#, N, i + 1#, N, WORK)
    Next i
End Sub
Private Sub UnpackHFromUpperHessenberg(ByRef A() As Double, _
         ByVal N As Long, _
         ByRef Tau() As Double, _
         ByRef H() As Double)
    Dim i As Long
    Dim j As Long
    Dim V() As Double
    Dim WORK() As Double
    Dim i_ As Long
    If N = 0# Then
        Exit Sub
    End If
    ReDim H(1# To N, 1# To N)
    For i = 1# To N Step 1
        For j = 1# To i - 2# Step 1
            H(i, j) = 0#
        Next j
        j = MaxInt(1#, i - 1#)
        For i_ = j To N Step 1
            H(i, i_) = A(i, i_)
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 1992-2007 The University of Tennessee.  All rights reserved.
'
'Contributors:
'    * Sergey Bochkanov (ALGLIB project). Translation from FORTRAN to
'      pseudocode.
'
'See subroutines comments for additional copyrights.
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Subroutine performing  the  Schur  decomposition  of  a  matrix  in  upper
'Hessenberg form using the QR algorithm with multiple shifts.
'
'The  source matrix  H  is  represented as  S'*H*S = T, where H - matrix in
'upper Hessenberg form,  S - orthogonal matrix (Schur vectors),   T - upper
'quasi-triangular matrix (with blocks of sizes  1x1  and  2x2  on  the main
'diagonal).
'
'Input parameters:
'    H   -   matrix to be decomposed.
'            Array whose indexes range within [1..N, 1..N].
'    N   -   size of H, N>=0.
'
'
'Output parameters:
'    H      contains the matrix T.
'            Array whose indexes range within [1..N, 1..N].
'            All elements below the blocks on the main diagonal are equal
'            to 0.
'    S   -   contains Schur vectors.
'            Array whose indexes range within [1..N, 1..N].
'
'Note 1:
'    The block structure of matrix T could be easily recognized: since  all
'    the elements  below  the blocks are zeros, the elements a[i+1,i] which
'    are equal to 0 show the block border.
'
'Note 2:
'    the algorithm  performance  depends  on  the  value  of  the  internal
'    parameter NS of InternalSchurDecomposition  subroutine  which  defines
'    the number of shifts in the QR algorithm (analog of  the  block  width
'    in block matrix algorithms in linear algebra). If you require  maximum
'    performance  on  your  machine,  it  is  recommended  to  adjust  this
'    parameter manually.
'
'Result:
'    True, if the algorithm has converged and the parameters H and S contain
'        the result.
'    False, if the algorithm has not converged.
'
'Algorithm implemented on the basis of subroutine DHSEQR (LAPACK 3.0 library).
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function UpperHessenbergSchurDecomposition(ByRef H() As Double, _
         ByVal N As Long, _
         ByRef S() As Double) As Boolean
    Dim Result As Boolean
    Dim WI() As Double
    Dim WR() As Double
    Dim Info As Long
    Call InternalSchurDecomposition(H, N, 1#, 2#, WR, WI, S, Info)
    Result = Info = 0#
    UpperHessenbergSchurDecomposition = Result
End Function
Public Sub InternalSchurDecomposition(ByRef H() As Double, _
         ByVal N As Long, _
         ByVal TNeeded As Long, _
         ByVal ZNeeded As Long, _
         ByRef WR() As Double, _
         ByRef WI() As Double, _
         ByRef z() As Double, _
         ByRef Info As Long)
    Dim WORK() As Double
    Dim i As Long
    Dim I1 As Long
    Dim I2 As Long
    Dim IERR As Long
    Dim II As Long
    Dim ITEMP As Long
    Dim ITN As Long
    Dim ITS As Long
    Dim j As Long
    Dim K As Long
    Dim L As Long
    Dim MAXB As Long
    Dim NR As Long
    Dim NS As Long
    Dim NV As Long
    Dim ABSW As Double
    Dim OVFL As Double
    Dim SMLNUM As Double
    Dim Tau As Double
    Dim temp As Double
    Dim TST1 As Double
    Dim Ulp As Double
    Dim UNFL As Double
    Dim S() As Double
    Dim V() As Double
    Dim VV() As Double
    Dim WORKC1() As Double
    Dim WORKS1() As Double
    Dim WORKV3() As Double
    Dim TmpWR() As Double
    Dim TmpWI() As Double
    Dim INITZ As Boolean
    Dim WANTT As Boolean
    Dim WANTZ As Boolean
    Dim CNST As Double
    Dim FailFlag As Boolean
    Dim P1 As Long
    Dim P2 As Long
    Dim VT As Double
    Dim i_ As Long
    Dim i1_ As Long
    '
    ' Set the order of the multi-shift QR algorithm to be used.
    ' If you want to tune algorithm, change this values
    '
    NS = 12#
    MAXB = 50#
    '
    ' Now 2 < NS <= MAXB < NH.
    '
    MAXB = MaxInt(3#, MAXB)
    NS = MinInt(MAXB, NS)
    '
    ' Initialize
    '
    CNST = 1.5
    ReDim WORK(1# To MaxInt(N, 1#))
    ReDim S(1# To NS, 1# To NS)
    ReDim V(1# To NS + 1#)
    ReDim VV(1# To NS + 1#)
    ReDim WR(1# To MaxInt(N, 1#))
    ReDim WI(1# To MaxInt(N, 1#))
    ReDim WORKC1(1# To 1#)
    ReDim WORKS1(1# To 1#)
    ReDim WORKV3(1# To 3#)
    ReDim TmpWR(1# To MaxInt(N, 1#))
    ReDim TmpWI(1# To MaxInt(N, 1#))
    WANTT = TNeeded = 1#
    INITZ = ZNeeded = 2#
    WANTZ = ZNeeded <> 0#
    Info = 0#
    '
    ' Initialize Z, if necessary
    '
    If INITZ Then
        ReDim z(1# To N, 1# To N)
        For i = 1# To N Step 1
            For j = 1# To N Step 1
                If i = j Then
                    z(i, j) = 1#
                Else
                    z(i, j) = 0#
                End If
            Next j
        Next i
    End If
    '
    ' Quick return if possible
    '
    If N = 0# Then
        Exit Sub
    End If
    If N = 1# Then
        WR(1#) = H(1#, 1#)
        WI(1#) = 0#
        Exit Sub
    End If
    '
    ' Set rows and columns 1 to N to zero below the first
    ' subdiagonal.
    '
    For j = 1# To N - 2# Step 1
        For i = j + 2# To N Step 1
            H(i, j) = 0#
        Next i
    Next j
    '
    ' Test if N is sufficiently small
    '
    If NS <= 2# Or NS > N Or MAXB >= N Then
        '
        ' Use the standard double-shift algorithm
        '
        Call InternalAuxSchur(WANTT, WANTZ, N, 1#, N, H, WR, WI, 1#, N, z, WORK, WORKV3, WORKC1, WORKS1, Info)
        '
        ' fill entries under diagonal blocks of T with zeros
        '
        If WANTT Then
            j = 1#
            Do While j <= N
                If WI(j) = 0# Then
                    For i = j + 1# To N Step 1
                        H(i, j) = 0#
                    Next i
                    j = j + 1#
                Else
                    For i = j + 2# To N Step 1
                        H(i, j) = 0#
                        H(i, j + 1#) = 0#
                    Next i
                    j = j + 2#
                End If
            Loop
        End If
        Exit Sub
    End If
    UNFL = MinRealNumber
    OVFL = 1# / UNFL
    Ulp = 2# * MachineEpsilon
    SMLNUM = UNFL * (N / Ulp)
    '
    ' I1 and I2 are the indices of the first row and last column of H
    ' to which transformations must be applied. If eigenvalues only are
    ' being computed, I1 and I2 are set inside the main loop.
    '
    I1 = 1#
    I2 = N
    '
    ' ITN is the total number of multiple-shift QR iterations allowed.
    '
    ITN = 30# * N
    '
    ' The main loop begins here. I is the loop index and decreases from
    ' IHI to ILO in steps of at most MAXB. Each iteration of the loop
    ' works with the active submatrix in rows and columns L to I.
    ' Eigenvalues I+1 to IHI have already converged. Either L = ILO or
    ' H(L,L-1) is negligible so that the matrix splits.
    '
    i = N
    Do While True
        L = 1#
        If i < 1# Then
            '
            ' fill entries under diagonal blocks of T with zeros
            '
            If WANTT Then
                j = 1#
                Do While j <= N
                    If WI(j) = 0# Then
                        For i = j + 1# To N Step 1
                            H(i, j) = 0#
                        Next i
                        j = j + 1#
                    Else
                        For i = j + 2# To N Step 1
                            H(i, j) = 0#
                            H(i, j + 1#) = 0#
                        Next i
                        j = j + 2#
                    End If
                Loop
            End If
            '
            ' Exit
            '
            Exit Sub
        End If
        '
        ' Perform multiple-shift QR iterations on rows and columns ILO to I
        ' until a submatrix of order at most MAXB splits off at the bottom
        ' because a subdiagonal element has become negligible.
        '
        FailFlag = True
        For ITS = 0# To ITN Step 1
            '
            ' Look for a single small subdiagonal element.
            '
            For K = i To L + 1# Step -1
                TST1 = Abs(H(K - 1#, K - 1#)) + Abs(H(K, K))
                If TST1 = 0# Then
                    TST1 = UpperHessenberg1Norm(H, L, i, L, i, WORK)
                End If
                If Abs(H(K, K - 1#)) <= MaxReal(Ulp * TST1, SMLNUM) Then
                    Exit For
                End If
            Next K
            L = K
            If L > 1# Then
                '
                ' H(L,L-1) is negligible.
                '
                H(L, L - 1#) = 0#
            End If
            '
            ' Exit from loop if a submatrix of order <= MAXB has split off.
            '
            If L >= i - MAXB + 1# Then
                FailFlag = False
                Exit For
            End If
            '
            ' Now the active submatrix is in rows and columns L to I. If
            ' eigenvalues only are being computed, only the active submatrix
            ' need be transformed.
            '
            If ITS = 20# Or ITS = 30# Then
                '
                ' Exceptional shifts.
                '
                For II = i - NS + 1# To i Step 1
                    WR(II) = CNST * (Abs(H(II, II - 1#)) + Abs(H(II, II)))
                    WI(II) = 0#
                Next II
            Else
                '
                ' Use eigenvalues of trailing submatrix of order NS as shifts.
                '
                Call CopyMatrix(H, i - NS + 1#, i, i - NS + 1#, i, S, 1#, NS, 1#, NS)
                Call InternalAuxSchur(False, False, NS, 1#, NS, S, TmpWR, TmpWI, 1#, NS, z, WORK, WORKV3, WORKC1, WORKS1, IERR)
                For P1 = 1# To NS Step 1
                    WR(i - NS + P1) = TmpWR(P1)
                    WI(i - NS + P1) = TmpWI(P1)
                Next P1
                If IERR > 0# Then
                    '
                    ' If DLAHQR failed to compute all NS eigenvalues, use the
                    ' unconverged diagonal elements as the remaining shifts.
                    '
                    For II = 1# To IERR Step 1
                        WR(i - NS + II) = S(II, II)
                        WI(i - NS + II) = 0#
                    Next II
                End If
            End If
            '
            ' Form the first column of (G-w(1)) (G-w(2)) . . . (G-w(ns))
            ' where G is the Hessenberg submatrix H(L:I,L:I) and w is
            ' the vector of shifts (stored in WR and WI). The result is
            ' stored in the local array V.
            '
            V(1#) = 1#
            For II = 2# To NS + 1# Step 1
                V(II) = 0#
            Next II
            NV = 1#
            For j = i - NS + 1# To i Step 1
                If WI(j) >= 0# Then
                    If WI(j) = 0# Then
                        '
                        ' real shift
                        '
                        P1 = NV + 1#
                        For i_ = 1# To P1 Step 1
                            VV(i_) = V(i_)
                        Next i_
                        Call MatrixVectorMultiply(H, L, L + NV, L, L + NV - 1#, False, VV, 1#, NV, 1#, V, 1#, NV + 1#, -WR(j))
                        NV = NV + 1#
                    Else
                        If WI(j) > 0# Then
                            '
                            ' complex conjugate pair of shifts
                            '
                            P1 = NV + 1#
                            For i_ = 1# To P1 Step 1
                                VV(i_) = V(i_)
                            Next i_
                            Call MatrixVectorMultiply(H, L, L + NV, L, L + NV - 1#, False, V, 1#, NV, 1#, VV, 1#, NV + 1#, -(2# * WR(j)))
                            ITEMP = VectorIdxAbsMax(VV, 1#, NV + 1#)
                            temp = 1# / MaxReal(Abs(VV(ITEMP)), SMLNUM)
                            P1 = NV + 1#
                            For i_ = 1# To P1 Step 1
                                VV(i_) = temp * VV(i_)
                            Next i_
                            ABSW = Pythag2(WR(j), WI(j))
                            temp = temp * ABSW * ABSW
                            Call MatrixVectorMultiply(H, L, L + NV + 1#, L, L + NV, False, VV, 1#, NV + 1#, 1#, V, 1#, NV + 2#, temp)
                            NV = NV + 2#
                        End If
                    End If
                    '
                    ' Scale V(1:NV) so that max(abs(V(i))) = 1. If V is zero,
                    ' reset it to the unit vector.
                    '
                    ITEMP = VectorIdxAbsMax(V, 1#, NV)
                    temp = Abs(V(ITEMP))
                    If temp = 0# Then
                        V(1#) = 1#
                        For II = 2# To NV Step 1
                            V(II) = 0#
                        Next II
                    Else
                        temp = MaxReal(temp, SMLNUM)
                        VT = 1# / temp
                        For i_ = 1# To NV Step 1
                            V(i_) = VT * V(i_)
                        Next i_
                    End If
                End If
            Next j
            '
            ' Multiple-shift QR step
            '
            For K = L To i - 1# Step 1
                '
                ' The first iteration of this loop determines a reflection G
                ' from the vector V and applies it from left and right to H,
                ' thus creating a nonzero bulge below the subdiagonal.
                '
                ' Each subsequent iteration determines a reflection G to
                ' restore the Hessenberg form in the (K-1)th column, and thus
                ' chases the bulge one step toward the bottom of the active
                ' submatrix. NR is the order of G.
                '
                NR = MinInt(NS + 1#, i - K + 1#)
                If K > L Then
                    P1 = K - 1#
                    P2 = K + NR - 1#
                    i1_ = (K) - (1#)
                    For i_ = 1# To NR Step 1
                        V(i_) = H(i_ + i1_, P1)
                    Next i_
                End If
                Call GenerateReflection(V, NR, Tau)
                If K > L Then
                    H(K, K - 1#) = V(1#)
                    For II = K + 1# To i Step 1
                        H(II, K - 1#) = 0#
                    Next II
                End If
                V(1#) = 1#
                '
                ' Apply G from the left to transform the rows of the matrix in
                ' columns K to I2.
                '
                Call ApplyReflectionFromTheLeft(H, Tau, V, K, K + NR - 1#, K, I2, WORK)
                '
                ' Apply G from the right to transform the columns of the
                ' matrix in rows I1 to min(K+NR,I).
                '
                Call ApplyReflectionFromTheRight(H, Tau, V, I1, MinInt(K + NR, i), K, K + NR - 1#, WORK)
                If WANTZ Then
                    '
                    ' Accumulate transformations in the matrix Z
                    '
                    Call ApplyReflectionFromTheRight(z, Tau, V, 1#, N, K, K + NR - 1#, WORK)
                End If
            Next K
        Next ITS
        '
        ' Failure to converge in remaining number of iterations
        '
        If FailFlag Then
            Info = i
            Exit Sub
        End If
        '
        ' A submatrix of order <= MAXB in rows and columns L to I has split
        ' off. Use the double-shift QR algorithm to handle it.
        '
        Call InternalAuxSchur(WANTT, WANTZ, N, L, i, H, WR, WI, 1#, N, z, WORK, WORKV3, WORKC1, WORKS1, Info)
        If Info > 0# Then
            Exit Sub
        End If
        '
        ' Decrement number of remaining iterations, and return to start of
        ' the main loop with a new value of I.
        '
        ITN = ITN - ITS
        i = L - 1#
    Loop
End Sub
Private Sub InternalAuxSchur(ByVal WANTT As Boolean, _
         ByVal WANTZ As Boolean, _
         ByVal N As Long, _
         ByVal ILO As Long, _
         ByVal IHI As Long, _
         ByRef H() As Double, _
         ByRef WR() As Double, _
         ByRef WI() As Double, _
         ByVal ILOZ As Long, _
         ByVal IHIZ As Long, _
         ByRef z() As Double, _
         ByRef WORK() As Double, _
         ByRef WORKV3() As Double, _
         ByRef WORKC1() As Double, _
         ByRef WORKS1() As Double, _
         ByRef Info As Long)
    Dim i As Long
    Dim I1 As Long
    Dim I2 As Long
    Dim ITN As Long
    Dim ITS As Long
    Dim j As Long
    Dim K As Long
    Dim L As Long
    Dim M As Long
    Dim NH As Long
    Dim NR As Long
    Dim nz As Long
    Dim AVE As Double
    Dim CS As Double
    Dim DISC As Double
    Dim H00 As Double
    Dim H10 As Double
    Dim H11 As Double
    Dim H12 As Double
    Dim H21 As Double
    Dim H22 As Double
    Dim H33 As Double
    Dim H33S As Double
    Dim H43H34 As Double
    Dim H44 As Double
    Dim H44S As Double
    Dim OVFL As Double
    Dim S As Double
    Dim SMLNUM As Double
    Dim SN As Double
    Dim SUM As Double
    Dim T1 As Double
    Dim T2 As Double
    Dim T3 As Double
    Dim TST1 As Double
    Dim UNFL As Double
    Dim V1 As Double
    Dim V2 As Double
    Dim V3 As Double
    Dim FailFlag As Boolean
    Dim DAT1 As Double
    Dim DAT2 As Double
    Dim P1 As Long
    Dim HIM1IM1 As Double
    Dim HIM1I As Double
    Dim HIIM1 As Double
    Dim HII As Double
    Dim WRIM1 As Double
    Dim WRI As Double
    Dim WIIM1 As Double
    Dim WII As Double
    Dim Ulp As Double
    Info = 0#
    DAT1 = 0.75
    DAT2 = -0.4375
    Ulp = MachineEpsilon
    '
    ' Quick return if possible
    '
    If N = 0# Then
        Exit Sub
    End If
    If ILO = IHI Then
        WR(ILO) = H(ILO, ILO)
        WI(ILO) = 0#
        Exit Sub
    End If
    NH = IHI - ILO + 1#
    nz = IHIZ - ILOZ + 1#
    '
    ' Set machine-dependent constants for the stopping criterion.
    ' If norm(H) <= sqrt(OVFL), overflow should not occur.
    '
    UNFL = MinRealNumber
    OVFL = 1# / UNFL
    SMLNUM = UNFL * (NH / Ulp)
    '
    ' I1 and I2 are the indices of the first row and last column of H
    ' to which transformations must be applied. If eigenvalues only are
    ' being computed, I1 and I2 are set inside the main loop.
    '
    I1 = 1#
    I2 = N
    '
    ' ITN is the total number of QR iterations allowed.
    '
    ITN = 30# * NH
    '
    ' The main loop begins here. I is the loop index and decreases from
    ' IHI to ILO in steps of 1 or 2. Each iteration of the loop works
    ' with the active submatrix in rows and columns L to I.
    ' Eigenvalues I+1 to IHI have already converged. Either L = ILO or
    ' H(L,L-1) is negligible so that the matrix splits.
    '
    i = IHI
    Do While True
        L = ILO
        If i < ILO Then
            Exit Sub
        End If
        '
        ' Perform QR iterations on rows and columns ILO to I until a
        ' submatrix of order 1 or 2 splits off at the bottom because a
        ' subdiagonal element has become negligible.
        '
        FailFlag = True
        For ITS = 0# To ITN Step 1
            '
            ' Look for a single small subdiagonal element.
            '
            For K = i To L + 1# Step -1
                TST1 = Abs(H(K - 1#, K - 1#)) + Abs(H(K, K))
                If TST1 = 0# Then
                    TST1 = UpperHessenberg1Norm(H, L, i, L, i, WORK)
                End If
                If Abs(H(K, K - 1#)) <= MaxReal(Ulp * TST1, SMLNUM) Then
                    Exit For
                End If
            Next K
            L = K
            If L > ILO Then
                '
                ' H(L,L-1) is negligible
                '
                H(L, L - 1#) = 0#
            End If
            '
            ' Exit from loop if a submatrix of order 1 or 2 has split off.
            '
            If L >= i - 1# Then
                FailFlag = False
                Exit For
            End If
            '
            ' Now the active submatrix is in rows and columns L to I. If
            ' eigenvalues only are being computed, only the active submatrix
            ' need be transformed.
            '
            If ITS = 10# Or ITS = 20# Then
                '
                ' Exceptional shift.
                '
                S = Abs(H(i, i - 1#)) + Abs(H(i - 1#, i - 2#))
                H44 = DAT1 * S + H(i, i)
                H33 = H44
                H43H34 = DAT2 * S * S
            Else
                '
                ' Prepare to use Francis' double shift
                ' (i.e. 2nd degree generalized Rayleigh quotient)
                '
                H44 = H(i, i)
                H33 = H(i - 1#, i - 1#)
                H43H34 = H(i, i - 1#) * H(i - 1#, i)
                S = H(i - 1#, i - 2#) * H(i - 1#, i - 2#)
                DISC = (H33 - H44) * 0.5
                DISC = DISC * DISC + H43H34
                If DISC > 0# Then
                    '
                    ' Real roots: use Wilkinson's shift twice
                    '
                    DISC = Sqr(DISC)
                    AVE = 0.5 * (H33 + H44)
                    If Abs(H33) - Abs(H44) > 0# Then
                        H33 = H33 * H44 - H43H34
                        H44 = H33 / (ExtSchurSign(DISC, AVE) + AVE)
                    Else
                        H44 = ExtSchurSign(DISC, AVE) + AVE
                    End If
                    H33 = H44
                    H43H34 = 0#
                End If
            End If
            '
            ' Look for two consecutive small subdiagonal elements.
            '
            For M = i - 2# To L Step -1
                '
                ' Determine the effect of starting the double-shift QR
                ' iteration at row M, and see if this would make H(M,M-1)
                ' negligible.
                '
                H11 = H(M, M)
                H22 = H(M + 1#, M + 1#)
                H21 = H(M + 1#, M)
                H12 = H(M, M + 1#)
                H44S = H44 - H11
                H33S = H33 - H11
                V1 = (H33S * H44S - H43H34) / H21 + H12
                V2 = H22 - H11 - H33S - H44S
                V3 = H(M + 2#, M + 1#)
                S = Abs(V1) + Abs(V2) + Abs(V3)
                V1 = V1 / S
                V2 = V2 / S
                V3 = V3 / S
                WORKV3(1#) = V1
                WORKV3(2#) = V2
                WORKV3(3#) = V3
                If M = L Then
                    Exit For
                End If
                H00 = H(M - 1#, M - 1#)
                H10 = H(M, M - 1#)
                TST1 = Abs(V1) * (Abs(H00) + Abs(H11) + Abs(H22))
                If Abs(H10) * (Abs(V2) + Abs(V3)) <= Ulp * TST1 Then
                    Exit For
                End If
            Next M
            '
            ' Double-shift QR step
            '
            For K = M To i - 1# Step 1
                '
                ' The first iteration of this loop determines a reflection G
                ' from the vector V and applies it from left and right to H,
                ' thus creating a nonzero bulge below the subdiagonal.
                '
                ' Each subsequent iteration determines a reflection G to
                ' restore the Hessenberg form in the (K-1)th column, and thus
                ' chases the bulge one step toward the bottom of the active
                ' submatrix. NR is the order of G.
                '
                NR = MinInt(3#, i - K + 1#)
                If K > M Then
                    For P1 = 1# To NR Step 1
                        WORKV3(P1) = H(K + P1 - 1#, K - 1#)
                    Next P1
                End If
                Call GenerateReflection(WORKV3, NR, T1)
                If K > M Then
                    H(K, K - 1#) = WORKV3(1#)
                    H(K + 1#, K - 1#) = 0#
                    If K < i - 1# Then
                        H(K + 2#, K - 1#) = 0#
                    End If
                Else
                    If M > L Then
                        H(K, K - 1#) = -H(K, K - 1#)
                    End If
                End If
                V2 = WORKV3(2#)
                T2 = T1 * V2
                If NR = 3# Then
                    V3 = WORKV3(3#)
                    T3 = T1 * V3
                    '
                    ' Apply G from the left to transform the rows of the matrix
                    ' in columns K to I2.
                    '
                    For j = K To I2 Step 1
                        SUM = H(K, j) + V2 * H(K + 1#, j) + V3 * H(K + 2#, j)
                        H(K, j) = H(K, j) - SUM * T1
                        H(K + 1#, j) = H(K + 1#, j) - SUM * T2
                        H(K + 2#, j) = H(K + 2#, j) - SUM * T3
                    Next j
                    '
                    ' Apply G from the right to transform the columns of the
                    ' matrix in rows I1 to min(K+3,I).
                    '
                    For j = I1 To MinInt(K + 3#, i) Step 1
                        SUM = H(j, K) + V2 * H(j, K + 1#) + V3 * H(j, K + 2#)
                        H(j, K) = H(j, K) - SUM * T1
                        H(j, K + 1#) = H(j, K + 1#) - SUM * T2
                        H(j, K + 2#) = H(j, K + 2#) - SUM * T3
                    Next j
                    If WANTZ Then
                        '
                        ' Accumulate transformations in the matrix Z
                        '
                        For j = ILOZ To IHIZ Step 1
                            SUM = z(j, K) + V2 * z(j, K + 1#) + V3 * z(j, K + 2#)
                            z(j, K) = z(j, K) - SUM * T1
                            z(j, K + 1#) = z(j, K + 1#) - SUM * T2
                            z(j, K + 2#) = z(j, K + 2#) - SUM * T3
                        Next j
                    End If
                Else
                    If NR = 2# Then
                        '
                        ' Apply G from the left to transform the rows of the matrix
                        ' in columns K to I2.
                        '
                        For j = K To I2 Step 1
                            SUM = H(K, j) + V2 * H(K + 1#, j)
                            H(K, j) = H(K, j) - SUM * T1
                            H(K + 1#, j) = H(K + 1#, j) - SUM * T2
                        Next j
                        '
                        ' Apply G from the right to transform the columns of the
                        ' matrix in rows I1 to min(K+3,I).
                        '
                        For j = I1 To i Step 1
                            SUM = H(j, K) + V2 * H(j, K + 1#)
                            H(j, K) = H(j, K) - SUM * T1
                            H(j, K + 1#) = H(j, K + 1#) - SUM * T2
                        Next j
                        If WANTZ Then
                            '
                            ' Accumulate transformations in the matrix Z
                            '
                            For j = ILOZ To IHIZ Step 1
                                SUM = z(j, K) + V2 * z(j, K + 1#)
                                z(j, K) = z(j, K) - SUM * T1
                                z(j, K + 1#) = z(j, K + 1#) - SUM * T2
                            Next j
                        End If
                    End If
                End If
            Next K
        Next ITS
        If FailFlag Then
            '
            ' Failure to converge in remaining number of iterations
            '
            Info = i
            Exit Sub
        End If
        If L = i Then
            '
            ' H(I,I-1) is negligible: one eigenvalue has converged.
            '
            WR(i) = H(i, i)
            WI(i) = 0#
        Else
            If L = i - 1# Then
                '
                ' H(I-1,I-2) is negligible: a pair of eigenvalues have converged.
                '
                '        Transform the 2-by-2 submatrix to standard Schur form,
                '        and compute and store the eigenvalues.
                '
                HIM1IM1 = H(i - 1#, i - 1#)
                HIM1I = H(i - 1#, i)
                HIIM1 = H(i, i - 1#)
                HII = H(i, i)
                Call Aux2X2Schur(HIM1IM1, HIM1I, HIIM1, HII, WRIM1, WIIM1, WRI, WII, CS, SN)
                WR(i - 1#) = WRIM1
                WI(i - 1#) = WIIM1
                WR(i) = WRI
                WI(i) = WII
                H(i - 1#, i - 1#) = HIM1IM1
                H(i - 1#, i) = HIM1I
                H(i, i - 1#) = HIIM1
                H(i, i) = HII
                If WANTT Then
                    '
                    ' Apply the transformation to the rest of H.
                    '
                    If I2 > i Then
                        WORKC1(1#) = CS
                        WORKS1(1#) = SN
                        Call ApplyRotationsFromTheLeft(True, i - 1#, i, i + 1#, I2, WORKC1, WORKS1, H, WORK)
                    End If
                    WORKC1(1#) = CS
                    WORKS1(1#) = SN
                    Call ApplyRotationsFromTheRight(True, I1, i - 2#, i - 1#, i, WORKC1, WORKS1, H, WORK)
                End If
                If WANTZ Then
                    '
                    ' Apply the transformation to Z.
                    '
                    WORKC1(1#) = CS
                    WORKS1(1#) = SN
                    Call ApplyRotationsFromTheRight(True, ILOZ, ILOZ + nz - 1#, i - 1#, i, WORKC1, WORKS1, z, WORK)
                End If
            End If
        End If
        '
        ' Decrement number of remaining iterations, and return to start of
        ' the main loop with new value of I.
        '
        ITN = ITN - ITS
        i = L - 1#
    Loop
End Sub
Private Sub Aux2X2Schur(ByRef A As Double, _
         ByRef B As Double, _
         ByRef C As Double, _
         ByRef D As Double, _
         ByRef RT1R As Double, _
         ByRef RT1I As Double, _
         ByRef RT2R As Double, _
         ByRef RT2I As Double, _
         ByRef CS As Double, _
         ByRef SN As Double)
    Dim MULTPL As Double
    Dim AA As Double
    Dim BB As Double
    Dim BCMAX As Double
    Dim BCMIS As Double
    Dim CC As Double
    Dim CS1 As Double
    Dim DD As Double
    Dim Eps As Double
    Dim p As Double
    Dim SAB As Double
    Dim SAC As Double
    Dim SCL As Double
    Dim Sigma As Double
    Dim SN1 As Double
    Dim Tau As Double
    Dim temp As Double
    Dim z As Double
    MULTPL = 4#
    Eps = MachineEpsilon
    If C = 0# Then
        CS = 1#
        SN = 0#
    Else
        If B = 0# Then
            '
            ' Swap rows and columns
            '
            CS = 0#
            SN = 1#
            temp = D
            D = A
            A = temp
            B = -C
            C = 0#
        Else
            If A - D = 0# And ExtSchurSignToOne(B) <> ExtSchurSignToOne(C) Then
                CS = 1#
                SN = 0#
            Else
                temp = A - D
                p = 0.5 * temp
                BCMAX = MaxReal(Abs(B), Abs(C))
                BCMIS = MinReal(Abs(B), Abs(C)) * ExtSchurSignToOne(B) * ExtSchurSignToOne(C)
                SCL = MaxReal(Abs(p), BCMAX)
                z = p / SCL * p + BCMAX / SCL * BCMIS
                '
                ' If Z is of the order of the machine accuracy, postpone the
                ' decision on the nature of eigenvalues
                '
                If z >= MULTPL * Eps Then
                    '
                    ' Real eigenvalues. Compute A and D.
                    '
                    z = p + ExtSchurSign(Sqr(SCL) * Sqr(z), p)
                    A = D + z
                    D = D - BCMAX / z * BCMIS
                    '
                    ' Compute B and the rotation matrix
                    '
                    Tau = Pythag2(C, z)
                    CS = z / Tau
                    SN = C / Tau
                    B = B - C
                    C = 0#
                Else
                    '
                    ' Complex eigenvalues, or real (almost) equal eigenvalues.
                    ' Make diagonal elements equal.
                    '
                    Sigma = B + C
                    Tau = Pythag2(Sigma, temp)
                    CS = Sqr(0.5 * (1# + Abs(Sigma) / Tau))
                    SN = -(p / (Tau * CS) * ExtSchurSign(1#, Sigma))
                    '
                    ' Compute [ AA  BB ] = [ A  B ] [ CS -SN ]
                    '         [ CC  DD ]   [ C  D ] [ SN  CS ]
                    '
                    AA = A * CS + B * SN
                    BB = -(A * SN) + B * CS
                    CC = C * CS + D * SN
                    DD = -(C * SN) + D * CS
                    '
                    ' Compute [ A  B ] = [ CS  SN ] [ AA  BB ]
                    '         [ C  D ]   [-SN  CS ] [ CC  DD ]
                    '
                    A = AA * CS + CC * SN
                    B = BB * CS + DD * SN
                    C = -(AA * SN) + CC * CS
                    D = -(BB * SN) + DD * CS
                    temp = 0.5 * (A + D)
                    A = temp
                    D = temp
                    If C <> 0# Then
                        If B <> 0# Then
                            If ExtSchurSignToOne(B) = ExtSchurSignToOne(C) Then
                                '
                                ' Real eigenvalues: reduce to upper triangular form
                                '
                                SAB = Sqr(Abs(B))
                                SAC = Sqr(Abs(C))
                                p = ExtSchurSign(SAB * SAC, C)
                                Tau = 1# / Sqr(Abs(B + C))
                                A = temp + p
                                D = temp - p
                                B = B - C
                                C = 0#
                                CS1 = SAB * Tau
                                SN1 = SAC * Tau
                                temp = CS * CS1 - SN * SN1
                                SN = CS * SN1 + SN * CS1
                                CS = temp
                            End If
                        Else
                            B = -C
                            C = 0#
                            temp = CS
                            CS = -SN
                            SN = temp
                        End If
                    End If
                End If
            End If
        End If
    End If
    '
    ' Store eigenvalues in (RT1R,RT1I) and (RT2R,RT2I).
    '
    RT1R = A
    RT2R = D
    If C = 0# Then
        RT1I = 0#
        RT2I = 0#
    Else
        RT1I = Sqr(Abs(B)) * Sqr(Abs(C))
        RT2I = -RT1I
    End If
End Sub
Private Function ExtSchurSign(ByVal A As Double, ByVal B As Double) As Double
    Dim Result As Double
    If B >= 0# Then
        Result = Abs(A)
    Else
        Result = -Abs(A)
    End If
    ExtSchurSign = Result
End Function
Private Function ExtSchurSignToOne(ByVal B As Double) As Long
    Dim Result As Long
    If B >= 0# Then
        Result = 1#
    Else
        Result = -1#
    End If
    ExtSchurSignToOne = Result
End Function

