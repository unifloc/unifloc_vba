'=======================================================================================
'Unifloc 7.25  coronav                                          khabibullin.ra@gubkin.ru
'Petroleum engineering calculations modules (macroses)
'2000 - 2019
'
'=======================================================================================
'
'
' класс для моделирования работы погружной части ЭЦН
' описывает работу набора одинаковых ступеней
'
Option Explicit
Option Base 0
' геометрические параметры насоса
Public h_mes_top_m As Double           ' глубина установки ЭЦН (по верхней части)
Public angle_deg As Double             ' угол установки УЭЦН (предполагается, что по глубине угол не меняется) ' not used for 7.24
' общие параметры
Public fluid As CPVT                   ' флюид движущийся через насос (с учетом сепарации газа)
Public c_calibr_head As Double         ' деградация характеристики УЭЦН по напору
Public c_calibr_rate As Double         ' деградация характеристики УЭЦН по дебиту
Public c_calibr_power As Double        ' деградация по мощности (она же по КПД системы)
' набор параметром для задания поведения в зоне турбинного вращения (когда дебит больше максимального)
Public turb_head_factor As Double
Public turb_rate_factor As Double
Public dnum_stages_integrate As Integer
Public freq_Hz As Double               ' частота вращения вала насоса (используется для расчета)
Public curves As New CCurves           ' все кривые планируется прятать тут
' параметры конструкции ЭЦН
Public stage_num As Integer            ' количество ступеней в насосе (используется для расчета характеристики насоса)
Private t_int_C_ As Double             ' температура потока на приемной сетке УЭЦН (учитывается нагрев двигателем)
Private t_dis_C_ As Double             ' температура потока на выкиде насоса (учитывается нагрев в насосе)
' параметры работы насоса для которых был проведен расчет
Private p_int_atma_ As Double          ' давление на приеме насоса (используется для расчета рабочих характеристик)
Private p_dis_atma_ As Double          ' давление на выкиде насоса
Private power_fluid_Wt_ As Double      ' Мощность передаваемая УЭЦН жидкости
Private power_ESP_Wt_ As Double        ' Мощность потребляемая ЭЦН с вала (механическая)
Private eff_ESP_d_ As Double           ' КПД УЭЦН по факту
Private head_real_m_ As Double
' параметры определяющие установку УЭЦН
Private db_ As ESP_PARAMS            ' набор параметров насоса из базы данных
Private gas_frac_intake_ As Double
Private gas_corr_ As Double
Public gas_correct As Double       ' тип для коррекции по газу
                                        ' ESP_gas_correct       - тип насоса по работе с газом
                                        '      ESP_gas_correct = 0 нет коррекции
                                        '      ESP_gas_correct = 1 стандартный ЭЦН (предел 25%)
                                        '      ESP_gas_correct = 2 ЭЦН с газостабилизирующим модулем (предел 50%)
                                        '      ESP_gas_correct = 3 ЭЦН с осевым модулем (предел 75%)
                                        '      ESP_gas_correct = 4 ЭЦН с модифицированным ступенями (предел 40%)
Private correct_visc_ As Boolean
Private corr_visc_h_ As Double          ' поправочный коэффициент для напорной характеристики на вязкость для текущего дебита и текущего расчета
Private corr_visc_q_ As Double          ' поправочный коэффициент для дебита
Private corr_visc_pow_ As Double        ' поправочный коэффициент для мощности
Private corr_visc_eff_ As Double        ' поправочный коэффициент для КПД
Private h_corr_qd_curve_ As New CInterpolation     ' зависимость поправочного коэффициента для напора от дебита (для расчета по модели американского института нефти)
Private p_curve_ As New CInterpolation  ' кривая распределения давления вдоль насоса   (как снаружи, так и внутри)
Private t_curve_ As New CInterpolation  ' кривая распределения температуры флюида вдоль насоса
Private calc_from_dis_ As Boolean
Public Property Get db() As ESP_PARAMS
    db = db_
End Property
Public Property Let db(val As ESP_PARAMS)
    db_ = val
End Property
' =======================  геометрия
Public Property Get length_m() As Double
   length_m = db_.height_stage_m * stage_num
End Property
' глубина нижней точки установки
Public Property Get h_mes_down_m() As Double
   h_mes_down_m = h_mes_top_m + length_m
End Property
' функция для расчета высоты сбори из num ступеней
Private Function stages_heigth_m(ByVal num As Double) As Double
   If num <= stage_num Then
       stages_heigth_m = length_m / stage_num * num
   Else
       stages_heigth_m = length_m
   End If
End Function
' свойство для расчета измеренной глубины расположения i ступени
Public Property Get HmesStage_m(I As Double) As Double
   HmesStage_m = h_mes_down_m - stages_heigth_m(I) ' тут надо отнять длину ступеней выше контрольной
End Property
Public Property Get area_shaft_m2() As Double
   area_shaft_m2 = db_.d_shaft_m * db_.d_shaft_m / 4 * const_Pi
End Property
Public Property Get angle_vert_deg() As Double
   angle_vert_deg = angle_vert_deg - 90
End Property
' ========================  конец блока описания геометрии
Public Property Get head_m() As Double
   head_m = head_real_m_
End Property
Public Function points_num() As Integer
   points_num = UBound(db_.head_points) + 1
End Function
Property Get eff_ESP_d() As Double
   eff_ESP_d = eff_ESP_d_
End Property
Property Get power_fluid_W() As Double
   power_fluid_W = power_fluid_Wt_
End Property
Property Get power_ESP_W() As Double
   power_ESP_W = power_ESP_Wt_
End Property
Public Property Get p_int_atma() As Double
   p_int_atma = p_int_atma_
End Property
Public Property Get p_dis_atma() As Double
   p_dis_atma = p_dis_atma_
End Property
Public Property Get t_int_C() As Double
t_int_C = t_int_C_
End Property
Public Property Get t_dis_C() As Double
t_dis_C = t_dis_C_
End Property
Public Property Get w_obmin() As Double
   w_obmin = freq_Hz * 60
End Property
Public Property Let w_obmin(val As Double)
   freq_Hz = w_obmin / 60
End Property
Public Property Get w_radsec() As Double
   w_radsec = freq_Hz * 2 * const_Pi
End Property
Public Property Get rate_max_sm3day(ByVal mu_cSt As Double) As Double
    If correct_visc_ And (mu_cSt > 0) Then        ' если большая вязкость - сделаем коррекцию
        Call calc_CorrVisc_PetrInst(0, mu_cSt)   ' метод меняет константы класса, которые влияют на характеристики насоса
    End If
   rate_max_sm3day = db_.rate_max_sm3day * freq_Hz / db_.freq_Hz * corr_visc_q_
End Property
Public Property Get rate_nom_sm3day(Optional ByVal mu_cSt As Double = -1) As Double
    If correct_visc_ And (mu_cSt > 0) Then        ' если большая вязкость - сделаем коррекцию
        Call calc_CorrVisc_PetrInst(0, mu_cSt)   ' метод меняет константы класса, которые влияют на характеристики насоса
    End If
   rate_nom_sm3day = db_.rate_nom_sm3day * freq_Hz / db_.freq_Hz * corr_visc_q_
End Property
'Public Property Get gas_degr() As Double
'   gas_degr = gas_degr_
'End Property
'
'Public Property Let gas_degr(val As Double)
'   If val >= 0 Then
'       gas_degr_ = val
'   End If
'End Property
Private Function calc_ESP_head_nominal_m(ByVal q_m3day As Double, Optional ByVal stage_num As Integer = 1) As Double
' функция для расчета номинального напора насоса
    Dim b As Double                  ' отношение частот
    With db_
        b = .freq_Hz / freq_Hz  ' определим отношение реальной частоты УЭЦН к номинальной для которой заданы характеристики
        calc_ESP_head_nominal_m = b ^ (-2) * stage_num * crv_interpolation(.rate_points, .head_points, b * q_m3day, 2)(1, 1)
        calc_ESP_head_nominal_m = calc_ESP_head_nominal_m '* corr_visc_h_  ' учтем коррекцию на вязкость
    End With
End Function
Private Sub corrections_clear()
    
    corr_visc_h_ = 1
    corr_visc_q_ = 1
    corr_visc_pow_ = 1
'    corr_visc_eff_ = 1
'    c_calibr_head = 1
'    c_calibr_power = 1
'    c_calibr_rate = 1
    
End Sub
Public Function get_ESP_head_m(ByVal q_m3day As Double, Optional ByVal stage_num As Integer = -1, Optional ByVal mu_cSt As Double = -1) As Double
    Dim b As Double                 ' отношение частот
    Dim stage_num_to_calc As Integer ' число ступеней с которым будет проводиться расчет
    Dim maxQ As Double
    Dim q_calc_m3day As Double
    
    Call corrections_clear
    
    If q_m3day < 0 Then             ' проверим исходные данные на релевантность
        get_ESP_head_m = 0
        addLogMsg "CPumpESP.get_ESP_head_m: расчет характеристики насоса с отрицательным дебитом  Q_m3day = " & Format(q_m3day, "###0.00") & "Напор установлен = 0"
        Exit Function
    End If
    ' определяем число ступеней с которым будем проводить расчет
    If stage_num > 0 Then           ' если в явном виде задан параметр то его используем
        stage_num_to_calc = stage_num
    Else                            ' иначе использует количество ступеней из характеристики насоса
        stage_num_to_calc = Me.stage_num
    End If
    
    If correct_visc And (mu_cSt > 0) Then   ' если большая вязкость - сделаем коррекцию
        Call calc_CorrVisc_PetrInst(q_m3day, mu_cSt)   ' метод меняет константы класса, которые влияют на характеристики насоса
    End If
    
    q_calc_m3day = q_m3day / corr_visc_q_    ' делаем коррекцию по вязкости для дебита
    maxQ = db_.rate_max_sm3day * freq_Hz / db_.freq_Hz                   ' здесь коррекция на вязкость тоже уже учтена
    If q_calc_m3day < maxQ Then
        get_ESP_head_m = calc_ESP_head_nominal_m(q_calc_m3day, stage_num_to_calc)
    ElseIf maxQ - turb_rate_factor * (q_calc_m3day - maxQ) > 0 Then
        ' apply correction for far rigth interval
        get_ESP_head_m = -turb_head_factor * calc_ESP_head_nominal_m(maxQ - turb_rate_factor * (q_calc_m3day - maxQ), stage_num_to_calc)
    Else
        get_ESP_head_m = -turb_head_factor * calc_ESP_head_nominal_m(0, stage_num_to_calc)
    End If
    get_ESP_head_m = get_ESP_head_m * corr_visc_h_
End Function
Public Function get_ESP_power_W(ByVal q_m3day As Double, _
                       Optional ByVal stage_num As Integer = -1, _
                       Optional ByVal mu_cSt As Double = 1 _
                               ) As Double
    Dim b As Double
    Dim stage_num_to_calc As Integer
    Dim rate_max As Double
        
    Call corrections_clear
    
    If q_m3day < 0 Then
        get_ESP_power_W = 0
        addLogMsg "CPumpESP.get_ESP_power_W: расчет характеристики насоса с отрицательным дебитом  Q_m3day = " & q_m3day & "Мощность установлена = 0"
        Exit Function
    End If
    rate_max = rate_max_sm3day(mu_cSt)
    If q_m3day > rate_max Then
        ' assume that for high rate power consumption will not be less that at max rate
       q_m3day = rate_max
    End If
    ' определяем число ступеней с которым будем проводить расчет
    If stage_num > 0 Then        ' если в явном виде задан параметр то его используем
        stage_num_to_calc = stage_num
    Else                        ' иначе использует количество ступеней из характеристики насоса
        stage_num_to_calc = Me.stage_num
    End If
    If correct_visc And (mu_cSt > 0) Then   ' если большая вязкость - сделаем коррекцию
        Call calc_CorrVisc_PetrInst(q_m3day, mu_cSt)   ' метод меняет константы класса, которые влияют на характеристики насоса
    End If
    q_m3day = q_m3day / corr_visc_q_   ' делаем коррекцию по вязкости
    With db_
        b = .freq_Hz / freq_Hz
        get_ESP_power_W = 1000 * b ^ (-3) * stage_num_to_calc * crv_interpolation(.rate_points, .power_points, b * q_m3day, 2)(1, 1)
        If get_ESP_power_W < 0 Then
            get_ESP_power_W = 0
        End If
        get_ESP_power_W = get_ESP_power_W * corr_visc_pow_
    End With
End Function
Public Function get_ESP_effeciency_fr(ByVal q_m3day As Double, Optional ByVal mu_cSt As Double = 1) As Double
    Dim b As Double
    Dim stage_num_to_calc As Integer
    
    Call corrections_clear
    
    If q_m3day < 0 Then
        get_ESP_effeciency_fr = 0
        addLogMsg "CPumpESP.get_ESP_effeciency_fr: расчет характеристики насоса с отрицательным дебитом  Q_m3day = " & q_m3day & "Мощность установлена = 0"
        Exit Function
    End If
    If q_m3day > rate_max_sm3day(mu_cSt) Then
        get_ESP_effeciency_fr = 0
        Exit Function
    End If
    If correct_visc And (mu_cSt > 0) Then   ' если большая вязкость - сделаем коррекцию
        Call calc_CorrVisc_PetrInst(q_m3day, mu_cSt)   ' метод меняет константы класса, которые влияют на характеристики насоса
    End If
    q_m3day = q_m3day / corr_visc_q_   ' делаем коррекцию по вязкости
    b = db_.freq_Hz / freq_Hz
    get_ESP_effeciency_fr = crv_interpolation(db_.rate_points, db_.eff_points, b * q_m3day, 2)(1, 1)
    If get_ESP_effeciency_fr < 0 Then
        get_ESP_effeciency_fr = 0
    End If
    get_ESP_effeciency_fr = get_ESP_effeciency_fr * corr_visc_eff_
End Function
Public Function get_ESP_MaxOptimRate_m3day() As Double
' получения границы оптимального диапазона из базы
    get_ESP_MaxOptimRate_m3day = (freq_Hz / db_.freq_Hz) * db_.rate_opt_max_sm3day
End Function
Public Function get_ESP_MinOptimRate_m3day() As Double
' получения границы оптимального диапазона из базы
    get_ESP_MinOptimRate_m3day = (freq_Hz / db_.freq_Hz) * db_.rate_opt_min_sm3day
End Function
Private Sub ESP_dPIntegration(ByVal p_atma, _
                              ByVal t_intake_C, _
                   Optional t_dis_C As Double = 0, _
                   Optional calc_from_dis As Boolean = False, _
                   Optional saveCurve As Boolean = False)
    ' Функция расчете распределения давления в УЭЦН - расчет снизу вверх от входного давления до выходного
    ' заодно считает и потребляемую мощность и КПД установки
    ' p_atma         pressure at pump intake
    ' t_intake_C          temprature at pump intake
    ' t_dis_C         температура на выходе, если задана учитывается, если нет то рассчитывается
    ' calc_from_dis  показывает будет ли предпринята попытка проинтегрировать сверху вниз насос
    ' p_int_estimation_atma приближения для давления на приеме, используется для расчета сверху вниз
    
    Dim I As Integer
    Dim head_mix As Double
    Dim dPStage As Double
    Dim PowfluidWt As Double, PowfluidTot_Wt As Double  ' полезная мощность передаваемая насосом жидкости
    Dim PowESP_Wt As Double, PowESPTot_Wt As Double     ' механическая мощность потребляемая насосом
    Dim EffESP_d As Double      ' КПД УЭЦН
    Dim EffStage As Double
    Dim dTpump_C As Double, dTpumpSum_C As Double
    Dim Pst_atma As Double
    Dim Tst_C As Double         ' температура по ступеням
    Dim sign_int As Integer
    Dim q_mix_ As Double, q_mix__degr As Double
    Dim dNst As Integer  ' шаг ускорения при интегрировании большими шагами
    Dim Nst As Integer   ' шаг на текущей итерации
    Dim n As Integer     ' текущий номер ступени
    Dim nn As Integer    ' номер ступени от приема для записи в архив
    Dim dPav As Double   ' поправки на давление и температуру при интегрировании
    Dim dTav As Double
   
    dNst = dnum_stages_integrate ' для начала пытаемся интегрировать такими шагами
             ' если тут поставить 10 будет быстрее считать за счет снижение числа шагов
             ' при этом может копиться ошибка, особенно если мало ступеней
    'dNst = 10 ' может быть надо будет когда то сделать глобальную настройку по скорости точности
    dPav = 0
    dTav = 0
    gas_corr_ = 1
On Error GoTo err1:
    calc_from_dis_ = calc_from_dis  ' save state to object
    
    ' rearrange variables to calc direction
    If calc_from_dis Then
        If t_dis_C < 0 Then t_dis_C = t_intake_C
        Tst_C = t_dis_C
        p_dis_atma_ = p_atma
        sign_int = -1
    Else
        Tst_C = t_intake_C
        p_int_atma_ = p_atma
        sign_int = 1
    End If
    
    ' init auxiliary variables
    Call corrections_clear
    Pst_atma = p_atma
    dTpumpSum_C = 0
    head_real_m_ = 0
    t_int_C_ = t_intake_C
    t_dis_C_ = t_dis_C
    PowfluidWt = 0
    PowfluidTot_Wt = 0
    PowESP_Wt = 0
    PowESPTot_Wt = 0
    dTpumpSum_C = 0
    n = 0
    I = 0
    If saveCurve Then
            curves.Item("gas_fractionInPump").ClearPoints
            curves.Item("PressureInPump").ClearPoints
            curves.Item("TempInPump").ClearPoints
            curves.Item("PowerfluidInPump").ClearPoints
            curves.Item("PowerESPInPump").ClearPoints
            curves.Item("EffESPInPump").ClearPoints
            curves.Item("q_mix_InPump").ClearPoints
            
            curves.Item("mu_stage_cP").ClearPoints
            curves.Item("corr_visc_h_").ClearPoints
            curves.Item("corr_visc_q_").ClearPoints
            curves.Item("corr_visc_pow_").ClearPoints
            curves.Item("corr_visc_eff_").ClearPoints
            curves.Item("gas_corr_").ClearPoints
                   
            p_curve_.ClearPoints
            t_curve_.ClearPoints
    End If
    
    ' init gas correction coefficient
    ' if calc from intake - it will be reinitialased later
    ' if calc from discharge - it can be set manually here
    gas_corr_ = GasCorrection_d(0, gas_correct)
    
    With fluid
        ' if  calc from intake - then save intake condition to 0 stage
        ' and calc intake gas fraction  and gas correction coefficient
        If Not calc_from_dis And saveCurve Then
            ' calc PVT for intake conditions
            Call .calc_PVT(Pst_atma, Tst_C)    ' calc properties for inteke conditions
            gas_frac_intake_ = .gas_fraction_d
            gas_corr_ = GasCorrection_d(gas_frac_intake_, gas_correct) ' reinit gas correction
            
            curves.Item("gas_fractionInPump").AddPoint n, .f_g
            curves.Item("PressureInPump").AddPoint n, Pst_atma
            curves.Item("TempInPump").AddPoint n, Tst_C
            curves.Item("PowerfluidInPump").AddPoint n, 0
            curves.Item("PowerESPInPump").AddPoint n, 0
            curves.Item("EffESPInPump").AddPoint n, 0
            curves.Item("q_mix_InPump").AddPoint n, .q_mix_rc_m3day
            
            curves.Item("mu_stage_cP").AddPoint n, .mu_mix_cP
            curves.Item("corr_visc_h_").AddPoint n, corr_visc_h_
            curves.Item("corr_visc_q_").AddPoint n, corr_visc_q_
            curves.Item("corr_visc_pow_").AddPoint n, corr_visc_pow_
            curves.Item("corr_visc_eff_").AddPoint n, corr_visc_eff_
            curves.Item("gas_corr_").AddPoint n, gas_corr_
            
            p_curve_.AddPoint HmesStage_m(CDbl(n)), Pst_atma
            t_curve_.AddPoint HmesStage_m(CDbl(n)), Tst_C
        End If
        
        If calc_from_dis And saveCurve Then
            ' calc PVT for intake conditions
            Call .calc_PVT(Pst_atma, Tst_C)    ' calc properties for inteke conditions
            
            curves.Item("gas_fractionInPump").AddPoint stage_num, .f_g
            curves.Item("PressureInPump").AddPoint stage_num, Pst_atma
            curves.Item("TempInPump").AddPoint stage_num, Tst_C
            curves.Item("PowerfluidInPump").AddPoint stage_num, 0
            curves.Item("PowerESPInPump").AddPoint stage_num, 0
            curves.Item("EffESPInPump").AddPoint stage_num, 0
            curves.Item("q_mix_InPump").AddPoint stage_num, .q_mix_rc_m3day
            
            curves.Item("mu_stage_cP").AddPoint stage_num, .mu_mix_cP
            curves.Item("corr_visc_h_").AddPoint stage_num, corr_visc_h_
            curves.Item("corr_visc_q_").AddPoint stage_num, corr_visc_q_
            curves.Item("corr_visc_pow_").AddPoint stage_num, corr_visc_pow_
            curves.Item("corr_visc_eff_").AddPoint stage_num, corr_visc_eff_
            curves.Item("gas_corr_").AddPoint stage_num, gas_corr_
            
            p_curve_.AddPoint HmesStage_m(CDbl(stage_num)), Pst_atma
            t_curve_.AddPoint HmesStage_m(CDbl(stage_num)), Tst_C
        End If
        
        
              
        ' ====================== start main loop ================================================
        Do While n < stage_num '+ 1
            If calc_from_dis Then
                If stage_num - n - dNst > 0 Then  ' смотрим какой будет величина следующего шага
                    Nst = dNst                          ' мелкие шаги оставляем в зоне низкий давлений
                Else
                    Nst = 1
                End If
            Else
                If (stage_num - n) Mod dNst = 0 Then  ' смотрим какой будет величина следующего шага
                    Nst = dNst                          ' мелкие шаги оставляем в зоне низкий давлений
                Else
                    Nst = 1
                End If
            End If
            
            Call .calc_PVT(Pst_atma + dPav, Tst_C + dTav)  ' делаем поправку на давление и температуру
            
            ' re init gas correction for each stage mode if applicable
            If gas_correct > 99 Then
                gas_corr_ = GasCorrection_d(.gas_fraction_d, gas_correct - 100)
            End If
            q_mix_ = .q_mix_rc_m3day
            q_mix__degr = q_mix_ * c_calibr_rate
            head_mix = get_ESP_head_m(q_mix__degr, Nst, .mu_mix_cSt) * c_calibr_head * gas_corr_
            head_real_m_ = head_real_m_ + head_mix
            dPStage = .rho_mix_rc_kgm3 * head_mix * const_g * const_convert_Pa_atma ' тут когда то надо сделать коррекцию характеристики на плотность
            Pst_atma = Pst_atma + sign_int * dPStage
            dPav = dPStage / 2 * sign_int
            If dPStage > 0 Then
                ' оценим работу совершаемую насосом по перекачке жидкости
                PowfluidWt = q_mix_ * const_convert_m3day_m3sec * dPStage * const_convert_atma_Pa   ' мощность с поправкой на плотность ГЖС
                PowfluidTot_Wt = PowfluidTot_Wt + PowfluidWt
                ' оценим мощность потребляемую насосом с вала
                PowESP_Wt = get_ESP_power_W(q_mix__degr, Nst, .mu_mix_cSt) * .rho_mix_rc_kgm3 / 1000 * c_calibr_power                ' мощность потребляемая одной ступенью на воде
                PowESPTot_Wt = PowESPTot_Wt + PowESP_Wt
                ' оценим КПД ступени в данных условиях
                If (PowESPTot_Wt > 0) Then
                    EffESP_d = PowfluidTot_Wt / PowESPTot_Wt
                Else
                    EffESP_d = 0
                End If
                
                If (PowESP_Wt > 0) Then
                    EffStage = PowfluidWt / PowESP_Wt
                Else
                    EffStage = 0
                End If
                
                If t_dis_C <= 0 And (Not calc_from_dis) Then ' оценка температуры по ступеням
                    If EffStage > 0 Then
                        dTpump_C = const_g * head_mix / .cmix_JkgC * (1 - EffStage) / EffStage
                    Else
                        dTpump_C = 0
                    End If
                Else
                    dTpump_C = (t_dis_C - t_intake_C) / stage_num * Nst
                End If
                
                If Tst_C < 299 Then
                    Tst_C = Tst_C + sign_int * dTpump_C
                    dTav = sign_int * dTpump_C / 2
                End If
                
                If Tst_C > 300 Then
                    Tst_C = 299
                    dTav = 0
                End If
                
                dTpumpSum_C = dTpumpSum_C + dTpump_C
            Else
                PowfluidWt = 0
                PowESP_Wt = 0
                EffESP_d = 0
            End If
            
            n = n + Nst
            
            If saveCurve Then
                If calc_from_dis Then
                    nn = stage_num - n + 1
                Else
                    nn = n
                End If
                curves.Item("gas_fractionInPump").AddPoint nn, .f_g
                curves.Item("PressureInPump").AddPoint nn, Pst_atma
                curves.Item("TempInPump").AddPoint nn, Tst_C
                curves.Item("PowerfluidInPump").AddPoint nn, PowfluidTot_Wt
                curves.Item("PowerESPInPump").AddPoint nn, PowESPTot_Wt
                curves.Item("EffESPInPump").AddPoint nn, EffESP_d
                curves.Item("q_mix_InPump").AddPoint nn, q_mix_
                
                
                curves.Item("mu_stage_cP").AddPoint nn, .mu_mix_cP
                curves.Item("corr_visc_h_").AddPoint nn, corr_visc_h_
                curves.Item("corr_visc_q_").AddPoint nn, corr_visc_q_
                curves.Item("corr_visc_pow_").AddPoint nn, corr_visc_pow_
                curves.Item("corr_visc_eff_").AddPoint nn, corr_visc_eff_
                curves.Item("gas_corr_").AddPoint nn, gas_corr_
                    
                p_curve_.AddPoint HmesStage_m(CDbl(nn)), Pst_atma
                t_curve_.AddPoint HmesStage_m(CDbl(nn)), Tst_C
            End If
            I = I + 1
        Loop
        ' ====================== end main loop ================================================
        If calc_from_dis Then
                nn = 0
                curves.Item("gas_fractionInPump").AddPoint nn, .f_g
                curves.Item("PressureInPump").AddPoint nn, Pst_atma
                curves.Item("TempInPump").AddPoint nn, Tst_C
                curves.Item("PowerfluidInPump").AddPoint nn, PowfluidTot_Wt
                curves.Item("PowerESPInPump").AddPoint nn, PowESPTot_Wt
                curves.Item("EffESPInPump").AddPoint nn, EffESP_d
                curves.Item("q_mix_InPump").AddPoint nn, q_mix_
                
                
                curves.Item("mu_stage_cP").AddPoint nn, .mu_mix_cP
                curves.Item("corr_visc_h_").AddPoint nn, corr_visc_h_
                curves.Item("corr_visc_q_").AddPoint nn, corr_visc_q_
                curves.Item("corr_visc_pow_").AddPoint nn, corr_visc_pow_
                curves.Item("corr_visc_eff_").AddPoint nn, corr_visc_eff_
                curves.Item("gas_corr_").AddPoint nn, gas_corr_
                    
                p_curve_.AddPoint HmesStage_m(CDbl(nn)), Pst_atma
                t_curve_.AddPoint HmesStage_m(CDbl(nn)), Tst_C
        
        End If
        
        
        If dTpumpSum_C > 298 Then
                addLogMsg "Перегрев около УЭЦН, расчетная температура =" & Format(Tst_C, "##0") & _
                              " рост температуры на ступени =" & Format(dTpump_C, "##0") & _
                              " КПД ступени =" & Format(EffStage, "##0.00") & _
                              " Дебит ступени =" & Format(.q_mix_rc_m3day, "##0.00") & _
                              " Температура исправлена на 299"
        End If
    End With
    power_ESP_Wt_ = PowESPTot_Wt
    power_fluid_Wt_ = PowfluidTot_Wt
    
    If calc_from_dis Then
        p_int_atma_ = Pst_atma
    Else
        p_dis_atma_ = Pst_atma
        t_dis_C_ = Tst_C
    End If
    
    eff_ESP_d_ = EffESP_d
    Exit Sub
err1:
    Dim errmsg As String
    errmsg = "Error:CESPpump.ESP_dPIntegration: " & sDELIM & Err.Description
    addLogMsg errmsg
    Err.Raise kErrESPcalc, Err.source, errmsg
End Sub
Public Sub set_num_stages(head_m As Double)
'  функция расчета необходимого числа ступеней для обеспечения заданного напора
    Dim Head1st As Double
    Head1st = get_ESP_head_m(rate_nom_sm3day, 1)
    If Head1st > 0 Then
        stage_num = CInt(head_m / Head1st)
    End If
End Sub
Public Function get_num_stages(q_mix_rc_m3day As Double, head_m As Double) As Integer
'  функция расчета необходимого числа ступеней для обеспечения заданного напора
    Dim Head1st As Double
    Head1st = get_ESP_head_m(q_mix_rc_m3day, 1)
    If Head1st > 0 Then
        get_num_stages = CInt(head_m / Head1st)
    Else
        get_num_stages = 0
    End If
End Function
Public Sub calc_ESP(p_atma As Double, t_intake_C As Double, Optional t_dis_C As Double = 0, _
                        Optional calc_from_intake As Boolean = True, _
                        Optional saveCurve As Boolean = False)
' метод расчета работы насоса
    Call ESP_dPIntegration(p_atma, t_intake_C, t_dis_C, Not calc_from_intake, saveCurve)
End Sub
Private Sub Class_Initialize()
    Set fluid = New CPVT
    correct_visc_ = True
    
    c_calibr_head = 1 ' по умолчанию нет деградации
    c_calibr_rate = 1 ' по умолчанию нет деградации
    c_calibr_power = 1 ' по умолчанию нет деградации
    
    stage_num = 1
    freq_Hz = 50
    
    Call corrections_clear
    
    gas_correct = 1
    turb_head_factor = 1 ' 2 ' 0.5
    turb_rate_factor = 1 ' 1.1 '0.9
    dnum_stages_integrate = 1
    
    h_mes_top_m = 1000
End Sub
' метод для построения кривых характеристик УЭЦН
Public Sub build_curves(Optional ByVal qliq As Double = -1)
    Dim I As Integer
    Dim degr_temp As Double
    Dim qmin As Double, qmax As Double, qcalc As Double
    Dim qold As Double
    qold = fluid.qliq_sm3day
    Const num_points = 20
    
    curves.Item("Head").ClearPoints
    curves.Item("Effeciency").ClearPoints
    curves.Item("Power").ClearPoints
    curves.Item("NominalPressureDrop").ClearPoints
    curves.Item("RealPressureDrop").ClearPoints
    curves.Item("RealEfficiency").ClearPoints
    curves.Item("RealPower").ClearPoints
    curves.Item("RealHead").ClearPoints
    curves.Item("PumpTdis").ClearPoints
    curves.Item("PumpTint").ClearPoints
    
    qmin = 0.1
    qmax = rate_max_sm3day(-1)
    For I = 0 To num_points
        qcalc = (qmax - qmin) / num_points * I + qmin
        
        Me.fluid.fw_perc = fluid.fw_perc
        Me.fluid.qliq_sm3day = qcalc
    
        curves.Item("Head").AddPoint qcalc, get_ESP_head_m(qcalc)
        curves.Item("Power").AddPoint qcalc, get_ESP_power_W(qcalc)
        curves.Item("Effeciency").AddPoint qcalc, get_ESP_effeciency_fr(qcalc)
        
        degr_temp = c_calibr_head
        c_calibr_head = 0
        Call calc_ESP(p_int_atma_, t_int_C_)
        curves.Item("NominalPressureDrop").AddPoint qcalc, p_dis_atma_ - p_int_atma_
        
        c_calibr_head = degr_temp
        Call calc_ESP(p_int_atma_, t_int_C_)
        curves.Item("RealPressureDrop").AddPoint qcalc, p_dis_atma_ - p_int_atma_
        curves.Item("RealPower").AddPoint qcalc, power_fluid_Wt_
        curves.Item("RealEfficiency").AddPoint qcalc, eff_ESP_d_
        curves.Item("RealHead").AddPoint qcalc, head_real_m_
        curves.Item("PumpTdis").AddPoint qcalc, t_dis_C_
        curves.Item("PumpTint").AddPoint qcalc, t_int_C_
    Next I
    If qliq < 0 Then Me.fluid.qliq_sm3day = qold
    Call calc_ESP(p_int_atma_, t_int_C_)
End Sub
Public Sub Copy(pump As CESPpump)
  
    With pump
       stage_num = .stage_num
       freq_Hz = .freq_Hz
       t_int_C_ = .t_int_C
       t_dis_C_ = .t_dis_C
       
       Call fluid.Copy(.fluid)
        
       p_int_atma_ = .p_int_atma
       p_dis_atma_ = .p_dis_atma
       
       db_ = pump.db
       
       c_calibr_head = .c_calibr_head
       c_calibr_rate = .c_calibr_rate
       c_calibr_power = .c_calibr_power
       
       h_mes_top_m = .h_mes_top_m
       angle_deg = .angle_deg
       turb_head_factor = .turb_head_factor
       turb_rate_factor = .turb_rate_factor
       dnum_stages_integrate = .dnum_stages_integrate
       
    End With
     
End Sub
Public Property Get correct_visc() As Boolean
    correct_visc = correct_visc_
End Property
Public Property Let correct_visc(val As Boolean)
    correct_visc_ = val
    If Not correct_visc_ Then
        Call corrections_clear
    End If
End Property
Private Sub calc_CorrVisc_PetrInst(ByVal q_mix_ As Double, ByVal nu_cSt As Double)
' метод для расчета корректировки напорной характеристики УЭЦН на вязкость для текущего насоса
' расчет для одной ступени
    
    Dim GAMMA As Double
    Dim QwBEP_100gpm As Double, HwBEP_ft As Double
    Dim Qstar As Double
    Dim Q0 As Double, Q0_6 As Double, Q0_8 As Double, Q1_0 As Double, Q1_2 As Double, qmax As Double
    Dim H0 As Double, H0_6 As Double, H0_8 As Double, H1_0 As Double, H1_2 As Double, Hmax As Double
    
    Dim corr_visc_h__                ' поправочный коэффициень для напорной характеристики на вязкость для текущего дебита и текущего расчета
    Dim corr_visc_q__                ' для дебита
    Dim corr_visc_pow__              ' для мощности
    Dim corr_visc_eff__              ' для КПД
On Error GoTo err1:
    ' turn off object correction factors
    corr_visc_h_ = 1             ' поправочный коэффициень для напорной характеристики на вязкость для текущего дебита и текущего расчета
    corr_visc_q_ = 1               ' для дебита
    corr_visc_pow_ = 1             ' для мощности
    corr_visc_eff_ = 1             ' для КПД
    
    ' turn off local corr factors as well
    corr_visc_h__ = 1             ' поправочный коэффициень для напорной характеристики на вязкость для текущего дебита и текущего расчета
    corr_visc_q__ = 1               ' для дебита
    corr_visc_pow__ = 1             ' для мощности
    corr_visc_eff__ = 1             ' для КПД
    
    If nu_cSt < 5 Then Exit Sub
    
    QwBEP_100gpm = Me.rate_nom_sm3day * const_convert_m3day_gpm '/ 100   '   похоже к книге Такаса ошибка - не надо делить на 100 тут
    HwBEP_ft = Me.get_ESP_head_m(Me.rate_nom_sm3day, 1) * const_convert_m_ft
    GAMMA = -7.5946 + 6.6504 * Log(HwBEP_ft) + 12.8429 * Log(QwBEP_100gpm)
    Qstar = Exp((39.5276 + 26.5606 * Log(nu_cSt) - GAMMA) / 51.6565)
    corr_visc_q__ = 1 - 4.0327 * 10 ^ (-3) * Qstar - 1.724 * 10 ^ (-4) * Qstar ^ 2
    
    If (corr_visc_q__ < 0) Then
        corr_visc_h__ = 0
        'exit without changes to object state
        Exit Sub
    End If
    
    corr_visc_eff__ = 1 - 3.3075 * 10 ^ (-2) * Qstar + 2.8875 * 10 ^ (-4) * Qstar ^ 2
    corr_visc_pow__ = 1 / corr_visc_eff__
    
    
    Q0 = 0:
    ' rate_nom_sm3day has inside correction corr_visc_q_ - but not here
    Q1_0 = rate_nom_sm3day * corr_visc_q__
    H1_0 = 1 - 7.00763 * 10 ^ (-3) * Qstar - 1.41 * 10 ^ (-5) * Qstar ^ 2
    Q0_8 = Q1_0 * 0.8
    H0_8 = 1 - 4.4726 * 10 ^ (-3) * Qstar - 4.18 * 10 ^ (-5) * Qstar ^ 2
    Q0_6 = Q1_0 * 0.6
    H0_6 = 1 - 3.68 * 10 ^ (-3) * Qstar - 4.36 * 10 ^ (-5) * Qstar ^ 2
    Q1_2 = Q1_0 * 1.2
    H1_2 = 1 - 9.01 * 10 ^ (-3) * Qstar + 1.31 * 10 ^ (-5) * Qstar ^ 2
    qmax = rate_max_sm3day(-1) * corr_visc_q__
    Hmax = H1_2
    
    
    If qmax < Q1_2 Then
        addLogMsg "CESPpump.calc_CorrVisc_PetrInst error. qmax >= Qmom * 1.2. Correction neglected"
        Exit Sub
       ' тут что то не так с характеристиков насоса - номинальный и максимальный дебит не соответствуют друг другу
    End If
    
    h_corr_qd_curve_.ClearPoints
    
    'Call h_corr_qd_curve_.AddPoint(Qmax, Hmax)
    Call h_corr_qd_curve_.AddPoint(Q1_2, H1_2)
    Call h_corr_qd_curve_.AddPoint(Q1_0, H1_0)
    Call h_corr_qd_curve_.AddPoint(Q0_8, H0_8)
    Call h_corr_qd_curve_.AddPoint(Q0_6, H0_6)
    H0 = h_corr_qd_curve_.getPoint(Q0) ' пытаемся экстраполировать
    If H0 < 0 Then H0 = H0_6
    Call h_corr_qd_curve_.AddPoint(Q0, H0)
    
    If q_mix_ > qmax Then q_mix_ = qmax
    
    corr_visc_h__ = h_corr_qd_curve_.getPoint(q_mix_)
    
    corr_visc_h_ = corr_visc_h__             ' поправочный коэффициень для напорной характеристики на вязкость для текущего дебита и текущего расчета
    corr_visc_q_ = corr_visc_q__               ' для дебита
    corr_visc_pow_ = corr_visc_pow__             ' для мощности
    corr_visc_eff_ = corr_visc_eff__             ' для КПД
    
    Exit Sub
err1:
    Dim msg As String
    msg = "CESPpump.calc_CorrVisc_PetrInst error with params q_mix_ = " & CStr(q_mix_) & " nu_cSt = " & CStr(nu_cSt)
    
End Sub
' метод для доступа к кривой давления в насосе относительно измеренных глубин
Public Property Get p_curve() As CInterpolation
    Set p_curve = p_curve_
End Property
Public Property Get t_curve() As CInterpolation
    Set t_curve = t_curve_
End Property
Public Function CheckShaft(ByVal M_Nm As Double) As Boolean
' проверка допустимой прочности вала
    Dim Pow_nom_kW As Double   ' мощность приведенная к номинальной
    Pow_nom_kW = M_Nm * w_radsec / 1000
    If Pow_nom_kW < db_.power_limit_shaft_kW Then
        CheckShaft = True
    ElseIf Pow_nom_kW < db_.power_limit_shaft_max_kW Then
        CheckShaft = False
        addLogMsg "Превышена нагрузка на вал. Требуется использовать вал повышенной прочности"
        ' здесь надо предпринимать действия по прочности вала
    Else
        CheckShaft = False
        addLogMsg "Превышена нагрузка на вал для вала повышенной прочности"
    End If
End Function
' свойство выдает момент на валу потребляемый насосом
Public Property Get M_Nm() As Double
    M_Nm = power_ESP_Wt_ / w_radsec
End Property
' функция расчета деградации из за газа
Private Function GasCorrection_d(GasFracIn As Double, Optional ByVal gas_degr_value As Double = 0) As Double
' переделываем логику расчета поправки на газ для ЭЦН
' чтобы можноб было задать руками и выбрать модель тоже
' gas_degr_value  - тип насоса по работе с газом:
'           0-2 значение применяется напрямую;
'           10 стандартный ЭЦН (предел 25%);
'           20 ЭЦН с газостабилизирующим модулем (предел 50%);
'           30 ЭЦН с осевым модулем (предел 75%);
'           40 ЭЦН с модифицированным ступенями (предел 40%).
'           110+, тогда модель n-100 применяется ко всем ступеням отдельно
'           Предел по доле газа на входе в насос после сепарации
'           на основе статьи SPE 117414 (с корректировкой)
'           поправка дополнительная к деградации (суммируется).
Dim b As Double
    b = 0
    If GasFracIn > 0 And GasFracIn < 1 Then
        b = GasFracIn
    End If
    If gas_degr_value >= 0 And gas_degr_value <= 2 Then
        GasCorrection_d = gas_degr_value
    ElseIf gas_degr_value > 9.99 And gas_degr_value < 10.01 Then
    
        GasCorrection_d = -9 * b ^ 2 + 0.6 * b + 1    ' SPE 117414
    
    ElseIf gas_degr_value > 19.99 And gas_degr_value < 20.01 Then
        GasCorrection_d = -2 * b ^ 2 + 0.05 * b + 1    ' SPE 117414  corrected rnt
    ElseIf gas_degr_value > 29.99 And gas_degr_value < 30.01 Then
        GasCorrection_d = -1.4 * b ^ 2 + 0.15 * b + 1    ' SPE 117414
    ElseIf gas_degr_value > 39.99 And gas_degr_value < 40.01 Then
        GasCorrection_d = -4 * b ^ 2 + 0.2 * b + 1    ' SPE 117414   corrected rnt
    Else
        GasCorrection_d = 1
    End If
    If GasCorrection_d < 0 Then GasCorrection_d = 0
End Function
Public Function array_out(Optional ByVal num_points As Integer = 20)
' подготовка массива для вывода в Excel
' num_points - количество точек в выходных массивах для вывода
'
    Dim arr()
    Dim M As Integer
   ' Dim FlowParams_out As PIPE_FLOW_PARAMS
    Dim offset As Integer
    Dim I As Integer
    Dim hh As Double
    
    offset = 2
On Error Resume Next
    Dim crv_P As CInterpolation
    Dim crv_T As CInterpolation
    
    ' rearrange output curves one time here - will be used later
    Set crv_P = curves.Item("PressureInPump").ClonePointsToNum(num_points)
    Set crv_T = curves.Item("TempInPump").ClonePointsToNum(num_points)
    
    M = crv_P.num_points
    ReDim arr(M + offset + 4, 16)
    
    ' в первом ряду параметров выведем результаты расчета
    ' которые могут пригодится в явном виде при массовых расчетах
    arr(0, 0) = 0
    arr(0, 1) = p_int_atma
    arr(0, 2) = t_int_C
    arr(0, 3) = p_dis_atma
    arr(0, 4) = t_dis_C
    arr(0, 5) = head_m
    arr(0, 6) = M_Nm
    arr(0, 7) = length_m
    arr(0, 8) = power_fluid_W
    arr(0, 9) = power_ESP_W
    arr(0, 10) = eff_ESP_d
    arr(0, 11) = gas_frac_intake_
    arr(0, 12) = gas_corr_
    
    arr(1, 0) = "0"
    arr(1, 1) = "p_int_atma"
    arr(1, 2) = "t_int_C"
    arr(1, 3) = "p_dis_atma"
    arr(1, 4) = "t_dis_C"
    arr(1, 5) = "head_m"
    arr(1, 6) = "m_Nm"
    arr(1, 7) = "length_m"
    arr(1, 8) = "power_fluid_W"
    arr(1, 9) = "power_ESP_W"
    arr(1, 10) = "eff_ESP_d"
    arr(1, 11) = "gas_frac_intake_"
    arr(1, 12) = "gas_corr_"
    
    
    
'    arr(offset, 1) = "n stage"
'    arr(offset, 2) = "p atma"
'    arr(offset, 3) = "t C"
'    arr(offset, 4) = "gas fraction"
'    arr(offset, 5) = "qmix rm3day"
'    arr(offset, 6) = "Power fluid W"
'    arr(offset, 7) = "Power ESP W"
'    arr(offset, 8) = "eff fluid"
'    arr(offset, 9) = "length m"
'    arr(offset, 10) = "p atma length"
'    arr(offset, 11) = "t C length"
    
    Dim j As Integer
    
    For I = 0 To M
      
        j = 0
        hh = crv_P.pointX(I)   ' fractional stage number :)
        If I = 0 Then
            arr(offset + I, j) = "i"
        Else
            arr(offset + I, 0) = I
        End If
        
        j = j + 1
        If I = 0 Then
            arr(offset + I, j) = "n_stage"
        Else
            arr(offset + I, j) = hh
        End If
        
        j = j + 1
        If I = 0 Then
            arr(offset, j) = "length_m"
        Else
            arr(offset + I, j) = HmesStage_m(hh)
        End If
        
        j = j + 1
        If I = 0 Then
            arr(offset + I, j) = "p_atma"
        Else
            arr(offset + I, j) = curves.Item("PressureInPump").getPoint(hh)
        End If
        
        j = j + 1
        If I = 0 Then
            arr(offset + I, j) = "t_C"
        Else
            arr(offset + I, j) = curves.Item("TempInPump").getPoint(hh)
        End If
        
        j = j + 1
        If I = 0 Then
            arr(offset + I, j) = "gas_fraction"
        Else
            arr(offset + I, j) = curves.Item("gas_fractionInPump").getPoint(hh)
        End If
        
        j = j + 1
        If I = 0 Then
            arr(offset + I, j) = "qmix_rm3day"
        Else
            arr(offset + I, j) = curves.Item("q_mix_InPump").getPoint(hh)
        End If
        
        j = j + 1
        If I = 0 Then
            arr(offset, j) = "Power_fluid_W"
        Else
            arr(offset + I, j) = curves.Item("PowerfluidInPump").getPoint(hh)
        End If
        
        j = j + 1
        If I = 0 Then
            arr(offset, j) = "Power_ESP_W"
        Else
            arr(offset + I, j) = curves.Item("PowerESPInPump").getPoint(hh)
        End If
        
        j = j + 1
        If I = 0 Then
            arr(offset, j) = "eff fluid"
        Else
            arr(offset + I, j) = curves.Item("EffESPInPump").getPoint(hh)
        End If
        
        
        j = j + 1
        If I = 0 Then
            arr(offset, j) = "mu_stage_cP"
        Else
            arr(offset + I, j) = curves.Item("mu_stage_cP").getPoint(hh)
        End If
        
        j = j + 1
        If I = 0 Then
            arr(offset, j) = "corr_visc_h_"
        Else
            arr(offset + I, j) = curves.Item("corr_visc_h_").getPoint(hh)
        End If
        
        j = j + 1
        If I = 0 Then
            arr(offset, j) = "corr_visc_q_"
        Else
            arr(offset + I, j) = curves.Item("corr_visc_q_").getPoint(hh)
        End If
        
        
        j = j + 1
        If I = 0 Then
            arr(offset, j) = "corr_visc_pow_"
        Else
            arr(offset + I, j) = curves.Item("corr_visc_pow_").getPoint(hh)
        End If
        
        
        j = j + 1
        If I = 0 Then
            arr(offset, j) = "corr_visc_eff_"
        Else
            arr(offset + I, j) = curves.Item("corr_visc_eff_").getPoint(hh)
        End If
        
        
        j = j + 1
        If I = 0 Then
            arr(offset, j) = "gas_corr_"
        Else
            arr(offset + I, j) = curves.Item("gas_corr_").getPoint(hh)
        End If
        
    Next I
    
'            curves.Item("mu_stage_cP").ClearPoints
'        curves.Item("corr_visc_h_").ClearPoints
'        curves.Item("corr_visc_q_").ClearPoints
'        curves.Item("corr_visc_pow_").ClearPoints
'        curves.Item("corr_visc_eff_").ClearPoints
'        curves.Item("gas_corr_").ClearPoints
    
        ' во втором ряде параметров справочные параметры
    arr(M + offset + 2, 0) = calc_from_dis_
    arr(M + offset + 2, 1) = db_.name
    arr(M + offset + 2, 2) = stage_num
    arr(M + offset + 2, 3) = freq_Hz
    arr(M + offset + 2, 4) = w_obmin
    arr(M + offset + 2, 5) = rate_nom_sm3day
    arr(M + offset + 2, 6) = rate_max_sm3day(-1)
    arr(M + offset + 2, 7) = c_calibr_head
    arr(M + offset + 2, 8) = c_calibr_rate
    arr(M + offset + 2, 9) = c_calibr_power
    arr(M + offset + 2, 10) = gas_correct
    arr(M + offset + 2, 11) = turb_head_factor
    arr(M + offset + 2, 12) = turb_rate_factor
    
    arr(M + offset + 1, 0) = "calc_from_dis"
    arr(M + offset + 1, 1) = "name"
    arr(M + offset + 1, 2) = "stage_num"
    arr(M + offset + 1, 3) = "freq_Hz"
    arr(M + offset + 1, 4) = "w_obmin"
    arr(M + offset + 1, 5) = "rate_nom_sm3day"
    arr(M + offset + 1, 6) = "rate_max_sm3day"
    arr(M + offset + 1, 7) = "c_calibr_head"
    arr(M + offset + 1, 8) = "c_calibr_rate"
    arr(M + offset + 1, 9) = "c_calibr_power"
    arr(M + offset + 1, 10) = "gas_degr"
    arr(M + offset + 1, 11) = "turb_head_factor"
    arr(M + offset + 1, 12) = "turb_rate_factor"
    arr(M + offset + 1, 13) = ""
    arr(M + offset + 1, 14) = ""
    arr(M + offset + 1, 15) = ""
    arr(M + offset + 4, 0) = db_.ID
    arr(M + offset + 4, 1) = db_.source
    arr(M + offset + 4, 2) = db_.manufacturer
    arr(M + offset + 4, 3) = db_.name
    arr(M + offset + 4, 4) = db_.freq_Hz
    arr(M + offset + 4, 5) = db_.slip_nom_rpm
    arr(M + offset + 4, 6) = db_.rate_nom_sm3day
    arr(M + offset + 4, 7) = db_.rate_opt_min_sm3day
    arr(M + offset + 4, 8) = db_.rate_opt_max_sm3day
    arr(M + offset + 4, 9) = db_.height_stage_m
    arr(M + offset + 4, 10) = db_.stages_max
    arr(M + offset + 4, 11) = db_.d_od_m
    arr(M + offset + 4, 12) = db_.d_motor_od_m
    arr(M + offset + 4, 13) = db_.d_cas_min_m
    arr(M + offset + 4, 14) = db_.d_shaft_m
    arr(M + offset + 4, 15) = db_.power_limit_shaft_kW
    arr(M + offset + 4, 16) = db_.pressure_limit_housing_atma
    
    arr(M + offset + 3, 0) = "ID"
    arr(M + offset + 3, 1) = "source"
    arr(M + offset + 3, 2) = "manufacturer"
    arr(M + offset + 3, 3) = "name"
    arr(M + offset + 3, 4) = "freq_Hz"
    arr(M + offset + 3, 5) = "slip_nom_rpm"
    arr(M + offset + 3, 6) = "rate_nom_sm3day"
    arr(M + offset + 3, 7) = "rate_opt_min_sm3day"
    arr(M + offset + 3, 8) = "rate_opt_max_sm3day"
    arr(M + offset + 3, 9) = "height_stage_m"
    arr(M + offset + 3, 10) = "stages_max"
    arr(M + offset + 3, 11) = "d_od_m"
    arr(M + offset + 3, 12) = "d_motor_od_m"
    arr(M + offset + 3, 13) = "d_cas_min_m"
    arr(M + offset + 3, 14) = "d_shaft_m"
    arr(M + offset + 3, 15) = "power_limit_shaft_kW"
    arr(M + offset + 3, 16) = "pressure_limit_housing_atma"
    
    
    array_out = arr
End Function

