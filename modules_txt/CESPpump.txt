'=======================================================================================
'Unifloc 7.51  2025.03                                  khabibullinra@gmail.com
'Petroleum engineering calculations modules (macroses)
'2000 - 2025
'
'=======================================================================================
'
'
' класс для моделирования работы погружной части ЭЦН
' описывает работу набора одинаковых ступеней
'
Option Explicit
Option Base 0
Public log_ As New CLogger                      ' create new log list for each object
' геометрические параметры насоса
Public h_mes_top_m As Double           ' глубина установки ЭЦН (по верхней части)
Public angle_deg As Double             ' угол установки УЭЦН (предполагается, что по глубине угол не меняется) ' not used for 7.24
' общие параметры
Public fluid As CPVT                   ' флюид движущийся через насос (с учетом сепарации газа)
Public calibr_head As Double         ' деградация характеристики УЭЦН по напору
Public calibr_rate As Double         ' деградация характеристики УЭЦН по дебиту
Public calibr_power As Double        ' деградация по мощности (она же по КПД системы)
' набор параметром для задания поведения в зоне турбинного вращения (когда дебит больше максимального)
'Public turb_head_factor As Double
'Public turb_rate_factor As Double
Public dnum_stages_integrate As Integer
Public freq_Hz As Double               ' частота вращения вала насоса (используется для расчета)
'Public freq_nom_Hz As Double           ' номинальная частота для которой задан номинальный напор
'Public head_nom_m As Double
'Public q_nom_sm3day As Double
Public curves As New CCurves           ' все кривые планируется прятать тут
' параметры конструкции ЭЦН
Public stage_num As Integer            ' количество ступеней в насосе (используется для расчета характеристики насоса)
Private t_int_C_ As Double             ' температура потока на приемной сетке УЭЦН (учитывается нагрев двигателем)
Private t_dis_C_ As Double             ' температура потока на выкиде насоса (учитывается нагрев в насосе)
' параметры работы насоса для которых был проведен расчет
Private p_int_atma_ As Double          ' давление на приеме насоса (используется для расчета рабочих характеристик)
Private p_dis_atma_ As Double          ' давление на выкиде насоса
Private power_fluid_Wt_ As Double      ' Мощность передаваемая УЭЦН жидкости
Private power_ESP_Wt_ As Double        ' Мощность потребляемая ЭЦН с вала (механическая)
Private eff_ESP_d_ As Double           ' КПД УЭЦН по факту
Private head_real_m_ As Double
' параметры определяющие установку УЭЦН
Private db_ As ESP_PARAMS            ' набор параметров насоса из базы данных
Private db_json_string As String
Private gas_frac_intake_ As Double
Private gas_corr_ As Double
Private gas_corr_min As Double
Private gas_corr_max As Double
Public gas_correct_model As Integer
                            ' gas_correct_model       - тип насоса по работе с газом
                            '      gas_correct_model = 0 нет коррекции
                            '      gas_correct_model = 1 стандартный ЭЦН (предел 25%)
                            '      gas_correct_model = 2 ЭЦН с газостабилизирующим модулем (предел 50%)
                            '      gas_correct_model = 3 ЭЦН с осевым модулем (предел 75%)
                            '      gas_correct_model = 4 ЭЦН с модифицированным ступенями (предел 40%)
Public gas_correct_stage_by_stage As Boolean
'Public gas_correct As Double       ' тип для коррекции по газу
                                        ' ESP_gas_correct       - тип насоса по работе с газом
                                        '      ESP_gas_correct = 0 нет коррекции
                                        '      ESP_gas_correct = 1 стандартный ЭЦН (предел 25%)
                                        '      ESP_gas_correct = 2 ЭЦН с газостабилизирующим модулем (предел 50%)
                                        '      ESP_gas_correct = 3 ЭЦН с осевым модулем (предел 75%)
                                        '      ESP_gas_correct = 4 ЭЦН с модифицированным ступенями (предел 40%)
Private correct_visc_ As Boolean
Private corr_visc_h_ As Double          ' поправочный коэффициент для напорной характеристики на вязкость для текущего дебита и текущего расчета
Private corr_visc_q_ As Double          ' поправочный коэффициент для дебита
Private corr_visc_pow_ As Double        ' поправочный коэффициент для мощности
Private corr_visc_eff_ As Double        ' поправочный коэффициент для КПД
Private h_corr_qd_curve_ As New CInterpolation     ' зависимость поправочного коэффициента для напора от дебита (для расчета по модели американского института нефти)
Private p_curve_ As New CInterpolation  ' кривая распределения давления вдоль насоса   (как снаружи, так и внутри)
Private t_curve_ As New CInterpolation  ' кривая распределения температуры флюида вдоль насоса
Private calc_from_dis_ As Boolean
Public gassep_M_Nm As Double
Public Sub add_log_msg(msg As String)
    Call log_.add_msg(msg)
End Sub
Public Property Get db() As ESP_PARAMS
    db = db_
End Property
Public Property Let db(val As ESP_PARAMS)
    db_ = val
End Property
' =======================  геометрия
Public Property Get length_m() As Double
   length_m = db_.height_stage_m * stage_num
End Property
' глубина нижней точки установки
Public Property Get h_mes_down_m() As Double
   h_mes_down_m = h_mes_top_m + length_m
End Property
' функция для расчета высоты сбори из num ступеней
Private Function stages_heigth_m(ByVal num As Double) As Double
   If num <= stage_num Then
       stages_heigth_m = length_m / stage_num * num
   Else
       stages_heigth_m = length_m
   End If
End Function
' свойство для расчета измеренной глубины расположения i ступени
Public Property Get HmesStage_m(i As Double) As Double
   HmesStage_m = h_mes_down_m - stages_heigth_m(i) ' тут надо отнять длину ступеней выше контрольной
End Property
Public Property Get area_shaft_m2() As Double
   area_shaft_m2 = db_.d_shaft_m * db_.d_shaft_m / 4 * const_Pi
End Property
Public Property Get angle_vert_deg() As Double
   angle_vert_deg = angle_vert_deg - 90
End Property
' ========================  конец блока описания геометрии
Public Property Get head_m() As Double
   head_m = head_real_m_
End Property
Public Function points_num() As Integer
   points_num = UBound(db_.head_points) + 1
End Function
Property Get eff_ESP_d() As Double
   eff_ESP_d = eff_ESP_d_
End Property
Property Get power_fluid_W() As Double
   power_fluid_W = power_fluid_Wt_
End Property
Property Get power_ESP_W() As Double
   power_ESP_W = power_ESP_Wt_
End Property
Public Property Get p_int_atma() As Double
   p_int_atma = p_int_atma_
End Property
Public Property Get p_dis_atma() As Double
   p_dis_atma = p_dis_atma_
End Property
Public Property Get t_int_C() As Double
t_int_C = t_int_C_
End Property
Public Property Get t_dis_C() As Double
t_dis_C = t_dis_C_
End Property
Public Property Get w_obmin() As Double
   w_obmin = freq_Hz * 60
End Property
Public Property Let w_obmin(val As Double)
   freq_Hz = w_obmin / 60
End Property
Public Property Get w_radsec() As Double
   w_radsec = freq_Hz * 2 * const_Pi
End Property
Public Property Get rate_max_sm3day(ByVal mu_cSt As Double) As Double
    If correct_visc_ And (mu_cSt > 0) Then        ' если большая вязкость - сделаем коррекцию
        Call calc_correct_visc_PetrInst(0, mu_cSt)   ' метод меняет константы класса, которые влияют на характеристики насоса
    End If
   rate_max_sm3day = db_.rate_max_sm3day * freq_Hz / db_.freq_Hz * corr_visc_q_
End Property
Public Property Get rate_nom_sm3day(Optional ByVal mu_cSt As Double = -1) As Double
    If correct_visc_ And (mu_cSt > 0) Then        ' если большая вязкость - сделаем коррекцию
        Call calc_correct_visc_PetrInst(0, mu_cSt)   ' метод меняет константы класса, которые влияют на характеристики насоса
    End If
   rate_nom_sm3day = db_.rate_nom_sm3day * freq_Hz / db_.freq_Hz * corr_visc_q_
End Property
Private Function calc_ESP_head_nominal_m(ByVal q_m3day As Double, Optional ByVal stage_num As Integer = 1) As Double
' функция для расчета номинального напора насоса
    Dim B As Double                  ' отношение частот
    With db_
        B = .freq_Hz / freq_Hz  ' определим отношение реальной частоты УЭЦН к номинальной для которой заданы характеристики
        calc_ESP_head_nominal_m = B ^ (-2) * stage_num * crv_interpolation(.rate_points, .head_points, B * q_m3day, 2)(1, 1)
    End With
End Function
Private Sub corrections_clear()
    corr_visc_h_ = 1
    corr_visc_q_ = 1
    corr_visc_pow_ = 1
    corr_visc_eff_ = 1
End Sub
Public Function get_ESP_head_m(ByVal q_m3day As Double, Optional ByVal stage_num As Integer = -1, Optional ByVal mu_cSt As Double = -1) As Double
    Dim B As Double                 ' отношение частот
    Dim stage_num_to_calc As Integer ' число ступеней с которым будет проводиться расчет
    Dim maxQ As Double
    Dim q_calc_m3day As Double
    
    Call corrections_clear
    
    If q_m3day < 0 Then             ' проверим исходные данные на релевантность
        get_ESP_head_m = 0
        add_log_msg "CPumpESP.get_ESP_head_m: расчет характеристики насоса с отрицательным дебитом  Q_m3day = " & Format(q_m3day, "###0.00") & "Напор установлен = 0"
        Exit Function
    End If
    ' определяем число ступеней с которым будем проводить расчет
    If stage_num > 0 Then           ' если в явном виде задан параметр то его используем
        stage_num_to_calc = stage_num
    Else                            ' иначе использует количество ступеней из характеристики насоса
        stage_num_to_calc = Me.stage_num
    End If
    
    If correct_visc And (mu_cSt > 0) Then   ' если большая вязкость - сделаем коррекцию
        Call calc_correct_visc_PetrInst(q_m3day, mu_cSt)   ' метод меняет константы класса, которые влияют на характеристики насоса
    End If
    
    q_calc_m3day = q_m3day / corr_visc_q_    ' делаем коррекцию по вязкости для дебита
    maxQ = db_.rate_max_sm3day * freq_Hz / db_.freq_Hz                   ' здесь коррекция на вязкость тоже уже учтена
    
    If q_calc_m3day < maxQ Then
        get_ESP_head_m = calc_ESP_head_nominal_m(q_calc_m3day, stage_num_to_calc)
    Else
        ' here we assume that head will drop linearly in negative area with same slope as in zero head proximity with positive head
        get_ESP_head_m = -calc_ESP_head_nominal_m(maxQ * 0.95, stage_num_to_calc) * ((q_calc_m3day - maxQ) / (maxQ * 0.05))
    End If
    get_ESP_head_m = get_ESP_head_m * corr_visc_h_
End Function
Public Function get_ESP_power_W(ByVal q_m3day As Double, _
                       Optional ByVal stage_num As Integer = -1, _
                       Optional ByVal mu_cSt As Double = 1 _
                               ) As Double
    Dim B As Double
    Dim stage_num_to_calc As Integer
    Dim rate_max As Double
        
    Call corrections_clear
    
    If q_m3day < 0 Then
        get_ESP_power_W = 0
        add_log_msg "CPumpESP.get_ESP_power_W: расчет характеристики насоса с отрицательным дебитом  Q_m3day = " & q_m3day & "Мощность установлена = 0"
        Exit Function
    End If
    rate_max = rate_max_sm3day(mu_cSt)
    If q_m3day > rate_max Then
        ' assume that for high rate power consumption will not be less that at max rate
       q_m3day = rate_max
    End If
    ' определяем число ступеней с которым будем проводить расчет
    If stage_num > 0 Then        ' если в явном виде задан параметр то его используем
        stage_num_to_calc = stage_num
    Else                        ' иначе использует количество ступеней из характеристики насоса
        stage_num_to_calc = Me.stage_num
    End If
    If correct_visc And (mu_cSt > 0) Then   ' если большая вязкость - сделаем коррекцию
        Call calc_correct_visc_PetrInst(q_m3day, mu_cSt)   ' метод меняет константы класса, которые влияют на характеристики насоса
    End If
    q_m3day = q_m3day / corr_visc_q_   ' делаем коррекцию по вязкости
    With db_
        B = .freq_Hz / freq_Hz
        get_ESP_power_W = 1000 * B ^ (-3) * stage_num_to_calc * crv_interpolation(.rate_points, .power_points, B * q_m3day, 2)(1, 1)
        If get_ESP_power_W < 0 Then
            get_ESP_power_W = 0
        End If
        get_ESP_power_W = get_ESP_power_W * corr_visc_pow_
    End With
End Function
Public Function get_ESP_effeciency_fr(ByVal q_m3day As Double, Optional ByVal mu_cSt As Double = 1) As Double
    Dim B As Double
    Dim stage_num_to_calc As Integer
    
    Call corrections_clear
    
    If q_m3day < 0 Then
        get_ESP_effeciency_fr = 0
        add_log_msg "CPumpESP.get_ESP_effeciency_fr: расчет характеристики насоса с отрицательным дебитом  Q_m3day = " & q_m3day & "Мощность установлена = 0"
        Exit Function
    End If
    If q_m3day > rate_max_sm3day(mu_cSt) Then
        get_ESP_effeciency_fr = 0
        Exit Function
    End If
    If correct_visc And (mu_cSt > 0) Then   ' если большая вязкость - сделаем коррекцию
        Call calc_correct_visc_PetrInst(q_m3day, mu_cSt)   ' метод меняет константы класса, которые влияют на характеристики насоса
    End If
    q_m3day = q_m3day / corr_visc_q_   ' делаем коррекцию по вязкости
    B = db_.freq_Hz / freq_Hz
    get_ESP_effeciency_fr = crv_interpolation(db_.rate_points, db_.eff_points, B * q_m3day, 2)(1, 1)
    If get_ESP_effeciency_fr < 0 Then
        get_ESP_effeciency_fr = 0
    End If
    get_ESP_effeciency_fr = get_ESP_effeciency_fr * corr_visc_eff_
End Function
Public Function get_ESP_MaxOptimRate_m3day() As Double
' получения границы оптимального диапазона из базы
    get_ESP_MaxOptimRate_m3day = (freq_Hz / db_.freq_Hz) * db_.rate_opt_max_sm3day
End Function
Public Function get_ESP_MinOptimRate_m3day() As Double
' получения границы оптимального диапазона из базы
    get_ESP_MinOptimRate_m3day = (freq_Hz / db_.freq_Hz) * db_.rate_opt_min_sm3day
End Function
Private Sub calc_integration(ByVal p_atma, _
                             ByVal t_intake_C, _
                   Optional t_dis_C As Double = 0, _
                   Optional calc_from_dis As Boolean = False, _
                   Optional saveCurve As Boolean = False)
    ' Функция расчете распределения давления в УЭЦН - расчет снизу вверх от входного давления до выходного
    ' заодно считает и потребляемую мощность и КПД установки
    ' p_atma         pressure at pump intake
    ' t_intake_C     temprature at pump intake
    ' t_dis_C        температура на выходе, если задана учитывается, если нет то рассчитывается
    ' calc_from_dis  показывает будет ли предпринята попытка проинтегрировать сверху вниз насос
    ' p_int_estimation_atma приближения для давления на приеме, используется для расчета сверху вниз
    
    Dim i As Integer
    Dim head_mix As Double
    Dim dPStage As Double
    Dim PowfluidWt As Double, PowfluidTot_Wt As Double  ' полезная мощность передаваемая насосом жидкости
    Dim PowESP_Wt As Double, PowESPTot_Wt As Double     ' механическая мощность потребляемая насосом
    Dim EffESP_d As Double      ' КПД УЭЦН
    Dim EffStage As Double
    Dim dTpump_C As Double, dTpumpSum_C As Double
    Dim Pst_atma As Double
    Dim Tst_C As Double         ' температура по ступеням
    Dim sign_int As Integer
    Dim q_mix_ As Double, q_mix__degr As Double
    Dim dNst As Integer  ' шаг ускорения при интегрировании большими шагами
    Dim Nst As Integer   ' шаг на текущей итерации
    Dim n As Integer     ' текущий номер ступени
    Dim nn As Integer    ' номер ступени от приема для записи в архив
    Dim dPav As Double   ' поправки на давление и температуру при интегрировании
    Dim dTav As Double
   
            Dim q_rel As Double
    dNst = dnum_stages_integrate ' для начала пытаемся интегрировать такими шагами
             ' если тут поставить 10 будет быстрее считать за счет снижение числа шагов
             ' при этом может копиться ошибка, особенно если мало ступеней
    'dNst = 10 ' может быть надо будет когда то сделать глобальную настройку по скорости точности
    dPav = 0
    dTav = 0
    gas_corr_ = 1
On Error GoTo err1:
    calc_from_dis_ = calc_from_dis  ' save state to object
    
    Dim tstart As Single
    tstart = Timer
    log_.add_msg "CESPpump start:"
    log_.add_msg "{""gas_correct_model"" :" & CStr(gas_correct_model) & _
            ", ""gas_correct_stage_by_stage"" : " & IIf(gas_correct_stage_by_stage, 1, 0) & _
            ", ""dnum_stages_integrate"" : " & CStr(dnum_stages_integrate) & _
            ", ""calc_from_dis"": " & IIf(calc_from_dis, 1, 0) & "}"
    ' rearrange variables to calc direction
    If calc_from_dis Then
        If t_dis_C < 0 Then t_dis_C = t_intake_C
        Tst_C = t_dis_C
        p_dis_atma_ = p_atma
        sign_int = -1
    Else
        Tst_C = t_intake_C
        p_int_atma_ = p_atma
        sign_int = 1
    End If
    
    ' init auxiliary variables
    Call corrections_clear
    Pst_atma = p_atma
    dTpumpSum_C = 0
    head_real_m_ = 0
    t_int_C_ = t_intake_C
    t_dis_C_ = t_dis_C
    PowfluidWt = 0
    PowfluidTot_Wt = 0
    PowESP_Wt = 0
    PowESPTot_Wt = 0
    dTpumpSum_C = 0
    n = 0
    i = 0
    If saveCurve Then
            curves.Item("gas_fractionInPump").ClearPoints
            curves.Item("PressureInPump").ClearPoints
            curves.Item("TempInPump").ClearPoints
            curves.Item("PowerfluidInPump").ClearPoints
            curves.Item("PowerESPInPump").ClearPoints
            curves.Item("EffESPInPump").ClearPoints
            curves.Item("q_mix_InPump").ClearPoints
            
            curves.Item("mu_stage_cP").ClearPoints
            curves.Item("corr_visc_h_").ClearPoints
            curves.Item("corr_visc_q_").ClearPoints
            curves.Item("corr_visc_pow_").ClearPoints
            curves.Item("corr_visc_eff_").ClearPoints
            curves.Item("gas_corr_").ClearPoints
                   
            p_curve_.ClearPoints
            t_curve_.ClearPoints
    End If
    
    ' init gas correction coefficient
    ' if calc from intake - it will be reinitialased later
    ' if calc from discharge - it can be set manually here
'    gas_corr_ = GasCorrection_d(0, gas_correct)
    
    With fluid
        ' if  calc from intake - then save intake condition to 0 stage
        ' and calc intake gas fraction  and gas correction coefficient
        If Not calc_from_dis Then
            ' calc PVT for intake conditions
            Call .calc_PVT(Pst_atma, Tst_C)    ' calc properties for inteke conditions
            gas_frac_intake_ = .gas_fraction_d
            q_rel = .q_mix_rc_m3day / rate_max_sm3day(1)
            gas_corr_ = calc_gas_correction(gas_frac_intake_, q_rel)   ' reinit gas correction
            gas_corr_min = gas_corr_
            gas_corr_max = gas_corr_
            log_.add_msg "{""gas_correct_intake"" :" & Format(gas_corr_, "0.000") & _
                        ", ""gas_frac_intake"" :" & Format(gas_frac_intake_, "0.000") & _
                        ", ""q_rel"" :" & Format(q_rel, "0.000") & _
                        "}"
            If saveCurve Then
                curves.Item("gas_fractionInPump").AddPoint n, .f_g
                curves.Item("PressureInPump").AddPoint n, Pst_atma
                curves.Item("TempInPump").AddPoint n, Tst_C
                curves.Item("PowerfluidInPump").AddPoint n, 0
                curves.Item("PowerESPInPump").AddPoint n, 0
                curves.Item("EffESPInPump").AddPoint n, 0
                curves.Item("q_mix_InPump").AddPoint n, .q_mix_rc_m3day
                
                curves.Item("mu_stage_cP").AddPoint n, .mu_mix_cP
                curves.Item("corr_visc_h_").AddPoint n, corr_visc_h_
                curves.Item("corr_visc_q_").AddPoint n, corr_visc_q_
                curves.Item("corr_visc_pow_").AddPoint n, corr_visc_pow_
                curves.Item("corr_visc_eff_").AddPoint n, corr_visc_eff_
                curves.Item("gas_corr_").AddPoint n, gas_corr_
                
                p_curve_.AddPoint HmesStage_m(CDbl(n)), Pst_atma
                t_curve_.AddPoint HmesStage_m(CDbl(n)), Tst_C
            End If
        End If
        
        If calc_from_dis And saveCurve Then
            ' calc PVT for intake conditions
            Call .calc_PVT(Pst_atma, Tst_C)    ' calc properties for inteke conditions
            
            curves.Item("gas_fractionInPump").AddPoint stage_num, .f_g
            curves.Item("PressureInPump").AddPoint stage_num, Pst_atma
            curves.Item("TempInPump").AddPoint stage_num, Tst_C
            curves.Item("PowerfluidInPump").AddPoint stage_num, 0
            curves.Item("PowerESPInPump").AddPoint stage_num, 0
            curves.Item("EffESPInPump").AddPoint stage_num, 0
            curves.Item("q_mix_InPump").AddPoint stage_num, .q_mix_rc_m3day
            
            curves.Item("mu_stage_cP").AddPoint stage_num, .mu_mix_cP
            curves.Item("corr_visc_h_").AddPoint stage_num, corr_visc_h_
            curves.Item("corr_visc_q_").AddPoint stage_num, corr_visc_q_
            curves.Item("corr_visc_pow_").AddPoint stage_num, corr_visc_pow_
            curves.Item("corr_visc_eff_").AddPoint stage_num, corr_visc_eff_
            curves.Item("gas_corr_").AddPoint stage_num, gas_corr_
            
            p_curve_.AddPoint HmesStage_m(CDbl(stage_num)), Pst_atma
            t_curve_.AddPoint HmesStage_m(CDbl(stage_num)), Tst_C
        End If
        
        
              
        ' ====================== start main loop ================================================
        Do While n < stage_num '+ 1
            If calc_from_dis Then
                If stage_num - n - dNst > 0 Then  ' смотрим какой будет величина следующего шага
                    Nst = dNst                          ' мелкие шаги оставляем в зоне низкий давлений
                Else
                    Nst = 1
                End If
            Else
                If (stage_num - n) Mod dNst = 0 Then  ' смотрим какой будет величина следующего шага
                    Nst = dNst                          ' мелкие шаги оставляем в зоне низкий давлений
                Else
                    Nst = 1
                End If
            End If
            
            If Pst_atma + dPav < 1 Then
                Pst_atma = 0.9
                Exit Do
            End If
            Call .calc_PVT(Pst_atma + dPav, Tst_C + dTav)  ' делаем поправку на давление и температуру
            
            ' re init gas correction for each stage mode if applicable
            If gas_correct_stage_by_stage Then
                q_rel = .q_mix_rc_m3day / rate_max_sm3day(1)
                gas_corr_ = calc_gas_correction(.gas_fraction_d, q_rel)
                If gas_corr_min > gas_corr_ Then gas_corr_min = gas_corr_
                If gas_corr_max < gas_corr_ Then gas_corr_max = gas_corr_
            End If
            q_mix_ = .q_mix_rc_m3day
            q_mix__degr = q_mix_ * calibr_rate
            head_mix = get_ESP_head_m(q_mix__degr, Nst, .mu_mix_cSt) * calibr_head
            If gas_corr_ > 0 Then
                ' похоже, что с текущей реализацией функции корректировки на содержание газа
                ' что то более менее корректно работает только если коэффициент корректировки положительный
                head_mix = head_mix * gas_corr_
            Else
                ' поэтому для отрицательного коэффициента корректировки ставим пока заглушку
                ' которая используется вместо фактического напора примерно максимальный напор ступени - 5 м
                ' это дает более менее понятные графики в итого, но вообще говоря это надо бы поменять
                head_mix = 20 * gas_corr_
            End If
            head_real_m_ = head_real_m_ + head_mix
            dPStage = .rho_mix_rc_kgm3 * head_mix * const_g * const_convert_Pa_atma ' тут когда то надо сделать коррекцию характеристики на плотность
            Pst_atma = Pst_atma + sign_int * dPStage
            dPav = dPStage / 2 * sign_int
            If dPStage > 0 Then
                ' оценим работу совершаемую насосом по перекачке жидкости
                PowfluidWt = q_mix_ * const_convert_m3day_m3sec * dPStage * const_convert_atma_Pa   ' мощность с поправкой на плотность ГЖС
                PowfluidTot_Wt = PowfluidTot_Wt + PowfluidWt
                ' оценим мощность потребляемую насосом с вала
                PowESP_Wt = get_ESP_power_W(q_mix__degr, Nst, .mu_mix_cSt) * .rho_mix_rc_kgm3 / 1000 * calibr_power                ' мощность потребляемая одной ступенью на воде
                PowESPTot_Wt = PowESPTot_Wt + PowESP_Wt
                ' оценим КПД ступени в данных условиях
                If (PowESPTot_Wt > 0) Then
                    EffESP_d = PowfluidTot_Wt / PowESPTot_Wt
                Else
                    EffESP_d = 0
                End If
                
                If (PowESP_Wt > 0) Then
                    EffStage = PowfluidWt / PowESP_Wt
                Else
                    EffStage = 0
                End If
                
                If t_dis_C <= 0 And (Not calc_from_dis) Then ' оценка температуры по ступеням
                    If EffStage > 0 Then
                        dTpump_C = const_g * head_mix / .cmix_JkgC * (1 - EffStage) / EffStage
                    Else
                        dTpump_C = 0
                    End If
                Else
                    dTpump_C = (t_dis_C - t_intake_C) / stage_num * Nst
                End If
                
                If Tst_C < 299 Then
                    Tst_C = Tst_C + sign_int * dTpump_C
                    dTav = sign_int * dTpump_C / 2
                End If
                
                If Tst_C > 300 Then
                    Tst_C = 299
                    dTav = 0
                End If
                
                dTpumpSum_C = dTpumpSum_C + dTpump_C
            Else
                PowfluidWt = 0
                PowESP_Wt = 0
                EffESP_d = 0
                EffStage = 0
            End If
            
            n = n + Nst
            
            If saveCurve Then
                If calc_from_dis Then
                    nn = stage_num - n + 1
                Else
                    nn = n
                End If
                curves.Item("gas_fractionInPump").AddPoint nn, .f_g
                curves.Item("PressureInPump").AddPoint nn, Pst_atma
                curves.Item("TempInPump").AddPoint nn, Tst_C
                curves.Item("PowerfluidInPump").AddPoint nn, PowfluidTot_Wt
                curves.Item("PowerESPInPump").AddPoint nn, PowESPTot_Wt
                curves.Item("EffESPInPump").AddPoint nn, EffStage
                curves.Item("q_mix_InPump").AddPoint nn, q_mix_
                
                
                curves.Item("mu_stage_cP").AddPoint nn, .mu_mix_cP
                curves.Item("corr_visc_h_").AddPoint nn, corr_visc_h_
                curves.Item("corr_visc_q_").AddPoint nn, corr_visc_q_
                curves.Item("corr_visc_pow_").AddPoint nn, corr_visc_pow_
                curves.Item("corr_visc_eff_").AddPoint nn, corr_visc_eff_
                curves.Item("gas_corr_").AddPoint nn, gas_corr_
                    
                p_curve_.AddPoint HmesStage_m(CDbl(nn)), Pst_atma
                t_curve_.AddPoint HmesStage_m(CDbl(nn)), Tst_C
            End If
            i = i + 1
        Loop
        ' ====================== end main loop ================================================
        If calc_from_dis Then
                nn = 0
                curves.Item("gas_fractionInPump").AddPoint nn, .f_g
                curves.Item("PressureInPump").AddPoint nn, Pst_atma
                curves.Item("TempInPump").AddPoint nn, Tst_C
                curves.Item("PowerfluidInPump").AddPoint nn, PowfluidTot_Wt
                curves.Item("PowerESPInPump").AddPoint nn, PowESPTot_Wt
                curves.Item("EffESPInPump").AddPoint nn, EffESP_d
                curves.Item("q_mix_InPump").AddPoint nn, q_mix_
                
                
                curves.Item("mu_stage_cP").AddPoint nn, .mu_mix_cP
                curves.Item("corr_visc_h_").AddPoint nn, corr_visc_h_
                curves.Item("corr_visc_q_").AddPoint nn, corr_visc_q_
                curves.Item("corr_visc_pow_").AddPoint nn, corr_visc_pow_
                curves.Item("corr_visc_eff_").AddPoint nn, corr_visc_eff_
                curves.Item("gas_corr_").AddPoint nn, gas_corr_
                    
                p_curve_.AddPoint HmesStage_m(CDbl(nn)), Pst_atma
                t_curve_.AddPoint HmesStage_m(CDbl(nn)), Tst_C
        
        End If
        
        
        If dTpumpSum_C > 298 Then
                add_log_msg "Перегрев около УЭЦН, расчетная температура =" & Format(Tst_C, "##0") & _
                              " рост температуры на ступени =" & Format(dTpump_C, "##0") & _
                              " КПД ступени =" & Format(EffStage, "##0.00") & _
                              " Дебит ступени =" & Format(.q_mix_rc_m3day, "##0.00") & _
                              " Температура исправлена на 299"
        End If
    End With
    power_ESP_Wt_ = PowESPTot_Wt + gassep_M_Nm * w_radsec
    power_fluid_Wt_ = PowfluidTot_Wt
    
    log_.add_msg "calc_integration calc done in " & CStr((Timer - tstart) * 1000) & " ms"
    
    If calc_from_dis Then
        p_int_atma_ = Pst_atma
    Else
        p_dis_atma_ = Pst_atma
        t_dis_C_ = Tst_C
    End If
    
    eff_ESP_d_ = EffESP_d
    Exit Sub
err1:
    Dim errmsg As String
    errmsg = "Error:CESPpump.calc_integration: " & sDELIM & Err.Description
    add_log_msg errmsg
    Err.Raise kErrESPcalc, Err.source, errmsg
End Sub
Public Sub set_num_stages(head_m As Double)
'  функция расчета необходимого числа ступеней для обеспечения заданного напора
    Dim Head1st As Double
    Head1st = get_ESP_head_m(rate_nom_sm3day, 1)
    If Head1st > 0 Then
        stage_num = CInt(head_m / Head1st)
    End If
End Sub
Public Function get_num_stages(q_mix_rc_m3day As Double, head_m As Double) As Integer
'  функция расчета необходимого числа ступеней для обеспечения заданного напора
    Dim Head1st As Double
    Head1st = get_ESP_head_m(q_mix_rc_m3day, 1)
    If Head1st > 0 Then
        get_num_stages = CInt(head_m / Head1st)
    Else
        get_num_stages = 0
    End If
End Function
Public Sub calc_ESP(p_atma As Double, _
                    t_intake_C As Double, _
           Optional t_dis_C As Double = 0, _
           Optional calc_from_intake As Boolean = True, _
           Optional saveCurve As Boolean = False, _
           Optional f_Hz As Double = -1)
' метод расчета работы насоса
    If f_Hz > 0 Then
        Me.freq_Hz = f_Hz
    End If
    Call calc_integration(p_atma, t_intake_C, t_dis_C, Not calc_from_intake, saveCurve)
End Sub
Private Sub Class_Initialize()
    Set fluid = New CPVT
    correct_visc_ = True
    
    calibr_head = 1 ' по умолчанию нет деградации
    calibr_rate = 1 ' по умолчанию нет деградации
    calibr_power = 1 ' по умолчанию нет деградации
    
    stage_num = 1
    freq_Hz = 50
    
    Call corrections_clear
    
    gas_correct_model = 1
    gas_correct_stage_by_stage = True
'    turb_head_factor = 1 ' 2 ' 0.5
'    turb_rate_factor = 1 ' 1.1 '0.9
    dnum_stages_integrate = 1
    
    h_mes_top_m = 1000
End Sub
' метод для построения кривых характеристик УЭЦН
Public Sub build_curves(Optional ByVal qliq As Double = -1)
    Dim i As Integer
    Dim degr_temp As Double
    Dim qmin As Double, qmax As Double, qcalc As Double
    Dim qold As Double
    qold = fluid.q_liq_sm3day
    Const num_points = 20
    
    curves.Item("Head").ClearPoints
    curves.Item("Effeciency").ClearPoints
    curves.Item("Power").ClearPoints
    curves.Item("NominalPressureDrop").ClearPoints
    curves.Item("RealPressureDrop").ClearPoints
    curves.Item("RealEfficiency").ClearPoints
    curves.Item("RealPower").ClearPoints
    curves.Item("RealHead").ClearPoints
    curves.Item("PumpTdis").ClearPoints
    curves.Item("PumpTint").ClearPoints
    
    qmin = 0.1
    qmax = rate_max_sm3day(-1)
    For i = 0 To num_points
        qcalc = (qmax - qmin) / num_points * i + qmin
        
        Me.fluid.fw_perc = fluid.fw_perc
        Me.fluid.q_liq_sm3day = qcalc
    
        curves.Item("Head").AddPoint qcalc, get_ESP_head_m(qcalc)
        curves.Item("Power").AddPoint qcalc, get_ESP_power_W(qcalc)
        curves.Item("Effeciency").AddPoint qcalc, get_ESP_effeciency_fr(qcalc)
        
        degr_temp = calibr_head
        calibr_head = 0
        Call calc_ESP(p_int_atma_, t_int_C_)
        curves.Item("NominalPressureDrop").AddPoint qcalc, p_dis_atma_ - p_int_atma_
        
        calibr_head = degr_temp
        Call calc_ESP(p_int_atma_, t_int_C_)
        curves.Item("RealPressureDrop").AddPoint qcalc, p_dis_atma_ - p_int_atma_
        curves.Item("RealPower").AddPoint qcalc, power_fluid_Wt_
        curves.Item("RealEfficiency").AddPoint qcalc, eff_ESP_d_
        curves.Item("RealHead").AddPoint qcalc, head_real_m_
        curves.Item("PumpTdis").AddPoint qcalc, t_dis_C_
        curves.Item("PumpTint").AddPoint qcalc, t_int_C_
    Next i
    If qliq < 0 Then Me.fluid.q_liq_sm3day = qold
    Call calc_ESP(p_int_atma_, t_int_C_)
End Sub
Public Sub copy(pump As CESPpump)
  
    With pump
       stage_num = .stage_num
       freq_Hz = .freq_Hz
       t_int_C_ = .t_int_C
       t_dis_C_ = .t_dis_C
       
       Call fluid.copy(.fluid)
        
       p_int_atma_ = .p_int_atma
       p_dis_atma_ = .p_dis_atma
       
       db_ = pump.db
       
       calibr_head = .calibr_head
       calibr_rate = .calibr_rate
       calibr_power = .calibr_power
       
       h_mes_top_m = .h_mes_top_m
       angle_deg = .angle_deg
'       turb_head_factor = .turb_head_factor
'       turb_rate_factor = .turb_rate_factor
       dnum_stages_integrate = .dnum_stages_integrate
       
    End With
     
End Sub
Public Property Get correct_visc() As Boolean
    correct_visc = correct_visc_
End Property
Public Property Let correct_visc(val As Boolean)
    correct_visc_ = val
    If Not correct_visc_ Then
        Call corrections_clear
    End If
End Property
Private Sub calc_correct_visc_PetrInst(ByVal q_mix_ As Double, ByVal nu_cSt As Double)
' метод для расчета корректировки напорной характеристики УЭЦН на вязкость для текущего насоса
' расчет для одной ступени
    
    Dim Gamma As Double
    Dim QwBEP_100gpm As Double, HwBEP_ft As Double
    Dim Qstar As Double
    Dim Q0 As Double, Q0_6 As Double, Q0_8 As Double, Q1_0 As Double, Q1_2 As Double, qmax As Double
    Dim H0 As Double, H0_6 As Double, H0_8 As Double, H1_0 As Double, H1_2 As Double, Hmax As Double
    
    Dim corr_visc_h__                ' поправочный коэффициень для напорной характеристики на вязкость для текущего дебита и текущего расчета
    Dim corr_visc_q__                ' для дебита
    Dim corr_visc_pow__              ' для мощности
    Dim corr_visc_eff__              ' для КПД
On Error GoTo err1:
    ' turn off object correction factors
    corr_visc_h_ = 1             ' поправочный коэффициень для напорной характеристики на вязкость для текущего дебита и текущего расчета
    corr_visc_q_ = 1               ' для дебита
    corr_visc_pow_ = 1             ' для мощности
    corr_visc_eff_ = 1             ' для КПД
    
    ' turn off local corr factors as well
    corr_visc_h__ = 1             ' поправочный коэффициень для напорной характеристики на вязкость для текущего дебита и текущего расчета
    corr_visc_q__ = 1               ' для дебита
    corr_visc_pow__ = 1             ' для мощности
    corr_visc_eff__ = 1             ' для КПД
    
    If nu_cSt < 5 Then Exit Sub
    
    QwBEP_100gpm = Me.rate_nom_sm3day * const_convert_m3day_gpm '/ 100   '   похоже к книге Такаса ошибка - не надо делить на 100 тут
    HwBEP_ft = Me.get_ESP_head_m(Me.rate_nom_sm3day, 1) * const_convert_m_ft
    Gamma = -7.5946 + 6.6504 * Log(HwBEP_ft) + 12.8429 * Log(QwBEP_100gpm)
    Qstar = Exp((39.5276 + 26.5606 * Log(nu_cSt) - Gamma) / 51.6565)
    corr_visc_q__ = 1 - 4.0327 * 10 ^ (-3) * Qstar - 1.724 * 10 ^ (-4) * Qstar ^ 2
    
    If (corr_visc_q__ < 0) Then
        corr_visc_h__ = 0
        'exit without changes to object state
        Exit Sub
    End If
    
    corr_visc_eff__ = 1 - 3.3075 * 10 ^ (-2) * Qstar + 2.8875 * 10 ^ (-4) * Qstar ^ 2
    corr_visc_pow__ = 1 / corr_visc_eff__
    
    
    Q0 = 0:
    ' rate_nom_sm3day has inside correction corr_visc_q_ - but not here
    Q1_0 = rate_nom_sm3day * corr_visc_q__
    H1_0 = 1 - 7.00763 * 10 ^ (-3) * Qstar - 1.41 * 10 ^ (-5) * Qstar ^ 2
    Q0_8 = Q1_0 * 0.8
    H0_8 = 1 - 4.4726 * 10 ^ (-3) * Qstar - 4.18 * 10 ^ (-5) * Qstar ^ 2
    Q0_6 = Q1_0 * 0.6
    H0_6 = 1 - 3.68 * 10 ^ (-3) * Qstar - 4.36 * 10 ^ (-5) * Qstar ^ 2
    Q1_2 = Q1_0 * 1.2
    H1_2 = 1 - 9.01 * 10 ^ (-3) * Qstar + 1.31 * 10 ^ (-5) * Qstar ^ 2
    qmax = rate_max_sm3day(-1) * corr_visc_q__
    Hmax = H1_2
    
    
    If qmax < Q1_2 Then
        add_log_msg "CESPpump.calc_correct_visc_PetrInst error. qmax >= Qmom * 1.2. Correction neglected"
        Exit Sub
       ' тут что то не так с характеристиков насоса - номинальный и максимальный дебит не соответствуют друг другу
    End If
    
    h_corr_qd_curve_.ClearPoints
    
    'Call h_corr_qd_curve_.AddPoint(Qmax, Hmax)
    Call h_corr_qd_curve_.AddPoint(Q1_2, H1_2)
    Call h_corr_qd_curve_.AddPoint(Q1_0, H1_0)
    Call h_corr_qd_curve_.AddPoint(Q0_8, H0_8)
    Call h_corr_qd_curve_.AddPoint(Q0_6, H0_6)
    H0 = h_corr_qd_curve_.getPoint(Q0) ' пытаемся экстраполировать
    If H0 < 0 Then H0 = H0_6
    Call h_corr_qd_curve_.AddPoint(Q0, H0)
    
    If q_mix_ > qmax Then q_mix_ = qmax
    
    corr_visc_h__ = h_corr_qd_curve_.getPoint(q_mix_)
    
    corr_visc_h_ = corr_visc_h__             ' поправочный коэффициень для напорной характеристики на вязкость для текущего дебита и текущего расчета
    corr_visc_q_ = corr_visc_q__               ' для дебита
    corr_visc_pow_ = corr_visc_pow__             ' для мощности
    corr_visc_eff_ = corr_visc_eff__             ' для КПД
    
    Exit Sub
err1:
    Dim msg As String
    msg = "CESPpump.calc_correct_visc_PetrInst error with params q_mix_ = " & CStr(q_mix_) & " nu_cSt = " & CStr(nu_cSt)
    log_.add_msg msg & " : " & Err.Description
End Sub
' метод для доступа к кривой давления в насосе относительно измеренных глубин
Public Property Get p_curve() As CInterpolation
    Set p_curve = p_curve_
End Property
Public Property Get t_curve() As CInterpolation
    Set t_curve = t_curve_
End Property
Public Function check_shaft(ByVal M_Nm As Double) As Boolean
' проверка допустимой прочности вала
    Dim Pow_nom_kW As Double   ' мощность приведенная к номинальной
    Pow_nom_kW = M_Nm * w_radsec / 1000
    If Pow_nom_kW < db_.power_limit_shaft_kW Then
        check_shaft = True
    ElseIf Pow_nom_kW < db_.power_limit_shaft_max_kW Then
        check_shaft = False
        add_log_msg "Превышена нагрузка на вал. Требуется использовать вал повышенной прочности"
        ' здесь надо предпринимать действия по прочности вала
    Else
        check_shaft = False
        add_log_msg "Превышена нагрузка на вал для вала повышенной прочности"
    End If
End Function
' свойство выдает момент на валу потребляемый насосом
Public Property Get M_Nm() As Double
    M_Nm = power_ESP_Wt_ / w_radsec
End Property
Private Function calc_gas_correction(gas_fraction_in As Double, Optional qrel As Double = 1)
            ' gas_correct_model       - тип насоса по работе с газом
            '      gas_correct_model = 0 нет коррекции
            '      gas_correct_model = 1 стандартный ЭЦН (предел 25%)
            '      gas_correct_model = 2 ЭЦН с газостабилизирующим модулем (предел 50%)
            '      gas_correct_model = 3 ЭЦН с осевым модулем (предел 75%)
            '      gas_correct_model = 4 ЭЦН с модифицированным ступенями (предел 40%)
    Dim B As Double
    B = 0
    If gas_fraction_in > 0 And gas_fraction_in < 1 Then
        B = gas_fraction_in
    End If
    Select Case gas_correct_model
        Case 0
            calc_gas_correction = 1
        Case 1
            calc_gas_correction = -9 * B ^ 2 + 0.6 * B + 1    ' SPE 117414  стандартный ЭЦН с пределом по газу 25%
        Case 2
            calc_gas_correction = -2 * B ^ 2 + 0.05 * B + 1    ' SPE 117414 (исправлению по сравнению со статьей верить)  ЭЦН с газостабилизирующим модулем с пределом по газу 50%
        Case 3
            calc_gas_correction = -1.4 * B ^ 2 + 0.15 * B + 1    ' SPE 117414 ЭЦН с осевым предвключенным модулем с пределом по газу 75%
        Case 4
            calc_gas_correction = -4 * B ^ 2 + 0.2 * B + 1    ' SPE 117414 (исправлению по сравнению со статьей верить)   ЭЦН с газостабилизирующим модулем с пределом по газу 35%
        Case 5
            calc_gas_correction = gas_corr(B * 100, qrel * 100)  ' по работе Казакбаевой Горидько 2021 стандарный ЭЦН с пределом по газу 25%
        Case Else
            calc_gas_correction = 1
    End Select
End Function
 
Public Function get_result_dict(Optional ByVal num_points As Integer = 20, _
                                Optional ByVal show_array As Boolean = False, _
                                Optional ByVal show_log As Boolean = False, _
                                Optional ByVal show_more_details As Integer = 0)
' подготовка массива для вывода в Excel
' num_points - количество точек в выходных массивах для вывода
'
    Dim dict As New Dictionary
On Error Resume Next
    With dict
        .Add "p_int_atma", Round(p_int_atma, const_decimal_output)
        .Add "t_int_C", Round(t_int_C, const_decimal_output)
        .Add "p_dis_atma", Round(p_dis_atma, const_decimal_output)
        .Add "t_dis_C", Round(t_dis_C, const_decimal_output)
        .Add "head_m", Round(head_m, const_decimal_output)
        .Add "M_pump_Nm", Round(M_Nm, const_decimal_output)
        .Add "gas_frac_intake", Round(gas_frac_intake_, const_decimal_output)
        .Add "eff_ESP_d", Round(eff_ESP_d, const_decimal_output)
        .Add "power_fluid_W", Round(power_fluid_W, const_decimal_output)
        .Add "power_ESP_W", Round(power_ESP_W, const_decimal_output)
        
        .Add "calc_from_dis", Round(calc_from_dis_, const_decimal_output)
        .Add "stage_num", stage_num
        .Add "freq_Hz", Round(freq_Hz, const_decimal_output)
        .Add "w_obmin", Round(w_obmin, const_decimal_output)
        .Add "rate_nom_sm3day", Round(rate_nom_sm3day, const_decimal_output)
        .Add "rate_max_sm3day", Round(rate_max_sm3day(-1), const_decimal_output)
        .Add "calibr_head", Round(calibr_head, const_decimal_output)
        .Add "calibr_rate", Round(calibr_rate, const_decimal_output)
        .Add "calibr_power", Round(calibr_power, const_decimal_output)
        .Add "gas_correct_model", Round(gas_correct_model, const_decimal_output)
        .Add "gas_correct_stage_by_stage", gas_correct_stage_by_stage
        If gas_correct_stage_by_stage Then
            .Add "gas_corr_", "[" & str(Round(gas_corr_min, const_decimal_output)) & "," & str(Round(gas_corr_max, const_decimal_output)) & "]"
        Else
            .Add "gas_corr_", Round(gas_corr_, const_decimal_output)
        End If
        
        If show_array Then
            If num_points > 5 Then
                .Add "n_stage", curves.Item("PressureInPump").ClonePointsToNum(num_points).getJson(only_vector_num:=1)
                .Add "PressureInPump", curves.Item("PressureInPump").ClonePointsToNum(num_points).getJson(only_vector_num:=2)
                .Add "TempInPump", curves.Item("TempInPump").ClonePointsToNum(num_points).getJson(only_vector_num:=2)
                .Add "gas_fractionInPump", curves.Item("gas_fractionInPump").ClonePointsToNum(num_points).getJson(only_vector_num:=2)
                
                If show_more_details > 0 Then
                    .Add "q_mix_InPump", curves.Item("q_mix_InPump").ClonePointsToNum(num_points).getJson(only_vector_num:=2)
                    .Add "PowerfluidInPump", curves.Item("PowerfluidInPump").ClonePointsToNum(num_points).getJson(only_vector_num:=2)
                    .Add "PowerESPInPump", curves.Item("PowerESPInPump").ClonePointsToNum(num_points).getJson(only_vector_num:=2)
                    .Add "EffESPInPump", curves.Item("EffESPInPump").ClonePointsToNum(num_points).getJson(only_vector_num:=2)
                    If show_more_details > 1 Then
                        .Add "gas_corr_", curves.Item("gas_corr_").ClonePointsToNum(num_points).getJson(only_vector_num:=2)
                        .Add "corr_visc_eff_", curves.Item("corr_visc_eff_").ClonePointsToNum(num_points).getJson(only_vector_num:=2)
                        .Add "corr_visc_pow_", curves.Item("corr_visc_pow_").ClonePointsToNum(num_points).getJson(only_vector_num:=2)
                        .Add "corr_visc_q_", curves.Item("corr_visc_q_").ClonePointsToNum(num_points).getJson(only_vector_num:=2)
                        .Add "corr_visc_h_", curves.Item("corr_visc_h_").ClonePointsToNum(num_points).getJson(only_vector_num:=2)
                        .Add "mu_stage_cP", curves.Item("mu_stage_cP").ClonePointsToNum(num_points).getJson(only_vector_num:=2)
                    End If
                End If
            Else
                .Add "n_stage", curves.Item("PressureInPump").getJson(only_vector_num:=1)
                .Add "PressureInPump", curves.Item("PressureInPump").getJson(only_vector_num:=2)
                .Add "TempInPump", curves.Item("TempInPump").getJson(only_vector_num:=2)
                .Add "gas_fractionInPump", curves.Item("gas_fractionInPump").getJson(only_vector_num:=2)
                
                If show_more_details > 0 Then
                    .Add "q_mix_InPump", curves.Item("q_mix_InPump").getJson(only_vector_num:=2)
                    .Add "PowerfluidInPump", curves.Item("PowerfluidInPump").getJson(only_vector_num:=2)
                    .Add "PowerESPInPump", curves.Item("PowerESPInPump").getJson(only_vector_num:=2)
                    .Add "EffESPInPump", curves.Item("EffESPInPump").getJson(only_vector_num:=2)
                    If show_more_details > 1 Then
                        .Add "gas_corr_", curves.Item("gas_corr_").getJson(only_vector_num:=2)
                        .Add "corr_visc_eff_", curves.Item("corr_visc_eff_").getJson(only_vector_num:=2)
                        .Add "corr_visc_pow_", curves.Item("corr_visc_pow_").getJson(only_vector_num:=2)
                        .Add "corr_visc_q_", curves.Item("corr_visc_q_").getJson(only_vector_num:=2)
                        .Add "corr_visc_h_", curves.Item("corr_visc_h_").getJson(only_vector_num:=2)
                        .Add "mu_stage_cP", curves.Item("mu_stage_cP").getJson(only_vector_num:=2)
                    End If
                End If
            End If
        End If
        If show_log Then
            .Add "log", log_.get_str_safe(show_log)
        End If
    End With
    Set get_result_dict = dict
End Function
Public Function get_result_dict_crv(Optional ByVal num_points As Integer = 20)
' подготовка массива для вывода в Excel
' num_points - количество точек в выходных массивах для вывода
    
    Dim dict As New Dictionary
On Error Resume Next
    With dict
        If num_points > 5 Then
            .Add "gas_corr_", curves.Item("gas_corr_").ClonePointsToNum(num_points).getDict
            .Add "corr_visc_eff_", curves.Item("corr_visc_eff_").ClonePointsToNum(num_points).getDict
            .Add "corr_visc_pow_", curves.Item("corr_visc_pow_").ClonePointsToNum(num_points).getDict
            .Add "corr_visc_q_", curves.Item("corr_visc_q_").ClonePointsToNum(num_points).getDict
            .Add "corr_visc_h_", curves.Item("corr_visc_h_").ClonePointsToNum(num_points).getDict
            .Add "mu_stage_cP", curves.Item("mu_stage_cP").ClonePointsToNum(num_points).getDict
            .Add "EffESPInPump", curves.Item("EffESPInPump").ClonePointsToNum(num_points).getDict
            .Add "PowerESPInPump", curves.Item("PowerESPInPump").ClonePointsToNum(num_points).getDict
            .Add "PowerfluidInPump", curves.Item("PowerfluidInPump").ClonePointsToNum(num_points).getDict
            .Add "q_mix_InPump", curves.Item("q_mix_InPump").ClonePointsToNum(num_points).getDict
            .Add "gas_fractionInPump", curves.Item("gas_fractionInPump").ClonePointsToNum(num_points).getDict
            .Add "TempInPump", curves.Item("TempInPump").ClonePointsToNum(num_points).getDict
            .Add "PressureInPump", curves.Item("PressureInPump").ClonePointsToNum(num_points).getDict
        Else
            .Add "gas_corr_", curves.Item("gas_corr_").getDict
            .Add "corr_visc_eff_", curves.Item("corr_visc_eff_").getDict
            .Add "corr_visc_pow_", curves.Item("corr_visc_pow_").getDict
            .Add "corr_visc_q_", curves.Item("corr_visc_q_").getDict
            .Add "corr_visc_h_", curves.Item("corr_visc_h_").getDict
            .Add "mu_stage_cP", curves.Item("mu_stage_cP").getDict
            .Add "EffESPInPump", curves.Item("EffESPInPump").getDict
            .Add "PowerESPInPump", curves.Item("PowerESPInPump").getDict
            .Add "PowerfluidInPump", curves.Item("PowerfluidInPump").getDict
            .Add "q_mix_InPump", curves.Item("q_mix_InPump").getDict
            .Add "gas_fractionInPump", curves.Item("gas_fractionInPump").getDict
            .Add "TempInPump", curves.Item("TempInPump").getDict
            .Add "PressureInPump", curves.Item("PressureInPump").getDict
        End If
    End With
    Set get_result_dict_crv = dict
End Function
Public Function get_results_array(Optional ByVal num_points As Integer = 20, _
                                  Optional ByVal show_log As Boolean = False)
' подготовка массива для вывода в Excel
' num_points - количество точек в выходных массивах для вывода
'
    Dim arr()
    Dim M As Integer
   ' Dim FlowParams_out As PIPE_FLOW_PARAMS
    Dim offset As Integer
    Dim i As Integer
    Dim hh As Double
    Dim dict_pressure As New Dictionary
    Dim dict_power As New Dictionary
    Dim dict_ESP As New Dictionary
    Dim dict_curves As New Dictionary
    Dim dict_geometry As New Dictionary
    
    Dim j As Integer
    
    offset = 2
On Error Resume Next
    Dim crv_p As CInterpolation
    Dim crv_t As CInterpolation
    
    ' rearrange output curves one time here - will be used later
    Set crv_p = curves.Item("PressureInPump").ClonePointsToNum(num_points)
    Set crv_t = curves.Item("TempInPump").ClonePointsToNum(num_points)
    
    M = crv_p.num_points
    ReDim arr(M + offset, 10)
    
    ' в первом ряду параметров выведем результаты расчета
    ' которые могут пригодится в явном виде при массовых расчетах
    arr(0, 0) = 0
    arr(1, 0) = "0"
    
    arr(0, 1) = p_int_atma:                     arr(1, 1) = "p_int_atma"
    arr(0, 2) = t_int_C:                        arr(1, 2) = "t_int_C"
    arr(0, 3) = p_dis_atma:                     arr(1, 3) = "p_dis_atma"
    arr(0, 4) = t_dis_C:                        arr(1, 4) = "t_dis_C"
       
    arr(0, 5) = head_m:                         arr(1, 5) = "head_m"
    arr(0, 6) = eff_ESP_d * 100:                arr(1, 6) = "eff_ESP_d, %"
    arr(0, 7) = power_fluid_W:                  arr(1, 7) = "power_fluid_W"
    arr(0, 8) = power_ESP_W:                    arr(1, 8) = "power_ESP_W"
    arr(0, 9) = gas_corr_:                      arr(1, 9) = "gas_correction"
    arr(0, 10) = log_.get_str_safe(show_log):    arr(1, 10) = "log"
    
    
    For i = 0 To M
      
        j = 0
        hh = crv_p.pointX(i)   ' fractional stage number :)
        If i = 0 Then
            arr(offset + i, j) = "n_stage"
        Else
            arr(offset + i, j) = hh
        End If
        
        j = j + 1
        If i = 0 Then
            arr(offset, j) = "length_m"
        Else
            arr(offset + i, j) = HmesStage_m(hh)
        End If
        
        j = j + 1
        If i = 0 Then
            arr(offset + i, j) = "p_atma"
        Else
            arr(offset + i, j) = curves.Item("PressureInPump").getPoint(hh)
        End If
        
        j = j + 1
        If i = 0 Then
            arr(offset + i, j) = "t_C"
        Else
            arr(offset + i, j) = curves.Item("TempInPump").getPoint(hh)
        End If
        
        j = j + 1
        If i = 0 Then
            arr(offset + i, j) = "gas_fraction, %"
        Else
            arr(offset + i, j) = curves.Item("gas_fractionInPump").getPoint(hh) * 100
        End If
        
        j = j + 1
        If i = 0 Then
            arr(offset + i, j) = "qmix_rm3day"
        Else
            arr(offset + i, j) = curves.Item("q_mix_InPump").getPoint(hh)
        End If
        
        j = j + 1
        If i = 0 Then
            arr(offset, j) = "Power_fluid_W"
        Else
            arr(offset + i, j) = curves.Item("PowerfluidInPump").getPoint(hh)
        End If
        
        j = j + 1
        If i = 0 Then
            arr(offset, j) = "Power_ESP_W"
        Else
            arr(offset + i, j) = curves.Item("PowerESPInPump").getPoint(hh)
        End If
        
        j = j + 1
        If i = 0 Then
            arr(offset, j) = "eff fluid, %"
        Else
            arr(offset + i, j) = curves.Item("EffESPInPump").getPoint(hh) * 100
        End If
        
        
        j = j + 1
        If i = 0 Then
            arr(offset, j) = "mu_stage_cP"
        Else
            arr(offset + i, j) = curves.Item("mu_stage_cP").getPoint(hh)
        End If
        
        j = j + 1
        If i = 0 Then
            arr(offset, j) = "gas correction, %"
        Else
            arr(offset + i, j) = curves.Item("gas_corr_").getPoint(hh) * 100
        End If
        
    Next i
    
    
    get_results_array = arr
End Function
Private Sub read_json_to_dict()
    ' read ESP database in json format
    ' ESP database in json format can be prepared with ESP_db.xlsm file
    
    Dim ss As String
    Dim line_from_file As String
    Dim lines_all As String
    Dim fname As String
    
    fname = ThisWorkbook.Path & esp_db_name
    
On Error GoTo err1:
    
    Open fname For Input As #1
    Do While Not EOF(1)
        Line Input #1, line_from_file
        lines_all = lines_all & line_from_file & vbCrLf
    Loop
    Close #1
    Set ESP_base_dictionary = ParseJson(lines_all)
    
    Exit Sub
err1:
    Dim msg As String
    msg = "read_json_to_dict:" & fname & "read error"
    Err.Raise kErrESPbase, , msg & Err.Description
End Sub
Public Property Get freq_nom_Hz()
    freq_nom_Hz = db_.freq_Hz
End Property
Public Property Get q_nom_sm3day()
    q_nom_sm3day = db_.rate_nom_sm3day
End Property
Public Property Get head_nom_m()
    head_nom_m = calc_ESP_head_nominal_m(q_nom_sm3day)
End Property
Public Sub set_ID(ESP_ID As Long, _
                  Optional freq_nom_update As Double = 0)
' freq_nom_update позволяет подменить базовую частоту насоса из каталога на новую
' полезно для ЭЦН с двигателями с двумя и более парами полюсов
' у таких двигателей частота питающего напряжения может быть в два (или более)
' раз больше чем частота вращения вала
    Dim esp_db As ESP_PARAMS
    Dim dict As Dictionary
    Dim j As Integer, num As Integer
    
    ' read esp db file into global variable
    If ESP_base_dictionary Is Nothing Then
        Call read_json_to_dict
    End If
    
    ' extract specific pupm id from db global variable
    Set dict = ESP_base_dictionary(CStr(ESP_ID))
    '
    If freq_nom_update > 0 Then
        If Not dict.Exists("freq_Hz_original") Then
            dict("freq_Hz_original") = dict("freq_Hz")
        End If
        dict("freq_Hz") = freq_nom_update
    Else
        If dict.Exists("freq_Hz_original") Then
            dict("freq_Hz") = dict("freq_Hz_original")
        End If
    End If
    db_json_string = ConvertToJson(dict)
  On Error GoTo err_load_pump:
    num = dict("rate_points").Count
    With esp_db
        
        ReDim .head_points(1 To num)
        ReDim .rate_points(1 To num)
        ReDim .power_points(1 To num)
        ReDim .eff_points(1 To num)
              
        For j = 1 To num
               .head_points(j) = dict("head_points")(j)
               .rate_points(j) = dict("rate_points")(j)
               .power_points(j) = dict("power_points")(j)
               .eff_points(j) = dict("eff_points")(j)
        Next j
        
            ' read all data from first line in DB table
        .ID = dict("ID")
        .manufacturer = dict("manufacturer")
        .name = dict("name")
        .stages_max = dict("stages_max")
        .rate_nom_sm3day = dict("rate_nom_sm3day")
        .rate_opt_min_sm3day = dict("rate_opt_min_sm3day")
        .rate_opt_max_sm3day = dict("rate_opt_max_sm3day")
        .rate_max_sm3day = dict("rate_max_sm3day")
        .slip_nom_rpm = dict("slip_nom_rpm")
        .freq_Hz = dict("freq_Hz")
        .eff_max = dict("eff_max")
        .d_od_m = dict("d_od_mm") / 1000 ' читаем габарит насоса
        .d_motor_od_m = dict("d_motor_od_mm") / 1000  ' читаем габарит насоса
        .d_cas_min_m = dict("d_cas_min_mm") / 1000
        .d_shaft_m = dict("d_shaft_mm") / 1000
        .power_limit_shaft_kW = dict("power_limit_shaft_kW")
        .power_limit_shaft_max_kW = dict("power_limit_shaft_max_kW")
        .pressure_limit_housing_atma = dict("pressure_limit_housing_atma")
        
        If dict("height_stage_m") <> "" Then
            .height_stage_m = dict("height_stage_m")
        Else
            .height_stage_m = 0.05   ' по умолчанию 5 см высота. Можно сделать зависимость от дебита
        End If
    End With
    
    db_ = esp_db
    freq_Hz = freq_nom_Hz
    Exit Sub
    
err_load_pump:
    On Error GoTo 0
    Dim msg As String
    msg = "CESPpump.set_ID error - Problem while loading pump . " & CStr(esp_db.ID) & Err.Description
    Err.Raise kErrESPcalc, , msg
    
End Sub
Public Sub init_json(json As String)
    Dim d As Dictionary
    Set d = ParseJson(json)
    Call init_dictionary(d)
 End Sub
 Private Sub init_dictionary(dict As Dictionary)
 Dim ESP_ID As Long
 Dim head_nom_m As Double
 Dim msg As String
On Error GoTo err1:
    With dict
        If .Exists("ESP_ID") Then
            ESP_ID = .Item("ESP_ID")
            If .Exists("freq_nom_Hz") Then
                Call set_ID(ESP_ID, .Item("freq_nom_Hz"))
            Else
                Call set_ID(ESP_ID)
            End If
        Else
            msg = "CESPpump.init_dictionary error - wrong input. No ESP_ID key in pump json"
            Err.Raise kErrESPcalc, , msg
        End If
        stage_num = 0
        If .Exists("num_stages") Then stage_num = .Item("num_stages")
        If stage_num <= 0 And .Exists("head_nom_m") Then
            head_nom_m = .Item("head_nom_m")
            Call set_num_stages(head_nom_m)
        End If
        If stage_num <= 0 Then
            msg = "CESPpump.init_dictionary error - wrong input. No stages in ESP defined"
            Err.Raise kErrESPcalc, , msg
        End If
        If .Exists("gas_correct_model") Then gas_correct_model = .Item("gas_correct_model")
        If .Exists("gas_correct_stage_by_stage") Then gas_correct_stage_by_stage = .Item("gas_correct_stage_by_stage")
        If .Exists("calibr_head") Then calibr_head = .Item("calibr_head")
        If .Exists("calibr_rate") Then calibr_rate = .Item("calibr_rate")
        If .Exists("calibr_power") Then calibr_power = .Item("calibr_power")
        If .Exists("dnum_stages_integrate") Then dnum_stages_integrate = .Item("dnum_stages_integrate")
    End With
    Exit Sub
err1:
    Dim errmsg As String
    errmsg = "Error:CESPpump.init_dictionary: init error " & sDELIM & Err.Description
    add_log_msg errmsg
    Err.Raise kErrESPcalc, Err.source, errmsg
 End Sub

