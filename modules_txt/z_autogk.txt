''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2005-2009, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Data types
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Integration report:
'* TerminationType = completetion code:
'    * -5    non-convergence of Gauss-Kronrod nodes
'            calculation subroutine.
'    * -1    incorrect parameters were specified
'    *  1    OK
'* Rep.NFEV countains number of function calculations
'* Rep.NIntervals contains number of intervals [a,b]
'  was partitioned into.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Type AutoGKReport
    TerminationType As Long
    NFEV As Long
    NIntervals As Long
End Type
Public Type AutoGKInternalState
    A As Double
    B As Double
    Eps As Double
    XWidth As Double
    x As Double
    F As Double
    Info As Long
    R As Double
    Heap() As Double
    HeapSize As Long
    HeapWidth As Long
    HeapUsed As Long
    SumErr As Double
    SumAbs As Double
    QN() As Double
    WG() As Double
    WK() As Double
    WR() As Double
    N As Long
    RState As RCommState
End Type
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This structure stores internal state of the integration algorithm  between
'subsequent calls of the AutoGKIteration() subroutine.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Type AutoGKState
    A As Double
    B As Double
    alpha As Double
    beta As Double
    XWidth As Double
    x As Double
    XMinusA As Double
    BMinusX As Double
    F As Double
    WrapperMode As Long
    InternalState As AutoGKInternalState
    RState As RCommState
    V As Double
    TerminationType As Long
    NFEV As Long
    NIntervals As Long
End Type
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Integration of a smooth function F(x) on a finite interval [a,b].
'
'Fast-convergent algorithm based on a Gauss-Kronrod formula is used. Result
'is calculated with accuracy close to the machine precision.
'
'Algorithm works well only with smooth integrands.  It  may  be  used  with
'continuous non-smooth integrands, but with  less  performance.
'
'It should never be used with integrands which have integrable singularities
'at lower or upper limits - algorithm may crash. Use AutoGKSingular in such
'cases.
'
'INPUT PARAMETERS:
'    A, B    -   interval boundaries (A<B, A=B or A>B)
'
'OUTPUT PARAMETERS
'    State   -   structure which stores algorithm state between  subsequent
'                calls of AutoGKIteration.  Used for reverse communication.
'                This structure should be  passed  to  the  AutoGKIteration
'                subroutine.
'
'SEE ALSO
'    AutoGKSmoothW, AutoGKSingular, AutoGKIteration, AutoGKResults.
'
'
'  -- ALGLIB --
'     Copyright 06.05.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub AutoGKSmooth(ByVal A As Double, _
         ByVal B As Double, _
         ByRef State As AutoGKState)
    Call AutoGKSmoothW(A, B, 0#, State)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Integration of a smooth function F(x) on a finite interval [a,b].
'
'This subroutine is same as AutoGKSmooth(), but it guarantees that interval
'[a,b] is partitioned into subintervals which have width at most XWidth.
'
'Subroutine  can  be  used  when  integrating nearly-constant function with
'narrow "bumps" (about XWidth wide). If "bumps" are too narrow, AutoGKSmooth
'subroutine can overlook them.
'
'INPUT PARAMETERS:
'    A, B    -   interval boundaries (A<B, A=B or A>B)
'
'OUTPUT PARAMETERS
'    State   -   structure which stores algorithm state between  subsequent
'                calls of AutoGKIteration.  Used for reverse communication.
'                This structure should be  passed  to  the  AutoGKIteration
'                subroutine.
'
'SEE ALSO
'    AutoGKSmooth, AutoGKSingular, AutoGKIteration, AutoGKResults.
'
'
'  -- ALGLIB --
'     Copyright 06.05.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub AutoGKSmoothW(ByVal A As Double, _
         ByVal B As Double, _
         ByVal XWidth As Double, _
         ByRef State As AutoGKState)
    State.WrapperMode = 0#
    State.A = A
    State.B = B
    State.XWidth = XWidth
    ReDim State.RState.RA(0# To 10#)
    State.RState.Stage = -1#
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Integration on a finite interval [A,B].
'Integrand have integrable singularities at A/B.
'
'F(X) must diverge as "(x-A)^alpha" at A, as "(B-x)^beta" at B,  with known
'alpha/beta (alpha>-1, beta>-1).  If alpha/beta  are  not known,  estimates
'from below can be used (but these estimates should be greater than -1 too).
'
'One  of  alpha/beta variables (or even both alpha/beta) may be equal to 0,
'which means than function F(x) is non-singular at A/B. Anyway (singular at
'bounds or not), function F(x) is supposed to be continuous on (A,B).
'
'Fast-convergent algorithm based on a Gauss-Kronrod formula is used. Result
'is calculated with accuracy close to the machine precision.
'
'INPUT PARAMETERS:
'    A, B    -   interval boundaries (A<B, A=B or A>B)
'    Alpha   -   power-law coefficient of the F(x) at A,
'                Alpha>-1
'    Beta    -   power-law coefficient of the F(x) at B,
'                Beta>-1
'
'OUTPUT PARAMETERS
'    State   -   structure which stores algorithm state between  subsequent
'                calls of AutoGKIteration.  Used for reverse communication.
'                This structure should be  passed  to  the  AutoGKIteration
'                subroutine.
'
'SEE ALSO
'    AutoGKSmooth, AutoGKSmoothW, AutoGKIteration, AutoGKResults.
'
'
'  -- ALGLIB --
'     Copyright 06.05.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub AutoGKSingular(ByVal A As Double, _
         ByVal B As Double, _
         ByVal alpha As Double, _
         ByVal beta As Double, _
         ByRef State As AutoGKState)
    State.WrapperMode = 1#
    State.A = A
    State.B = B
    State.alpha = alpha
    State.beta = beta
    State.XWidth = 0#
    ReDim State.RState.RA(0# To 10#)
    State.RState.Stage = -1#
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'One step of adaptive integration process.
'
'Called after initialization with one of AutoGKXXX subroutines.
'See HTML documentation for examples.
'
'Input parameters:
'    State   -   structure which stores algorithm state between  calls  and
'                which  is  used  for   reverse   communication.   Must  be
'                initialized with one of AutoGKXXX subroutines.
'
'If suborutine returned False, iterative proces has converged. If subroutine
'returned True, caller should calculate function value State.F  at  State.X
'and call AutoGKIteration again.
'
'NOTE:
'
'When integrating "difficult" functions with integrable singularities like
'
'    F(x) = (x-A)^alpha * (B-x)^beta
'
'subroutine may require the value of F at points which are too close to A/B.
'Sometimes to calculate integral with high enough precision we  may need to
'calculate F(A+delta) when delta is less than machine  epsilon.  In  finite
'precision arithmetics A+delta will be effectively equal to A,  so  we  may
'find us in situation when  we  are  trying  to  calculate  something  like
'1/sqrt(1-1).
'
'To avoid  such  situations,  AutoGKIteration  subroutine  fills  not  only
'State.X  field,  but  also   State.XMinusA   (which  equals  to  X-A)  and
'State.BMinusX  (which  equals to B-X) fields.  If X is too close to A or B
'(X-A<0.001*A, or B-X<0.001*B, for example) use  these  fields  instead  of
'State.X
'
'
'  -- ALGLIB --
'     Copyright 07.05.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function AutoGKIteration(ByRef State As AutoGKState) As Boolean
    Dim Result As Boolean
    Dim s As Double
    Dim Tmp As Double
    Dim Eps As Double
    Dim A As Double
    Dim B As Double
    Dim x As Double
    Dim T As Double
    Dim alpha As Double
    Dim beta As Double
    Dim V1 As Double
    Dim V2 As Double
    '
    ' Reverse communication preparations
    ' I know it looks ugly, but it works the same way
    ' anywhere from C++ to Python.
    '
    ' This code initializes locals by:
    ' * random values determined during code
    '   generation - on first subroutine call
    ' * values from previous call - on subsequent calls
    '
    If State.RState.Stage >= 0# Then
        s = State.RState.RA(0#)
        Tmp = State.RState.RA(1#)
        Eps = State.RState.RA(2#)
        A = State.RState.RA(3#)
        B = State.RState.RA(4#)
        x = State.RState.RA(5#)
        T = State.RState.RA(6#)
        alpha = State.RState.RA(7#)
        beta = State.RState.RA(8#)
        V1 = State.RState.RA(9#)
        V2 = State.RState.RA(10#)
    Else
        s = -983#
        Tmp = -989#
        Eps = -834#
        A = 900#
        B = -287#
        x = 364#
        T = 214#
        alpha = -338#
        beta = -686#
        V1 = 912#
        V2 = 585#
    End If
    If State.RState.Stage = 0# Then
        GoTo lbl_0
    End If
    If State.RState.Stage = 1# Then
        GoTo lbl_1
    End If
    If State.RState.Stage = 2# Then
        GoTo lbl_2
    End If
    '
    ' Routine body
    '
    Eps = 0#
    A = State.A
    B = State.B
    alpha = State.alpha
    beta = State.beta
    State.TerminationType = -1#
    State.NFEV = 0#
    State.NIntervals = 0#
    '
    ' smooth function  at a finite interval
    '
    If State.WrapperMode <> 0# Then
        GoTo lbl_3
    End If
    '
    ' special case
    '
    If A = B Then
        State.TerminationType = 1#
        State.V = 0#
        Result = False
        AutoGKIteration = Result
        Exit Function
    End If
    '
    ' general case
    '
    Call AutoGKInternalPrepare(A, B, Eps, State.XWidth, State.InternalState)
lbl_5:
    If Not AutoGKInternalIteration(State.InternalState) Then
        GoTo lbl_6
    End If
    x = State.InternalState.x
    State.x = x
    State.XMinusA = x - A
    State.BMinusX = B - x
    State.RState.Stage = 0#
    GoTo lbl_rcomm
lbl_0:
    State.NFEV = State.NFEV + 1#
    State.InternalState.F = State.F
    GoTo lbl_5
lbl_6:
    State.V = State.InternalState.R
    State.TerminationType = State.InternalState.Info
    State.NIntervals = State.InternalState.HeapUsed
    Result = False
    AutoGKIteration = Result
    Exit Function
lbl_3:
    '
    ' function with power-law singularities at the ends of a finite interval
    '
    If State.WrapperMode <> 1# Then
        GoTo lbl_7
    End If
    '
    ' test coefficients
    '
    If alpha <= -1# Or beta <= -1# Then
        State.TerminationType = -1#
        State.V = 0#
        Result = False
        AutoGKIteration = Result
        Exit Function
    End If
    '
    ' special cases
    '
    If A = B Then
        State.TerminationType = 1#
        State.V = 0#
        Result = False
        AutoGKIteration = Result
        Exit Function
    End If
    '
    ' reduction to general form
    '
    If A < B Then
        s = 1#
    Else
        s = -1#
        Tmp = A
        A = B
        B = Tmp
        Tmp = alpha
        alpha = beta
        beta = Tmp
    End If
    alpha = MinReal(alpha, 0#)
    beta = MinReal(beta, 0#)
    '
    ' first, integrate left half of [a,b]:
    '     integral(f(x)dx, a, (b+a)/2) =
    '     = 1/(1+alpha) * integral(t^(-alpha/(1+alpha))*f(a+t^(1/(1+alpha)))dt, 0, (0.5*(b-a))^(1+alpha))
    '
    Call AutoGKInternalPrepare(0#, Power(0.5 * (B - A), 1# + alpha), Eps, State.XWidth, State.InternalState)
lbl_9:
    If Not AutoGKInternalIteration(State.InternalState) Then
        GoTo lbl_10
    End If
    '
    ' Fill State.X, State.XMinusA, State.BMinusX.
    ' Latter two are filled correctly even if B<A.
    '
    x = State.InternalState.x
    T = Power(x, 1# / (1# + alpha))
    State.x = A + T
    If s > 0# Then
        State.XMinusA = T
        State.BMinusX = B - (A + T)
    Else
        State.XMinusA = A + T - B
        State.BMinusX = -T
    End If
    State.RState.Stage = 1#
    GoTo lbl_rcomm
lbl_1:
    If alpha <> 0# Then
        State.InternalState.F = State.F * Power(x, -(alpha / (1# + alpha))) / (1# + alpha)
    Else
        State.InternalState.F = State.F
    End If
    State.NFEV = State.NFEV + 1#
    GoTo lbl_9
lbl_10:
    V1 = State.InternalState.R
    State.NIntervals = State.NIntervals + State.InternalState.HeapUsed
    '
    ' then, integrate right half of [a,b]:
    '     integral(f(x)dx, (b+a)/2, b) =
    '     = 1/(1+beta) * integral(t^(-beta/(1+beta))*f(b-t^(1/(1+beta)))dt, 0, (0.5*(b-a))^(1+beta))
    '
    Call AutoGKInternalPrepare(0#, Power(0.5 * (B - A), 1# + beta), Eps, State.XWidth, State.InternalState)
lbl_11:
    If Not AutoGKInternalIteration(State.InternalState) Then
        GoTo lbl_12
    End If
    '
    ' Fill State.X, State.XMinusA, State.BMinusX.
    ' Latter two are filled correctly (X-A, B-X) even if B<A.
    '
    x = State.InternalState.x
    T = Power(x, 1# / (1# + beta))
    State.x = B - T
    If s > 0# Then
        State.XMinusA = B - T - A
        State.BMinusX = T
    Else
        State.XMinusA = -T
        State.BMinusX = A - (B - T)
    End If
    State.RState.Stage = 2#
    GoTo lbl_rcomm
lbl_2:
    If beta <> 0# Then
        State.InternalState.F = State.F * Power(x, -(beta / (1# + beta))) / (1# + beta)
    Else
        State.InternalState.F = State.F
    End If
    State.NFEV = State.NFEV + 1#
    GoTo lbl_11
lbl_12:
    V2 = State.InternalState.R
    State.NIntervals = State.NIntervals + State.InternalState.HeapUsed
    '
    ' final result
    '
    State.V = s * (V1 + V2)
    State.TerminationType = 1#
    Result = False
    AutoGKIteration = Result
    Exit Function
lbl_7:
    Result = False
    AutoGKIteration = Result
    Exit Function
    '
    ' Saving state
    '
lbl_rcomm:
    Result = True
    State.RState.RA(0#) = s
    State.RState.RA(1#) = Tmp
    State.RState.RA(2#) = Eps
    State.RState.RA(3#) = A
    State.RState.RA(4#) = B
    State.RState.RA(5#) = x
    State.RState.RA(6#) = T
    State.RState.RA(7#) = alpha
    State.RState.RA(8#) = beta
    State.RState.RA(9#) = V1
    State.RState.RA(10#) = V2
    AutoGKIteration = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Adaptive integration results
'
'Called after AutoGKIteration returned False.
'
'Input parameters:
'    State   -   algorithm state (used by AutoGKIteration).
'
'Output parameters:
'    V       -   integral(f(x)dx,a,b)
'    Rep     -   optimization report (see AutoGKReport description)
'
'  -- ALGLIB --
'     Copyright 14.11.2007 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub AutoGKResults(ByRef State As AutoGKState, _
         ByRef V As Double, _
         ByRef Rep As AutoGKReport)
    V = State.V
    Rep.TerminationType = State.TerminationType
    Rep.NFEV = State.NFEV
    Rep.NIntervals = State.NIntervals
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal AutoGK subroutine
'eps<0   - error
'eps=0   - automatic eps selection
'
'width<0 -   error
'width=0 -   no width requirements
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub AutoGKInternalPrepare(ByVal A As Double, _
         ByVal B As Double, _
         ByVal Eps As Double, _
         ByVal XWidth As Double, _
         ByRef State As AutoGKInternalState)
    '
    ' Save settings
    '
    State.A = A
    State.B = B
    State.Eps = Eps
    State.XWidth = XWidth
    '
    ' Prepare RComm structure
    '
    ReDim State.RState.IA(0# To 3#)
    ReDim State.RState.RA(0# To 8#)
    State.RState.Stage = -1#
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal AutoGK subroutine
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Function AutoGKInternalIteration(ByRef State As AutoGKInternalState) As Boolean
    Dim Result As Boolean
    Dim C1 As Double
    Dim C2 As Double
    Dim i As Long
    Dim j As Long
    Dim IntG As Double
    Dim IntK As Double
    Dim IntA As Double
    Dim V As Double
    Dim TA As Double
    Dim TB As Double
    Dim NS As Long
    Dim QEps As Double
    Dim Info As Long
    '
    ' Reverse communication preparations
    ' I know it looks ugly, but it works the same way
    ' anywhere from C++ to Python.
    '
    ' This code initializes locals by:
    ' * random values determined during code
    '   generation - on first subroutine call
    ' * values from previous call - on subsequent calls
    '
    If State.RState.Stage >= 0# Then
        i = State.RState.IA(0#)
        j = State.RState.IA(1#)
        NS = State.RState.IA(2#)
        Info = State.RState.IA(3#)
        C1 = State.RState.RA(0#)
        C2 = State.RState.RA(1#)
        IntG = State.RState.RA(2#)
        IntK = State.RState.RA(3#)
        IntA = State.RState.RA(4#)
        V = State.RState.RA(5#)
        TA = State.RState.RA(6#)
        TB = State.RState.RA(7#)
        QEps = State.RState.RA(8#)
    Else
        i = 497#
        j = -271#
        NS = -581#
        Info = 745#
        C1 = -533#
        C2 = -77#
        IntG = 678#
        IntK = -293#
        IntA = 316#
        V = 647#
        TA = -756#
        TB = 830#
        QEps = -871#
    End If
    If State.RState.Stage = 0# Then
        GoTo lbl_0
    End If
    If State.RState.Stage = 1# Then
        GoTo lbl_1
    End If
    If State.RState.Stage = 2# Then
        GoTo lbl_2
    End If
    '
    ' Routine body
    '
    '
    ' initialize quadratures.
    ' use 15-point Gauss-Kronrod formula.
    '
    State.N = 15#
    Call GKQGenerateGaussLegendre(State.N, Info, State.QN, State.WK, State.WG)
    If Info < 0# Then
        State.Info = -5#
        State.R = 0#
        Result = False
        AutoGKInternalIteration = Result
        Exit Function
    End If
    ReDim State.WR(0 To State.N - 1)
    For i = 0# To State.N - 1# Step 1
        If i = 0# Then
            State.WR(i) = 0.5 * Abs(State.QN(1#) - State.QN(0#))
            GoTo Cont_1
        End If
        If i = State.N - 1# Then
            State.WR(State.N - 1#) = 0.5 * Abs(State.QN(State.N - 1#) - State.QN(State.N - 2#))
            GoTo Cont_1
        End If
        State.WR(i) = 0.5 * Abs(State.QN(i - 1#) - State.QN(i + 1#))
Cont_1:
    Next i
    '
    ' special case
    '
    If State.A = State.B Then
        State.Info = 1#
        State.R = 0#
        Result = False
        AutoGKInternalIteration = Result
        Exit Function
    End If
    '
    ' test parameters
    '
    If State.Eps < 0# Or State.XWidth < 0# Then
        State.Info = -1#
        State.R = 0#
        Result = False
        AutoGKInternalIteration = Result
        Exit Function
    End If
    State.Info = 1#
    If State.Eps = 0# Then
        State.Eps = 1000# * MachineEpsilon
    End If
    '
    ' First, prepare heap
    ' * column 0   -   absolute error
    ' * column 1   -   integral of a F(x) (calculated using Kronrod extension nodes)
    ' * column 2   -   integral of a |F(x)| (calculated using modified rect. method)
    ' * column 3   -   left boundary of a subinterval
    ' * column 4   -   right boundary of a subinterval
    '
    If State.XWidth <> 0# Then
        GoTo lbl_3
    End If
    '
    ' no maximum width requirements
    ' start from one big subinterval
    '
    State.HeapWidth = 5#
    State.HeapSize = 1#
    State.HeapUsed = 1#
    ReDim State.Heap(0 To State.HeapSize - 1, 0 To State.HeapWidth - 1)
    C1 = 0.5 * (State.B - State.A)
    C2 = 0.5 * (State.B + State.A)
    IntG = 0#
    IntK = 0#
    IntA = 0#
    i = 0#
lbl_5:
    If i > State.N - 1# Then
        GoTo lbl_7
    End If
    '
    ' obtain F
    '
    State.x = C1 * State.QN(i) + C2
    State.RState.Stage = 0#
    GoTo lbl_rcomm
lbl_0:
    V = State.F
    '
    ' Gauss-Kronrod formula
    '
    IntK = IntK + V * State.WK(i)
    If i Mod 2# = 1# Then
        IntG = IntG + V * State.WG(i)
    End If
    '
    ' Integral |F(x)|
    ' Use rectangles method
    '
    IntA = IntA + Abs(V) * State.WR(i)
    i = i + 1#
    GoTo lbl_5
lbl_7:
    IntK = IntK * (State.B - State.A) * 0.5
    IntG = IntG * (State.B - State.A) * 0.5
    IntA = IntA * (State.B - State.A) * 0.5
    State.Heap(0#, 0#) = Abs(IntG - IntK)
    State.Heap(0#, 1#) = IntK
    State.Heap(0#, 2#) = IntA
    State.Heap(0#, 3#) = State.A
    State.Heap(0#, 4#) = State.B
    State.SumErr = State.Heap(0#, 0#)
    State.SumAbs = Abs(IntA)
    GoTo lbl_4
lbl_3:
    '
    ' maximum subinterval should be no more than XWidth.
    ' so we create Ceil((B-A)/XWidth)+1 small subintervals
    '
    NS = Ceil(Abs(State.B - State.A) / State.XWidth) + 1#
    State.HeapSize = NS
    State.HeapUsed = NS
    State.HeapWidth = 5#
    ReDim State.Heap(0 To State.HeapSize - 1, 0 To State.HeapWidth - 1)
    State.SumErr = 0#
    State.SumAbs = 0#
    j = 0#
lbl_8:
    If j > NS - 1# Then
        GoTo lbl_10
    End If
    TA = State.A + j * (State.B - State.A) / NS
    TB = State.A + (j + 1#) * (State.B - State.A) / NS
    C1 = 0.5 * (TB - TA)
    C2 = 0.5 * (TB + TA)
    IntG = 0#
    IntK = 0#
    IntA = 0#
    i = 0#
lbl_11:
    If i > State.N - 1# Then
        GoTo lbl_13
    End If
    '
    ' obtain F
    '
    State.x = C1 * State.QN(i) + C2
    State.RState.Stage = 1#
    GoTo lbl_rcomm
lbl_1:
    V = State.F
    '
    ' Gauss-Kronrod formula
    '
    IntK = IntK + V * State.WK(i)
    If i Mod 2# = 1# Then
        IntG = IntG + V * State.WG(i)
    End If
    '
    ' Integral |F(x)|
    ' Use rectangles method
    '
    IntA = IntA + Abs(V) * State.WR(i)
    i = i + 1#
    GoTo lbl_11
lbl_13:
    IntK = IntK * (TB - TA) * 0.5
    IntG = IntG * (TB - TA) * 0.5
    IntA = IntA * (TB - TA) * 0.5
    State.Heap(j, 0#) = Abs(IntG - IntK)
    State.Heap(j, 1#) = IntK
    State.Heap(j, 2#) = IntA
    State.Heap(j, 3#) = TA
    State.Heap(j, 4#) = TB
    State.SumErr = State.SumErr + State.Heap(j, 0#)
    State.SumAbs = State.SumAbs + Abs(IntA)
    j = j + 1#
    GoTo lbl_8
lbl_10:
lbl_4:
    '
    ' method iterations
    '
lbl_14:
    If False Then
        GoTo lbl_15
    End If
    '
    ' additional memory if needed
    '
    If State.HeapUsed = State.HeapSize Then
        Call MHeapResize(State.Heap, State.HeapSize, 4# * State.HeapSize, State.HeapWidth)
    End If
    '
    ' TODO: every 20 iterations recalculate errors/sums
    ' TODO: one more criterion to prevent infinite loops with too strict Eps
    '
    If State.SumErr <= State.Eps * State.SumAbs Then
        State.R = 0#
        For j = 0# To State.HeapUsed - 1# Step 1
            State.R = State.R + State.Heap(j, 1#)
        Next j
        Result = False
        AutoGKInternalIteration = Result
        Exit Function
    End If
    '
    ' Exclude interval with maximum absolute error
    '
    Call MHeapPop(State.Heap, State.HeapUsed, State.HeapWidth)
    State.SumErr = State.SumErr - State.Heap(State.HeapUsed - 1#, 0#)
    State.SumAbs = State.SumAbs - State.Heap(State.HeapUsed - 1#, 2#)
    '
    ' Divide interval, create subintervals
    '
    TA = State.Heap(State.HeapUsed - 1#, 3#)
    TB = State.Heap(State.HeapUsed - 1#, 4#)
    State.Heap(State.HeapUsed - 1#, 3#) = TA
    State.Heap(State.HeapUsed - 1#, 4#) = 0.5 * (TA + TB)
    State.Heap(State.HeapUsed, 3#) = 0.5 * (TA + TB)
    State.Heap(State.HeapUsed, 4#) = TB
    j = State.HeapUsed - 1#
lbl_16:
    If j > State.HeapUsed Then
        GoTo lbl_18
    End If
    C1 = 0.5 * (State.Heap(j, 4#) - State.Heap(j, 3#))
    C2 = 0.5 * (State.Heap(j, 4#) + State.Heap(j, 3#))
    IntG = 0#
    IntK = 0#
    IntA = 0#
    i = 0#
lbl_19:
    If i > State.N - 1# Then
        GoTo lbl_21
    End If
    '
    ' F(x)
    '
    State.x = C1 * State.QN(i) + C2
    State.RState.Stage = 2#
    GoTo lbl_rcomm
lbl_2:
    V = State.F
    '
    ' Gauss-Kronrod formula
    '
    IntK = IntK + V * State.WK(i)
    If i Mod 2# = 1# Then
        IntG = IntG + V * State.WG(i)
    End If
    '
    ' Integral |F(x)|
    ' Use rectangles method
    '
    IntA = IntA + Abs(V) * State.WR(i)
    i = i + 1#
    GoTo lbl_19
lbl_21:
    IntK = IntK * (State.Heap(j, 4#) - State.Heap(j, 3#)) * 0.5
    IntG = IntG * (State.Heap(j, 4#) - State.Heap(j, 3#)) * 0.5
    IntA = IntA * (State.Heap(j, 4#) - State.Heap(j, 3#)) * 0.5
    State.Heap(j, 0#) = Abs(IntG - IntK)
    State.Heap(j, 1#) = IntK
    State.Heap(j, 2#) = IntA
    State.SumErr = State.SumErr + State.Heap(j, 0#)
    State.SumAbs = State.SumAbs + State.Heap(j, 2#)
    j = j + 1#
    GoTo lbl_16
lbl_18:
    Call MHeapPush(State.Heap, State.HeapUsed - 1#, State.HeapWidth)
    Call MHeapPush(State.Heap, State.HeapUsed, State.HeapWidth)
    State.HeapUsed = State.HeapUsed + 1#
    GoTo lbl_14
lbl_15:
    Result = False
    AutoGKInternalIteration = Result
    Exit Function
    '
    ' Saving state
    '
lbl_rcomm:
    Result = True
    State.RState.IA(0#) = i
    State.RState.IA(1#) = j
    State.RState.IA(2#) = NS
    State.RState.IA(3#) = Info
    State.RState.RA(0#) = C1
    State.RState.RA(1#) = C2
    State.RState.RA(2#) = IntG
    State.RState.RA(3#) = IntK
    State.RState.RA(4#) = IntA
    State.RState.RA(5#) = V
    State.RState.RA(6#) = TA
    State.RState.RA(7#) = TB
    State.RState.RA(8#) = QEps
    AutoGKInternalIteration = Result
End Function
Private Sub MHeapPop(ByRef Heap() As Double, _
         ByVal HeapSize As Long, _
         ByVal HeapWidth As Long)
    Dim i As Long
    Dim p As Long
    Dim T As Double
    Dim MaxCP As Long
    If HeapSize = 1# Then
        Exit Sub
    End If
    For i = 0# To HeapWidth - 1# Step 1
        T = Heap(HeapSize - 1#, i)
        Heap(HeapSize - 1#, i) = Heap(0#, i)
        Heap(0#, i) = T
    Next i
    p = 0#
    Do While 2# * p + 1# < HeapSize - 1#
        MaxCP = 2# * p + 1#
        If 2# * p + 2# < HeapSize - 1# Then
            If Heap(2# * p + 2#, 0#) > Heap(2# * p + 1#, 0#) Then
                MaxCP = 2# * p + 2#
            End If
        End If
        If Heap(p, 0#) < Heap(MaxCP, 0#) Then
            For i = 0# To HeapWidth - 1# Step 1
                T = Heap(p, i)
                Heap(p, i) = Heap(MaxCP, i)
                Heap(MaxCP, i) = T
            Next i
            p = MaxCP
        Else
            Exit Do
        End If
    Loop
End Sub
Private Sub MHeapPush(ByRef Heap() As Double, _
         ByVal HeapSize As Long, _
         ByVal HeapWidth As Long)
    Dim i As Long
    Dim p As Long
    Dim T As Double
    Dim Parent As Long
    If HeapSize = 0# Then
        Exit Sub
    End If
    p = HeapSize
    Do While p <> 0#
        Parent = (p - 1#) \ 2#
        If Heap(p, 0#) > Heap(Parent, 0#) Then
            For i = 0# To HeapWidth - 1# Step 1
                T = Heap(p, i)
                Heap(p, i) = Heap(Parent, i)
                Heap(Parent, i) = T
            Next i
            p = Parent
        Else
            Exit Do
        End If
    Loop
End Sub
Private Sub MHeapResize(ByRef Heap() As Double, _
         ByRef HeapSize As Long, _
         ByVal NewHeapSize As Long, _
         ByVal HeapWidth As Long)
    Dim Tmp() As Double
    Dim i As Long
    Dim i_ As Long
    ReDim Tmp(0 To HeapSize - 1, 0 To HeapWidth - 1)
    For i = 0# To HeapSize - 1# Step 1
        For i_ = 0# To HeapWidth - 1# Step 1
            Tmp(i, i_) = Heap(i, i_)
        Next i_
    Next i
    ReDim Heap(0 To NewHeapSize - 1, 0 To HeapWidth - 1)
    For i = 0# To HeapSize - 1# Step 1
        For i_ = 0# To HeapWidth - 1# Step 1
            Heap(i, i_) = Tmp(i, i_)
        Next i_
    Next i
    HeapSize = NewHeapSize
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2005-2009, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Computation of nodes and weights of a Gauss-Kronrod quadrature formula
'
'The algorithm generates the N-point Gauss-Kronrod quadrature formula  with
'weight  function  given  by  coefficients  alpha  and beta of a recurrence
'relation which generates a system of orthogonal polynomials:
'
'    P-1(x)   =  0
'    P0(x)    =  1
'    Pn+1(x)  =  (x-alpha(n))*Pn(x)  -  beta(n)*Pn-1(x)
'
'and zero moment Mu0
'
'    Mu0 = integral(W(x)dx,a,b)
'
'
'INPUT PARAMETERS:
'    Alpha       –   alpha coefficients, array[0..floor(3*K/2)].
'    Beta        –   beta coefficients,  array[0..ceil(3*K/2)].
'                    Beta[0] is not used and may be arbitrary.
'                    Beta[I]>0.
'    Mu0         –   zeroth moment of the weight function.
'    N           –   number of nodes of the Gauss-Kronrod quadrature formula,
'                    N >= 3,
'                    N =  2*K+1.
'
'OUTPUT PARAMETERS:
'    Info        -   error code:
'                    * -5    no real and positive Gauss-Kronrod formula can
'                            be created for such a weight function  with  a
'                            given number of nodes.
'                    * -4    N is too large, task may be ill  conditioned -
'                            x[i]=x[i+1] found.
'                    * -3    internal eigenproblem solver hasn't converged
'                    * -2    Beta[i]<=0
'                    * -1    incorrect N was passed
'                    * +1    OK
'    X           -   array[0..N-1] - array of quadrature nodes,
'                    in ascending order.
'    WKronrod    -   array[0..N-1] - Kronrod weights
'    WGauss      -   array[0..N-1] - Gauss weights (interleaved with zeros
'                    corresponding to extended Kronrod nodes).
'
'  -- ALGLIB --
'     Copyright 08.05.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub GKQGenerateRec(ByRef Alpha_() As Double, _
         ByRef Beta_() As Double, _
         ByVal Mu0 As Double, _
         ByVal N As Long, _
         ByRef Info As Long, _
         ByRef x() As Double, _
         ByRef WKronrod() As Double, _
         ByRef WGauss() As Double)
    Dim alpha() As Double
    Dim beta() As Double
    Dim TA() As Double
    Dim i As Long
    Dim j As Long
    Dim T() As Double
    Dim s() As Double
    Dim WLen As Long
    Dim WOffs As Long
    Dim U As Double
    Dim M As Long
    Dim L As Long
    Dim K As Long
    Dim XGTmp() As Double
    Dim WGTmp() As Double
    Dim i_ As Long
    alpha = Alpha_
    beta = Beta_
    If N Mod 2# <> 1# Or N < 3# Then
        Info = -1#
        Exit Sub
    End If
    For i = 0# To Ceil(3# * (N \ 2#) / 2#) Step 1
        If beta(i) <= 0# Then
            Info = -2#
            Exit Sub
        End If
    Next i
    Info = 1#
    '
    ' from external conventions about N/Beta/Mu0 to internal
    '
    N = N \ 2#
    beta(0#) = Mu0
    '
    ' Calculate Gauss nodes/weights, save them for later processing
    '
    Call GQGenerateRec(alpha, beta, Mu0, N, Info, XGTmp, WGTmp)
    If Info < 0# Then
        Exit Sub
    End If
    '
    ' Resize:
    ' * A from 0..floor(3*n/2) to 0..2*n
    ' * B from 0..ceil(3*n/2)  to 0..2*n
    '
    ReDim TA(0 To Int(3# * N / 2#) + 1# - 1)
    For i_ = 0# To Int(3# * N / 2#) Step 1
        TA(i_) = alpha(i_)
    Next i_
    ReDim alpha(0 To 2# * N + 1# - 1)
    For i_ = 0# To Int(3# * N / 2#) Step 1
        alpha(i_) = TA(i_)
    Next i_
    For i = Int(3# * N / 2#) + 1# To 2# * N Step 1
        alpha(i) = 0#
    Next i
    ReDim TA(0 To Ceil(3# * N / 2#) + 1# - 1)
    For i_ = 0# To Ceil(3# * N / 2#) Step 1
        TA(i_) = beta(i_)
    Next i_
    ReDim beta(0 To 2# * N + 1# - 1)
    For i_ = 0# To Ceil(3# * N / 2#) Step 1
        beta(i_) = TA(i_)
    Next i_
    For i = Ceil(3# * N / 2#) + 1# To 2# * N Step 1
        beta(i) = 0#
    Next i
    '
    ' Initialize T, S
    '
    WLen = 2# + N \ 2#
    ReDim T(0 To WLen - 1)
    ReDim s(0 To WLen - 1)
    ReDim TA(0 To WLen - 1)
    WOffs = 1#
    For i = 0# To WLen - 1# Step 1
        T(i) = 0#
        s(i) = 0#
    Next i
    '
    ' Algorithm from Dirk P. Laurie, "Calculation of Gauss-Kronrod quadrature rules", 1997.
    '
    T(WOffs + 0#) = beta(N + 1#)
    For M = 0# To N - 2# Step 1
        U = 0#
        For K = (M + 1#) \ 2# To 0# Step -1
            L = M - K
            U = U + (alpha(K + N + 1#) - alpha(L)) * T(WOffs + K) + beta(K + N + 1#) * s(WOffs + K - 1#) - beta(L) * s(WOffs + K)
            s(WOffs + K) = U
        Next K
        For i_ = 0# To WLen - 1# Step 1
            TA(i_) = T(i_)
        Next i_
        For i_ = 0# To WLen - 1# Step 1
            T(i_) = s(i_)
        Next i_
        For i_ = 0# To WLen - 1# Step 1
            s(i_) = TA(i_)
        Next i_
    Next M
    For j = N \ 2# To 0# Step -1
        s(WOffs + j) = s(WOffs + j - 1#)
    Next j
    For M = N - 1# To 2# * N - 3# Step 1
        U = 0#
        For K = M + 1# - N To (M - 1#) \ 2# Step 1
            L = M - K
            j = N - 1# - L
            U = U - (alpha(K + N + 1#) - alpha(L)) * T(WOffs + j) - beta(K + N + 1#) * s(WOffs + j) + beta(L) * s(WOffs + j + 1#)
            s(WOffs + j) = U
        Next K
        If M Mod 2# = 0# Then
            K = M \ 2#
            alpha(K + N + 1#) = alpha(K) + (s(WOffs + j) - beta(K + N + 1#) * s(WOffs + j + 1#)) / T(WOffs + j + 1#)
        Else
            K = (M + 1#) \ 2#
            beta(K + N + 1#) = s(WOffs + j) / s(WOffs + j + 1#)
        End If
        For i_ = 0# To WLen - 1# Step 1
            TA(i_) = T(i_)
        Next i_
        For i_ = 0# To WLen - 1# Step 1
            T(i_) = s(i_)
        Next i_
        For i_ = 0# To WLen - 1# Step 1
            s(i_) = TA(i_)
        Next i_
    Next M
    alpha(2# * N) = alpha(N - 1#) - beta(2# * N) * s(WOffs + 0#) / T(WOffs + 0#)
    '
    ' calculation of Kronrod nodes and weights, unpacking of Gauss weights
    '
    Call GQGenerateRec(alpha, beta, Mu0, 2# * N + 1#, Info, x, WKronrod)
    If Info = -2# Then
        Info = -5#
    End If
    If Info < 0# Then
        Exit Sub
    End If
    For i = 0# To 2# * N - 1# Step 1
        If x(i) >= x(i + 1#) Then
            Info = -4#
        End If
    Next i
    If Info < 0# Then
        Exit Sub
    End If
    ReDim WGauss(0 To 2# * N + 1# - 1)
    For i = 0# To 2# * N Step 1
        WGauss(i) = 0#
    Next i
    For i = 0# To N - 1# Step 1
        WGauss(2# * i + 1#) = WGTmp(i)
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Returns   Gauss   and   Gauss-Kronrod   nodes/weights  for  Gauss-Legendre
'quadrature with N points.
'
'GKQLegendreCalc (calculation) or  GKQLegendreTbl  (precomputed  table)  is
'used depending on machine precision and number of nodes.
'
'INPUT PARAMETERS:
'    N           -   number of Kronrod nodes, must be odd number, >=3.
'
'OUTPUT PARAMETERS:
'    Info        -   error code:
'                    * -4    an  error   was   detected   when  calculating
'                            weights/nodes.  N  is  too  large   to  obtain
'                            weights/nodes  with  high   enough   accuracy.
'                            Try  to   use   multiple   precision  version.
'                    * -3    internal eigenproblem solver hasn't converged
'                    * -1    incorrect N was passed
'                    * +1    OK
'    X           -   array[0..N-1] - array of quadrature nodes, ordered in
'                    ascending order.
'    WKronrod    -   array[0..N-1] - Kronrod weights
'    WGauss      -   array[0..N-1] - Gauss weights (interleaved with zeros
'                    corresponding to extended Kronrod nodes).
'
'
'  -- ALGLIB --
'     Copyright 12.05.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub GKQGenerateGaussLegendre(ByVal N As Long, _
         ByRef Info As Long, _
         ByRef x() As Double, _
         ByRef WKronrod() As Double, _
         ByRef WGauss() As Double)
    Dim Eps As Double
    If MachineEpsilon > 1E-32 And (N = 15# Or N = 21# Or N = 31# Or N = 41# Or N = 51# Or N = 61#) Then
        Info = 1#
        Call GKQLegendreTbl(N, x, WKronrod, WGauss, Eps)
    Else
        Call GKQLegendreCalc(N, Info, x, WKronrod, WGauss)
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Returns   Gauss   and   Gauss-Kronrod   nodes/weights   for   Gauss-Jacobi
'quadrature on [-1,1] with weight function
'
'    W(x)=Power(1-x,Alpha)*Power(1+x,Beta).
'
'INPUT PARAMETERS:
'    N           -   number of Kronrod nodes, must be odd number, >=3.
'    Alpha       -   power-law coefficient, Alpha>-1
'    Beta        -   power-law coefficient, Beta>-1
'
'OUTPUT PARAMETERS:
'    Info        -   error code:
'                    * -5    no real and positive Gauss-Kronrod formula can
'                            be created for such a weight function  with  a
'                            given number of nodes.
'                    * -4    an  error  was   detected   when   calculating
'                            weights/nodes. Alpha or  Beta  are  too  close
'                            to -1 to obtain weights/nodes with high enough
'                            accuracy, or, may be, N is too large.  Try  to
'                            use multiple precision version.
'                    * -3    internal eigenproblem solver hasn't converged
'                    * -1    incorrect N was passed
'                    * +1    OK
'                    * +2    OK, but quadrature rule have exterior  nodes,
'                            x[0]<-1 or x[n-1]>+1
'    X           -   array[0..N-1] - array of quadrature nodes, ordered in
'                    ascending order.
'    WKronrod    -   array[0..N-1] - Kronrod weights
'    WGauss      -   array[0..N-1] - Gauss weights (interleaved with zeros
'                    corresponding to extended Kronrod nodes).
'
'
'  -- ALGLIB --
'     Copyright 12.05.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub GKQGenerateGaussJacobi(ByVal N As Long, _
         ByVal alpha As Double, _
         ByVal beta As Double, _
         ByRef Info As Long, _
         ByRef x() As Double, _
         ByRef WKronrod() As Double, _
         ByRef WGauss() As Double)
    Dim CLen As Long
    Dim A() As Double
    Dim B() As Double
    Dim Alpha2 As Double
    Dim Beta2 As Double
    Dim APB As Double
    Dim T As Double
    Dim i As Long
    Dim s As Double
    If N Mod 2# <> 1# Or N < 3# Then
        Info = -1#
        Exit Sub
    End If
    If alpha <= -1# Or beta <= -1# Then
        Info = -1#
        Exit Sub
    End If
    CLen = Ceil(3# * (N \ 2#) / 2#) + 1#
    ReDim A(0 To CLen - 1)
    ReDim B(0 To CLen - 1)
    For i = 0# To CLen - 1# Step 1
        A(i) = 0#
    Next i
    APB = alpha + beta
    A(0#) = (beta - alpha) / (APB + 2#)
    T = (APB + 1#) * log(2#) + LnGamma(alpha + 1#, s) + LnGamma(beta + 1#, s) - LnGamma(APB + 2#, s)
    If T > log(MaxRealNumber) Then
        Info = -4#
        Exit Sub
    End If
    B(0#) = Exp(T)
    If CLen > 1# Then
        Alpha2 = Square(alpha)
        Beta2 = Square(beta)
        A(1#) = (Beta2 - Alpha2) / ((APB + 2#) * (APB + 4#))
        B(1#) = 4# * (alpha + 1#) * (beta + 1#) / ((APB + 3#) * Square(APB + 2#))
        For i = 2# To CLen - 1# Step 1
            A(i) = 0.25 * (Beta2 - Alpha2) / (i * i * (1# + 0.5 * APB / i) * (1# + 0.5 * (APB + 2#) / i))
            B(i) = 0.25 * (1# + alpha / i) * (1# + beta / i) * (1# + APB / i) / ((1# + 0.5 * (APB + 1#) / i) * (1# + 0.5 * (APB - 1#) / i) * Square(1# + 0.5 * APB / i))
        Next i
    End If
    Call GKQGenerateRec(A, B, B(0#), N, Info, x, WKronrod, WGauss)
    '
    ' test basic properties to detect errors
    '
    If Info > 0# Then
        If x(0#) < -1# Or x(N - 1#) > 1# Then
            Info = 2#
        End If
        For i = 0# To N - 2# Step 1
            If x(i) >= x(i + 1#) Then
                Info = -4#
            End If
        Next i
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Returns Gauss and Gauss-Kronrod nodes for quadrature with N points.
'
'Reduction to tridiagonal eigenproblem is used.
'
'INPUT PARAMETERS:
'    N           -   number of Kronrod nodes, must be odd number, >=3.
'
'OUTPUT PARAMETERS:
'    Info        -   error code:
'                    * -4    an  error   was   detected   when  calculating
'                            weights/nodes.  N  is  too  large   to  obtain
'                            weights/nodes  with  high   enough   accuracy.
'                            Try  to   use   multiple   precision  version.
'                    * -3    internal eigenproblem solver hasn't converged
'                    * -1    incorrect N was passed
'                    * +1    OK
'    X           -   array[0..N-1] - array of quadrature nodes, ordered in
'                    ascending order.
'    WKronrod    -   array[0..N-1] - Kronrod weights
'    WGauss      -   array[0..N-1] - Gauss weights (interleaved with zeros
'                    corresponding to extended Kronrod nodes).
'
'  -- ALGLIB --
'     Copyright 12.05.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub GKQLegendreCalc(ByVal N As Long, _
         ByRef Info As Long, _
         ByRef x() As Double, _
         ByRef WKronrod() As Double, _
         ByRef WGauss() As Double)
    Dim alpha() As Double
    Dim beta() As Double
    Dim ALen As Long
    Dim BLen As Long
    Dim Mu0 As Double
    Dim K As Long
    Dim i As Long
    If N Mod 2# <> 1# Or N < 3# Then
        Info = -1#
        Exit Sub
    End If
    Mu0 = 2#
    ALen = Int(3# * (N \ 2#) / 2#) + 1#
    BLen = Ceil(3# * (N \ 2#) / 2#) + 1#
    ReDim alpha(0 To ALen - 1)
    ReDim beta(0 To BLen - 1)
    For K = 0# To ALen - 1# Step 1
        alpha(K) = 0#
    Next K
    beta(0#) = 2#
    For K = 1# To BLen - 1# Step 1
        beta(K) = 1# / (4# - 1# / Square(K))
    Next K
    Call GKQGenerateRec(alpha, beta, Mu0, N, Info, x, WKronrod, WGauss)
    '
    ' test basic properties to detect errors
    '
    If Info > 0# Then
        If x(0#) < -1# Or x(N - 1#) > 1# Then
            Info = -4#
        End If
        For i = 0# To N - 2# Step 1
            If x(i) >= x(i + 1#) Then
                Info = -4#
            End If
        Next i
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Returns Gauss and Gauss-Kronrod nodes for quadrature with N  points  using
'pre-calculated table. Nodes/weights were  computed  with  accuracy  up  to
'1.0E-32 (if MPFR version of ALGLIB is used). In standard double  precision
'accuracy reduces to something about 2.0E-16 (depending  on your compiler's
'handling of long floating point constants).
'
'INPUT PARAMETERS:
'    N           -   number of Kronrod nodes.
'                    N can be 15, 21, 31, 41, 51, 61.
'
'OUTPUT PARAMETERS:
'    X           -   array[0..N-1] - array of quadrature nodes, ordered in
'                    ascending order.
'    WKronrod    -   array[0..N-1] - Kronrod weights
'    WGauss      -   array[0..N-1] - Gauss weights (interleaved with zeros
'                    corresponding to extended Kronrod nodes).
'
'
'  -- ALGLIB --
'     Copyright 12.05.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub GKQLegendreTbl(ByVal N As Long, _
         ByRef x() As Double, _
         ByRef WKronrod() As Double, _
         ByRef WGauss() As Double, _
         ByRef Eps As Double)
    Dim i As Long
    Dim NG As Long
    Dim P1() As Long
    Dim P2() As Long
    Dim Tmp As Double
    ReDim x(0# To N - 1#)
    ReDim WKronrod(0# To N - 1#)
    ReDim WGauss(0# To N - 1#)
    For i = 0# To N - 1# Step 1
        x(i) = 0#
        WKronrod(i) = 0#
        WGauss(i) = 0#
    Next i
    Eps = MaxReal(MachineEpsilon, 1E-32)
    If N = 15# Then
        NG = 4#
        WGauss(0#) = 0.12948496616887
        WGauss(1#) = 0.279705391489277
        WGauss(2#) = 0.381830050505119
        WGauss(3#) = 0.417959183673469
        x(0#) = 0.991455371120813
        x(1#) = 0.949107912342758
        x(2#) = 0.864864423359769
        x(3#) = 0.741531185599394
        x(4#) = 0.586087235467691
        x(5#) = 0.405845151377397
        x(6#) = 0.207784955007898
        x(7#) = 0#
        WKronrod(0#) = 2.29353220105292E-02
        WKronrod(1#) = 6.30920926299786E-02
        WKronrod(2#) = 0.10479001032225
        WKronrod(3#) = 0.140653259715526
        WKronrod(4#) = 0.169004726639268
        WKronrod(5#) = 0.190350578064785
        WKronrod(6#) = 0.204432940075299
        WKronrod(7#) = 0.209482141084728
    End If
    If N = 21# Then
        NG = 5#
        WGauss(0#) = 6.66713443086881E-02
        WGauss(1#) = 0.149451349150581
        WGauss(2#) = 0.219086362515982
        WGauss(3#) = 0.269266719309996
        WGauss(4#) = 0.295524224714753
        x(0#) = 0.995657163025808
        x(1#) = 0.973906528517172
        x(2#) = 0.930157491355708
        x(3#) = 0.865063366688985
        x(4#) = 0.780817726586417
        x(5#) = 0.679409568299024
        x(6#) = 0.562757134668605
        x(7#) = 0.433395394129247
        x(8#) = 0.29439286270146
        x(9#) = 0.148874338981631
        x(10#) = 0#
        WKronrod(0#) = 1.16946388673719E-02
        WKronrod(1#) = 3.25581623079647E-02
        WKronrod(2#) = 0.054755896574352
        WKronrod(3#) = 0.07503967481092
        WKronrod(4#) = 9.31254545836976E-02
        WKronrod(5#) = 0.109387158802298
        WKronrod(6#) = 0.123491976262066
        WKronrod(7#) = 0.134709217311473
        WKronrod(8#) = 0.14277593857706
        WKronrod(9#) = 0.147739104901338
        WKronrod(10#) = 0.149445554002917
    End If
    If N = 31# Then
        NG = 8#
        WGauss(0#) = 3.07532419961173E-02
        WGauss(1#) = 7.03660474881081E-02
        WGauss(2#) = 0.107159220467172
        WGauss(3#) = 0.139570677926154
        WGauss(4#) = 0.166269205816994
        WGauss(5#) = 0.186161000015562
        WGauss(6#) = 0.198431485327112
        WGauss(7#) = 0.202578241925561
        x(0#) = 0.998002298693397
        x(1#) = 0.987992518020485
        x(2#) = 0.967739075679139
        x(3#) = 0.937273392400706
        x(4#) = 0.897264532344082
        x(5#) = 0.848206583410427
        x(6#) = 0.790418501442466
        x(7#) = 0.72441773136017
        x(8#) = 0.650996741297417
        x(9#) = 0.570972172608539
        x(10#) = 0.48508186364024
        x(11#) = 0.394151347077563
        x(12#) = 0.299180007153169
        x(13#) = 0.201194093997435
        x(14#) = 0.101142066918717
        x(15#) = 0#
        WKronrod(0#) = 5.37747987292335E-03
        WKronrod(1#) = 1.50079473293161E-02
        WKronrod(2#) = 2.54608473267153E-02
        WKronrod(3#) = 3.53463607913758E-02
        WKronrod(4#) = 4.45897513247649E-02
        WKronrod(5#) = 5.34815246909281E-02
        WKronrod(6#) = 6.20095678006706E-02
        WKronrod(7#) = 6.98541213187283E-02
        WKronrod(8#) = 7.68496807577204E-02
        WKronrod(9#) = 0.083080502823133
        WKronrod(10#) = 8.85644430562118E-02
        WKronrod(11#) = 9.31265981708253E-02
        WKronrod(12#) = 9.66427269836237E-02
        WKronrod(13#) = 0.099173598721792
        WKronrod(14#) = 0.100769845523876
        WKronrod(15#) = 0.101330007014792
    End If
    If N = 41# Then
        NG = 10#
        WGauss(0#) = 1.76140071391521E-02
        WGauss(1#) = 4.06014298003869E-02
        WGauss(2#) = 6.26720483341091E-02
        WGauss(3#) = 8.32767415767048E-02
        WGauss(4#) = 0.10193011981724
        WGauss(5#) = 0.118194531961518
        WGauss(6#) = 0.131688638449177
        WGauss(7#) = 0.142096109318382
        WGauss(8#) = 0.149172986472604
        WGauss(9#) = 0.152753387130726
        x(0#) = 0.998859031588278
        x(1#) = 0.993128599185095
        x(2#) = 0.98150787745025
        x(3#) = 0.963971927277914
        x(4#) = 0.940822633831755
        x(5#) = 0.912234428251326
        x(6#) = 0.878276811252282
        x(7#) = 0.839116971822219
        x(8#) = 0.795041428837551
        x(9#) = 0.746331906460151
        x(10#) = 0.693237656334751
        x(11#) = 0.636053680726515
        x(12#) = 0.57514044681971
        x(13#) = 0.510867001950827
        x(14#) = 0.443593175238725
        x(15#) = 0.37370608871542
        x(16#) = 0.301627868114913
        x(17#) = 0.227785851141645
        x(18#) = 0.152605465240923
        x(19#) = 7.65265211334973E-02
        x(20#) = 0#
        WKronrod(0#) = 3.07358371852053E-03
        WKronrod(1#) = 8.60026985564294E-03
        WKronrod(2#) = 1.46261692569713E-02
        WKronrod(3#) = 2.03883734612665E-02
        WKronrod(4#) = 2.58821336049512E-02
        WKronrod(5#) = 3.12873067770328E-02
        WKronrod(6#) = 3.66001697582008E-02
        WKronrod(7#) = 4.16688733279737E-02
        WKronrod(8#) = 4.64348218674977E-02
        WKronrod(9#) = 5.09445739237287E-02
        WKronrod(10#) = 0.055195105348286
        WKronrod(11#) = 5.91114008806396E-02
        WKronrod(12#) = 6.26532375547812E-02
        WKronrod(13#) = 6.58345971336184E-02
        WKronrod(14#) = 6.86486729285216E-02
        WKronrod(15#) = 7.10544235534441E-02
        WKronrod(16#) = 7.30306903327867E-02
        WKronrod(17#) = 7.45828754004992E-02
        WKronrod(18#) = 7.57044976845567E-02
        WKronrod(19#) = 7.63778676720807E-02
        WKronrod(20#) = 7.66007119179997E-02
    End If
    If N = 51# Then
        NG = 13#
        WGauss(0#) = 1.13937985010263E-02
        WGauss(1#) = 2.63549866150321E-02
        WGauss(2#) = 4.09391567013063E-02
        WGauss(3#) = 5.49046959758352E-02
        WGauss(4#) = 6.80383338123569E-02
        WGauss(5#) = 0.080140700335001
        WGauss(6#) = 9.10282619829637E-02
        WGauss(7#) = 0.100535949067051
        WGauss(8#) = 0.108519624474264
        WGauss(9#) = 0.114858259145712
        WGauss(10#) = 0.119455763535785
        WGauss(11#) = 0.12224244299031
        WGauss(12#) = 0.123176053726715
        x(0#) = 0.99926210499261
        x(1#) = 0.995556969790498
        x(2#) = 0.988035794534077
        x(3#) = 0.976663921459518
        x(4#) = 0.961614986425843
        x(5#) = 0.942974571228974
        x(6#) = 0.920747115281702
        x(7#) = 0.894991997878275
        x(8#) = 0.865847065293276
        x(9#) = 0.833442628760834
        x(10#) = 0.7978737979985
        x(11#) = 0.759259263037358
        x(12#) = 0.717766406813084
        x(13#) = 0.673566368473468
        x(14#) = 0.626810099010317
        x(15#) = 0.577662930241223
        x(16#) = 0.526325284334719
        x(17#) = 0.473002731445715
        x(18#) = 0.417885382193038
        x(19#) = 0.361172305809388
        x(20#) = 0.303089538931108
        x(21#) = 0.243866883720988
        x(22#) = 0.183718939421049
        x(23#) = 0.12286469261071
        x(24#) = 6.15444830056851E-02
        x(25#) = 0#
        WKronrod(0#) = 1.98738389233032E-03
        WKronrod(1#) = 5.56193213535671E-03
        WKronrod(2#) = 9.47397338617415E-03
        WKronrod(3#) = 1.32362291955717E-02
        WKronrod(4#) = 1.68478177091283E-02
        WKronrod(5#) = 2.04353711458828E-02
        WKronrod(6#) = 2.40099456069532E-02
        WKronrod(7#) = 2.74753175878517E-02
        WKronrod(8#) = 3.07923001673875E-02
        WKronrod(9#) = 3.40021302743293E-02
        WKronrod(10#) = 3.71162714834155E-02
        WKronrod(11#) = 4.00838255040324E-02
        WKronrod(12#) = 4.28728450201701E-02
        WKronrod(13#) = 4.55029130499218E-02
        WKronrod(14#) = 4.79825371388367E-02
        WKronrod(15#) = 5.02776790807157E-02
        WKronrod(16#) = 5.23628858064075E-02
        WKronrod(17#) = 5.42511298885455E-02
        WKronrod(18#) = 5.59508112204123E-02
        WKronrod(19#) = 5.74371163615678E-02
        WKronrod(20#) = 5.86896800223942E-02
        WKronrod(21#) = 5.97203403241741E-02
        WKronrod(22#) = 6.05394553760459E-02
        WKronrod(23#) = 0.061128509717053
        WKronrod(24#) = 6.14711898714253E-02
        WKronrod(25#) = 6.15808180678329E-02
    End If
    If N = 61# Then
        NG = 15#
        WGauss(0#) = 7.96819249616661E-03
        WGauss(1#) = 0.018466468311091
        WGauss(2#) = 2.87847078833234E-02
        WGauss(3#) = 3.87991925696271E-02
        WGauss(4#) = 4.84026728305941E-02
        WGauss(5#) = 5.74931562176191E-02
        WGauss(6#) = 6.59742298821805E-02
        WGauss(7#) = 7.37559747377052E-02
        WGauss(8#) = 8.07558952294202E-02
        WGauss(9#) = 0.086899787201083
        WGauss(10#) = 9.21225222377861E-02
        WGauss(11#) = 9.63687371746443E-02
        WGauss(12#) = 9.95934205867953E-02
        WGauss(13#) = 0.101762389748405
        WGauss(14#) = 0.102852652893559
        x(0#) = 0.999484410050491
        x(1#) = 0.99689348407465
        x(2#) = 0.991630996870405
        x(3#) = 0.983668123279747
        x(4#) = 0.973116322501126
        x(5#) = 0.960021864968308
        x(6#) = 0.94437444474856
        x(7#) = 0.926200047429274
        x(8#) = 0.905573307699908
        x(9#) = 0.882560535792053
        x(10#) = 0.857205233546061
        x(11#) = 0.829565762382768
        x(12#) = 0.799727835821839
        x(13#) = 0.767777432104826
        x(14#) = 0.733790062453227
        x(15#) = 0.697850494793316
        x(16#) = 0.660061064126627
        x(17#) = 0.620526182989243
        x(18#) = 0.579345235826362
        x(19#) = 0.53662414814202
        x(20#) = 0.492480467861779
        x(21#) = 0.447033769538089
        x(22#) = 0.400401254830394
        x(23#) = 0.352704725530878
        x(24#) = 0.304073202273625
        x(25#) = 0.25463692616789
        x(26#) = 0.20452511668231
        x(27#) = 0.153869913608584
        x(28#) = 0.102806937966737
        x(29#) = 5.14718425553177E-02
        x(30#) = 0#
        WKronrod(0#) = 1.38901369867701E-03
        WKronrod(1#) = 3.89046112709988E-03
        WKronrod(2#) = 6.63070391593129E-03
        WKronrod(3#) = 9.27327965951776E-03
        WKronrod(4#) = 1.18230152534963E-02
        WKronrod(5#) = 1.43697295070458E-02
        WKronrod(6#) = 1.69208891890533E-02
        WKronrod(7#) = 1.94141411939424E-02
        WKronrod(8#) = 2.18280358216092E-02
        WKronrod(9#) = 2.41911620780806E-02
        WKronrod(10#) = 2.65099548823331E-02
        WKronrod(11#) = 2.87540487650413E-02
        WKronrod(12#) = 3.09072575623878E-02
        WKronrod(13#) = 3.29814470574837E-02
        WKronrod(14#) = 0.03497933802806
        WKronrod(15#) = 3.68823646518212E-02
        WKronrod(16#) = 3.86789456247276E-02
        WKronrod(17#) = 0.040374538951536
        WKronrod(18#) = 4.19698102151642E-02
        WKronrod(19#) = 4.34525397013561E-02
        WKronrod(20#) = 4.48148001331627E-02
        WKronrod(21#) = 0.046059238271007
        WKronrod(22#) = 4.71855465692992E-02
        WKronrod(23#) = 4.81858617570871E-02
        WKronrod(24#) = 4.90554345550298E-02
        WKronrod(25#) = 4.97956834270742E-02
        WKronrod(26#) = 5.04059214027823E-02
        WKronrod(27#) = 5.08817958987496E-02
        WKronrod(28#) = 5.12215478492588E-02
        WKronrod(29#) = 0.051426128537459
        WKronrod(30#) = 5.14947294294516E-02
    End If
    '
    ' copy nodes
    '
    For i = N - 1# To N \ 2# Step -1
        x(i) = -x(N - 1# - i)
    Next i
    '
    ' copy Kronrod weights
    '
    For i = N - 1# To N \ 2# Step -1
        WKronrod(i) = WKronrod(N - 1# - i)
    Next i
    '
    ' copy Gauss weights
    '
    For i = NG - 1# To 0# Step -1
        WGauss(N - 2# - 2# * i) = WGauss(i)
        WGauss(1# + 2# * i) = WGauss(i)
    Next i
    For i = 0# To N \ 2# Step 1
        WGauss(2# * i) = 0#
    Next i
    '
    ' reorder
    '
    Call TagSort(x, N, P1, P2)
    For i = 0# To N - 1# Step 1
        Tmp = WKronrod(i)
        WKronrod(i) = WKronrod(P2(i))
        WKronrod(P2(i)) = Tmp
        Tmp = WGauss(i)
        WGauss(i) = WGauss(P2(i))
        WGauss(P2(i)) = Tmp
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2005-2007, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Computation of nodes and weights for a Gauss quadrature formula
'
'The algorithm generates the N-point Gauss quadrature formula  with  weight
'function given by coefficients alpha and beta  of  a  recurrence  relation
'which generates a system of orthogonal polynomials:
'
'P-1(x)   =  0
'P0(x)    =  1
'Pn+1(x)  =  (x-alpha(n))*Pn(x)  -  beta(n)*Pn-1(x)
'
'and zeroth moment Mu0
'
'Mu0 = integral(W(x)dx,a,b)
'
'INPUT PARAMETERS:
'    Alpha   –   array[0..N-1], alpha coefficients
'    Beta    –   array[0..N-1], beta coefficients
'                Zero-indexed element is not used and may be arbitrary.
'                Beta[I]>0.
'    Mu0     –   zeroth moment of the weight function.
'    N       –   number of nodes of the quadrature formula, N>=1
'
'OUTPUT PARAMETERS:
'    Info    -   error code:
'                * -3    internal eigenproblem solver hasn't converged
'                * -2    Beta[i]<=0
'                * -1    incorrect N was passed
'                *  1    OK
'    X       -   array[0..N-1] - array of quadrature nodes,
'                in ascending order.
'    W       -   array[0..N-1] - array of quadrature weights.
'
'  -- ALGLIB --
'     Copyright 2005-2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub GQGenerateRec(ByRef alpha() As Double, _
         ByRef beta() As Double, _
         ByVal Mu0 As Double, _
         ByVal N As Long, _
         ByRef Info As Long, _
         ByRef x() As Double, _
         ByRef w() As Double)
    Dim i As Long
    Dim d() As Double
    Dim E() As Double
    Dim z() As Double
    If N < 1# Then
        Info = -1#
        Exit Sub
    End If
    Info = 1#
    '
    ' Initialize
    '
    ReDim d(0 To N - 1)
    ReDim E(0 To N - 1)
    For i = 1# To N - 1# Step 1
        d(i - 1#) = alpha(i - 1#)
        If beta(i) <= 0# Then
            Info = -2#
            Exit Sub
        End If
        E(i - 1#) = Sqr(beta(i))
    Next i
    d(N - 1#) = alpha(N - 1#)
    '
    ' EVD
    '
    If Not SMatrixTDEVD(d, E, N, 3#, z) Then
        Info = -3#
        Exit Sub
    End If
    '
    ' Generate
    '
    ReDim x(0 To N - 1)
    ReDim w(0 To N - 1)
    For i = 1# To N Step 1
        x(i - 1#) = d(i - 1#)
        w(i - 1#) = Mu0 * Square(z(0#, i - 1#))
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Computation of nodes and weights for a Gauss-Lobatto quadrature formula
'
'The algorithm generates the N-point Gauss-Lobatto quadrature formula  with
'weight function given by coefficients alpha and beta of a recurrence which
'generates a system of orthogonal polynomials.
'
'P-1(x)   =  0
'P0(x)    =  1
'Pn+1(x)  =  (x-alpha(n))*Pn(x)  -  beta(n)*Pn-1(x)
'
'and zeroth moment Mu0
'
'Mu0 = integral(W(x)dx,a,b)
'
'INPUT PARAMETERS:
'    Alpha   –   array[0..N-2], alpha coefficients
'    Beta    –   array[0..N-2], beta coefficients.
'                Zero-indexed element is not used, may be arbitrary.
'                Beta[I]>0
'    Mu0     –   zeroth moment of the weighting function.
'    A       –   left boundary of the integration interval.
'    B       –   right boundary of the integration interval.
'    N       –   number of nodes of the quadrature formula, N>=3
'                (including the left and right boundary nodes).
'
'OUTPUT PARAMETERS:
'    Info    -   error code:
'                * -3    internal eigenproblem solver hasn't converged
'                * -2    Beta[i]<=0
'                * -1    incorrect N was passed
'                *  1    OK
'    X       -   array[0..N-1] - array of quadrature nodes,
'                in ascending order.
'    W       -   array[0..N-1] - array of quadrature weights.
'
'  -- ALGLIB --
'     Copyright 2005-2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub GQGenerateGaussLobattoRec(ByRef Alpha_() As Double, _
         ByRef Beta_() As Double, _
         ByVal Mu0 As Double, _
         ByVal A As Double, _
         ByVal B As Double, _
         ByVal N As Long, _
         ByRef Info As Long, _
         ByRef x() As Double, _
         ByRef w() As Double)
    Dim alpha() As Double
    Dim beta() As Double
    Dim i As Long
    Dim d() As Double
    Dim E() As Double
    Dim z() As Double
    Dim PIM1A As Double
    Dim PIA As Double
    Dim PIM1B As Double
    Dim PIB As Double
    Dim T As Double
    Dim A11 As Double
    Dim A12 As Double
    Dim A21 As Double
    Dim A22 As Double
    Dim b1 As Double
    Dim b2 As Double
    Dim Alph As Double
    Dim Bet As Double
    alpha = Alpha_
    beta = Beta_
    If N <= 2# Then
        Info = -1#
        Exit Sub
    End If
    Info = 1#
    '
    ' Initialize, D[1:N+1], E[1:N]
    '
    N = N - 2#
    ReDim d(0 To N + 2# - 1)
    ReDim E(0 To N + 1# - 1)
    For i = 1# To N + 1# Step 1
        d(i - 1#) = alpha(i - 1#)
    Next i
    For i = 1# To N Step 1
        If beta(i) <= 0# Then
            Info = -2#
            Exit Sub
        End If
        E(i - 1#) = Sqr(beta(i))
    Next i
    '
    ' Caclulate Pn(a), Pn+1(a), Pn(b), Pn+1(b)
    '
    beta(0#) = 0#
    PIM1A = 0#
    PIA = 1#
    PIM1B = 0#
    PIB = 1#
    For i = 1# To N + 1# Step 1
        '
        ' Pi(a)
        '
        T = (A - alpha(i - 1#)) * PIA - beta(i - 1#) * PIM1A
        PIM1A = PIA
        PIA = T
        '
        ' Pi(b)
        '
        T = (B - alpha(i - 1#)) * PIB - beta(i - 1#) * PIM1B
        PIM1B = PIB
        PIB = T
    Next i
    '
    ' Calculate alpha'(n+1), beta'(n+1)
    '
    A11 = PIA
    A12 = PIM1A
    A21 = PIB
    A22 = PIM1B
    b1 = A * PIA
    b2 = B * PIB
    If Abs(A11) > Abs(A21) Then
        A22 = A22 - A12 * A21 / A11
        b2 = b2 - b1 * A21 / A11
        Bet = b2 / A22
        Alph = (b1 - Bet * A12) / A11
    Else
        A12 = A12 - A22 * A11 / A21
        b1 = b1 - b2 * A11 / A21
        Bet = b1 / A12
        Alph = (b2 - Bet * A22) / A21
    End If
    If Bet < 0# Then
        Info = -3#
        Exit Sub
    End If
    d(N + 1#) = Alph
    E(N) = Sqr(Bet)
    '
    ' EVD
    '
    If Not SMatrixTDEVD(d, E, N + 2#, 3#, z) Then
        Info = -3#
        Exit Sub
    End If
    '
    ' Generate
    '
    ReDim x(0 To N + 2# - 1)
    ReDim w(0 To N + 2# - 1)
    For i = 1# To N + 2# Step 1
        x(i - 1#) = d(i - 1#)
        w(i - 1#) = Mu0 * Square(z(0#, i - 1#))
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Computation of nodes and weights for a Gauss-Radau quadrature formula
'
'The algorithm generates the N-point Gauss-Radau  quadrature  formula  with
'weight function given by the coefficients alpha and  beta  of a recurrence
'which generates a system of orthogonal polynomials.
'
'P-1(x)   =  0
'P0(x)    =  1
'Pn+1(x)  =  (x-alpha(n))*Pn(x)  -  beta(n)*Pn-1(x)
'
'and zeroth moment Mu0
'
'Mu0 = integral(W(x)dx,a,b)
'
'INPUT PARAMETERS:
'    Alpha   –   array[0..N-2], alpha coefficients.
'    Beta    –   array[0..N-1], beta coefficients
'                Zero-indexed element is not used.
'                Beta[I]>0
'    Mu0     –   zeroth moment of the weighting function.
'    A       –   left boundary of the integration interval.
'    N       –   number of nodes of the quadrature formula, N>=2
'                (including the left boundary node).
'
'OUTPUT PARAMETERS:
'    Info    -   error code:
'                * -3    internal eigenproblem solver hasn't converged
'                * -2    Beta[i]<=0
'                * -1    incorrect N was passed
'                *  1    OK
'    X       -   array[0..N-1] - array of quadrature nodes,
'                in ascending order.
'    W       -   array[0..N-1] - array of quadrature weights.
'
'
'  -- ALGLIB --
'     Copyright 2005-2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub GQGenerateGaussRadauRec(ByRef Alpha_() As Double, _
         ByRef Beta_() As Double, _
         ByVal Mu0 As Double, _
         ByVal A As Double, _
         ByVal N As Long, _
         ByRef Info As Long, _
         ByRef x() As Double, _
         ByRef w() As Double)
    Dim alpha() As Double
    Dim beta() As Double
    Dim i As Long
    Dim d() As Double
    Dim E() As Double
    Dim z() As Double
    Dim PolIM1 As Double
    Dim PolI As Double
    Dim T As Double
    alpha = Alpha_
    beta = Beta_
    If N < 2# Then
        Info = -1#
        Exit Sub
    End If
    Info = 1#
    '
    ' Initialize, D[1:N], E[1:N]
    '
    N = N - 1#
    ReDim d(0 To N + 1# - 1)
    ReDim E(0 To N - 1)
    For i = 1# To N Step 1
        d(i - 1#) = alpha(i - 1#)
        If beta(i) <= 0# Then
            Info = -2#
            Exit Sub
        End If
        E(i - 1#) = Sqr(beta(i))
    Next i
    '
    ' Caclulate Pn(a), Pn-1(a), and D[N+1]
    '
    beta(0#) = 0#
    PolIM1 = 0#
    PolI = 1#
    For i = 1# To N Step 1
        T = (A - alpha(i - 1#)) * PolI - beta(i - 1#) * PolIM1
        PolIM1 = PolI
        PolI = T
    Next i
    d(N) = A - beta(N) * PolIM1 / PolI
    '
    ' EVD
    '
    If Not SMatrixTDEVD(d, E, N + 1#, 3#, z) Then
        Info = -3#
        Exit Sub
    End If
    '
    ' Generate
    '
    ReDim x(0# To N)
    ReDim w(0# To N)
    For i = 1# To N + 1# Step 1
        x(i - 1#) = d(i - 1#)
        w(i - 1#) = Mu0 * Square(z(0#, i - 1#))
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Returns nodes/weights for Gauss-Legendre quadrature on [-1,1] with N
'nodes.
'
'INPUT PARAMETERS:
'    N           -   number of nodes, >=1
'
'OUTPUT PARAMETERS:
'    Info        -   error code:
'                    * -4    an  error   was   detected   when  calculating
'                            weights/nodes.  N  is  too  large   to  obtain
'                            weights/nodes  with  high   enough   accuracy.
'                            Try  to   use   multiple   precision  version.
'                    * -3    internal eigenproblem solver hasn't  converged
'                    * -1    incorrect N was passed
'                    * +1    OK
'    X           -   array[0..N-1] - array of quadrature nodes,
'                    in ascending order.
'    W           -   array[0..N-1] - array of quadrature weights.
'
'
'  -- ALGLIB --
'     Copyright 12.05.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub GQGenerateGaussLegendre(ByVal N As Long, _
         ByRef Info As Long, _
         ByRef x() As Double, _
         ByRef w() As Double)
    Dim alpha() As Double
    Dim beta() As Double
    Dim i As Long
    If N < 1# Then
        Info = -1#
        Exit Sub
    End If
    ReDim alpha(0 To N - 1)
    ReDim beta(0 To N - 1)
    For i = 0# To N - 1# Step 1
        alpha(i) = 0#
    Next i
    beta(0#) = 2#
    For i = 1# To N - 1# Step 1
        beta(i) = 1# / (4# - 1# / Square(i))
    Next i
    Call GQGenerateRec(alpha, beta, beta(0#), N, Info, x, w)
    '
    ' test basic properties to detect errors
    '
    If Info > 0# Then
        If x(0#) < -1# Or x(N - 1#) > 1# Then
            Info = -4#
        End If
        For i = 0# To N - 2# Step 1
            If x(i) >= x(i + 1#) Then
                Info = -4#
            End If
        Next i
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Returns  nodes/weights  for  Gauss-Jacobi quadrature on [-1,1] with weight
'function W(x)=Power(1-x,Alpha)*Power(1+x,Beta).
'
'INPUT PARAMETERS:
'    N           -   number of nodes, >=1
'    Alpha       -   power-law coefficient, Alpha>-1
'    Beta        -   power-law coefficient, Beta>-1
'
'OUTPUT PARAMETERS:
'    Info        -   error code:
'                    * -4    an  error  was   detected   when   calculating
'                            weights/nodes. Alpha or  Beta  are  too  close
'                            to -1 to obtain weights/nodes with high enough
'                            accuracy, or, may be, N is too large.  Try  to
'                            use multiple precision version.
'                    * -3    internal eigenproblem solver hasn't converged
'                    * -1    incorrect N/Alpha/Beta was passed
'                    * +1    OK
'    X           -   array[0..N-1] - array of quadrature nodes,
'                    in ascending order.
'    W           -   array[0..N-1] - array of quadrature weights.
'
'
'  -- ALGLIB --
'     Copyright 12.05.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub GQGenerateGaussJacobi(ByVal N As Long, _
         ByVal alpha As Double, _
         ByVal beta As Double, _
         ByRef Info As Long, _
         ByRef x() As Double, _
         ByRef w() As Double)
    Dim A() As Double
    Dim B() As Double
    Dim Alpha2 As Double
    Dim Beta2 As Double
    Dim APB As Double
    Dim T As Double
    Dim i As Long
    Dim s As Double
    If N < 1# Or alpha <= -1# Or beta <= -1# Then
        Info = -1#
        Exit Sub
    End If
    ReDim A(0 To N - 1)
    ReDim B(0 To N - 1)
    APB = alpha + beta
    A(0#) = (beta - alpha) / (APB + 2#)
    T = (APB + 1#) * log(2#) + LnGamma(alpha + 1#, s) + LnGamma(beta + 1#, s) - LnGamma(APB + 2#, s)
    If T > log(MaxRealNumber) Then
        Info = -4#
        Exit Sub
    End If
    B(0#) = Exp(T)
    If N > 1# Then
        Alpha2 = Square(alpha)
        Beta2 = Square(beta)
        A(1#) = (Beta2 - Alpha2) / ((APB + 2#) * (APB + 4#))
        B(1#) = 4# * (alpha + 1#) * (beta + 1#) / ((APB + 3#) * Square(APB + 2#))
        For i = 2# To N - 1# Step 1
            A(i) = 0.25 * (Beta2 - Alpha2) / (i * i * (1# + 0.5 * APB / i) * (1# + 0.5 * (APB + 2#) / i))
            B(i) = 0.25 * (1# + alpha / i) * (1# + beta / i) * (1# + APB / i) / ((1# + 0.5 * (APB + 1#) / i) * (1# + 0.5 * (APB - 1#) / i) * Square(1# + 0.5 * APB / i))
        Next i
    End If
    Call GQGenerateRec(A, B, B(0#), N, Info, x, w)
    '
    ' test basic properties to detect errors
    '
    If Info > 0# Then
        If x(0#) < -1# Or x(N - 1#) > 1# Then
            Info = -4#
        End If
        For i = 0# To N - 2# Step 1
            If x(i) >= x(i + 1#) Then
                Info = -4#
            End If
        Next i
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Returns  nodes/weights  for  Gauss-Laguerre  quadrature  on  [0,+inf) with
'weight function W(x)=Power(x,Alpha)*Exp(-x)
'
'INPUT PARAMETERS:
'    N           -   number of nodes, >=1
'    Alpha       -   power-law coefficient, Alpha>-1
'
'OUTPUT PARAMETERS:
'    Info        -   error code:
'                    * -4    an  error  was   detected   when   calculating
'                            weights/nodes. Alpha is too  close  to  -1  to
'                            obtain weights/nodes with high enough accuracy
'                            or, may  be,  N  is  too  large.  Try  to  use
'                            multiple precision version.
'                    * -3    internal eigenproblem solver hasn't converged
'                    * -1    incorrect N/Alpha was passed
'                    * +1    OK
'    X           -   array[0..N-1] - array of quadrature nodes,
'                    in ascending order.
'    W           -   array[0..N-1] - array of quadrature weights.
'
'
'  -- ALGLIB --
'     Copyright 12.05.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub GQGenerateGaussLaguerre(ByVal N As Long, _
         ByVal alpha As Double, _
         ByRef Info As Long, _
         ByRef x() As Double, _
         ByRef w() As Double)
    Dim A() As Double
    Dim B() As Double
    Dim T As Double
    Dim i As Long
    Dim s As Double
    If N < 1# Or alpha <= -1# Then
        Info = -1#
        Exit Sub
    End If
    ReDim A(0 To N - 1)
    ReDim B(0 To N - 1)
    A(0#) = alpha + 1#
    T = LnGamma(alpha + 1#, s)
    If T >= log(MaxRealNumber) Then
        Info = -4#
        Exit Sub
    End If
    B(0#) = Exp(T)
    If N > 1# Then
        For i = 1# To N - 1# Step 1
            A(i) = 2# * i + alpha + 1#
            B(i) = i * (i + alpha)
        Next i
    End If
    Call GQGenerateRec(A, B, B(0#), N, Info, x, w)
    '
    ' test basic properties to detect errors
    '
    If Info > 0# Then
        If x(0#) < 0# Then
            Info = -4#
        End If
        For i = 0# To N - 2# Step 1
            If x(i) >= x(i + 1#) Then
                Info = -4#
            End If
        Next i
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Returns  nodes/weights  for  Gauss-Hermite  quadrature on (-inf,+inf) with
'weight function W(x)=Exp(-x*x)
'
'INPUT PARAMETERS:
'    N           -   number of nodes, >=1
'
'OUTPUT PARAMETERS:
'    Info        -   error code:
'                    * -4    an  error  was   detected   when   calculating
'                            weights/nodes.  May be, N is too large. Try to
'                            use multiple precision version.
'                    * -3    internal eigenproblem solver hasn't converged
'                    * -1    incorrect N/Alpha was passed
'                    * +1    OK
'    X           -   array[0..N-1] - array of quadrature nodes,
'                    in ascending order.
'    W           -   array[0..N-1] - array of quadrature weights.
'
'
'  -- ALGLIB --
'     Copyright 12.05.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub GQGenerateGaussHermite(ByVal N As Long, _
         ByRef Info As Long, _
         ByRef x() As Double, _
         ByRef w() As Double)
    Dim A() As Double
    Dim B() As Double
    Dim i As Long
    If N < 1# Then
        Info = -1#
        Exit Sub
    End If
    ReDim A(0 To N - 1)
    ReDim B(0 To N - 1)
    For i = 0# To N - 1# Step 1
        A(i) = 0#
    Next i
    B(0#) = Sqr(4# * Atn(1#))
    If N > 1# Then
        For i = 1# To N - 1# Step 1
            B(i) = 0.5 * i
        Next i
    End If
    Call GQGenerateRec(A, B, B(0#), N, Info, x, w)
    '
    ' test basic properties to detect errors
    '
    If Info > 0# Then
        For i = 0# To N - 2# Step 1
            If x(i) >= x(i + 1#) Then
                Info = -4#
            End If
        Next i
    End If
End Sub

